<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    一些简单的偏序维护问题
  
</title>

<meta name="description" content="综述拜读了毒瘤的数据结构课件, 深受启发, 甚是谔谔, 当即感觉自己之前一直在玩泥巴. 初学数据结构, 恳请指正.">
<meta property="og:type" content="article">
<meta property="og:title" content="一些简单的偏序维护问题">
<meta property="og:url" content="https://depletedprism.github.io/memos/simple-partial-order/index.html">
<meta property="og:site_name" content="DepletedPrism&#39;s Blog">
<meta property="og:description" content="综述拜读了毒瘤的数据结构课件, 深受启发, 甚是谔谔, 当即感觉自己之前一直在玩泥巴. 初学数据结构, 恳请指正.">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-02-14T15:15:28.000Z">
<meta property="article:modified_time" content="2025-07-09T08:40:16.324Z">
<meta property="article:author" content="DepletedPrism">
<meta property="article:tag" content="Data Structure">
<meta name="twitter:card" content="summary">


  <link rel="alternative" href="/atom.xml" title="DepletedPrism&#39;s Blog" type="application/atom+xml">



  <link rel="icon" href="/images/favicon.jpg">



<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">


<link rel="stylesheet" href="/styles/main.css">







<meta name="generator" content="Hexo 7.3.0"></head>
<body
  
    class="monochrome"
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">DepletedPrism&#39;s Blog</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">DepletedPrism&#39;s Blog</a></h1>
    
      <p class="subtitle">
        厌离秽土, 欣求净土.
      </p>
    
    <div class="info">
      <div class="content">
        
        
          <div class="author">DepletedPrism</div>
        
      </div>
      
        <div class="avatar">
          
            <a href="/about"><img src="/images/favicon.jpg"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">分类</a>
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a><span class="category-list-count">38</span></li></ul>
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">标签</a>
                <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Calculus/" rel="tag">Calculus</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Combinatorics/" rel="tag">Combinatorics</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/" rel="tag">DP</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Game-Theory/" rel="tag">Game Theory</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Geometry/" rel="tag">Geometry</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Graph/" rel="tag">Graph</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Greedy/" rel="tag">Greedy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Number-Theory/" rel="tag">Number Theory</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Polynomial/" rel="tag">Polynomial</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Probability/" rel="tag">Probability</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/String/" rel="tag">String</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vim/" rel="tag">Vim</a><span class="tag-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">归档</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/9102/">9102</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/">2025</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">42</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">4</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/index.html" title="Homepage" external="false">Homepage</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://github.com/DepletedPrism" title="Github" target="_blank" rel="noopener">Github</a>
              </li>
            
          
            
              <li>
                <a href="https://codeforces.com/profile/DepletedPrism" title="Codeforces" target="_blank" rel="noopener">Codeforces</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          <article id="post-memos/simple-partial-order" class="article article-type-post">
  
    <h1 class="article-header">
      一些简单的偏序维护问题
    </h1>
  
  

  <div class="article-info">
    <span class="article-date">
  2020-02-14
</span>

    
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></li></ul>
	</span>


    
	<span class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li></ul>
	</span>


    
  </div>
  <div class="article-entry">
    <hr>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>拜读了毒瘤的数据结构课件, 深受启发, <del>甚是谔谔, 当即感觉自己之前一直在玩泥巴</del>.</p>
<p>初学数据结构, 恳请指正.</p>
<span id="more"></span>
<h3 id="什么是偏序"><a href="#什么是偏序" class="headerlink" title="什么是偏序"></a>什么是偏序</h3><p><em>其实这一点也不重要</em></p>
<p>对于一个非空集上的二元关系, 如果其满足<strong>自反性</strong>, <strong>反对称性</strong>, <strong>传递性</strong>, 那么称这个二元关系就是这个集合上的偏序.</p>
<p>一个简单的例子: 实数集上的小于等于关系是一个偏序关系.</p>
<h3 id="偏序维护"><a href="#偏序维护" class="headerlink" title="偏序维护"></a>偏序维护</h3><p>现在我们有一个具有很多属性的元素, 比如有 $a_i, b_i, c_i, \ldots$</p>
<p>接下来对每个属性给出一些限制, 对满足这些限制的元素进行一些操作, 像 $L_1 \leq a_i \leq R_1, L_2 \leq b_i \leq R_2, L_3 \leq c_i \leq R_3, \ldots$</p>
<p>这就是在维护偏序了, 有时候也把 “属性” 称作 “维度”.</p>
<h2 id="一些维护方法-amp-例题"><a href="#一些维护方法-amp-例题" class="headerlink" title="一些维护方法 &amp; 例题"></a>一些维护方法 &amp; 例题</h2><blockquote>
<p>反正我之前是先推出一个 poly log 的数据结构做法</p>
<p>然后想办法去 log，到一个可以接受的复杂度</p>
<p>from lxl 某次洛谷网课</p>
</blockquote>
<p>先是两个离线方法.</p>
<h3 id="CDQ-分治"><a href="#CDQ-分治" class="headerlink" title="CDQ 分治"></a>CDQ 分治</h3><p>强烈推荐 <a href="https://www.cnblogs.com/mlystdcall/p/6219421.html">__stdcall 的 CDQ 分治教程</a>.</p>
<p>简单来说, CDQ 分治做了这样一件事情: 把操作离线下来, 分成两部分, 递归解决; 考虑把这两部分合并, 就要考虑左半部分操作对右半部分的影响, 然后合并.</p>
<h4 id="Luogu-P3810【模板】三维偏序"><a href="#Luogu-P3810【模板】三维偏序" class="headerlink" title="Luogu P3810【模板】三维偏序"></a>Luogu P3810【模板】三维偏序</h4><ul>
<li>题目链接: <a href="https://www.luogu.com.cn/problem/P3810">https://www.luogu.com.cn/problem/P3810</a></li>
</ul>
<p>是一道经典题, 考虑 CDQ 分治, 先将第一维排序, CDQ 分治过程中按第二维排序, 使用树状数组统计第三维答案.</p>
<p>有一个细节: 可能存在相同元素, 按题意来讲这些完全相同的元素互相有贡献, 但是在 CDQ 分治的过程中只能统计左半部分对右半部分的贡献, 所以需要去重, 对重复不同次数的元素给定一个不同的权值.</p>
<p>时间复杂度: $O (n\log n \log k)$</p>
<p><strong>代码实现</strong></p>
<div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3810</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span><span class="number">+5</span>, MAXM = <span class="number">2e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="type">int</span> idx, a, b, c, w;</span><br><span class="line">    <span class="built_in">Item</span>(<span class="type">int</span> _i = <span class="number">0</span>, <span class="type">int</span> _a = <span class="number">0</span>, <span class="type">int</span> _b = <span class="number">0</span>, <span class="type">int</span> _c = <span class="number">0</span>, <span class="type">int</span> _w = <span class="number">0</span>):</span><br><span class="line">        <span class="built_in">idx</span>(_i), <span class="built_in">a</span>(_a), <span class="built_in">b</span>(_b), <span class="built_in">c</span>(_c), <span class="built_in">w</span>(_w) &#123; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Item&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (a == rhs.a)? ((b == rhs.b)? c &lt; rhs.c: b &lt; rhs.b): a &lt; rhs.a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>== (<span class="type">const</span> Item&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; rhs) &amp;&amp; !(rhs &lt; *<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; A[MAXN], tmp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, nA, K;</span><br><span class="line"><span class="type">int</span> Ans[MAXN], f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">    <span class="type">int</span> C[MAXM];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Mdy</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; pos, <span class="type">const</span> <span class="type">int</span>&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt;= K; i += <span class="built_in">lowbit</span>(i)) C[i] += d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Qry</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = pos; i; i -= <span class="built_in">lowbit</span>(i)) ret += C[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDQ</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; L, <span class="type">const</span> <span class="type">int</span>&amp; R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>, p = L, q = Mid<span class="number">+1</span>;</span><br><span class="line">    <span class="built_in">CDQ</span>(L, Mid), <span class="built_in">CDQ</span>(Mid<span class="number">+1</span>, R);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">        <span class="comment">// 在右半部分排满时移动左半部分</span></span><br><span class="line">        <span class="keyword">if</span> ((p &lt;= Mid &amp;&amp; A[p].b &lt;= A[q].b) || q &gt; R)</span><br><span class="line">            BIT::<span class="built_in">Mdy</span>(A[p].c, A[p].w), tmp[i] = A[p++];</span><br><span class="line">        <span class="keyword">else</span> Ans[A[q].idx] += BIT::<span class="built_in">Qry</span>(A[q].c), tmp[i] = A[q++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空树状数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= Mid; ++i) BIT::<span class="built_in">Mdy</span>(A[i].c, -A[i].w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; ++i) A[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a, b, c, i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">read</span>(a), <span class="built_in">read</span>(b), <span class="built_in">read</span>(c), A[i] = <span class="built_in">Item</span>(i, a, b, c, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="built_in">sort</span>(A<span class="number">+1</span>, A<span class="number">+1</span>+n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; A[i] == A[j<span class="number">+1</span>]) ++j;</span><br><span class="line">        A[++nA] = A[i], A[nA].w = j - i + <span class="number">1</span>;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CDQ</span>(<span class="number">1</span>, nA);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nA; ++i) f[Ans[A[i].idx] + A[i].w] += A[i].w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h4 id="Luogu-P3374【模板】树状数组-1"><a href="#Luogu-P3374【模板】树状数组-1" class="headerlink" title="Luogu P3374【模板】树状数组 1"></a>Luogu P3374【模板】树状数组 1</h4><blockquote>
<p>CDQ 分治可以顶替复杂的高级数据结构.</p>
</blockquote>
<ul>
<li>题目链接: <a href="https://www.luogu.com.cn/problem/P3374">https://www.luogu.com.cn/problem/P3374</a></li>
</ul>
<p>我们可以把初始值看作在 $0$ 的基础上单点修改, 把查询看作两次询问前缀和, 这样每个操作有时间, 对应操作位置, 权值三个属性.</p>
<p>时间这一维按给定顺序有序, CDQ 分治过程中按操作位置维护权值和即可, 注意在操作位置相同时, 按照先修改后查询的顺序统计.</p>
<p><strong>代码实现</strong></p>
<div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3374</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>(); </span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">500005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ask</span> &#123;</span><br><span class="line">    <span class="type">int</span> opt, pos; LL val;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Ask&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pos &lt; rhs.pos || (pos == rhs.pos &amp;&amp; opt &lt; rhs.opt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Q[MAXN * <span class="number">3</span>], tmp[MAXN * <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, qidx, aidx;</span><br><span class="line">LL A[MAXN], Ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDQ</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">CDQ</span>(L, Mid), <span class="built_in">CDQ</span>(Mid<span class="number">+1</span>, R);</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p = L, q = Mid<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">    	<span class="keyword">if</span> ((p &lt;= Mid &amp;&amp; Q[p] &lt; Q[q]) || q &gt; R) &#123;</span><br><span class="line">    	    <span class="keyword">if</span> (Q[p].opt == <span class="number">1</span>) sum += Q[p].val;</span><br><span class="line">    	    tmp[i] = Q[p++];</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	    <span class="keyword">if</span> (Q[q].opt == <span class="number">2</span>) Ans[Q[q].val] -= sum;</span><br><span class="line">    	    <span class="keyword">if</span> (Q[q].opt == <span class="number">3</span>) Ans[Q[q].val] += sum;</span><br><span class="line">    	    tmp[i] = Q[q++];</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; ++i) Q[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(A[i]);</span><br><span class="line">        Q[++qidx] = (Ask)&#123; <span class="number">1</span>, i, A[i] &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> opt, L, R; LL val;</span><br><span class="line">        <span class="built_in">read</span>(opt); <span class="built_in">read</span>(L);</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">read</span>(val);</span><br><span class="line">                Q[++qidx] = (Ask)&#123; opt, L, val &#125;;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">read</span>(R);</span><br><span class="line">                Q[++qidx] = (Ask)&#123; opt, L<span class="number">-1</span>, ++aidx &#125;;</span><br><span class="line">                Q[++qidx] = (Ask)&#123; opt<span class="number">+1</span>, R, aidx &#125;;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="built_in">puts</span>(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CDQ</span>(<span class="number">1</span>, qidx);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= aidx; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, Ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h4 id="HDU-5126-stars"><a href="#HDU-5126-stars" class="headerlink" title="HDU 5126 stars"></a>HDU 5126 stars</h4><ul>
<li>题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5126">http://acm.hdu.edu.cn/showproblem.php?pid=5126</a></li>
</ul>
<p>对于四维的情况, CDQ 分治可以嵌套使用. <del>但是 CDQ 套 CDQ 套 CDQ… 就和树套树套树… 一样没用, 不如直接写 bitset</del></p>
<p>这是一个三维数点问题, 因为要考虑操作时间的影响就是四维偏序了, 在此我使用 CDQ 套 CDQ 解决.</p>
<p>还是参考 <a href="https://www.cnblogs.com/mlystdcall/p/6232324.html">__stdcall 的 CDQ 套 CDQ 教程</a>, 把第二维按左右两部分重标号, 依此为根据统计答案.</p>
<p>空间内数点可仿照平面内数点的思路, 统计前缀和按坐标点容斥计算就好了.</p>
<p>时间复杂度大概是 $O(n \log ^3 n)$</p>
<p><strong>代码实现</strong></p>
<div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HDU 5126</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ask</span> &#123;</span><br><span class="line">    <span class="type">int</span> opt, idx, x, y, z, part;</span><br><span class="line">&#125; Q[MAXN], tmp2d[MAXN], tmp3d[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, qidx, aidx;</span><br><span class="line"><span class="type">int</span> A[MAXN], B[MAXN &lt;&lt; <span class="number">1</span>], nB;</span><br><span class="line"><span class="type">int</span> Ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">    <span class="type">int</span> C[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Mdy</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; pos, <span class="type">const</span> <span class="type">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt;= nB; i += <span class="built_in">lowbit</span>(i)) C[i] += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Qry</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = pos; i; i -= <span class="built_in">lowbit</span>(i)) ret += C[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDQ3d</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>, p = L, q = Mid<span class="number">+1</span>;</span><br><span class="line">    <span class="built_in">CDQ3d</span>(L, Mid), <span class="built_in">CDQ3d</span>(Mid<span class="number">+1</span>, R);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p &lt;= Mid &amp;&amp; tmp2d[p].y &lt;= tmp2d[q].y) || q &gt; R) &#123;</span><br><span class="line">            <span class="comment">// 只考虑两次归并都排布在左半部分的元素的贡献</span></span><br><span class="line">            <span class="keyword">if</span> (tmp2d[p].opt == <span class="number">0</span> &amp;&amp; tmp2d[p].part == <span class="number">0</span>)</span><br><span class="line">                BIT::<span class="built_in">Mdy</span>(tmp2d[p].z, <span class="number">1</span>);</span><br><span class="line">            tmp3d[i] = tmp2d[p++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 只统计两次归并都排布在右半部分的元素的答案</span></span><br><span class="line">            <span class="keyword">if</span> (tmp2d[q].opt != <span class="number">0</span> &amp;&amp; tmp2d[q].part == <span class="number">1</span>)</span><br><span class="line">                Ans[tmp2d[q].idx] += tmp2d[q].opt * BIT::<span class="built_in">Qry</span>(tmp2d[q].z);</span><br><span class="line">            tmp3d[i] = tmp2d[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= Mid; ++i)</span><br><span class="line">        <span class="keyword">if</span> (tmp2d[i].opt == <span class="number">0</span> &amp;&amp; tmp2d[i].part == <span class="number">0</span>)</span><br><span class="line">            BIT::<span class="built_in">Mdy</span>(tmp2d[i].z, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; ++i) tmp2d[i] = tmp3d[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDQ2d</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>, p = L, q = Mid<span class="number">+1</span>;</span><br><span class="line">    <span class="built_in">CDQ2d</span>(L, Mid), <span class="built_in">CDQ2d</span>(Mid<span class="number">+1</span>, R);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">        <span class="comment">// 重标号: 左半部分标为 0, 右半部分标为 1</span></span><br><span class="line">        <span class="keyword">if</span> ((p &lt;= Mid &amp;&amp; Q[p].x &lt;= Q[q].x) || q &gt; R) &#123;</span><br><span class="line">            Q[p].part = <span class="number">0</span>;</span><br><span class="line">            tmp2d[i] = Q[p++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Q[q].part = <span class="number">1</span>;</span><br><span class="line">            tmp2d[i] = Q[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; ++i) Q[i] = tmp2d[i];</span><br><span class="line">    <span class="built_in">CDQ3d</span>(L, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> Ti; <span class="built_in">read</span>(Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        qidx = nB = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="built_in">read</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> opt, x1, y1, z1, x2, y2, z2;</span><br><span class="line">            <span class="built_in">read</span>(opt), <span class="built_in">read</span>(x1), <span class="built_in">read</span>(y1), <span class="built_in">read</span>(z1);</span><br><span class="line">            <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    Q[++qidx] = (Ask)&#123; <span class="number">0</span>, i, x1, y1, z1, <span class="number">0</span> &#125;;</span><br><span class="line">                    Ans[i] = <span class="number">-1</span>, B[++nB] = z1;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="built_in">read</span>(x2), <span class="built_in">read</span>(y2), <span class="built_in">read</span>(z2);</span><br><span class="line">                    --x1, --y1, --z1;</span><br><span class="line">                    <span class="comment">// 容斥</span></span><br><span class="line">                    Q[++qidx] = (Ask)&#123; <span class="number">1</span>, i, x2, y2, z2, <span class="number">0</span> &#125;;</span><br><span class="line">                    Q[++qidx] = (Ask)&#123;<span class="number">-1</span>, i, x1, y1, z1, <span class="number">0</span> &#125;;</span><br><span class="line">                    Q[++qidx] = (Ask)&#123;<span class="number">-1</span>, i, x1, y2, z2, <span class="number">0</span> &#125;;</span><br><span class="line">                    Q[++qidx] = (Ask)&#123;<span class="number">-1</span>, i, x2, y1, z2, <span class="number">0</span> &#125;;</span><br><span class="line">                    Q[++qidx] = (Ask)&#123;<span class="number">-1</span>, i, x2, y2, z1, <span class="number">0</span> &#125;;</span><br><span class="line">                    Q[++qidx] = (Ask)&#123; <span class="number">1</span>, i, x2, y1, z1, <span class="number">0</span> &#125;;</span><br><span class="line">                    Q[++qidx] = (Ask)&#123; <span class="number">1</span>, i, x1, y2, z1, <span class="number">0</span> &#125;;</span><br><span class="line">                    Q[++qidx] = (Ask)&#123; <span class="number">1</span>, i, x1, y1, z2, <span class="number">0</span> &#125;;</span><br><span class="line">                    Ans[i] = <span class="number">0</span>, B[++nB] = z1, B[++nB] = z2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ERR\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// solve</span></span><br><span class="line">        <span class="built_in">sort</span>(B<span class="number">+1</span>, B<span class="number">+1</span>+nB);</span><br><span class="line">        nB = <span class="built_in">unique</span>(B<span class="number">+1</span>, B<span class="number">+1</span>+nB) - B - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 这一维要丢到 BIT 里, 于是离散化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= qidx; ++i)</span><br><span class="line">            Q[i].z = <span class="built_in">lower_bound</span>(B<span class="number">+1</span>, B<span class="number">+1</span>+nB, Q[i].z) - B;</span><br><span class="line">        <span class="built_in">CDQ2d</span>(<span class="number">1</span>, qidx);</span><br><span class="line">        <span class="comment">// output</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (~Ans[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="整体二分"><a href="#整体二分" class="headerlink" title="整体二分"></a>整体二分</h3><p>对于一个询问, 例如区间第 K 小, 有一个朴素的想法: 每次二分答案的值域, 看当前二分值是否恰好在区间的排名为 K.</p>
<p>这样看起来很慢, 于是可以将所有操作视为一个整体进行二分, 每次给定一个答案区间和一个操作区间, 这就是整体二分了.</p>
<h4 id="Luogu-P3834【模板】可持久化线段树-1（主席树）"><a href="#Luogu-P3834【模板】可持久化线段树-1（主席树）" class="headerlink" title="Luogu P3834【模板】可持久化线段树 1（主席树）"></a>Luogu P3834【模板】可持久化线段树 1（主席树）</h4><ul>
<li>题目链接: <a href="https://www.luogu.com.cn/problem/P3834">https://www.luogu.com.cn/problem/P3834</a></li>
</ul>
<p>可持久化线段树 $\times$ 静态区间第 k 小 $\checkmark$</p>
<p>算是整体二分的经典问题了. 直接使用之前说过的思路, 整体二分即可.</p>
<p>具体地说, 对于原序列上的数, 按当前二分的值域进行划分; 而对于操作, 则统计当前操作对应区间内数的个数, 以当前操作第 k 小为依据进行划分.</p>
<p><strong>代码实现</strong></p>
<div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3834</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ask</span> &#123;</span><br><span class="line">    <span class="type">int</span> opt, idx, L, R, k;</span><br><span class="line">&#125; Q[MAXN &lt;&lt; <span class="number">1</span>], tmpL[MAXN &lt;&lt; <span class="number">1</span>], tmpR[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, qidx;</span><br><span class="line"><span class="type">int</span> A[MAXN], B[MAXN], nB;</span><br><span class="line"><span class="type">int</span> Ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">    <span class="type">int</span> C[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Mdy</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; pos, <span class="type">const</span> <span class="type">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) C[i] += val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Qry</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = pos; i; i -= <span class="built_in">lowbit</span>(i)) ret += C[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Qry</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; L, <span class="type">const</span> <span class="type">int</span>&amp; R)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Qry</span>(R) - <span class="built_in">Qry</span>(L<span class="number">-1</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">const</span> <span class="type">int</span>&amp; opL, <span class="type">const</span> <span class="type">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opL &gt; opR) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = opL; i &lt;= opR; ++i)</span><br><span class="line">            <span class="keyword">if</span> (Q[i].opt == <span class="number">1</span>) Ans[Q[i].idx] = L;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>, p = <span class="number">0</span>, q = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = opL; i &lt;= opR; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Q[i].opt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Q[i].R &lt;= Mid)</span><br><span class="line">                BIT::<span class="built_in">Mdy</span>(Q[i].L, Q[i].k), tmpL[++p] = Q[i];</span><br><span class="line">            <span class="keyword">else</span> tmpR[++q] = Q[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> w = BIT::<span class="built_in">Qry</span>(Q[i].L, Q[i].R);</span><br><span class="line">            <span class="keyword">if</span> (Q[i].k &lt;= w) tmpL[++p] = Q[i];</span><br><span class="line">            <span class="keyword">else</span> Q[i].k -= w, tmpR[++q] = Q[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; ++i)</span><br><span class="line">        <span class="keyword">if</span> (tmpL[i].opt == <span class="number">0</span>) BIT::<span class="built_in">Mdy</span>(tmpL[i].L, -tmpL[i].k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) Q[opL+i<span class="number">-1</span>] = tmpL[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) Q[opL+p+i<span class="number">-1</span>] = tmpR[i];</span><br><span class="line">    <span class="built_in">divide</span>(L, Mid, opL, opL + p - <span class="number">1</span>), <span class="built_in">divide</span>(Mid<span class="number">+1</span>, R, opL + p, opR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(A[i]), B[++nB] = A[i];</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="built_in">sort</span>(B<span class="number">+1</span>, B<span class="number">+1</span>+nB);</span><br><span class="line">    nB = <span class="built_in">unique</span>(B<span class="number">+1</span>, B<span class="number">+1</span>+nB) - B - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        A[i] = <span class="built_in">lower_bound</span>(B<span class="number">+1</span>, B<span class="number">+1</span>+nB, A[i]) - B;</span><br><span class="line">        Q[++qidx] = (Ask)&#123; <span class="number">0</span>, <span class="number">-1</span>, i, A[i], <span class="number">1</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> L, R, k;</span><br><span class="line">        <span class="built_in">read</span>(L), <span class="built_in">read</span>(R), <span class="built_in">read</span>(k);</span><br><span class="line">        Q[++qidx] = (Ask)&#123; <span class="number">1</span>, i, L, R, k &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">divide</span>(<span class="number">1</span>, nB, <span class="number">1</span>, qidx);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, B[Ans[i]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h4 id="Luogu-P3242-HNOI2015-接水果"><a href="#Luogu-P3242-HNOI2015-接水果" class="headerlink" title="Luogu P3242 [HNOI2015] 接水果"></a>Luogu P3242 [HNOI2015] 接水果</h4><ul>
<li>题目链接: <a href="https://www.luogu.com.cn/problem/P3242">https://www.luogu.com.cn/problem/P3242</a></li>
</ul>
<p>通过对路径两端点的 dfs 序的讨论, 路径之间的相互包含可以看作是在二维矩阵中数点, 放在这道题中就是二维矩阵中查询第 k 小了.</p>
<p>类似的转化还有子树内距离小于等于的点, 将 DFS 序看作一维, 深度看作另一维…</p>
<p><del>这东西可以写可持久化树套树, 我…</del></p>
<p>我当然是把矩阵拆成扫描线, 然后整体二分进行统计.</p>
<p><strong>代码实现</strong></p>
<div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3242</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">4e4</span><span class="number">+5</span>, MAXM = <span class="number">5</span> * MAXN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ask</span> &#123;</span><br><span class="line">    <span class="type">int</span> opt, idx, u, L, R, k, val;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Ask&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> u &lt; rhs.u || (u == rhs.u &amp;&amp; opt &lt; rhs.opt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Q[MAXM], tmpL[MAXM], tmpR[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, qc, qidx;</span><br><span class="line"><span class="type">int</span> st[MAXN], ed[MAXN];</span><br><span class="line"><span class="type">int</span> Ans[MAXN], B[MAXN], nB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123; <span class="type">int</span> nxt, to; &#125; edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HLD &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="type">int</span> size[MAXN], depth[MAXN], pre[MAXN], son[MAXN];</span><br><span class="line">    <span class="type">int</span> topfa[MAXN], dfs_clock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">        depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">        pre[u] = fa, size[u] = <span class="number">1</span>, son[u] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) == fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs1</span>(v, u), size[u] += size[v];</span><br><span class="line">            <span class="keyword">if</span> (son[u] == <span class="number">-1</span> || size[v] &gt; size[son[u]]) son[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> top)</span> </span>&#123;</span><br><span class="line">        topfa[u] = top, st[u] = ++dfs_clock;</span><br><span class="line">        <span class="keyword">if</span> (~son[u]) <span class="built_in">dfs2</span>(son[u], top);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) != pre[u] &amp;&amp; v != son[u]) <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">        ed[u] = dfs_clock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (topfa[u] != topfa[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth[topfa[u]] &lt; depth[topfa[v]]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">            u = pre[topfa[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth[u] &gt; depth[v]? v: u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findson</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (topfa[u] != topfa[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[topfa[u]] == v) <span class="keyword">return</span> topfa[u];</span><br><span class="line">            u = pre[topfa[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> son[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> root = <span class="number">1</span>)</span> </span>&#123; <span class="built_in">dfs1</span>(root, <span class="number">0</span>), <span class="built_in">dfs2</span>(root, root); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">    <span class="type">int</span> C[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Mdy</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; pos, <span class="type">const</span> <span class="type">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) C[i] += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Mdy</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; L, <span class="type">const</span> <span class="type">int</span>&amp; R, <span class="type">const</span> <span class="type">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">Mdy</span>(L, val), <span class="built_in">Mdy</span>(R<span class="number">+1</span>, -val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Qry</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = pos; i; i -= <span class="built_in">lowbit</span>(i)) ret += C[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">const</span> <span class="type">int</span>&amp; opL, <span class="type">const</span> <span class="type">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opL &gt; opR) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = opL; i &lt;= opR; ++i)</span><br><span class="line">            <span class="keyword">if</span> (Q[i].opt == <span class="number">1</span>) Ans[Q[i].idx] = B[L];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>, p = <span class="number">0</span>, q = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = opL; i &lt;= opR; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Q[i].opt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Q[i].k &lt;= Mid)</span><br><span class="line">                BIT::<span class="built_in">Mdy</span>(Q[i].L, Q[i].R, Q[i].val), tmpL[++p] = Q[i];</span><br><span class="line">            <span class="keyword">else</span> tmpR[++q] = Q[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> w = BIT::<span class="built_in">Qry</span>(Q[i].L);</span><br><span class="line">            <span class="keyword">if</span> (Q[i].k &lt;= w) tmpL[++p] = Q[i];</span><br><span class="line">            <span class="keyword">else</span> Q[i].k -= w, tmpR[++q] = Q[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; ++i)</span><br><span class="line">        <span class="keyword">if</span> (tmpL[i].opt == <span class="number">0</span>) BIT::<span class="built_in">Mdy</span>(tmpL[i].L, tmpL[i].R, -tmpL[i].val);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) Q[opL + i - <span class="number">1</span>] = tmpL[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) Q[opL + p + i - <span class="number">1</span>] = tmpR[i];</span><br><span class="line">    <span class="built_in">divide</span>(L, Mid, opL, opL + p - <span class="number">1</span>), <span class="built_in">divide</span>(Mid<span class="number">+1</span>, R, opL + p, opR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::<span class="built_in">init</span>();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m), <span class="built_in">read</span>(qc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u, v, i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">read</span>(u), <span class="built_in">read</span>(v), Graph::<span class="built_in">AddEdge</span>(u, v), Graph::<span class="built_in">AddEdge</span>(v, u);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    HLD::<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u, v, w, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(u), <span class="built_in">read</span>(v), <span class="built_in">read</span>(w);</span><br><span class="line">        <span class="keyword">if</span> (st[u] &gt; st[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">        B[++nB] = w;</span><br><span class="line">        <span class="keyword">if</span> (HLD::<span class="built_in">LCA</span>(u, v) == u) &#123;</span><br><span class="line">            <span class="type">int</span> z = HLD::<span class="built_in">findson</span>(v, u);</span><br><span class="line">            <span class="keyword">if</span> (st[z] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                Q[++qidx] = (Ask)&#123; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, st[v], ed[v], w, <span class="number">1</span> &#125;;</span><br><span class="line">                Q[++qidx] = (Ask)&#123; <span class="number">0</span>, <span class="number">-1</span>, st[z], st[v], ed[v], w, <span class="number">-1</span> &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ed[z] &lt; n) &#123;</span><br><span class="line">                Q[++qidx] = (Ask)&#123; <span class="number">0</span>, <span class="number">-1</span>, st[v], ed[z]<span class="number">+1</span>, n, w, <span class="number">1</span> &#125;;</span><br><span class="line">                Q[++qidx] = (Ask)&#123; <span class="number">0</span>, <span class="number">-1</span>, ed[v]<span class="number">+1</span>, ed[z]<span class="number">+1</span>, n, w, <span class="number">-1</span> &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Q[++qidx] = (Ask)&#123; <span class="number">0</span>, <span class="number">-1</span>, st[u], st[v], ed[v], w, <span class="number">1</span> &#125;;</span><br><span class="line">            Q[++qidx] = (Ask)&#123; <span class="number">0</span>, <span class="number">-1</span>, ed[u]<span class="number">+1</span>, st[v], ed[v], w, <span class="number">-1</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(B<span class="number">+1</span>, B<span class="number">+1</span>+nB);</span><br><span class="line">    nB = <span class="built_in">unique</span>(B<span class="number">+1</span>, B<span class="number">+1</span>+nB) - B - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= qidx; ++i)</span><br><span class="line">        Q[i].k = <span class="built_in">lower_bound</span>(B<span class="number">+1</span>, B<span class="number">+1</span>+nB, Q[i].k) - B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u, v, k, i = <span class="number">1</span>; i &lt;= qc; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(u), <span class="built_in">read</span>(v), <span class="built_in">read</span>(k);</span><br><span class="line">        <span class="keyword">if</span> (st[u] &gt; st[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">        Q[++qidx] = (Ask)&#123; <span class="number">1</span>, i, st[u], st[v], <span class="number">-1</span>, k, <span class="number">0</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(Q<span class="number">+1</span>, Q<span class="number">+1</span>+qidx);</span><br><span class="line">    <span class="built_in">divide</span>(<span class="number">1</span>, nB, <span class="number">1</span>, qidx);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= qc; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<p>遇到毒瘤出题人强制在线就挂了 = =, 所以还需要一些在线解决问题的科技.</p>
<h3 id="可持久化"><a href="#可持久化" class="headerlink" title="可持久化"></a>可持久化</h3><p>刚开始学可持久化的时候感觉这个好高级啊, 后来感觉…</p>
<p>这不就是个数据结构的前缀和吗 = =</p>
<h4 id="Luogu-P3834【模板】可持久化线段树-1（主席树）-1"><a href="#Luogu-P3834【模板】可持久化线段树-1（主席树）-1" class="headerlink" title="Luogu P3834【模板】可持久化线段树 1（主席树）"></a>Luogu P3834【模板】可持久化线段树 1（主席树）</h4><ul>
<li>题目链接: <a href="https://www.luogu.com.cn/problem/P3834">https://www.luogu.com.cn/problem/P3834</a></li>
</ul>
<p>建权值线段树, 动态开点.</p>
<p>按照初始序列建可持久化线段树, 每个位置对应的线段树, 就是包含这个位置前缀信息的线段树了.</p>
<p>具体地说, 先建出一个空树, 然后对于每个位置, 在上一个位置的基础上拓展, 尽量利用之前以及储存过的信息, 再建出一颗新树. 这样每次新增的节点数为 $O(\log n)$, 总共建出 $n$ 颗线段树, 总空间复杂度为 $O(n \log n + n \log n)$.</p>
<p>这样对于每个询问 $[L, R]$, 按照前缀和的基本思想, 在 $L-1, R$ 两颗树上进行二分就好了, 即记录当前二分到的两颗树的左子树 size 之差 (因为是求第 $k$ 小), 然后分类讨论移动到左子树还是右子树.</p>
<p>时间复杂度: $O(n \log n)$</p>
<p><strong>代码实现</strong></p>
<div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3834</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, nB;</span><br><span class="line"><span class="type">int</span> A[MAXN], B[MAXN], rt[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123; <span class="type">int</span> lc, rc, sum; &#125; dat[MAXN &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> nidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span>&amp; nd, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">        nd = ++nidx;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">build</span>(dat[nd].lc, L, Mid), <span class="built_in">build</span>(dat[nd].rc, Mid<span class="number">+1</span>, R);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Mdy</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">const</span> <span class="type">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nxt = ++nidx;</span><br><span class="line">        dat[nxt] = dat[nd], ++dat[nxt].sum;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> nxt;</span><br><span class="line">        <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (val &lt;= Mid) dat[nxt].lc = <span class="built_in">Mdy</span>(dat[nxt].lc, L, Mid, val);</span><br><span class="line">        <span class="keyword">else</span> dat[nxt].rc = <span class="built_in">Mdy</span>(dat[nxt].rc, Mid<span class="number">+1</span>, R, val);</span><br><span class="line">        <span class="keyword">return</span> nxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Qry</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">const</span> <span class="type">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> L;</span><br><span class="line">        <span class="type">int</span> d = dat[dat[y].lc].sum - dat[dat[x].lc].sum, Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= d) <span class="keyword">return</span> <span class="built_in">Qry</span>(dat[x].lc, dat[y].lc, L, Mid, k);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Qry</span>(dat[x].rc, dat[y].rc, Mid<span class="number">+1</span>, R, k - d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(A[i]), B[i] = A[i];</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="built_in">sort</span>(B<span class="number">+1</span>, B<span class="number">+1</span>+n);</span><br><span class="line">    nB = <span class="built_in">unique</span>(B<span class="number">+1</span>, B<span class="number">+1</span>+n) - B - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) A[i] = <span class="built_in">lower_bound</span>(B<span class="number">+1</span>, B<span class="number">+1</span>+nB, A[i]) - B;</span><br><span class="line">    SGT::<span class="built_in">build</span>(rt[<span class="number">0</span>], <span class="number">1</span>, nB);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rt[i] = SGT::<span class="built_in">Mdy</span>(rt[i<span class="number">-1</span>], <span class="number">1</span>, nB, A[i]);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> L, R, K;</span><br><span class="line">        <span class="built_in">read</span>(L), <span class="built_in">read</span>(R), <span class="built_in">read</span>(K);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, B[SGT::<span class="built_in">Qry</span>(rt[L<span class="number">-1</span>], rt[R], <span class="number">1</span>, nB, K)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h4 id="Luogu-P3168-CQOI2015-任务查询系统"><a href="#Luogu-P3168-CQOI2015-任务查询系统" class="headerlink" title="Luogu P3168 [CQOI2015] 任务查询系统"></a>Luogu P3168 [CQOI2015] 任务查询系统</h4><ul>
<li>题目链接: <a href="https://www.luogu.com.cn/problem/P3168">https://www.luogu.com.cn/problem/P3168</a></li>
</ul>
<p>刚才是单点修改, 区间求和, 而现在是区间修改, 单点求和, 那么差分即可解决.</p>
<p><del>尝试了不先建出空树的写法, 感觉还行 ?</del></p>
<p>对时间建权值线段树, 把每次区间操作差分, 挂在对应的时间点上, 记录最后操作对应的节点为当前时间点的节点, 对于询问直接在对应时间点的树上二分即可.</p>
<p><strong>代码实现</strong></p>
<div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3168</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e5</span><span class="number">+5</span>, MAXV = <span class="number">1e7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> rt[MAXN], pos[MAXN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PSGT &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mid ((L + R) / 2)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123; <span class="type">int</span> lc, rc, size; LL sum; &#125; dat[MAXN &lt;&lt; <span class="number">6</span>];</span><br><span class="line">    <span class="type">int</span> nidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Abs</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> v &gt; <span class="number">0</span>? v: -v; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Mdy</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">const</span> <span class="type">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nxt = ++nidx;</span><br><span class="line">        dat[nxt] = dat[nd], dat[nxt].size += (val &lt; <span class="number">0</span>? <span class="number">-1</span>: <span class="number">1</span>), dat[nxt].sum += val;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> nxt;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Abs</span>(val) &lt;= Mid) dat[nxt].lc = <span class="built_in">Mdy</span>(dat[nxt].lc, L, Mid, val);</span><br><span class="line">        <span class="keyword">else</span> dat[nxt].rc = <span class="built_in">Mdy</span>(dat[nxt].rc, Mid<span class="number">+1</span>, R, val);</span><br><span class="line">        <span class="keyword">return</span> nxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">Qry</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">const</span> <span class="type">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> k * L;</span><br><span class="line">        <span class="type">int</span> d = dat[dat[nd].lc].size;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= d) <span class="keyword">return</span> <span class="built_in">Qry</span>(dat[nd].lc, L, Mid, k);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Qry</span>(dat[nd].rc, Mid<span class="number">+1</span>, R, k - d) + dat[dat[nd].lc].sum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> Mid</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">read</span>(m), <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> L, R, val;</span><br><span class="line">        <span class="built_in">read</span>(L), <span class="built_in">read</span>(R), <span class="built_in">read</span>(val);</span><br><span class="line">        A[L].<span class="built_in">push_back</span>(val), A[R<span class="number">+1</span>].<span class="built_in">push_back</span>(-val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="type">int</span> nidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; A[i].<span class="built_in">size</span>(); ++k)</span><br><span class="line">            ++nidx, rt[nidx] = PSGT::<span class="built_in">Mdy</span>(rt[nidx<span class="number">-1</span>], <span class="number">1</span>, MAXV, A[i][k]);</span><br><span class="line">        pos[i] = nidx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> x, a, b, c, k, nd; <span class="type">static</span> LL pre = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">read</span>(x), <span class="built_in">read</span>(a), <span class="built_in">read</span>(b), <span class="built_in">read</span>(c);</span><br><span class="line">        k = <span class="number">1</span> + (a * pre + b) % c, nd = pos[x];</span><br><span class="line">        <span class="keyword">if</span> (PSGT::dat[rt[nd]].size &gt; k) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, pre = PSGT::<span class="built_in">Qry</span>(rt[nd], <span class="number">1</span>, MAXV, k));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, pre = PSGT::dat[rt[nd]].sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="K-D-Tree"><a href="#K-D-Tree" class="headerlink" title="K-D Tree"></a>K-D Tree</h3><p>解决 K 维问题 !</p>
<p>K-D Tree 类似于二叉搜索树, 建树选择一个维度对当前元素进行分割, 采用合适选择方法和优秀实现, 建树的时间复杂度为 $O(n \log n)$. 详情请 <a href="https://oi-wiki.org/ds/kdt/">OI Wiki</a>.</p>
<p>考虑到 K-D Tree 的结构, 插入采用类似替罪羊树的平衡方法, 如果有一个节点某一子树的大小超过限制, 就直接重构这个以这一节点为根的子树.</p>
<p>查询直接仿照二叉搜索树了, 注意到 K-D Tree 某些情况下可以剪枝, 可以多维护一些信息来排除掉一些子树.</p>
<p>可以证明, 在 $k$ 维情况下, 单次查询时间复杂度为 $O(n ^ {1 - \frac{1}{k}} + \log n )$.</p>
<p>不过值得注意的是, 这里的查询是类似于矩阵查询的偏序维护, 来个平面最近点对单次操作还是最劣 $O(n)$.</p>
<h4 id="Luogu-P4148-简单题"><a href="#Luogu-P4148-简单题" class="headerlink" title="Luogu P4148 简单题"></a>Luogu P4148 简单题</h4><ul>
<li>题目链接: <a href="https://www.luogu.com.cn/problem/P4148">https://www.luogu.com.cn/problem/P4148</a></li>
</ul>
<p>感觉 K-D Tree 的模板题, 没什么好说的, 把 K-D Tree 的操作汇总就好了.</p>
<p><del>然而我重构写挂了调了好久…</del></p>
<p><strong>代码实现</strong></p>
<div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P4148</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> alpha = <span class="number">0.725</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, nidx, root;</span><br><span class="line"><span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123; <span class="type">int</span> x, y, val; &#125; A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> KDT &#123;</span><br><span class="line">    <span class="type">int</span> ch[<span class="number">2</span>][MAXN], d[MAXN], g[MAXN], t;</span><br><span class="line">    <span class="type">int</span> size[MAXN], datSum[MAXN], mnL[MAXN], mxR[MAXN], mnD[MAXN], mxU[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp1</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)</span> </span>&#123; <span class="keyword">return</span> A[a].x &lt; A[b].x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp2</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)</span> </span>&#123; <span class="keyword">return</span> A[a].y &lt; A[b].y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> nd)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> &amp;lc = ch[<span class="number">0</span>][nd], &amp;rc = ch[<span class="number">1</span>][nd];</span><br><span class="line">        size[nd] = <span class="number">1</span>, datSum[nd] = A[nd].val;</span><br><span class="line">        mnL[nd] = mxR[nd] = A[nd].x, mnD[nd] = mxU[nd] = A[nd].y;</span><br><span class="line">        <span class="keyword">if</span> (lc) &#123;</span><br><span class="line">            size[nd] += size[lc], datSum[nd] += datSum[lc];</span><br><span class="line">            mnL[nd] = <span class="built_in">min</span>(mnL[nd], mnL[lc]), mxR[nd] = <span class="built_in">max</span>(mxR[nd], mxR[lc]);</span><br><span class="line">            mnD[nd] = <span class="built_in">min</span>(mnD[nd], mnD[lc]), mxU[nd] = <span class="built_in">max</span>(mxU[nd], mxU[lc]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            size[nd] += size[rc], datSum[nd] += datSum[rc];</span><br><span class="line">            mnL[nd] = <span class="built_in">min</span>(mnL[nd], mnL[rc]), mxR[nd] = <span class="built_in">max</span>(mxR[nd], mxR[rc]);</span><br><span class="line">            mnD[nd] = <span class="built_in">min</span>(mnD[nd], mnD[rc]), mxU[nd] = <span class="built_in">max</span>(mxU[nd], mxU[rc]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">double</span> avx = <span class="number">0</span>, avy = <span class="number">0</span>, x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; ++i) avx += A[g[i]].x, avy += A[g[i]].y;</span><br><span class="line">        avx /= (R - L + <span class="number">1.0</span>), avy /= (R - L + <span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">            x += (A[g[i]].x - avx) * (A[g[i]].x - avx);</span><br><span class="line">            y += (A[g[i]].y - avy) * (A[g[i]].y - avy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">            <span class="built_in">nth_element</span>(g+L, g+Mid, g+R<span class="number">+1</span>, cmp1), d[g[Mid]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">nth_element</span>(g+L, g+Mid, g+R<span class="number">+1</span>, cmp2), d[g[Mid]] = <span class="number">2</span>;</span><br><span class="line">        ch[<span class="number">0</span>][g[Mid]] = <span class="built_in">build</span>(L, Mid<span class="number">-1</span>), ch[<span class="number">1</span>][g[Mid]] = <span class="built_in">build</span>(Mid<span class="number">+1</span>, R);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maintain</span>(g[Mid]), g[Mid];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> nd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nd) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>][nd]) <span class="built_in">dfs</span>(ch[<span class="number">0</span>][nd]);</span><br><span class="line">        g[++t] = nd;</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">1</span>][nd]) <span class="built_in">dfs</span>(ch[<span class="number">1</span>][nd]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rebuild</span><span class="params">(<span class="type">int</span>&amp; nd)</span> </span>&#123;</span><br><span class="line">        t = <span class="number">0</span>, <span class="built_in">dfs</span>(nd), nd = <span class="built_in">build</span>(<span class="number">1</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">canrb</span><span class="params">(<span class="type">int</span> nd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> alpha * size[nd] &lt;= <span class="built_in">max</span>(size[ch[<span class="number">0</span>][nd]], size[ch[<span class="number">1</span>][nd]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Ins</span><span class="params">(<span class="type">int</span>&amp; nd, <span class="type">const</span> <span class="type">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nd) &#123; nd = pos, <span class="built_in">maintain</span>(nd); <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (d[nd] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[pos].x &lt;= A[nd].x) <span class="built_in">Ins</span>(ch[<span class="number">0</span>][nd], pos);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">Ins</span>(ch[<span class="number">1</span>][nd], pos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[pos].y &lt;= A[nd].y) <span class="built_in">Ins</span>(ch[<span class="number">0</span>][nd], pos);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">Ins</span>(ch[<span class="number">1</span>][nd], pos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">maintain</span>(nd);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">canrb</span>(nd)) <span class="built_in">rebuild</span>(nd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Qry</span><span class="params">(<span class="type">int</span> nd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nd || x1 &gt; mxR[nd] || x2 &lt; mnL[nd] || y1 &gt; mxU[nd] || y2 &lt; mnD[nd])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x1 &lt;= mnL[nd] &amp;&amp; mxR[nd] &lt;= x2 &amp;&amp; y1 &lt;= mnD[nd] &amp;&amp; mxU[nd] &lt;= y2)</span><br><span class="line">            <span class="keyword">return</span> datSum[nd];</span><br><span class="line">        <span class="keyword">if</span> (x1 &lt;= A[nd].x &amp;&amp; A[nd].x &lt;= x2 &amp;&amp; y1 &lt;= A[nd].y &amp;&amp; A[nd].y &lt;= y2)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Qry</span>(ch[<span class="number">0</span>][nd]) + <span class="built_in">Qry</span>(ch[<span class="number">1</span>][nd]) + A[nd].val;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Qry</span>(ch[<span class="number">0</span>][nd]) + <span class="built_in">Qry</span>(ch[<span class="number">1</span>][nd]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;11.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="type">int</span> opt, val, lastans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">read</span>(opt), opt != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">read</span>(x1), <span class="built_in">read</span>(y1), <span class="built_in">read</span>(val);</span><br><span class="line">            x1 ^= lastans, y1 ^= lastans, val ^= lastans;</span><br><span class="line">            A[++nidx] = (Point)&#123; x1, y1, val &#125;;</span><br><span class="line">            KDT::<span class="built_in">Ins</span>(root, nidx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">read</span>(x1), <span class="built_in">read</span>(y1), <span class="built_in">read</span>(x2), <span class="built_in">read</span>(y2);</span><br><span class="line">            x1 ^= lastans, y1 ^= lastans, x2 ^= lastans, y2 ^= lastans;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lastans = KDT::<span class="built_in">Qry</span>(root));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h4 id="Luogu-P5471-NOI2019-弹跳"><a href="#Luogu-P5471-NOI2019-弹跳" class="headerlink" title="Luogu P5471 [NOI2019] 弹跳"></a>Luogu P5471 [NOI2019] 弹跳</h4><ul>
<li>题目链接: <a href="https://www.luogu.com.cn/problem/P5471">https://www.luogu.com.cn/problem/P5471</a></li>
</ul>
<p><em>如果直接用 K-D Tree 建图, <del>如果用四分树甚至可以 AC</del>, 可以收获 88 pts 的好成绩</em></p>
<p><del><em>卡卡常可以卡过? 为什么不尝试更快的做法呢…</em></del></p>
<p>这个写法似乎在 UOJ 被叉掉了 (</p>
<p>那么怎么做呢? 考虑模拟 Dijkstra 的过程, 把这个 K-D Tree 当成堆使用, 记录子树内最小路径长度 (用于更新答案), 以及最大路径长度 (用于剪枝).</p>
<p>具体地说, 因为每个点的最短距离只会被更新一次, 所以 K-D Tree 要维护</p>
<ol>
<li>当前子树覆盖矩阵范围</li>
<li>当前节点到起点的最短路, 视作当前点的权值</li>
<li>子树内最小权值, 用于查找节点及更新答案</li>
<li>当前节点是否被更新过, 换言之, 在 Dijkstra 维护的点集中是否被删去</li>
</ol>
<p>另外有一个剪枝: 维护一个子树内最大权值, 这样在修改值 (也就是一个矩阵内更新最小值) 的时候遇到 “最大值比修改值还要小” 的情况就可以剪枝.</p>
<p>还有一些细节, 在修改整块矩阵的时候打一个类似于线段树的标记, 以及对于已删除节点值的情况要注意分类讨论.</p>
<p><strong>代码实现</strong></p>
<div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P5471</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">7e4</span><span class="number">+5</span>, MAXM = <span class="number">15e4</span>, MAXD = <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x[MAXD], idx;</span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[] (<span class="type">const</span> <span class="type">int</span>&amp; i) &#123; <span class="keyword">return</span> x[i]; &#125;</span><br><span class="line">&#125; A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, W, H;</span><br><span class="line"><span class="type">int</span> pos[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> KDT &#123;</span><br><span class="line">    <span class="type">int</span> ch[<span class="number">2</span>][MAXN], mn[MAXD][MAXN], mx[MAXD][MAXN];</span><br><span class="line">    <span class="type">bool</span> vis[MAXN];</span><br><span class="line">    <span class="type">int</span> tag[MAXN], datMin[MAXN], datMax[MAXN], datVal[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; nd)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> &amp;lc = ch[<span class="number">0</span>][nd], &amp;rc = ch[<span class="number">1</span>][nd];</span><br><span class="line">        <span class="keyword">if</span> (vis[nd]) &#123;</span><br><span class="line">            datMin[nd] = INF, datMax[nd] = -INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">0</span>; d &lt; MAXD; ++d) mn[d][nd] = INF, mx[d][nd] = -INF;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            datMin[nd] = datMax[nd] = datVal[nd];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">0</span>; d &lt; MAXD; ++d) mn[d][nd] = mx[d][nd] = A[nd][d];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lc) &#123;</span><br><span class="line">            datMin[nd] = <span class="built_in">min</span>(datMin[nd], datMin[lc]);</span><br><span class="line">            datMax[nd] = <span class="built_in">max</span>(datMax[nd], datMax[lc]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">0</span>; d &lt; MAXD; ++d) &#123;</span><br><span class="line">                mn[d][nd] = <span class="built_in">min</span>(mn[d][nd], mn[d][lc]);</span><br><span class="line">                mx[d][nd] = <span class="built_in">max</span>(mx[d][nd], mx[d][lc]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            datMin[nd] = <span class="built_in">min</span>(datMin[nd], datMin[rc]);</span><br><span class="line">            datMax[nd] = <span class="built_in">max</span>(datMax[nd], datMax[rc]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">0</span>; d &lt; MAXD; ++d) &#123;</span><br><span class="line">                mn[d][nd] = <span class="built_in">min</span>(mn[d][nd], mn[d][rc]);</span><br><span class="line">                mx[d][nd] = <span class="built_in">max</span>(mx[d][nd], mx[d][rc]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushTag</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; nd, <span class="type">const</span> <span class="type">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (val &gt;= datMax[nd] || val &gt;= tag[nd]) <span class="keyword">return</span>;</span><br><span class="line">        datMax[nd] = tag[nd] = val;</span><br><span class="line">        datMin[nd] = <span class="built_in">min</span>(datMin[nd], val);</span><br><span class="line">        <span class="keyword">if</span> (!vis[nd]) datVal[nd] = <span class="built_in">min</span>(datVal[nd], val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> nd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nd || tag[nd] == INF) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> &amp;lc = ch[<span class="number">0</span>][nd], &amp;rc = ch[<span class="number">1</span>][nd];</span><br><span class="line">        <span class="keyword">if</span> (lc) <span class="built_in">pushTag</span>(lc, tag[nd]);</span><br><span class="line">        <span class="keyword">if</span> (rc) <span class="built_in">pushTag</span>(rc, tag[nd]);</span><br><span class="line">        tag[nd] = INF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp0</span><span class="params">(<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b)</span> </span>&#123; <span class="keyword">return</span> a.x[<span class="number">0</span>] &lt; b.x[<span class="number">0</span>]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp1</span><span class="params">(<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b)</span> </span>&#123; <span class="keyword">return</span> a.x[<span class="number">1</span>] &lt; b.x[<span class="number">1</span>]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">double</span> avx = <span class="number">0</span>, avy = <span class="number">0</span>, x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; ++i) avx += A[i][<span class="number">0</span>], avy += A[i][<span class="number">1</span>];</span><br><span class="line">        avx /= (R - L + <span class="number">1.0</span>), avy /= (R - L + <span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">            x += (avx - A[i][<span class="number">0</span>]) * (avx - A[i][<span class="number">0</span>]);</span><br><span class="line">            y += (avy - A[i][<span class="number">1</span>]) * (avy - A[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) <span class="built_in">nth_element</span>(A + L, A + Mid, A + R + <span class="number">1</span>, cmp0);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">nth_element</span>(A + L, A + Mid, A + R + <span class="number">1</span>, cmp1);</span><br><span class="line">        pos[Mid] = A[Mid].idx;</span><br><span class="line">        tag[Mid] = INF, datVal[Mid] = (pos[Mid] == <span class="number">1</span>)? <span class="number">0</span>: INF;</span><br><span class="line">        ch[<span class="number">0</span>][Mid] = <span class="built_in">build</span>(L, Mid<span class="number">-1</span>), ch[<span class="number">1</span>][Mid] = <span class="built_in">build</span>(Mid<span class="number">+1</span>, R);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maintain</span>(Mid), Mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Mdy</span><span class="params">(<span class="type">int</span> nd, <span class="type">const</span> <span class="type">int</span>&amp; val,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> <span class="type">int</span>&amp; L, <span class="type">const</span> <span class="type">int</span>&amp; R, <span class="type">const</span> <span class="type">int</span>&amp; D, <span class="type">const</span> <span class="type">int</span>&amp; U)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(nd);</span><br><span class="line">        <span class="keyword">if</span> (datMax[nd] &lt;= val) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (L &gt; mx[<span class="number">0</span>][nd] || R &lt; mn[<span class="number">0</span>][nd] || D &gt; mx[<span class="number">1</span>][nd] || U &lt; mn[<span class="number">1</span>][nd]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= mn[<span class="number">0</span>][nd] &amp;&amp; mx[<span class="number">0</span>][nd] &lt;= R &amp;&amp; D &lt;= mn[<span class="number">1</span>][nd] &amp;&amp; mx[<span class="number">1</span>][nd] &lt;= U)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pushTag</span>(nd, val);</span><br><span class="line">        <span class="keyword">if</span> (!vis[nd] &amp;&amp; L &lt;= A[nd][<span class="number">0</span>] &amp;&amp; A[nd][<span class="number">0</span>] &lt;= R &amp;&amp; D &lt;= A[nd][<span class="number">1</span>] &amp;&amp; A[nd][<span class="number">1</span>] &lt;= U)</span><br><span class="line">            datVal[nd] = <span class="built_in">min</span>(datVal[nd], val);</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>][nd]) <span class="built_in">Mdy</span>(ch[<span class="number">0</span>][nd], val, L, R, D, U);</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">1</span>][nd]) <span class="built_in">Mdy</span>(ch[<span class="number">1</span>][nd], val, L, R, D, U);</span><br><span class="line">        <span class="built_in">maintain</span>(nd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Qry</span><span class="params">(<span class="type">int</span> nd, <span class="type">const</span> <span class="type">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(nd);</span><br><span class="line">        <span class="keyword">if</span> (!vis[nd] &amp;&amp; datVal[nd] == val) &#123;</span><br><span class="line">            vis[nd] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">maintain</span>(nd), nd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>][nd] &amp;&amp; datMin[ch[<span class="number">0</span>][nd]] == val) &#123;</span><br><span class="line">            <span class="type">int</span> ret = <span class="built_in">Qry</span>(ch[<span class="number">0</span>][nd], val);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">maintain</span>(nd), ret;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> ret = <span class="built_in">Qry</span>(ch[<span class="number">1</span>][nd], val);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">maintain</span>(nd), ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123; <span class="type">int</span> L, R, D, U, w; &#125;; </span><br><span class="line">    vector&lt;Edge&gt; G[MAXN];</span><br><span class="line">    <span class="type">int</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> D, <span class="type">int</span> U, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        G[from].<span class="built_in">push_back</span>((Edge)&#123; L, R, D, U, w &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> root = KDT::<span class="built_in">build</span>(<span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> nd = KDT::<span class="built_in">Qry</span>(root, KDT::datMin[root]);</span><br><span class="line">            <span class="type">int</span> u = pos[nd];</span><br><span class="line">            dist[u] = KDT::datVal[nd];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; G[u].<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">                <span class="type">const</span> Edge&amp; e = G[u][k];</span><br><span class="line">                KDT::<span class="built_in">Mdy</span>(root, dist[u] + e.w, e.L, e.R, e.D, e.U);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dist[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m), <span class="built_in">read</span>(W), <span class="built_in">read</span>(H);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        A[i].idx = i, <span class="built_in">read</span>(A[i][<span class="number">0</span>]), <span class="built_in">read</span>(A[i][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> p, w, L, R, D, U;</span><br><span class="line">        <span class="built_in">read</span>(p), <span class="built_in">read</span>(w), <span class="built_in">read</span>(L), <span class="built_in">read</span>(R), <span class="built_in">read</span>(D), <span class="built_in">read</span>(U);</span><br><span class="line">        Graph::<span class="built_in">AddEdge</span>(p, L, R, D, U, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    Graph::<span class="built_in">Dijkstra</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="树套树"><a href="#树套树" class="headerlink" title="树套树"></a>树套树</h3><p>字面意思, 嵌套数据结构.</p>
<p>带有巨大常数, 占用大量空间.</p>
<h4 id="Luogu-P3380【模板】二逼平衡树（树套树）"><a href="#Luogu-P3380【模板】二逼平衡树（树套树）" class="headerlink" title="Luogu P3380【模板】二逼平衡树（树套树）"></a>Luogu P3380【模板】二逼平衡树（树套树）</h4><ul>
<li>题目链接: <a href="https://www.luogu.com.cn/problem/P3380">https://www.luogu.com.cn/problem/P3380</a></li>
</ul>
<p>采用线段树套平衡树的方法, 为了好写一些, 内层平衡树我选择了 无旋 Treap.</p>
<ol>
<li><p>$k$ 在区间内的排名</p>
<p>把区间丢到线段树上处理, 把区间拆分后得到的排名相加即可. 单次操作时间复杂度 $O(\log^2 n)$</p>
<p>注意一些细节: 数值 $k$ 可能在区间内的贡献可能被计算多次, 所以每次查询内层平衡树时把得到的排名 $-1$, 最后得出答案时再把自己加上.</p>
</li>
<li><p>查询区间内排名为 $k$ 的值</p>
<p>这个问题在普通的平衡树上可以通过二分解决, 但是在多棵平衡树的情况下进行二分好像很困难…</p>
<p>所以直接采用二分值域的方式, 判断当前二分的值是否在区间内排名为 $k$, 单次操作时间复杂度 $O(\log ^3 n)$.</p>
<p>(好像在多个 Trie 上二分很可做, 或者用树状数组套 Trie 来维护, 可以做到 $O(\log ^2 n)$, 还没写过, 值得尝试)</p>
</li>
<li><p>修改某一位值上的数值</p>
<p>在线段树上跑一遍单点修改的操作, 沿途把原来的值删除, 再把修改的值加入就好了. 时间复杂度 $O(\log^2 n)$.</p>
</li>
<li><p>查询 $k$ 在区间内的前驱</p>
</li>
<li><p>查询 $k$ 在区间内的后继</p>
<p>也是把区间丢到线段树上, 注意把前驱取 $\max$, 后缀取 $\min$. 时间复杂度 $O(\log^2 n)$</p>
</li>
</ol>
<p><strong>代码实现</strong></p>
<p>只有靠 O2 才勉强续命的样子.</p>
<div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3380</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e4</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Treap &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXN = ::MAXN &lt;&lt; <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> ch[<span class="number">2</span>][MAXN], size[MAXN], rnd[MAXN], val[MAXN], nidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> nd)</span> </span>&#123;</span><br><span class="line">        size[nd] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>][nd]) size[nd] += size[ch[<span class="number">0</span>][nd]];</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">1</span>][nd]) size[nd] += size[ch[<span class="number">1</span>][nd]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val[++nidx] = v, size[nidx] = <span class="number">1</span>, rnd[nidx] = <span class="built_in">rand</span>(), nidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> nd, <span class="type">const</span> <span class="type">int</span>&amp; k, <span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nd) <span class="keyword">return</span> <span class="built_in">void</span>( x = y = <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">if</span> (val[nd] &lt;= k) x = nd, <span class="built_in">split</span>(ch[<span class="number">1</span>][nd], k, ch[<span class="number">1</span>][nd], y);</span><br><span class="line">        <span class="keyword">else</span> y = nd, <span class="built_in">split</span>(ch[<span class="number">0</span>][nd], k, x, ch[<span class="number">0</span>][nd]);</span><br><span class="line">        <span class="built_in">maintain</span>(nd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line">        <span class="keyword">if</span> (rnd[x] &lt; rnd[y]) <span class="keyword">return</span> ch[<span class="number">1</span>][x] = <span class="built_in">merge</span>(ch[<span class="number">1</span>][x], y), <span class="built_in">maintain</span>(x), x;</span><br><span class="line">        <span class="keyword">return</span> ch[<span class="number">0</span>][y] = <span class="built_in">merge</span>(x, ch[<span class="number">0</span>][y]), <span class="built_in">maintain</span>(y), y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span>&amp; root, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> x, y; x = y = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">split</span>(root, v, x, y), root = <span class="built_in">merge</span>(<span class="built_in">merge</span>(x, <span class="built_in">newnode</span>(v)), y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span>&amp; root, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> x, y, z; x = y = z = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">split</span>(root, v, x, z), <span class="built_in">split</span>(x, v<span class="number">-1</span>, x, y);</span><br><span class="line">        y = <span class="built_in">merge</span>(ch[<span class="number">0</span>][y], ch[<span class="number">1</span>][y]), root = <span class="built_in">merge</span>(<span class="built_in">merge</span>(x, y), z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Rnk</span><span class="params">(<span class="type">int</span>&amp; root, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> x, y, ret; x = y = ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">split</span>(root, v<span class="number">-1</span>, x, y), ret = size[x] + <span class="number">1</span>, root = <span class="built_in">merge</span>(x, y), ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Kth</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (nd) &#123;</span><br><span class="line">            <span class="type">int</span> t = ch[<span class="number">0</span>][nd]? size[ch[<span class="number">0</span>][nd]] + <span class="number">1</span>: <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (k == t) <span class="keyword">return</span> nd;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; t) k -= t, nd = ch[<span class="number">1</span>][nd];</span><br><span class="line">            <span class="keyword">else</span> nd = ch[<span class="number">0</span>][nd];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Pre</span><span class="params">(<span class="type">int</span>&amp; root, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> x, y, ret; x = y = ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">split</span>(root, v<span class="number">-1</span>, x, y), ret = x? val[<span class="built_in">Kth</span>(x, size[x])]: -INT_MAX, root = <span class="built_in">merge</span>(x, y), ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Suf</span><span class="params">(<span class="type">int</span>&amp; root, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> x, y, ret; x = y = ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">split</span>(root, v, x, y), ret = y? val[<span class="built_in">Kth</span>(y, <span class="number">1</span>)]: INT_MAX, root = <span class="built_in">merge</span>(x, y), ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>][u]) <span class="built_in">dfs</span>(ch[<span class="number">0</span>][u]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, val[u]);</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">1</span>][u]) <span class="built_in">dfs</span>(ch[<span class="number">1</span>][u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (nd&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (nd&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mid ((L + R) / 2)</span></span><br><span class="line">    <span class="type">int</span> rt[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; ++i) Treap::<span class="built_in">insert</span>(rt[nd], A[i]);</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">build</span>(lc, L, Mid), <span class="built_in">build</span>(rc, Mid<span class="number">+1</span>, R);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Mdy</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">const</span> <span class="type">int</span>&amp; pos, <span class="type">const</span> <span class="type">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        Treap::<span class="built_in">remove</span>(rt[nd], A[pos]), Treap::<span class="built_in">insert</span>(rt[nd], val);</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= Mid) <span class="built_in">Mdy</span>(lc, L, Mid, pos, val);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">Mdy</span>(rc, Mid<span class="number">+1</span>, R, pos, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Rnk</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">const</span> <span class="type">int</span>&amp; opL, <span class="type">const</span> <span class="type">int</span>&amp; opR, <span class="type">const</span> <span class="type">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> Treap::<span class="built_in">Rnk</span>(rt[nd], val) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> <span class="built_in">Rnk</span>(lc, L, Mid, opL, opR, val);</span><br><span class="line">        <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> <span class="built_in">Rnk</span>(rc, Mid<span class="number">+1</span>, R, opL, opR, val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Rnk</span>(lc, L, Mid, opL, opR, val) + <span class="built_in">Rnk</span>(rc, Mid<span class="number">+1</span>, R, opL, opR, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Kth</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; opL, <span class="type">const</span> <span class="type">int</span>&amp; opR, <span class="type">const</span> <span class="type">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> L = <span class="number">0</span>, R = <span class="number">1e8</span>, ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Rnk</span>(<span class="number">1</span>, <span class="number">1</span>, n, opL, opR, Mid) + <span class="number">1</span> &lt;= k) ret = Mid, L = Mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> R = Mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Pre</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">const</span> <span class="type">int</span>&amp; opL, <span class="type">const</span> <span class="type">int</span>&amp; opR, <span class="type">const</span> <span class="type">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> Treap::<span class="built_in">Pre</span>(rt[nd], val);</span><br><span class="line">        <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> <span class="built_in">Pre</span>(lc, L, Mid, opL, opR, val);</span><br><span class="line">        <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> <span class="built_in">Pre</span>(rc, Mid<span class="number">+1</span>, R, opL, opR, val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">Pre</span>(lc, L, Mid, opL, opR, val), <span class="built_in">Pre</span>(rc, Mid<span class="number">+1</span>, R, opL, opR, val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Suf</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">const</span> <span class="type">int</span>&amp; opL, <span class="type">const</span> <span class="type">int</span>&amp; opR, <span class="type">const</span> <span class="type">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> Treap::<span class="built_in">Suf</span>(rt[nd], val);</span><br><span class="line">        <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> <span class="built_in">Suf</span>(lc, L, Mid, opL, opR, val);</span><br><span class="line">        <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> <span class="built_in">Suf</span>(rc, Mid<span class="number">+1</span>, R, opL, opR, val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">Suf</span>(lc, L, Mid, opL, opR, val), <span class="built_in">Suf</span>(rc, Mid<span class="number">+1</span>, R, opL, opR, val));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> rc</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> Mid</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">srand</span>( <span class="built_in">time</span>(<span class="literal">nullptr</span>) );</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(A[i]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    SGT::<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> opt, L, R, K;</span><br><span class="line">        <span class="built_in">read</span>(opt), <span class="built_in">read</span>(L), <span class="built_in">read</span>(R); <span class="keyword">if</span> (opt != <span class="number">3</span>) <span class="built_in">read</span>(K);</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, SGT::<span class="built_in">Rnk</span>(<span class="number">1</span>, <span class="number">1</span>, n, L, R, K) + <span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, SGT::<span class="built_in">Kth</span>(L, R, K)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: SGT::<span class="built_in">Mdy</span>(<span class="number">1</span>, <span class="number">1</span>, n, L, R), A[L] = R; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, SGT::<span class="built_in">Pre</span>(<span class="number">1</span>, <span class="number">1</span>, n, L, R, K)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, SGT::<span class="built_in">Suf</span>(<span class="number">1</span>, <span class="number">1</span>, n, L, R, K)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ERR\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h4 id="Luogu-P3332-ZJOI2013-K-大数查询"><a href="#Luogu-P3332-ZJOI2013-K-大数查询" class="headerlink" title="Luogu P3332 [ZJOI2013] K 大数查询"></a>Luogu P3332 [ZJOI2013] K 大数查询</h4><ul>
<li>题目链接: <a href="https://www.luogu.com.cn/problem/P3332">https://www.luogu.com.cn/problem/P3332</a></li>
</ul>
<p>大概是权值线段树套普通线段树 ?</p>
<p><del>话说这种直接给出操作的数据结构应该是几年前的画风吧 ?</del></p>
<p>首先对题意进行转化, 将加入的元素看作一个带有两种属性的元素, 那么操作 1 就是加入 $(l, c), (l+1, c), \ldots, (r, c)$ 这些点, 操作 2 就是查询第一个属性 $a$ 满足 $l \le a \le r$ 的点集中第 $k$ 大.</p>
<p>于是就可以很自然地联想到树套树了. 但是区间加入一个数的操作不好实现, 所以就有了一个朴素的想法: 在外层线段树上维护权值, 在内层维护位置.</p>
<p>现在的问题就很明朗了:</p>
<ul>
<li><p>对于操作 1: 在外层线段树单点插入一个值, 并在这个位置对应的线段树区间加 1, 表明这个位置加入值了.</p>
<p>注意到代码中使用了 “标记永久化” 的技巧, 这样会比每次下传标记要快, <del>但是我要卡常为什么不直接写整体二分呢?</del></p>
<p>单次操作时间复杂度 $O(\log^2 n)$.</p>
</li>
<li><p>对于操作 2: 在外层线段树上二分, 和普通权值线段树的操作没什么大的差别, 只是查询子树大小的 $O(\log n)$ 而已…</p>
<p>单次操作时间复杂度 $O(\log^2 n)$.</p>
</li>
</ul>
<p><strong>代码实现</strong></p>
<p>活在 O2, 以及被整体二分吊打的空气之下 = =.</p>
<div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3332</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e4</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ask</span> &#123;</span><br><span class="line">    <span class="type">int</span> opt, L, R; LL c;</span><br><span class="line">&#125; Q[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">LL B[MAXN], nB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DSGT &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXN = ::MAXN * <span class="number">17</span> * <span class="number">17</span>;</span><br><span class="line">    <span class="type">int</span> lc[MAXN], rc[MAXN], nidx;</span><br><span class="line">    LL datSum[MAXN], tagAdd[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> l1, <span class="type">int</span> r1, <span class="type">int</span> l2, <span class="type">int</span> r2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">max</span>(l1, l2) &gt; <span class="built_in">min</span>(r1, r2)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(r1, r2) - <span class="built_in">max</span>(l1, l2) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Mdy</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">const</span> <span class="type">int</span>&amp; opL, <span class="type">const</span> <span class="type">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 标记永久化</span></span><br><span class="line">        datSum[nd] += <span class="built_in">calc</span>(L, R, opL, opR);</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> <span class="built_in">void</span>( ++tagAdd[nd] );</span><br><span class="line">        <span class="comment">// 内层线段树需要动态开点, 空间复杂度 O(n log^2 n)</span></span><br><span class="line">        <span class="keyword">if</span> (!lc[nd]) lc[nd] = ++nidx;</span><br><span class="line">        <span class="keyword">if</span> (!rc[nd]) rc[nd] = ++nidx;</span><br><span class="line">        <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= Mid) <span class="built_in">Mdy</span>(lc[nd], L, Mid, opL, opR);</span><br><span class="line">        <span class="keyword">if</span> (opR &gt; Mid) <span class="built_in">Mdy</span>(rc[nd], Mid<span class="number">+1</span>, R, opL, opR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">Qry</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">const</span> <span class="type">int</span>&amp; opL, <span class="type">const</span> <span class="type">int</span>&amp; opR, <span class="type">const</span> <span class="type">int</span>&amp; tag = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 标记永久化</span></span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> datSum[nd] + tag * (R-L<span class="number">+1</span>);</span><br><span class="line">        <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= Mid) ret += <span class="built_in">Qry</span>(lc[nd], L, Mid, opL, opR, tag + tagAdd[nd]);</span><br><span class="line">        <span class="keyword">if</span> (opR &gt; Mid) ret += <span class="built_in">Qry</span>(rc[nd], Mid<span class="number">+1</span>, R, opL, opR, tag + tagAdd[nd]);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (nd&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (nd&lt;&lt;1|1)</span></span><br><span class="line">    <span class="type">int</span> rt[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Mdy</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">const</span> <span class="type">int</span>&amp; opL, <span class="type">const</span> <span class="type">int</span>&amp; opR, <span class="type">const</span> <span class="type">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!rt[nd]) rt[nd] = ++DSGT::nidx;</span><br><span class="line">        DSGT::<span class="built_in">Mdy</span>(rt[nd], <span class="number">1</span>, n, opL, opR);</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= Mid) <span class="built_in">Mdy</span>(lc, L, Mid, opL, opR, pos);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">Mdy</span>(rc, Mid<span class="number">+1</span>, R, opL, opR, pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Kth</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">const</span> <span class="type">int</span>&amp; opL, <span class="type">const</span> <span class="type">int</span>&amp; opR, <span class="type">const</span> LL&amp; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> L;</span><br><span class="line">        <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        LL d = DSGT::<span class="built_in">Qry</span>(rt[rc], <span class="number">1</span>, n, opL, opR);</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= d) <span class="keyword">return</span> <span class="built_in">Kth</span>(rc, Mid<span class="number">+1</span>, R, opL, opR, k);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Kth</span>(lc, L, Mid, opL, opR, k - d);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> rc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> opt, L, R; <span class="type">static</span> LL c;</span><br><span class="line">        <span class="built_in">read</span>(opt), <span class="built_in">read</span>(L), <span class="built_in">read</span>(R), <span class="built_in">read</span>(c);</span><br><span class="line">        Q[i] = (Ask)&#123; opt, L, R, c &#125;;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) B[++nB] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="built_in">sort</span>(B<span class="number">+1</span>, B<span class="number">+1</span>+nB);</span><br><span class="line">    nB = <span class="built_in">unique</span>(B<span class="number">+1</span>, B<span class="number">+1</span>+nB) - B - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 需要丢到权值线段树里, 随手离散化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">if</span> (Q[i].opt == <span class="number">1</span>) Q[i].c = <span class="built_in">lower_bound</span>(B<span class="number">+1</span>, B<span class="number">+1</span>+nB, Q[i].c) - B;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="type">const</span> Ask&amp; q = Q[i];</span><br><span class="line">        <span class="keyword">switch</span> (q.opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: SGT::<span class="built_in">Mdy</span>(<span class="number">1</span>, <span class="number">1</span>, nB, q.L, q.R, q.c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, B[SGT::<span class="built_in">Kth</span>(<span class="number">1</span>, <span class="number">1</span>, nB, q.L, q.R, q.c)]); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ERR\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h4 id="Luogu-P3759-TJOI2017-不勤劳的图书管理员"><a href="#Luogu-P3759-TJOI2017-不勤劳的图书管理员" class="headerlink" title="Luogu P3759 [TJOI2017] 不勤劳的图书管理员"></a>Luogu P3759 [TJOI2017] 不勤劳的图书管理员</h4><ul>
<li>题目链接: <a href="https://www.luogu.com.cn/problem/P3759">https://www.luogu.com.cn/problem/P3759</a></li>
</ul>
<p>带权动态逆序对.</p>
<p><del>题外话: 这题有点题意杀, 不过模拟一遍样例就好了</del></p>
<p>仍然使用上一题的转化思路, 题目所求即为 $n$ 个带有两种属性的元素 $(a_i, b_i)$ 中满足 $a_i &lt; a_j$ 且 $b_i &gt; b_j$ 的元素对权值和.</p>
<p>交换位置的操作可以看作删除两个元素后加入两个新元素, 所以问题的关键在于加入 / 删除元素对答案的影响.</p>
<p>每次查询一个元素 $(a, b)$ 的影响, 对这个元素有贡献的, 一定满足:</p>
<ul>
<li><p>第一维 $&lt; a$, 第二维 $&gt; b$</p>
</li>
<li><p>第一维 $&gt; a$, 第二维 $&lt; b$</p>
</li>
</ul>
<p>由于记录信息具有可减性, 采用树状数组套权值线段树实现.</p>
<p><strong>代码实现</strong></p>
<div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3759</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e4</span><span class="number">+5</span>, P = <span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, ans;</span><br><span class="line"><span class="type">int</span> A[MAXN], v[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXN = ::MAXN * <span class="number">16</span> * <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> size, sum;</span><br><span class="line">        <span class="built_in">Node</span>() &#123; size = sum = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> _s, <span class="type">int</span> _v): <span class="built_in">size</span>(_s), <span class="built_in">sum</span>(_v) &#123; &#125;</span><br><span class="line">        Node <span class="keyword">operator</span> + (<span class="type">const</span> Node&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Node</span>((size + rhs.size) % P, (sum + rhs.sum) % P);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; dat[MAXN];</span><br><span class="line">    <span class="type">int</span> lc[MAXN], rc[MAXN], nidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Mdy</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">const</span> <span class="type">int</span>&amp; pos, <span class="type">const</span> <span class="type">int</span>&amp; val, <span class="type">const</span> <span class="type">int</span>&amp; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nd) nd = ++nidx;</span><br><span class="line">        dat[nd].size = (dat[nd].size + <span class="number">1LL</span> * type) % P;</span><br><span class="line">        dat[nd].sum = (dat[nd].sum + <span class="number">1LL</span> * type * val) % P;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> nd;</span><br><span class="line">        <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= Mid) lc[nd] = <span class="built_in">Mdy</span>(lc[nd], L, Mid, pos, val, type);</span><br><span class="line">        <span class="keyword">else</span> rc[nd] = <span class="built_in">Mdy</span>(rc[nd], Mid<span class="number">+1</span>, R, pos, val, type);</span><br><span class="line">        <span class="keyword">return</span> nd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node <span class="title">Qry</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">const</span> <span class="type">int</span>&amp; opL, <span class="type">const</span> <span class="type">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> dat[nd];</span><br><span class="line">        <span class="keyword">if</span> (!nd) <span class="keyword">return</span> <span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> <span class="built_in">Qry</span>(lc[nd], L, Mid, opL, opR);</span><br><span class="line">        <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> <span class="built_in">Qry</span>(rc[nd], Mid<span class="number">+1</span>, R, opL, opR);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Qry</span>(lc[nd], L, Mid, opL, opR) + <span class="built_in">Qry</span>(rc[nd], Mid<span class="number">+1</span>, R, opL, opR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">    <span class="keyword">using</span> SGT::Node;</span><br><span class="line">    <span class="type">int</span> rt[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Mdy</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; d1, <span class="type">const</span> <span class="type">int</span>&amp; d2, <span class="type">const</span> <span class="type">int</span>&amp; val, <span class="type">const</span> <span class="type">int</span>&amp; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d1; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">            rt[i] = SGT::<span class="built_in">Mdy</span>(rt[i], <span class="number">1</span>, n, d2, val, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Qry</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; d1, <span class="type">const</span> <span class="type">int</span>&amp; d2, <span class="type">const</span> <span class="type">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d1; i; i -= <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">            Node tmp = SGT::<span class="built_in">Qry</span>(rt[i], <span class="number">1</span>, n, d2, n);</span><br><span class="line">            ret = (ret + tmp.sum + <span class="number">1LL</span> * val * tmp.size) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i; i -= <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">            Node tmp = SGT::<span class="built_in">Qry</span>(rt[i], <span class="number">1</span>, n, <span class="number">1</span>, d2);</span><br><span class="line">            ret = (ret + tmp.sum + <span class="number">1LL</span> * val * tmp.size) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d1; i; i -= <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">            Node tmp = SGT::<span class="built_in">Qry</span>(rt[i], <span class="number">1</span>, n, <span class="number">1</span>, d2);</span><br><span class="line">            ret = (ret - (tmp.sum + <span class="number">1LL</span> * val * tmp.size) % P + P) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(A[i]), <span class="built_in">read</span>(v[i]);</span><br><span class="line">        ans = (ans + BIT::<span class="built_in">Qry</span>(i, A[i], v[i])) % P;</span><br><span class="line">        BIT::<span class="built_in">Mdy</span>(i, A[i], v[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> L, R;</span><br><span class="line">        <span class="built_in">read</span>(L), <span class="built_in">read</span>(R);</span><br><span class="line">        <span class="comment">// remove</span></span><br><span class="line">        ans = (ans - BIT::<span class="built_in">Qry</span>(L, A[L], v[L]) + P) % P;</span><br><span class="line">        BIT::<span class="built_in">Mdy</span>(L, A[L], v[L], <span class="number">-1</span>);</span><br><span class="line">        ans = (ans - BIT::<span class="built_in">Qry</span>(R, A[R], v[R]) + P) % P;</span><br><span class="line">        BIT::<span class="built_in">Mdy</span>(R, A[R], v[R], <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">swap</span>(A[L], A[R]), <span class="built_in">swap</span>(v[L], v[R]);</span><br><span class="line">        <span class="comment">// add</span></span><br><span class="line">        BIT::<span class="built_in">Mdy</span>(L, A[L], v[L], <span class="number">1</span>);</span><br><span class="line">        ans = (ans + BIT::<span class="built_in">Qry</span>(L, A[L], v[L])) % P;</span><br><span class="line">        BIT::<span class="built_in">Mdy</span>(R, A[R], v[R], <span class="number">1</span>);</span><br><span class="line">        ans = (ans + BIT::<span class="built_in">Qry</span>(R, A[R], v[R])) % P;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<p>数据结构还是学不明白啊, 真是活该退役.png</p>
<p><strong>UPD on 2020.2.27</strong></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>nzhtl1477, 简单数据结构</li>
<li>__stdcall, <a href="https://www.cnblogs.com/mlystdcall/p/6219421.html">简易 CDQ 分治教程 &amp; 学习笔记</a></li>
<li>Owen_codeisking, <a href="https://www.luogu.com.cn/blog/Owencodeisking/post-xue-xi-bi-ji-cdq-fen-zhi-hu-zheng-ti-er-fen">[学习笔记] CDQ 分治和整体二分
</a></li>
</ol>
<hr>

  </div>
  <footer class="article-footer">
    
  <div class="cc">
    <a href="http://creativecommons.org/licenses/by-nc/4.0/deed.z" target="_blank" title="署名-非商业性使用">
      <img src="/images/cc/cc.png">
      
          <img src="/images/cc/by.png">
        
          <img src="/images/cc/nc.png">
        
      <span>
        本作品采用知识共享 署名-非商业性使用 4.0 国际许可协议进行许可。
      </span>
    </a>
  </div>


  </footer>
</article>





          <div class="main-footer">
  
    ©
    
      2019-2025
    
    DepletedPrism&#39;s Blog
    
	- Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  
<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>


  
<link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">

  
<link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">


  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  
<script src="/PhotoSwipe/photoswipe.js"></script>

  
<script src="/PhotoSwipe/photoswipe-ui-default.js"></script>




<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>


<script src="/scripts/main.js"></script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ["$","$"], ["\\(","\\)"] ],
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax();
    for (var i = 0; i < all.length; ++i)
      all[i].SourceElement().parentNode.className += ' has-jax';
  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>


</body>
</html>
