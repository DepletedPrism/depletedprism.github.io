<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    HNOI 2019 大赏
  
</title>

<meta name="description" content="AH 跑去十二省联考了 ( HNOI 独自毒瘤.">
<meta property="og:type" content="article">
<meta property="og:title" content="HNOI 2019 大赏">
<meta property="og:url" content="https://depletedprism.github.io/题解/sol/HNOI-2019-sol/index.html">
<meta property="og:site_name" content="DepletedPrism&#39;s Blog">
<meta property="og:description" content="AH 跑去十二省联考了 ( HNOI 独自毒瘤.">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-04-28T16:16:31.017Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HNOI 2019 大赏">
<meta name="twitter:description" content="AH 跑去十二省联考了 ( HNOI 独自毒瘤.">


  <link rel="alternative" href="/atom.xml" title="DepletedPrism&#39;s Blog" type="application/atom+xml">



  <link rel="icon" href="/images/favicon.jpg">


<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">
<link rel="stylesheet" href="/styles/main.css">


  <!-- Google Analytics -->
  <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-158626830-1', 'auto');
    ga('send', 'pageview');

  </script>
  <!-- End Google Analytics -->





</head>
<body class="monochrome">
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">DepletedPrism&#39;s Blog</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">DepletedPrism&#39;s Blog</a></h1>
    
      <p class="subtitle">
        知其然而不知其所以然是可悲的.
      </p>
    
    <div class="info">
      <div class="content">
        
        
          <div class="author">DepletedPrism</div>
        
      </div>
      
        <div class="avatar">
          
            <a href="/about"><img src="/images/favicon.jpg"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">分类</a>
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/笔记/">笔记</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/题解/">题解</a><span class="category-list-count">41</span></li></ul>
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">标签</a>
                <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Combinatorics/">Combinatorics</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Structure/">Data Structure</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dynamic-Programing/">Dynamic Programing</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Geometry/">Geometry</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Graph/">Graph</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Number-Theory/">Number Theory</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Polynomial/">Polynomial</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Probability-Mean/">Probability & Mean</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/String/">String</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vim/">Vim</a><span class="tag-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">归档</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/9102/">9102</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/4096/">4096</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">37</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">16</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/index.html" title="Homepage">Homepage</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://github.com/DepletedPrism" title="Github" target="_blank" rel="noopener">Github</a>
              </li>
            
          
            
              <li>
                <a href="https://zyzoj.com" title="ZYZOJ" target="_blank" rel="noopener">ZYZOJ</a>
              </li>
            
          
            
              <li>
                <a href="/atom.xml" title="RSS">RSS</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          <article id="post-sol/HNOI-2019-sol" class="article article-type-post">
  
    <h1 class="article-header">
      HNOI 2019 大赏
    </h1>
  
  

  <div class="article-info">
    <span class="article-date">
  2020-03-18
</span>

    
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/题解/">题解</a></li></ul>
	</span>


    

	
  </div>
  <div class="article-entry">
    <hr>
<p>AH 跑去十二省联考了 (</p>
<p>HNOI 独自毒瘤.</p>
<a id="more"></a>
<h3 id="「HNOI2019」鱼"><a href="#「HNOI2019」鱼" class="headerlink" title="「HNOI2019」鱼"></a>「HNOI2019」鱼</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/3054" target="_blank" rel="noopener">https://loj.ac/problem/3054</a></li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>考虑枚举点 $D$, 将其他点按照极角排序, 在排序后得到的结果中枚举点 $A$.</p>
<p>先处理鱼头部分. 显然有 $AD$ 垂直平分 $BC$, 可以通过二分找到中点在 $AD$ 上, 且垂直于 $AD$ 的线段的范围. 将所有点两两连线, 记录得到的向量及中点, 并排序, 可以保证排序后, 满足以上条件的线段是连续的.</p>
<p>再考虑鱼尾部分. 现在已经确定了 $AD$ 位置, 因为有 $DE = DF$, 以及 $\angle ADE,\ \angle ADF$ 的限制, 用 <code>map</code> 记录到点 $D$ 为某一长度的线段出现次数, 并用 Two-Points 的技巧维护合法鱼尾的方案数即可.</p>
<p>此时将鱼头鱼尾的方案数相乘即可. 因为翻转后视为不同的鱼, 最后统计答案需 $\times 4$.</p>
<p>实际代码中并没有用到 <code>double</code> 之类的东西… 判断两向量位置关系用叉积和点积就好了 (</p>
<p>时间复杂度 $O(n^2 \log n)$.</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>在极角序和平面序的浑水里折腾.cpp</p>
<div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3054</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123; <span class="keyword">return</span> !b? a: gcd(b, a % b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Geo &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line">        LL x, y;</span><br><span class="line">        Vector(LL _x = <span class="number">0</span>, LL _y = <span class="number">0</span>): x(_x), y(_y) &#123; &#125;</span><br><span class="line">        Vector <span class="keyword">operator</span> + (<span class="keyword">const</span> Vector&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Vector(x + rhs.x, y + rhs.y); &#125;</span><br><span class="line">        Vector <span class="keyword">operator</span> - (<span class="keyword">const</span> Vector&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Vector(x - rhs.x, y - rhs.y); &#125;</span><br><span class="line">        Vector <span class="keyword">operator</span> * (<span class="keyword">const</span> LL&amp; p) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Vector(p * x, p * y); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">typedef</span> Vector Point;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point&amp; A, <span class="keyword">const</span> Point&amp; B) &#123;</span><br><span class="line">        <span class="keyword">return</span> A.x &lt; B.x || (A.x == B.x &amp;&amp; A.y &lt; B.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">Dot</span><span class="params">(<span class="keyword">const</span> Vector&amp; A, <span class="keyword">const</span> Vector&amp; B)</span> </span>&#123; <span class="keyword">return</span> A.x * B.x + A.y * B.y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">Cross</span><span class="params">(<span class="keyword">const</span> Vector&amp; A, <span class="keyword">const</span> Vector&amp; B)</span> </span>&#123; <span class="keyword">return</span> A.x * B.y - A.y * B.x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">Length2</span><span class="params">(<span class="keyword">const</span> Vector&amp; A)</span> </span>&#123; <span class="keyword">return</span> Dot(A, A); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Vector <span class="title">Normal</span><span class="params">(Vector A)</span> </span>&#123;</span><br><span class="line">        LL g = gcd(A.x, A.y);</span><br><span class="line">        A.x /= g, A.y /= g;</span><br><span class="line">        <span class="keyword">if</span> (A.x &lt; <span class="number">0</span> || (A.x == <span class="number">0</span> &amp;&amp; A.y &lt; <span class="number">0</span>)) A.x = -A.x, A.y = -A.y;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">        Point p; Vector v;</span><br><span class="line">        Line() &#123; p = v = Point(); &#125;</span><br><span class="line">        Line(Point _p, Vector _v): p(_p), v(_v) &#123; &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Line&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (v &lt; rhs.v || rhs.v &lt; v) <span class="keyword">return</span> v &lt; rhs.v;</span><br><span class="line">            <span class="keyword">if</span> (Dot(v, p) != Dot(rhs.v, rhs.p)) <span class="keyword">return</span> Dot(v, p) &lt; Dot(rhs.v, rhs.p);</span><br><span class="line">            <span class="keyword">return</span> p &lt; rhs.p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Geo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">where</span><span class="params">(<span class="keyword">const</span> Vector&amp; A)</span> </span>&#123; <span class="keyword">return</span> A.y &gt; <span class="number">0</span> || (A.y == <span class="number">0</span> &amp;&amp; A.x &lt; <span class="number">0</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Vector&amp; A, <span class="keyword">const</span> Vector&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> where(A) &lt; where(B) || (where(A) == where(B) &amp;&amp; Cross(A, B) &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, nL, nA;</span><br><span class="line">Point P[MAXN], A[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">Line Li[MAXN * MAXN / <span class="number">2</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;LL, <span class="keyword">int</span>&gt; M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(P[i].x), read(P[i].y);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            Li[++nL] = Line(P[i] + P[j], Normal(P[i] - P[j]));</span><br><span class="line">    sort(Li+<span class="number">1</span>, Li+<span class="number">1</span>+nL);</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        nA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="keyword">if</span> (i != j) A[++nA] = P[j] - P[i];</span><br><span class="line">        sort(A+<span class="number">1</span>, A+<span class="number">1</span>+nA, cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nA; ++j) A[nA + j] = A[j];</span><br><span class="line">        M.clear();</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, L = <span class="number">1</span>, R = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nA; ++j) &#123;</span><br><span class="line">            <span class="comment">// [L, R)</span></span><br><span class="line">            <span class="keyword">while</span> (Cross(A[j], A[R]) &gt; <span class="number">0</span> || (R &lt;= nA &amp;&amp; Cross(A[j], A[R]) == <span class="number">0</span>) || Dot(A[j], A[R]) &lt; <span class="number">0</span>)</span><br><span class="line">                s += M[Length2(A[R++])]++;</span><br><span class="line">            <span class="keyword">while</span> (L &lt; R &amp;&amp; Dot(A[j], A[L]) &gt;= <span class="number">0</span>) s -= --M[Length2(A[L++])];</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            Point v = Normal(Point(A[j].y, -A[j].x)), lp = P[i] * <span class="number">2</span>, rp = (P[i] + A[j]) * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (rp &lt; lp) swap(lp, rp);</span><br><span class="line">            <span class="keyword">int</span> d = lower_bound(Li+<span class="number">1</span>, Li+<span class="number">1</span>+nL, Line(rp, v)) - upper_bound(Li+<span class="number">1</span>, Li+<span class="number">1</span>+nL, Line(lp, v));</span><br><span class="line">            ans += <span class="number">4L</span>L * d * s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="「HNOI2019」JOJO"><a href="#「HNOI2019」JOJO" class="headerlink" title="「HNOI2019」JOJO"></a>「HNOI2019」JOJO</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/3055" target="_blank" rel="noopener">https://loj.ac/problem/3055</a></li>
</ul>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>还是 <a href="https://www.luogu.com.cn/blog/dsidsi/solution-p5287" target="_blank" rel="noopener">dsidsi 的题解</a> 好啊.</del></p>
<p>时间复杂度 $O(n\log n)$.</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3055</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read; <span class="keyword">using</span> IO::Gc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>, M = <span class="number">1e4</span> + <span class="number">5</span>, SIGMA = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">s1</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1L</span>L * p * (p + <span class="number">1</span>) / <span class="number">2</span> % P; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, uidx, top;</span><br><span class="line"><span class="keyword">int</span> Ans[MAXN], pos[MAXN], val[MAXN];</span><br><span class="line"><span class="keyword">int</span> rt[MAXN][SIGMA], mx[MAXN][SIGMA];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PSGT &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> <span class="keyword">int</span> lc, rc, s, t, f; &#125; dat[MAXN &lt;&lt; <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">int</span> nidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nidx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(rt[<span class="number">1</span>], <span class="number">0</span>, <span class="keyword">sizeof</span> rt[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">memset</span>(mx[<span class="number">1</span>], <span class="number">0</span>, <span class="keyword">sizeof</span> mx[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span>&amp; nd)</span> </span>&#123; dat[++nidx] = dat[nd], nd = nidx; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">        dat[nd].s = (dat[dat[nd].lc].s + dat[dat[nd].rc].s) % P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushset</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        dat[nd].s = <span class="number">1L</span>L * v * (R - L + <span class="number">1</span>) % P, dat[nd].t = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!dat[nd].t) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> &amp;lc = dat[nd].lc, &amp;rc = dat[nd].rc, Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        newnode(lc), pushset(lc, L, Mid, dat[nd].t);</span><br><span class="line">        newnode(rc), pushset(rc, Mid+<span class="number">1</span>, R, dat[nd].t);</span><br><span class="line">        dat[nd].t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [1, p]: 前缀赋值, 前缀求和</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span>&amp; nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; p, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v, <span class="keyword">const</span> <span class="keyword">int</span>&amp; f)</span> </span>&#123;</span><br><span class="line">        newnode(nd);</span><br><span class="line">        <span class="keyword">if</span> (R &lt; p) <span class="keyword">return</span> pushset(nd, L, R, v);</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> dat[nd].f = f, pushset(nd, L, R, v);</span><br><span class="line">        pushdown(nd, L, R);</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        Mdy(dat[nd].lc, L, Mid, p, v, f);</span><br><span class="line">        <span class="keyword">if</span> (p &gt; Mid) Mdy(dat[nd].rc, Mid+<span class="number">1</span>, R, p, v, f);</span><br><span class="line">        maintain(nd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; p, <span class="keyword">int</span>&amp; s, <span class="keyword">int</span>&amp; fail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (R &lt; p) <span class="keyword">return</span> <span class="keyword">void</span>( s = (s + dat[nd].s) % P );</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> s = (s + dat[nd].s) % P, <span class="keyword">void</span>( fail = dat[nd].f );</span><br><span class="line">        pushdown(nd, L, R);</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        Qry(dat[nd].lc, L, Mid, p, s, fail);</span><br><span class="line">        <span class="keyword">if</span> (p &gt; Mid) Qry(dat[nd].rc, Mid+<span class="number">1</span>, R, p, s, fail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">    <span class="comment">// 维护根节点到 u 的一条链, A[i] 记录链上颜色, B[i] 记录链长度</span></span><br><span class="line">    ++top;</span><br><span class="line">    <span class="keyword">int</span> x = val[u] % M, c = val[u] / M, fail = <span class="number">0</span>;</span><br><span class="line">    A[top] = c, B[top] = B[top - <span class="number">1</span>] + x;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">1</span>) Ans[u] = s1(x - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Ans[u] = (Ans[u] + s1(min(mx[top][c], x))) % P;</span><br><span class="line">        PSGT::Qry(rt[top][c], <span class="number">1</span>, M, x, Ans[u], fail);</span><br><span class="line">        <span class="comment">// 特判前缀第一段字符同末尾相同的情况</span></span><br><span class="line">        <span class="keyword">if</span> (!fail &amp;&amp; A[<span class="number">1</span>] == c &amp;&amp; B[<span class="number">1</span>] &lt; x)</span><br><span class="line">            fail = <span class="number">1</span>, Ans[u] = (Ans[u] + <span class="number">1L</span>L * B[<span class="number">1</span>] * max(<span class="number">0</span>, x - mx[top][c]) % P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    mx[top][c] = max(mx[top][c], x);</span><br><span class="line">    PSGT::Mdy(rt[top][c], <span class="number">1</span>, M, x, B[top - <span class="number">1</span>], top);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v: G[u]) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(rt[top + <span class="number">1</span>], rt[fail + <span class="number">1</span>], <span class="keyword">sizeof</span> rt[top + <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">memcpy</span>(mx[top + <span class="number">1</span>], mx[fail + <span class="number">1</span>], <span class="keyword">sizeof</span> mx[top + <span class="number">1</span>]);</span><br><span class="line">        Ans[v] = Ans[u], dfs(v);</span><br><span class="line">    &#125;</span><br><span class="line">    --top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> opt, x, c;</span><br><span class="line">        read(opt), read(x);</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                c = Gc();</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">isspace</span>(c)) c = Gc();</span><br><span class="line">                val[++uidx] = (c - <span class="string">'a'</span>) * M + x;</span><br><span class="line">                G[pos[i - <span class="number">1</span>]].push_back(pos[i] = uidx);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: pos[i] = pos[x]; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERR\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v: G[<span class="number">0</span>]) PSGT::init(), dfs(v);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans[pos[i]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="「HNOI2019」多边形"><a href="#「HNOI2019」多边形" class="headerlink" title="「HNOI2019」多边形"></a>「HNOI2019」多边形</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/3056" target="_blank" rel="noopener">https://loj.ac/problem/3056</a></li>
</ul>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>通过手玩可以发现, 最终状态一定是多边形内所有的边都连向顶点 $n$. 如果要保证旋转次数最小, 那么每次操作都要使不连向顶点 $n$ 的边, 连向顶点 $n$.</p>
<p>记 $s$ 为 $S_0$ 中同 $n$ 直接相连的边数, 最小旋转次数即为 $n - 3 - s$. 接下来的问题就是求解方案数了.</p>
<p>按照顶点 $n$ 出发的边将多边形分成多个部分, 那么各部分之间互不影响.</p>
<p>单独考虑每个部分. 设当前操作的部分, 边界处顶点为 $[L,\ R]$, 如果要保证旋转次数最小, 那么第一次旋转操作一定选择顶点 $R$ 出边中最靠近 $L$ 的可行边旋转. 设当前选择边为 $(R,\ k)$, 此后该部分被分成两块: $[L,\ k]$, $[k,\ R]$.</p>
<p>此时就可以建立出二叉树的模型. 方案数可以通过子树大小和树上结构计算.</p>
<p>考虑子树间的转移, 也就是取出根节点后, 其余节点按照子树内部顺序考虑. 记左儿子为 $lc$, 右儿子为 $rc$, 根据乘法原理, 方案数乘上</p>
<script type="math/tex; mode=display">\binom{\mathrm{size}(lc) + \mathrm{size}(rc)}{\mathrm{size}(lc)} \cdot \binom{\mathrm{size}(lc) + \mathrm{size}(rc)}{\mathrm{size}(rc)} = \dfrac{(\mathrm{size}(lc) + \mathrm{size}(rc))!}{\mathrm{size}(lc)! \cdot \mathrm{size}(rc)!}</script><p>即可. 根节点之间的情况则类似.</p>
<p>此时的转移, 化简之后可以得到相当简洁的结果. 参见: <a href="https://blog.csdn.net/zhouyuheng2003/article/details/89177440" target="_blank" rel="noopener">zhouyuheng2003 的博客</a>.</p>
<p>但是原来的式子就很够用了, 只有代码长度与常数的区别.</p>
<p>接下来考虑做一次旋转对答案的影响.</p>
<p>在二叉树上考虑. 如果强制旋转一条边, 那么二叉树结构的改变类似于平衡树的旋转操作.</p>
<p><del>此处有张图会非常好理解, 但是这位退役选手却非常鸽子 (</del></p>
<p>图例就参考 <a href="https://www.cnblogs.com/xzz_233/p/10672208.html" target="_blank" rel="noopener">https://www.cnblogs.com/xzz_233/p/10672208.html</a> 好了 (</p>
<p>去掉原有贡献, 并计算新增贡献即可.</p>
<p>时间复杂度 $O(n\log n)$.</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>采用了代码较为冗长的写法…</p>
<div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3056</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % P;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fac[MAXN &lt;&lt; <span class="number">1</span>], ifac[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1L</span>L * fac[n + m] * ifac[n] % P * ifac[m] % P; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">invc</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1L</span>L * ifac[n + m] * fac[n] % P * fac[m] % P; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, W;</span><br><span class="line"><span class="built_in">map</span>&lt;Pii, <span class="keyword">int</span>&gt; M;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="keyword">int</span> rt[MAXN], ch[<span class="number">2</span>][MAXN], pre[MAXN], size[MAXN], nidx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>&amp; u, <span class="keyword">int</span> fa, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span>&amp; p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L + <span class="number">1</span> &gt;= R) <span class="keyword">return</span>;</span><br><span class="line">    M[Pii(L, R)] = u = ++nidx;</span><br><span class="line">    size[u] = <span class="number">1</span>, pre[u] = fa;</span><br><span class="line">    <span class="keyword">int</span> k = *lower_bound(G[R].begin(), G[R].end(), L + <span class="number">1</span>);</span><br><span class="line">    dfs(ch[<span class="number">0</span>][u], u, L, k, p2), dfs(ch[<span class="number">1</span>][u], u, k, R, p2);</span><br><span class="line">    size[u] += size[ch[<span class="number">0</span>][u]] + size[ch[<span class="number">1</span>][u]];</span><br><span class="line">    p2 = <span class="number">1L</span>L * p2 * calc(size[ch[<span class="number">0</span>][u]], size[ch[<span class="number">1</span>][u]]) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(W), read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= n<span class="number">-3</span>; ++i)</span><br><span class="line">        read(u), read(v), G[u].push_back(v), G[v].push_back(u);</span><br><span class="line">    <span class="comment">// init factorial</span></span><br><span class="line">    <span class="keyword">int</span> N = n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    ifac[<span class="number">0</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) fac[i] = <span class="number">1L</span>L * i * fac[i<span class="number">-1</span>] % P;</span><br><span class="line">    ifac[N] = fpow(fac[N], P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i; --i) ifac[i<span class="number">-1</span>] = <span class="number">1L</span>L * i * ifac[i] % P;</span><br><span class="line">    <span class="comment">// build polygon</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) G[i].push_back(i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>) G[i].push_back(i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    G[<span class="number">1</span>].push_back(n), G[n].push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) sort(G[i].begin(), G[i].end());</span><br><span class="line">    <span class="comment">// calculate</span></span><br><span class="line">    <span class="keyword">int</span> p1 = (n<span class="number">-3</span>) - (G[n].size() - <span class="number">2</span>), p2 = <span class="number">1</span>, s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; G[n].size(); ++i) &#123;</span><br><span class="line">        dfs(rt[i], <span class="number">0</span>, G[n][i], G[n][i + <span class="number">1</span>], p2);</span><br><span class="line">        p2 = <span class="number">1L</span>L * p2 * calc(s, size[rt[i]]) % P, s += size[rt[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (W) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, p1, p2); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p1);</span><br><span class="line">    <span class="comment">// solve &amp; output</span></span><br><span class="line">    read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> L, R, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        read(L), read(R);</span><br><span class="line">        <span class="keyword">int</span> n1 = p1, n2 = p2, u = M[Pii(L, R)];</span><br><span class="line">        <span class="keyword">if</span> (pre[u]) &#123;</span><br><span class="line">            <span class="keyword">int</span> fa = pre[u], w = ch[<span class="number">1</span>][fa] == u;</span><br><span class="line">            n2 = <span class="number">1L</span>L * n2 * invc(size[ch[<span class="number">0</span>][u]], size[ch[<span class="number">1</span>][u]]) % P;</span><br><span class="line">            n2 = <span class="number">1L</span>L * n2 * invc(size[ch[<span class="number">0</span>][fa]], size[ch[<span class="number">1</span>][fa]]) % P;</span><br><span class="line">            n2 = <span class="number">1L</span>L * n2 * calc(size[ch[w^<span class="number">1</span>][fa]], size[ch[w^<span class="number">1</span>][u]]) % P;</span><br><span class="line">            n2 = <span class="number">1L</span>L * n2 * calc(size[fa] - size[u] + size[ch[w^<span class="number">1</span>][u]], size[ch[w][u]]) % P;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --n1;</span><br><span class="line">            n2 = <span class="number">1L</span>L * n2 * invc(size[ch[<span class="number">0</span>][u]], size[ch[<span class="number">1</span>][u]]) % P;</span><br><span class="line">            n2 = <span class="number">1L</span>L * n2 * invc(s - size[u], size[u]) % P;</span><br><span class="line">            n2 = <span class="number">1L</span>L * n2 * calc(s - size[u], size[ch[<span class="number">0</span>][u]]) % P;</span><br><span class="line">            n2 = <span class="number">1L</span>L * n2 * calc(s - size[u] + size[ch[<span class="number">0</span>][u]], size[ch[<span class="number">1</span>][u]]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (W) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, n1, n2); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="「HNOI2019」校园旅行"><a href="#「HNOI2019」校园旅行" class="headerlink" title="「HNOI2019」校园旅行"></a>「HNOI2019」校园旅行</h3><p>myy 的题感觉很有意思… 就是做不出来 (</p>
<h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/3057" target="_blank" rel="noopener">https://loj.ac/problem/3057</a></li>
</ul>
<h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>先祭上官方题解: <a href="https://matthew99.blog.uoj.ac/blog/4968" target="_blank" rel="noopener">https://matthew99.blog.uoj.ac/blog/4968</a></p>
<p>首先有一个朴素的 DP.</p>
<p>设 $f(i, j)$ 表示节点 $i$ 到 $j$ 是否存在一条路径, 使得标记形成回文串.</p>
<p>将所有在给定条件下能形成回文串的点对丢到队列中, 枚举边更新 $f$ 即可. 注意到单独一个点也是合法的情况. 此时的时间复杂度为 $O(m^2)$.</p>
<p>考虑到边数较多, 而点数较少. 可以将连通块内连边情况进行一些改造, 以降低时间复杂度.</p>
<p>先只考虑连接两相同标记的边, 对于此时的一个连通块, 如果</p>
<ul>
<li><p>为二分图, 那么保留连通块的任意一个生成树即可.</p>
<p>因为不限制为简单路径, 因此可以在连通块内一条边上反复横跳, 此时得到的标记串长度可以改变, 而奇偶性并不改变. 因此保留生成树即可.</p>
</li>
<li><p>不为二分图, 此时保留任意一个生成树, 并选择任意一个节点增加一个自环.</p>
<p>此时存在奇环, 标记串长度和奇偶性都可以任意改变, 增加一个自环就好了.</p>
</li>
</ul>
<p>对于连接两不同标记的边, 直接按标记分类即可得到一个二分图, 因此保留任意一个生成树.</p>
<p>转化后边数不超过 $2n - 2$, 且不会影响到原来 DP 的转移, 用原来的 DP 就好了.</p>
<p>时间复杂度 $O(n^2)$.</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3057</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e3</span> + <span class="number">5</span>, MAXM = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Abs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span> </span>&#123; <span class="keyword">return</span> x &lt; <span class="number">0</span>? -x: x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">char</span> S[MAXN];</span><br><span class="line"><span class="keyword">int</span> C[MAXN], U[MAXM], V[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;Pii&gt; Q;</span><br><span class="line"><span class="keyword">bool</span> f[MAXN][MAXN], Odd[MAXN], vis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DSU &#123;</span><br><span class="line">    <span class="keyword">int</span> fa[<span class="number">2</span>][MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[<span class="number">0</span>][i] = fa[<span class="number">1</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findfa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; idx, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fa[idx][u] == u? u: fa[idx][u] = findfa(idx, fa[idx][u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front().first, v = Q.front().second; Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> iu = head[u]; ~iu; iu = edges[iu].nxt) &#123;</span><br><span class="line">                <span class="keyword">int</span> vu = edges[iu].to;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> vv, iv = head[v]; ~iv; iv = edges[iv].nxt)</span><br><span class="line">                    <span class="keyword">if</span> (S[vu] == S[vv = edges[iv].to] &amp;&amp; !f[vu][vv])</span><br><span class="line">                        f[vu][vv] = f[vv][vu] = <span class="literal">true</span>, Q.push(Pii(vu, vv));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        C[u] = c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!C[v = edges[i].to]) dfs(v, -c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (C[v] == c) Odd[Abs(c)] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="comment">// freopen("input.in", "r", stdin);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%s"</span>, &amp;n, &amp;m, &amp;q, S+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        read(u), read(v), U[i] = u, V[i] = v;</span><br><span class="line">        <span class="keyword">if</span> (S[u] == S[v]) Graph::AddEdge(u, v), Graph::AddEdge(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!C[i]) Graph::dfs(i, i);</span><br><span class="line">    Graph::init(), DSU::init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> &amp;u = U[i], &amp;v = V[i];</span><br><span class="line">        <span class="keyword">if</span> (S[u] != S[v]) &#123;</span><br><span class="line">            <span class="keyword">int</span> fu = DSU::findfa(<span class="number">1</span>, u), fv = DSU::findfa(<span class="number">1</span>, v);</span><br><span class="line">            <span class="keyword">if</span> (fu == fv) <span class="keyword">continue</span>;</span><br><span class="line">            DSU::fa[<span class="number">1</span>][fv] = fu;</span><br><span class="line">            Graph::AddEdge(u, v), Graph::AddEdge(v, u);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> fu = DSU::findfa(<span class="number">0</span>, u), fv = DSU::findfa(<span class="number">0</span>, v);</span><br><span class="line">            <span class="keyword">if</span> (fu == fv) <span class="keyword">continue</span>;</span><br><span class="line">            DSU::fa[<span class="number">0</span>][fv] = fu;</span><br><span class="line">            Graph::AddEdge(u, v), Graph::AddEdge(v, u);</span><br><span class="line">            Q.push(Pii(u, v)), f[u][v] = f[v][u] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = Abs(C[i]);</span><br><span class="line">        Q.push(Pii(i, i)), f[i][i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (Odd[c] &amp;&amp; !vis[c]) Graph::AddEdge(i, i), vis[c] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Graph::BFS();</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x, y;</span><br><span class="line">        read(x), read(y), <span class="built_in">puts</span>(f[x][y]? <span class="string">"YES"</span>: <span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="「HNOI2019」白兔之舞"><a href="#「HNOI2019」白兔之舞" class="headerlink" title="「HNOI2019」白兔之舞"></a>「HNOI2019」白兔之舞</h3><blockquote>
<p>强制类型转换而 “溢出” 不会被 <code>-fsanitize=undefined</code> 警告, <code>-Wconversion</code> 报平安.</p>
</blockquote>
<h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/3058" target="_blank" rel="noopener">https://loj.ac/problem/3058</a></li>
</ul>
<h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><ul>
<li><p>单位根反演</p>
<p><del>之前看 <a href="http://vfleaking.blog.uoj.ac/blog/87" target="_blank" rel="noopener">VFleaKing</a> 课件还以为这个东西没考过 (</del></p>
<p>给定两个长度为 $n$ 的序列 $a_0,\ a_1,\ \ldots,\ a_{n-1}$, $b_0,\ b_1,\ \ldots,\ b_{n-1}$, 求序列 $c$ 满足</p>
<script type="math/tex; mode=display">c_r = \sum_{p,\ q} [(p + q) \bmod n = r] a_p b_q</script><p>由单位根反演, 可得</p>
<script type="math/tex; mode=display">c_r = \sum_{p,\ q} (\frac{1}{n} \sum_{k = 0} ^ {n-1} \omega_{n}^{-rk} \omega_{n}^{pk} \omega_{n}^{qk} )\ a_p b_q = \frac{1}{n} \sum_{k = 0}^{n-1} \omega_{n}^{-rk} \sum_{p} \omega_{n}^{pk} a_p \sum_{q} \omega_{n}^{qk} b_q</script><p>具体证明参见课件好了…</p>
</li>
</ul>
<h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>将题目中 “有向图” 看作二维平面, 并称第一维为行, 第二维为列. 那么共有 $L+1$ 行, 以及 $n$ 列.</p>
<p>考虑朴素 DP. 设 $f(i, j)$ 表示共走 $i$ 步, 到达第 $j$ 行任意位置的方案数. $g(i, j)$ 表示共走 $i$ 步, 达到第 $j$ 行的方案数. 那么有</p>
<script type="math/tex; mode=display">f(i, j) = \binom{L}{i} g(i, j)</script><script type="math/tex; mode=display">g(i, j) = \sum_{k = 1} ^ n g(i-1, k) \cdot w(k, j)</script><p>显然 $g$ 的转移可以用矩阵快速幂优化. 记初始矩阵为 $G_0$, 转移矩阵为 $S$. 设所求答案为 $A_t$, 那么</p>
<script type="math/tex; mode=display">A_t = \sum_{i = 1} ^ L [i \bmod k = t]\ f(i, y)</script><p>由单位根反演, 得</p>
<script type="math/tex; mode=display">A_t = \sum_{i = 1} ^ L \frac{1}{k} \sum_{j = 0} ^ {k-1} \omega_{k}^{-tj} \omega_{k}^{ij}\ f(i, y)</script><p>简单整理, 得</p>
<script type="math/tex; mode=display">A_t = \frac{1}{k} \sum_{j = 0}^{k-1} \omega_{k}^{-tj} \sum_{i = 1} ^ L \omega_{k}^{ij} \binom{L}{i} g(i, j) \\\\
A_t = \frac{1}{k} \sum_{j = 0}^{k-1} \omega_{k}^{-tj} \sum_{i = 1} ^ L \binom{L}{i} \omega_{k}^{ij} G_0 S^i</script><p>根据二项式定理, 并设矩阵 $B_t$ 的第 $y$ 项为 $A_t$, 可知</p>
<script type="math/tex; mode=display">B_t = \frac{1}{k} \sum_{i = 0}^{k-1} \omega_{k}^{-ti} G_0 (\omega_{k}^{i} S + I)^L</script><p>设 $h_i$ 为 $G_0 (\omega_{k}^{i} + I) ^ L$ 的第 $y$ 项. 那么</p>
<script type="math/tex; mode=display">A_t = \frac{1}{k} \sum_{i = 0} ^ {k-1} \omega_{k}^{-ti} h_i</script><p>考虑 $\omega_{k}^{ti}$ 如何处理. 此处可以构造</p>
<script type="math/tex; mode=display">ti = \binom{t + i}{2} - \binom{t}{2} - \binom{i}{2}</script><p>容易发现这是对的. 此外还有</p>
<script type="math/tex; mode=display">ti = \frac{1}{2} (t + i) ^ 2 - \frac{1}{2}\ t ^ 2 - \frac{1}{2}\ i ^ 2</script><p>不过在此题中并不适用. <del>想一想, 为什么.</del></p>
<p>那么答案可写作</p>
<script type="math/tex; mode=display">A_t = \frac{1}{k} \omega_{k}^{\binom{t}{2}} \sum_{i = 0} ^ {k-1} \omega_{k}^{\binom{i}{2}} h_i \cdot \omega_{k}^{-\binom{t+i}{2}}</script><p>模意义下单位根用原根就好了, 翻转即可凑出来卷积…</p>
<p>使用 MTT, 时间复杂度 $O(n \log n)$.</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3058</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>, MAXM = <span class="number">4</span>, MAXL = <span class="number">64</span>, MAXK = <span class="number">7e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Complex(<span class="keyword">double</span> _x = <span class="number">0.0</span>, <span class="keyword">double</span> _y = <span class="number">0.0</span>): x(_x), y(_y) &#123; &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> + (<span class="keyword">const</span> Complex&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Complex(x + rhs.x, y + rhs.y); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> - (<span class="keyword">const</span> Complex&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Complex(x - rhs.x, y - rhs.y); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> * (<span class="keyword">const</span> Complex&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Complex <span class="title">conj</span><span class="params">(<span class="keyword">const</span> Complex&amp; p)</span> </span>&#123; <span class="keyword">return</span> Complex(p.x, -p.y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> P;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> m = P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % m;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    Complex W[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) W[i] = Complex(<span class="built_in">cos</span>(PI / Lim * i), <span class="built_in">sin</span>(PI / Lim * i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j) &#123;</span><br><span class="line">                    Complex f0 = f[i+j], f1 = W[<span class="number">1L</span>L * j * Lim / Mid] * f[i+j+Mid];</span><br><span class="line">                    f[i+j] = f0 + f1, f[i+j+Mid] = f0 - f1;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> Lim, <span class="keyword">int</span>* h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Complex A[MAXN], B[MAXN];</span><br><span class="line">        <span class="keyword">static</span> Complex dfta[MAXN], dftb[MAXN], dftc[MAXN], dftd[MAXN];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = Complex(f[i] &amp; <span class="number">32767</span>, f[i] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) B[i] = Complex(g[i] &amp; <span class="number">32767</span>, g[i] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">        FFT(A, Lim), FFT(B, Lim);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) &#123;</span><br><span class="line">            <span class="keyword">static</span> Complex da, db, dc, dd;</span><br><span class="line">            <span class="keyword">int</span> j = (Lim - i) &amp; (Lim - <span class="number">1</span>);</span><br><span class="line">            da = (A[i] + conj(A[j])) * Complex(<span class="number">0.5</span>, <span class="number">0.0</span>);</span><br><span class="line">            db = (A[i] - conj(A[j])) * Complex(<span class="number">0.0</span>, <span class="number">-0.5</span>);</span><br><span class="line">            dc = (B[i] + conj(B[j])) * Complex(<span class="number">0.5</span>, <span class="number">0.0</span>);</span><br><span class="line">            dd = (B[i] - conj(B[j])) * Complex(<span class="number">0.0</span>, <span class="number">-0.5</span>);</span><br><span class="line">            dfta[j] = da * dc, dftb[j] = da * dd;</span><br><span class="line">            dftc[j] = db * dc, dftd[j] = db * dd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = dfta[i] + dftb[i] * Complex(<span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) B[i] = dftc[i] + dftd[i] * Complex(<span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        FFT(A, Lim), FFT(B, Lim);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> da = LL(A[i].x / Lim + <span class="number">0.5</span>) % P, db = LL(A[i].y / Lim + <span class="number">0.5</span>) % P;</span><br><span class="line">            <span class="keyword">int</span> dc = LL(B[i].x / Lim + <span class="number">0.5</span>) % P, dd = LL(B[i].y / Lim + <span class="number">0.5</span>) % P;</span><br><span class="line">            h[i] = (da + (LL(db + dc) &lt;&lt; <span class="number">15</span>) + (LL(dd) &lt;&lt; <span class="number">30</span>)) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> n, <span class="keyword">int</span>* g, <span class="keyword">int</span> m, <span class="keyword">int</span>* h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt;= n + m) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">        init(Lim, L), MTT(f, g, Lim, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">proot</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> fact[MAXL];</span><br><span class="line">    <span class="keyword">int</span> phi = p - <span class="number">1</span>, tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">2</span>; d*d &lt;= phi; ++d) <span class="keyword">if</span> (phi % d == <span class="number">0</span>) &#123;</span><br><span class="line">        fact[++tot] = d;</span><br><span class="line">        <span class="keyword">while</span> (phi % d == <span class="number">0</span>) phi /= d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (phi &gt; <span class="number">1</span>) fact[++tot] = phi;</span><br><span class="line">    phi = p - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= phi; ++i) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; flag; ++j)</span><br><span class="line">            <span class="keyword">if</span> (fpow(i, phi / fact[j], p) == <span class="number">1</span>) flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 long long --- 引用部分就是在说这个 (</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1L</span>L * n * (n<span class="number">-1</span>) / <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K, L, x, y;</span><br><span class="line"><span class="keyword">int</span> W[MAXM][MAXM], powG[MAXK];</span><br><span class="line"><span class="keyword">int</span> f[MAXN], g[MAXN], h[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m[MAXM][MAXM];</span><br><span class="line">    Matrix() &#123; <span class="built_in">memset</span>(m, <span class="number">0</span>, <span class="keyword">sizeof</span> m); &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        Matrix ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                    ret.m[i][j] = (ret.m[i][j] + <span class="number">1L</span>L * m[i][k] * rhs.m[k][j] % P) % P;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">fpow</span><span class="params">(Matrix base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    Matrix ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ret.m[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * base;</span><br><span class="line">        base = base * base, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>, &amp;n, &amp;K, &amp;L, &amp;x, &amp;y, &amp;P);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, W[i] + j);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">int</span> G = fpow(proot(P), (P - <span class="number">1</span>) / K);</span><br><span class="line">    powG[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; K; ++i) powG[i] = <span class="number">1L</span>L * powG[i<span class="number">-1</span>] * G % P;</span><br><span class="line">    Matrix base, G0;</span><br><span class="line">    G0.m[<span class="number">1</span>][x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">1</span>; a &lt;= n; ++a) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">1</span>; b &lt;= n; ++b) base.m[a][b] = <span class="number">1L</span>L * W[a][b] * powG[i] % P;</span><br><span class="line">            base.m[a][a] = (base.m[a][a] + <span class="number">1</span>) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        base = G0 * fpow(base, L);</span><br><span class="line">        f[i] = <span class="number">1L</span>L * base.m[<span class="number">1</span>][y] * powG[C2(i) % K] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>*K; ++i) g[i] = powG[(K - C2(i) % K) % K];</span><br><span class="line">    reverse(g, g + <span class="number">2</span>*K + <span class="number">1</span>);</span><br><span class="line">    Poly::Mul(f, K, g, <span class="number">2</span>*K + <span class="number">1</span>, h);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">int</span> invK = fpow(K, P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; K; ++t) &#123;</span><br><span class="line">        LL s1 = <span class="number">1L</span>L * invK * powG[C2(t) % K] % P;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, s1 * h[<span class="number">2</span>*K - t] % P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="「HNOI2019」序列"><a href="#「HNOI2019」序列" class="headerlink" title="「HNOI2019」序列"></a>「HNOI2019」序列</h3><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/3059" target="_blank" rel="noopener">https://loj.ac/problem/3059</a></li>
</ul>
<h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>类似于 <a href="https://m1.oi-archive.org:9000/#/problem/bzoj/1367" target="_blank" rel="noopener">BZOJ 1367</a>, 可得到这样的思路:</p>
<p>将 $A$ 分段, 对每一段 $[L,\ R]$ 构造相同的序列 $B_i$, 并令 $B_i$ 为该段 $A_i$ 的平均值. 在满足 $B$ 单调不降的条件下使每次分出区间长度尽量小, 此时可以得到最优结果.</p>
<p><del>个人感觉证明方法应该类似于 黄源河 &lt;左偏树的特点及其应用&gt; 例题部分对 BZOJ 1367 的证明</del>.</p>
<p>证明参见 <a href="https://www.cnblogs.com/Paul-Guderian/p/10801584.html" target="_blank" rel="noopener">https://www.cnblogs.com/Paul-Guderian/p/10801584.html</a> 好了.</p>
<p>$A$ 的分段情况可以利用单调栈维护.</p>
<p>具体地说, 每个单调栈中元素对应 $A$ 中一段区间. 假设单调栈内某一元素对应 $A_i$ 中区间 $[L,\ R]$, 记该段平均值为 $\bar x$, 那么区间内的答案为</p>
<script type="math/tex; mode=display">\sum_{i = L}^ R (A_i - \bar x) ^ 2 = \sum_{i = L}^R A_i^2 - \frac{1}{R - L + 1} (\sum_{i = L}^R A_i) ^ 2</script><p>此时记录区间和, 区间平方和, 区间大小就可以快速合并两个区间的信息, 也就是单调栈内两元素的值.</p>
<p>从前往后扫描 $A$, 假设当前扫描到位置 $i$, 那么在单调栈中加入 $i$. 此时不断检查栈中元素. 如果不满足 $B$ 单调不降, 则不断向栈内元素合并. 同时记录在每个位置得到的答案.</p>
<p>此时得到了 $m = 0$ 情况下的做法.</p>
<p>注意到每次都是单点修改, 考虑单点修改对单调栈中元素的影响. 设当前修改位置为 $x$, 那么在修改后重新计算得到单调栈中一定存在一个区间满足 $L \le x \le R$.</p>
<p>重构单调栈的复杂度过高, 如果确定了 $L$, $R$ 的位置, 那么除去这一部分, 其他部分并不会改变. 因此仿照从前到后维护单调栈的过程, 从后往前扫描 $A$, 这样配合可持久化就能快速得到 $[1,\ L)$ 以及 $(R, n]$ 的信息.</p>
<p>现在的问题就是如何确定 $L,\ R$ 的位置. 根据单调性, $L,\ R$ 的位置可以通过二分来确定.</p>
<p>具体地说, 在维护单调栈的过程中, 利用可持久化线段树维护单调栈中每个元素在序列上的实际范围. 线段树向上合并时维护该节点对应实际范围 $[L,\ R]$, 以及最靠左元素对应的右端点位置 $k$.</p>
<p>不断二分 $x$ 修改后影响到的单调栈编号 $p$, 每次在线段树上查询到该编号对应的右端点位置 $R$. 可以证明, 改变 $x$ 位置的值后, 确定的 $L$, $R$ 位置仍是原有单调栈中某个元素的左右端点之一, 否则答案一定不优.</p>
<p>另外需保证选择的区间长度尽量小, 因此 $R$ 的位置很好确定, 直接找到编号 $p$ 对应的右端点位置. 根据 $R$ 的位置, 并利用 $B$ 单调不降的限制, 可以确定出左端点 $L$ 的位置, 并在查询 $L$ 位置的同时维护 $[L,\ R]$ 这一段合并后得到的元素. 如果该元素小于后一位置单调栈中元素, 那么编号 $p$ 合法, 减小区间长度继续二分.</p>
<p><del>似乎也可以通过二分套二分实现这个过程 ?</del></p>
<p>时间复杂度 $O(n \log n + m \log ^ 2 n)$.</p>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3059</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>, P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> inv[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> s0; LL s1; <span class="keyword">int</span> s2;</span><br><span class="line">    Data() &#123; s1 = s0 = s2 = <span class="number">0</span>; &#125;</span><br><span class="line">    Data(<span class="keyword">int</span> _s0, LL _s1, <span class="keyword">int</span> _s2): s0(_s0), s1(_s1), s2(_s2) &#123; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Data&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s1 * rhs.s0 &lt; rhs.s1 * s0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> Data&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(rhs &lt; *<span class="keyword">this</span>); &#125;</span><br><span class="line">    Data <span class="keyword">operator</span> + (<span class="keyword">const</span> Data&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Data(s0 + rhs.s0, s1 + rhs.s1, (s2 + rhs.s2) % P);</span><br><span class="line">    &#125;</span><br><span class="line">    Data <span class="keyword">operator</span> - (<span class="keyword">const</span> Data&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Data(s0 - rhs.s0, s1 - rhs.s1, (s2 - rhs.s2 + P) % P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> s = s1 % P; <span class="keyword">return</span> (s2 - <span class="number">1L</span>L * s % P * s % P * inv[s0] % P + P) % P; &#125;</span><br><span class="line">&#125; Sum[MAXN], stk[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, top;</span><br><span class="line"><span class="keyword">int</span> A[MAXN];</span><br><span class="line"><span class="keyword">int</span> pre[MAXN], suf[MAXN];</span><br><span class="line"><span class="keyword">int</span> Ansp[MAXN], Anss[MAXN], Posp[MAXN], Poss[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Data <span class="title">Part</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="number">0</span> || R == <span class="number">0</span>) <span class="keyword">return</span> Data();</span><br><span class="line">    <span class="keyword">return</span> Sum[R] - Sum[L - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PSGT &#123;</span><br><span class="line">    <span class="comment">// [L, k], (k, ..., R]</span></span><br><span class="line">    <span class="comment">// [L, k] 为一段, 其余部分不一定是一段 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> <span class="keyword">int</span> lc, rc, L, R, k; &#125; dat[MAXN &lt;&lt; <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">int</span> nidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> &amp;rc = dat[nd].rc, &amp;lc = dat[nd].lc;</span><br><span class="line">        dat[nd].L = dat[nd].R = dat[lc].L;</span><br><span class="line">        <span class="keyword">if</span> (rc) dat[nd].R = dat[rc].R;</span><br><span class="line">        dat[nd].k = dat[lc].k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; pos, <span class="keyword">const</span> <span class="keyword">int</span>&amp; vL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; vR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nxt = ++nidx;</span><br><span class="line">        dat[nxt] = dat[nd];</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> dat[nxt].L = vL, dat[nxt].R = dat[nxt].k = vR, nxt;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= Mid) dat[nxt].lc = Mdy(dat[nxt].lc, L, Mid, pos, vL, vR);</span><br><span class="line">        <span class="keyword">else</span> dat[nxt].rc = Mdy(dat[nxt].rc, Mid+<span class="number">1</span>, R, pos, vL, vR);</span><br><span class="line">        <span class="keyword">return</span> maintain(nxt), nxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">QryR</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> dat[nd].R;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= Mid) <span class="keyword">return</span> QryR(dat[nd].lc, L, Mid, pos);</span><br><span class="line">        <span class="keyword">return</span> QryR(dat[nd].rc, Mid+<span class="number">1</span>, R, pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">QryL</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; pos, Data&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (R &lt;= pos) &#123;</span><br><span class="line">            Data vL = Part(dat[nd].L, dat[nd].k), vR = Part(dat[nd].k + <span class="number">1</span>, dat[nd].R);</span><br><span class="line">            <span class="keyword">if</span> (vR + d &lt;= vL)</span><br><span class="line">                <span class="keyword">return</span> d = d + Part(dat[nd].L, dat[nd].R), <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (L == R) <span class="keyword">return</span> dat[nd].R;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 尽可能找到最大的可行 L</span></span><br><span class="line">        <span class="keyword">if</span> (pos &gt; Mid) &#123;</span><br><span class="line">            <span class="keyword">int</span> ret = QryL(dat[nd].rc, Mid+<span class="number">1</span>, R, pos, d); </span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> QryL(dat[nd].lc, L, Mid, pos, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]);</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) inv[i] = <span class="number">1L</span>L * (P - P / i) * inv[P % i] % P;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        Sum[i] = Sum[i<span class="number">-1</span>] + Data(<span class="number">1</span>, A[i], <span class="number">1L</span>L * A[i] * A[i] % P);</span><br><span class="line">    <span class="comment">// pre done</span></span><br><span class="line">    stk[top = <span class="number">0</span>] = Data();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        stk[++top] = Data(<span class="number">1</span>, A[i], <span class="number">1L</span>L * A[i] * A[i] % P);</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; stk[top] &lt;= stk[top<span class="number">-1</span>])</span><br><span class="line">            stk[top<span class="number">-1</span>] = stk[top<span class="number">-1</span>] + stk[top], --top;</span><br><span class="line">        Posp[i] = top;</span><br><span class="line">        Ansp[i] = (Ansp[i - stk[top].s0] + stk[top].calc()) % P;</span><br><span class="line">        pre[i] = PSGT::Mdy(pre[i<span class="number">-1</span>], <span class="number">1</span>, n, top, i - stk[top].s0 + <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// suf done</span></span><br><span class="line">    stk[top = <span class="number">0</span>] = Data();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) &#123;</span><br><span class="line">        stk[++top] = Data(<span class="number">1</span>, A[i], <span class="number">1L</span>L * A[i] * A[i] % P);</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; stk[top<span class="number">-1</span>] &lt;= stk[top])</span><br><span class="line">            stk[top<span class="number">-1</span>] = stk[top<span class="number">-1</span>] + stk[top], --top;</span><br><span class="line">        Poss[i] = top;</span><br><span class="line">        Anss[i] = (Anss[i + stk[top].s0] + stk[top].calc()) % P;</span><br><span class="line">        suf[i] = PSGT::Mdy(suf[i+<span class="number">1</span>], <span class="number">1</span>, n, top, i, i + stk[top].s0 - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ansp[n]);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x, val;</span><br><span class="line">        read(x), read(val);</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = Poss[x + <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> Rp = Mid? PSGT::QryR(suf[x+<span class="number">1</span>], <span class="number">1</span>, n, Poss[x+<span class="number">1</span>] - Mid + <span class="number">1</span>): x;</span><br><span class="line">            Data d = Data(<span class="number">1</span>, val, <span class="number">1L</span>L * val * val % P) + Part(x+<span class="number">1</span>, Rp);</span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">1</span>) PSGT::QryL(pre[x<span class="number">-1</span>], <span class="number">1</span>, n, Posp[x<span class="number">-1</span>], d);</span><br><span class="line">            <span class="keyword">if</span> (d &lt; Part(Rp + <span class="number">1</span>, PSGT::QryR(suf[x+<span class="number">1</span>], <span class="number">1</span>, n, Poss[x+<span class="number">1</span>] - Mid))) R = Mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> L = Mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Rp = (R + <span class="number">1</span> &gt; <span class="number">0</span>)? PSGT::QryR(suf[x+<span class="number">1</span>], <span class="number">1</span>, n, Poss[x+<span class="number">1</span>] - R): x;</span><br><span class="line">        Data d = Data(<span class="number">1</span>, val, <span class="number">1L</span>L * val * val % P) + Part(x+<span class="number">1</span>, Rp);</span><br><span class="line">        <span class="keyword">int</span> Lp = x &gt; <span class="number">1</span>? PSGT::QryL(pre[x<span class="number">-1</span>], <span class="number">1</span>, n, Posp[x<span class="number">-1</span>], d): x;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ((Ansp[Lp] + d.calc()) % P + Anss[Rp+<span class="number">1</span>]) % P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<hr>

  </div>
  <footer class="article-footer">
    
  <div class="cc">
    <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.z" target="_blank" title="署名-非商业性使用-相同方式共享">
      <img src="/images/cc/cc.png">
      
          <img src="/images/cc/by.png">
        
          <img src="/images/cc/nc.png">
        
          <img src="/images/cc/sa.png">
      
      <span>
        本作品采用知识共享 署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。
      </span>
    </a>
  </div>


  </footer>
  
</article>


    <link rel="stylesheet" href="/css/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <div id="gitalk-container"></div>
    <script src="/scripts/gitalk.js"></script>




          <div class="main-footer">
  
    © 2020 DepletedPrism&#39;s Blog
    
	- Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  <script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

  <link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">
  <link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/PhotoSwipe/photoswipe.js"></script>
  <script src="/PhotoSwipe/photoswipe-ui-default.js"></script>


<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>
<script src="/scripts/main.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!--script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

</body>
</html>
--></body></html>