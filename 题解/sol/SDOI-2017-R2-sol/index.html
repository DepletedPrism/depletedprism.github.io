<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    SDOI 2017 Round 2 大赏
  
</title>

<meta name="description" content="图源 ZZQ&apos;s Blog, 至少我是从那里找到的 这 Round 2 也太毒瘤了 = =">
<meta property="og:type" content="article">
<meta property="og:title" content="SDOI 2017 Round 2 大赏">
<meta property="og:url" content="https://depletedprism.github.io/题解/sol/SDOI-2017-R2-sol/index.html">
<meta property="og:site_name" content="DepletedPrism&#39;s Blog">
<meta property="og:description" content="图源 ZZQ&apos;s Blog, 至少我是从那里找到的 这 Round 2 也太毒瘤了 = =">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://depletedprism.github.io/images/SDOI-2017-sol/SDOI.jpg">
<meta property="og:updated_time" content="2020-04-28T16:07:02.790Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SDOI 2017 Round 2 大赏">
<meta name="twitter:description" content="图源 ZZQ&apos;s Blog, 至少我是从那里找到的 这 Round 2 也太毒瘤了 = =">
<meta name="twitter:image" content="https://depletedprism.github.io/images/SDOI-2017-sol/SDOI.jpg">


  <link rel="alternative" href="/atom.xml" title="DepletedPrism&#39;s Blog" type="application/atom+xml">



  <link rel="icon" href="/images/favicon.jpg">


<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">
<link rel="stylesheet" href="/styles/main.css">


  <!-- Google Analytics -->
  <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-158626830-1', 'auto');
    ga('send', 'pageview');

  </script>
  <!-- End Google Analytics -->





</head>
<body class="monochrome">
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">DepletedPrism&#39;s Blog</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">DepletedPrism&#39;s Blog</a></h1>
    
      <p class="subtitle">
        知其然而不知其所以然是可悲的.
      </p>
    
    <div class="info">
      <div class="content">
        
        
          <div class="author">DepletedPrism</div>
        
      </div>
      
        <div class="avatar">
          
            <a href="/about"><img src="/images/favicon.jpg"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">分类</a>
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/笔记/">笔记</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/题解/">题解</a><span class="category-list-count">38</span></li></ul>
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">标签</a>
                <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Combinatorics/">Combinatorics</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Structure/">Data Structure</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dynamic-Programing/">Dynamic Programing</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Geometry/">Geometry</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Graph/">Graph</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Number-Theory/">Number Theory</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Polynomial/">Polynomial</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Probability-Mean/">Probability & Mean</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/String/">String</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vim/">Vim</a><span class="tag-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">归档</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/9102/">9102</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/4096/">4096</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">33</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">16</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/index.html" title="Homepage">Homepage</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://github.com/DepletedPrism" title="Github" target="_blank" rel="noopener">Github</a>
              </li>
            
          
            
              <li>
                <a href="https://zyzoj.com" title="ZYZOJ" target="_blank" rel="noopener">ZYZOJ</a>
              </li>
            
          
            
              <li>
                <a href="/atom.xml" title="RSS">RSS</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          <article id="post-sol/SDOI-2017-R2-sol" class="article article-type-post">
  
    <h1 class="article-header">
      SDOI 2017 Round 2 大赏
    </h1>
  
  

  <div class="article-info">
    <span class="article-date">
  2020-03-08
</span>

    
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/题解/">题解</a></li></ul>
	</span>


    

	
  </div>
  <div class="article-entry">
    <hr>
<div style="text-align:center;"><img src="/images/SDOI-2017-sol/SDOI.jpg"> </div>

<p><em><p style="text-align:center;">图源 <a href="https://www.cnblogs.com/zzqsblog/p/7523003.html" target="_blank" rel="noopener">ZZQ's Blog</a>, 至少我是从那里找到的</p></em></p>
<p>这 Round 2 也太毒瘤了 = =</p>
<a id="more"></a>
<p>久 等 了.</p>
<h3 id="「SDOI2017」龙与地下城"><a href="#「SDOI2017」龙与地下城" class="headerlink" title="「SDOI2017」龙与地下城"></a>「SDOI2017」龙与地下城</h3><p>验题人在多测的情况下总算是写了十行代码?</p>
<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/2267" target="_blank" rel="noopener">https://loj.ac/problem/2267</a></li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先有一个多项式做法.</p>
<p>构造一个生成函数 $g(x)$, 其 $k$ 次项系数表示掷一次骰子造成伤害 $k$ 的概率, 则</p>
<script type="math/tex; mode=display">g(x) = \sum_{k=0}^{X-1} \frac{1}{X} x^k</script><p>那么 $g(x)^Y$ 的 $A_i$ 到 $B_i$ 次项和即为答案.</p>
<p>对于这个多项式幂函数的计算, 可以用带大常数的 $O(n \log n)$ 多项式 $\exp$ , 或者朴素快速幂 $O(n \log ^2 n)$.</p>
<p>但是有精巧的做法, 此处直接把点值做 $Y$ 次幂就好了.</p>
<p>当年考场 AC 似乎有更为精巧的优化方法, 好像 myy 的论文 &lt;再探快速傅里叶变换&gt; 里有涉及, <del>以后再说以后再说</del></p>
<p>对于大数据 <del>如果问什么是大数据, 那就是 FFT 跑不过的数据</del>, 则要用到 <a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86#%E6%9E%97%E5%BE%B7%E4%BC%AF%E6%A0%BC%EF%BC%8D%E5%88%97%E7%BB%B4%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">中心极限定理</a>.</p>
<p>记 $\zeta_{n} = \dfrac{\bar X - \mu}{\sigma / \sqrt n} = \dfrac{\sum\limits_{i=1}^n X_i - n \mu}{\sqrt {n \sigma ^2 }}$, 根据中心极限定理, 当 $n \rightarrow \infty$ 时, 认为其满足正态分布 $N(0, 1)$.</p>
<p>而正态分布 $N(\mu, \sigma^2)$ 的概率密度函数为</p>
<script type="math/tex; mode=display">f(x) = \frac{1}{\sqrt{ 2 \sigma^2 \pi }} e ^{ -\frac {(x-\mu)^2}{2 \sigma ^2} }</script><p>对于 $N(0, 1)$, 带进去可得</p>
<script type="math/tex; mode=display">f(x) = \frac{1}{\sqrt{ 2 \pi}} e ^{ -\frac{x^2}{2} }</script><p>具体应用到这道题中, 用自适应 Simpson 计算</p>
<script type="math/tex; mode=display">\int _a^b f(x)\ dx</script><p>就好了, 其中 $a = \dfrac{A_i - Y \mu}{\sqrt{ Y \sigma ^2 }},\ b = \dfrac{B_i - Y\mu}{\sqrt{ Y \sigma ^ 2}}$.</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>就这样吧 = =, 只能流下没有数理基础的眼泪.</p>
<p>至今不知道为什么直接大力 Simpson $[L, R]$ 会挂, 取端点做差就对了 = =</p>
<p>可能是因为 $L$ 正负性的问题?</p>
<div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2267</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">262145</span> &lt;&lt; <span class="number">1</span>, MAXM = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Complex(<span class="keyword">double</span> _x = <span class="number">0.0</span>, <span class="keyword">double</span> _y = <span class="number">0.0</span>): x(_x), y(_y) &#123; &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> + (<span class="keyword">const</span> Complex&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Complex(x + rhs.x, y + rhs.y); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> - (<span class="keyword">const</span> Complex&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Complex(x - rhs.x, y - rhs.y); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> * (<span class="keyword">const</span> Complex&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">fpow</span><span class="params">(Complex base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">ret</span><span class="params">(<span class="number">1.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * base;</span><br><span class="line">        base = base * base, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex* f, <span class="keyword">int</span> Lim, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="function">Complex <span class="title">unit</span><span class="params">(<span class="built_in">cos</span>(PI / Mid), type * <span class="built_in">sin</span>(PI / Mid))</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += (Mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j, w = w * unit) &#123;</span><br><span class="line">                    Complex f0 = f[i+j], f1 = w * f[i+j+Mid];</span><br><span class="line">                    f[i+j] = f0 + f1, f[i+j+Mid] = f0 - f1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i].x /= Lim;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> X, Y;</span><br><span class="line"><span class="keyword">int</span> A[MAXM], B[MAXM];</span><br><span class="line">Complex g[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> frac = <span class="number">1.0</span> / <span class="built_in">sqrt</span>(<span class="number">2.0</span> * PI);</span><br><span class="line">    <span class="keyword">return</span> frac * <span class="built_in">exp</span>(x * x / <span class="number">-2.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">simpson</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; L, <span class="keyword">const</span> <span class="keyword">double</span>&amp; R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (R - L) / <span class="number">6.0</span> * (f(L) + f(R) + <span class="number">4.0</span> * f((L + R) / <span class="number">2.0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">asr</span><span class="params">(<span class="keyword">double</span> L, <span class="keyword">double</span> R, <span class="keyword">const</span> <span class="keyword">double</span>&amp; eps, <span class="keyword">double</span> ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Mid = (L + R) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">double</span> fl = simpson(L, Mid), fr = simpson(Mid, R);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(fl + fr - ans) &lt; <span class="number">15</span> * eps) <span class="keyword">return</span> fl + fr + (fl + fr - ans) / <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">return</span> asr(L, Mid, eps / <span class="number">2.0</span>, fl) + asr(Mid, R, eps / <span class="number">2.0</span>, fr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> Ti;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;X, &amp;Y);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXM; ++i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, A+i, B+i);</span><br><span class="line">        <span class="comment">// solve</span></span><br><span class="line">        <span class="keyword">if</span> (X * Y &lt; MAXN) &#123;</span><br><span class="line">            <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (Lim &lt;= X * Y) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">            Poly::init(Lim, L);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; X; ++i) g[i].x = <span class="number">1.0</span> / X;</span><br><span class="line">            Poly::FFT(g, Lim, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) g[i] = fpow(g[i], Y);</span><br><span class="line">            Poly::FFT(g, Lim, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXM; ++i) &#123;</span><br><span class="line">                <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = A[i]; j &lt;= B[i]; ++j) ans += g[j].x;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> mu = (X - <span class="number">1.0</span>) / <span class="number">2.0</span>, sigma2 = (X * X - <span class="number">1.0</span>) / <span class="number">12.0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXM; ++i) &#123;</span><br><span class="line">                <span class="keyword">double</span> L = (A[i] - Y * mu) / <span class="built_in">sqrt</span>(Y * sigma2),</span><br><span class="line">                       R = (B[i] - Y * mu) / <span class="built_in">sqrt</span>(Y * sigma2);</span><br><span class="line">                <span class="comment">// printf("%.7lf\n", asr(L, R, 1e-9, simpson(L, R)));</span></span><br><span class="line">                <span class="comment">// 如果使用以上写法, 某些答案为 1.0 的情况, 算出来是 0.0 = =</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%.7lf\n"</span>, asr(<span class="number">0</span>, R, <span class="number">1e-9</span>, simpson(<span class="number">0</span>, R)) - asr(<span class="number">0</span>, L, <span class="number">1e-9</span>, simpson(<span class="number">0</span>, L)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="「SDOI2017」苹果树"><a href="#「SDOI2017」苹果树" class="headerlink" title="「SDOI2017」苹果树"></a>「SDOI2017」苹果树</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/2268" target="_blank" rel="noopener">https://loj.ac/problem/2268</a></li>
</ul>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>观察题意可以发现, 关于 $k$ 的限定可以看作免费取一条从根开始的链, 再取 $k$ 个物品, 取儿子必须取至少一个父亲的树形依赖背包. 棘手的地方在于链的处理.</p>
<p>考虑怎么把链干掉. 可以发现, 树上点权都是正的, 如果取一条链, 那么一定从根一直取到叶子. 所以可以枚举叶子, 把树分成链左半部分和右半部分.</p>
<p>再看一遍树的结构, 实际上把树分成了 3 部分</p>
<ol>
<li>链上免费取的部分</li>
<li>链左边付费取的部分 (我们把链上付费取的部分归到这里)</li>
<li>链右边付费取的部分</li>
</ol>
<p>所以设 $f(i, j)$ 表示第 $i$ 个节点, 体积为 $j$ 的最大收益, 也就是在计算第 2 部分的答案.</p>
<p>类似地, 设 $g(i, j)$ 表示 DFS 序翻转后, 第 $i$ 个节点, 体积为 $j$ 的最大收益, 也就是在计算第 3 部分的答案.</p>
<p>树上依赖的关系不好处理, 考虑将每个物品数 $a_i &gt; 1$ 节点拆开, 拆成一个物品数为 $1$ 的节点留在原来的位置, 以及一个物品数为 $a_i - 1$ 的节点挂在另外一个节点旁.</p>
<p>(实际上建图的时候并不必要把这个点真的拆开, 在转移的时候额外判断就好了).</p>
<p>最后枚举叶子, 累加第 1 部分, 把另外两部分拼起来即可. (也就是 $f(i, j) + g(i, j-k)$)</p>
<p>注意到对于每个节点的转移, 实际上是一个多重背包, 使用单调队列优化即可.</p>
<p>时间复杂度 $O(Qnk)$.</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>实现参考了 <a href="https://www.cnblogs.com/clrs97/p/7842530.html" target="_blank" rel="noopener">Claris</a>.</p>
<p>有些卡常, 需要把 DP 的二维数组开成一维, 增加缓存命中率.</p>
<div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2268</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e4</span> + <span class="number">5</span>, MAXK = <span class="number">5e5</span> + <span class="number">5</span>, MAXM = <span class="number">2</span> * MAXK + <span class="number">25e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K, M, ans;</span><br><span class="line"><span class="keyword">int</span> pre[MAXN], A[MAXN], V[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXM], g[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>* F, <span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> Q[MAXK], W[MAXK], head, tail;</span><br><span class="line">    Q[head = <span class="number">1</span>] = tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt;= K; ++i, j += v) &#123;</span><br><span class="line">        F[i] -= j;</span><br><span class="line">        <span class="keyword">while</span> (head &lt;= tail &amp;&amp; F[Q[tail]] &lt; F[i]) --tail;</span><br><span class="line">        Q[++tail] = i;</span><br><span class="line">        <span class="keyword">while</span> (head &lt;= tail &amp;&amp; i - Q[head] &gt; a) ++head;</span><br><span class="line">        W[i] = F[Q[head]] + j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(F, W, M * <span class="keyword">sizeof</span> (<span class="keyword">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, (n + <span class="number">1</span>) * <span class="keyword">sizeof</span> (<span class="keyword">int</span>)), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs0</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A[u]) solve(f + M * u, A[u], V[u]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edges[i].to;</span><br><span class="line">            <span class="built_in">memcpy</span>(f + M * v, f + M * u, M * <span class="keyword">sizeof</span> (<span class="keyword">int</span>));</span><br><span class="line">            dfs0(v);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; ++j)</span><br><span class="line">                f[M * u + j] = max(f[M * u + j], f[M * v + j - <span class="number">1</span>] + V[v]);</span><br><span class="line">            <span class="comment">// "至少取一个父节点的物品" 的限制就体现在这里了, g(i, j) 同理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edges[i].to;</span><br><span class="line">            <span class="built_in">memcpy</span>(g + M * v, g + M * u, M * <span class="keyword">sizeof</span> (<span class="keyword">int</span>));</span><br><span class="line">            dfs1(v, s + V[u]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; ++j)</span><br><span class="line">                g[M * u + j] = max(g[M * u + j], g[M * v + j - <span class="number">1</span>] + V[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head[u] == <span class="number">-1</span>) <span class="comment">// leaf</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= K; ++j)</span><br><span class="line">                ans = max(ans, V[u] + s + f[M * u + j] + g[M * u + K - j]);</span><br><span class="line">        <span class="keyword">if</span> (A[u]) solve(g + M * u, A[u], V[u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> Ti; read(Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        read(n), read(K);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            read(pre[i]), read(A[i]), read(V[i]), --A[i];</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        ans = <span class="number">0</span>, M = K + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f + M, <span class="number">0</span>, M * <span class="keyword">sizeof</span> (<span class="keyword">int</span>));</span><br><span class="line">        <span class="built_in">memset</span>(g + M, <span class="number">0</span>, M * <span class="keyword">sizeof</span> (<span class="keyword">int</span>));</span><br><span class="line">        <span class="comment">// solve</span></span><br><span class="line">        Graph::init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) Graph::AddEdge(pre[i], i);</span><br><span class="line">        Graph::dfs0(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 对于 "DFS 翻转", 反着建图即可</span></span><br><span class="line">        Graph::init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">2</span>; --i) Graph::AddEdge(pre[i], i);</span><br><span class="line">        Graph::dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// output</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="「SDOI2017」切树游戏"><a href="#「SDOI2017」切树游戏" class="headerlink" title="「SDOI2017」切树游戏"></a>「SDOI2017」切树游戏</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/2269" target="_blank" rel="noopener">https://loj.ac/problem/2269</a></li>
</ul>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>先祭上 <a href="http://immortalco.blog.uoj.ac/blog/2625" target="_blank" rel="noopener">猫锟的解题报告</a>.</p>
<p>然后就是动态 DP 了.</p>
<p>此处信息仍具有可减性, 维护数非 0 部分的积, 以及乘积中 0 的个数即可了.</p>
<p>落实到代码中就是那个 <code>Num</code> 了.</p>
<p>还有个可以借鉴的 Trick 就是化简矩阵减小常数了. 直接搬来 immortalCO 的公式.</p>
<script type="math/tex; mode=display">\begin{pmatrix} \underline{a_1} & \underline{b_1} & 0 \\ 0 & 1 & 0 \\ \underline{c_1} & \underline{d_1} & 1 \end{pmatrix} \times \begin{pmatrix} \underline{a_2} & \underline{b_2} & 0 \\ 0 & 1 & 0 \\ \underline{c_2} & \underline{d_2} & 1 \end{pmatrix} = \begin{pmatrix} \underline{a_1 a_2} & \underline{b_1 + a_1 b_2} & 0 \\ 0 & 1 & 0 \\ \underline{a_2 c_1 + c_2} & \underline{b_2 c_1 + d_1 + d_2} & 1 \end{pmatrix}</script><p>运用这个 Trick 的时候, 需要额外注意矩阵的运算顺序.</p>
<p>动态 DP 采用树链剖分实现, 时间复杂度 $O(n\log ^ 3 n)$.</p>
<p><del>最近一群毒瘤看着这个 log^3 不爽, 看来要去学 DDP 的 LCT 实现了</del></p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2269</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read; <span class="keyword">using</span> IO::Gc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e4</span>+<span class="number">5</span>, MAXM = <span class="number">128</span>, P = <span class="number">10007</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FWT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> Lim, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> LL inv2 = <span class="number">5004</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, Mid = <span class="number">2</span>; Mid &lt;= Lim; Mid &lt;&lt;= <span class="number">1</span>, k &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> f0 = f[i+j], f1 = f[i+j+k];</span><br><span class="line">                f[i+j] = (f0 + f1) % P, f[i+j+k] = (f0 - f1 + P) % P;</span><br><span class="line">                <span class="keyword">if</span> (type == <span class="number">-1</span>) f[i+j] = inv2 * f[i+j] % P, f[i+j+k] = inv2 * f[i+j+k] % P;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">int</span> E[MAXM][MAXM], V[MAXN], inv[P];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXM], g[MAXN][MAXM], lg[MAXN][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Num</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, c;</span><br><span class="line">    Num() &#123; x = c = <span class="number">0</span>; &#125;</span><br><span class="line">    Num(<span class="keyword">int</span> _x): x((_x == <span class="number">0</span>)? <span class="number">1</span>: _x), c(_x == <span class="number">0</span>) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">val</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c? <span class="number">0</span>: x; &#125;</span><br><span class="line">    Num&amp; <span class="keyword">operator</span>*= (<span class="keyword">const</span> <span class="keyword">int</span>&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rhs != <span class="number">0</span>) x = <span class="number">1L</span>L * x * rhs % P; <span class="keyword">else</span> ++c;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Num&amp; <span class="keyword">operator</span>/= (<span class="keyword">const</span> <span class="keyword">int</span>&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rhs != <span class="number">0</span>) x = <span class="number">1L</span>L * x * inv[rhs] % P; <span class="keyword">else</span> --c;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; lf[MAXN][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HLD &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">int</span> son[MAXN], pre[MAXN], depth[MAXN], size[MAXN];</span><br><span class="line">    <span class="keyword">int</span> dfn[MAXN], Ed[MAXN], rnk[MAXN], topfa[MAXN], dfs_clock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">        size[u] = <span class="number">1</span>, son[u] = <span class="number">-1</span>, pre[u] = fa;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) f[u][j] = E[V[u]][j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) == fa) <span class="keyword">continue</span>;</span><br><span class="line">            dfs1(v, u), size[u] += size[v];</span><br><span class="line">            <span class="keyword">if</span> (son[u] == <span class="number">-1</span> || size[v] &gt; size[son[u]]) son[u] = v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                f[u][j] = (f[u][j] + <span class="number">1L</span>L * f[u][j] * f[v][j] % P) % P;</span><br><span class="line">                g[u][j] = (g[u][j] + g[v][j]) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) g[u][j] = (g[u][j] + f[u][j]) % P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">        topfa[u] = top;</span><br><span class="line">        dfn[u] = ++dfs_clock, rnk[dfs_clock] = u, Ed[top] = dfs_clock;</span><br><span class="line">        <span class="keyword">if</span> (~son[u]) dfs2(son[u], top);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) lf[u][j] = Num(E[<span class="number">0</span>][j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) == pre[u] || v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">            dfs2(v, v);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">                lf[u][j] *= (<span class="number">1</span> + f[v][j]) % P, lg[u][j] = (lg[u][j] + g[v][j]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt = <span class="number">1</span>)</span> </span>&#123; dfs1(rt, <span class="number">0</span>), dfs2(rt, rt); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> A[MAXM], B[MAXM], C[MAXM], D[MAXM];</span><br><span class="line">    Node() &#123; <span class="built_in">memset</span>(<span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">sizeof</span> *<span class="keyword">this</span>); &#125;</span><br><span class="line">    Node <span class="keyword">operator</span> * (<span class="keyword">const</span> Node&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        Node ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            ret.A[i] = <span class="number">1L</span>L * A[i] * rhs.A[i] % P;</span><br><span class="line">            ret.B[i] = (<span class="number">1L</span>L * A[i] * rhs.B[i] % P + B[i]) % P;</span><br><span class="line">            ret.C[i] = (<span class="number">1L</span>L * rhs.A[i] * C[i] % P + rhs.C[i]) % P;</span><br><span class="line">            ret.D[i] = (<span class="number">1L</span>L * C[i] * rhs.B[i] % P + rhs.D[i] + D[i]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (nd&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (nd&lt;&lt;1|1)</span></span><br><span class="line">    Node dat[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123; dat[nd] = dat[rc] * dat[lc]; &#125;</span><br><span class="line">    <span class="comment">// 注意 maintain 合并两矩阵的顺序</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">1L</span>L * lf[u][i].val() * E[V[u]][i] % P;</span><br><span class="line">            dat[nd].A[i] = dat[nd].B[i] = dat[nd].C[i] = a;</span><br><span class="line">            dat[nd].D[i] = (a + lg[u][i]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> newnode(nd, HLD::rnk[L]);</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        build(lc, L, Mid), build(rc, Mid+<span class="number">1</span>, R);</span><br><span class="line">        maintain(nd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> newnode(nd, HLD::rnk[L]);</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= Mid) Mdy(lc, L, Mid, pos);</span><br><span class="line">        <span class="keyword">else</span> Mdy(rc, Mid+<span class="number">1</span>, R, pos);</span><br><span class="line">        maintain(nd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> dat[nd];</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> Qry(lc, L, Mid, opL, opR);</span><br><span class="line">        <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> Qry(rc, Mid+<span class="number">1</span>, R, opL, opR);</span><br><span class="line">        <span class="keyword">return</span> Qry(rc, Mid+<span class="number">1</span>, R, opL, opR) * Qry(lc, L, Mid, opL, opR);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t1[MAXN], t2[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HLD &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        Node res = SGT::Qry(<span class="number">1</span>, <span class="number">1</span>, n, dfn[u], Ed[u]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) t1[i] = res.C[i], t2[i] = res.D[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        V[u] = val;</span><br><span class="line">        <span class="keyword">while</span> (u &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> fa = pre[topfa[u]];</span><br><span class="line">            Qry(topfa[u]);</span><br><span class="line">            <span class="keyword">if</span> (fa) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">                lf[fa][i] /= (t1[i] + <span class="number">1</span>) % P, lg[fa][i] = (lg[fa][i] - t2[i] + P) % P;</span><br><span class="line">            SGT::Mdy(<span class="number">1</span>, <span class="number">1</span>, n, dfn[u]);</span><br><span class="line">            Qry(topfa[u]);</span><br><span class="line">            <span class="keyword">if</span> (fa) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">                lf[fa][i] *= (t1[i] + <span class="number">1</span>) % P, lg[fa][i] = (lg[fa][i] + t2[i]) % P;</span><br><span class="line">            u = fa;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; P; ++i) inv[i] = <span class="number">1L</span>L * (P - P / i) * inv[P % i] % P;</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(V[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        read(u), read(v), Graph::AddEdge(u, v), Graph::AddEdge(v, u);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) E[i][i] = <span class="number">1</span>, FWT(E[i], m, <span class="number">1</span>);</span><br><span class="line">    HLD::solve(), SGT::build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    read(q);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> opt, x, y;</span><br><span class="line">        opt = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isspace</span>(opt)) opt = Gc();</span><br><span class="line">        read(x);</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>: read(y), HLD::Mdy(x, y); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'Q'</span>: HLD::Qry(<span class="number">1</span>), FWT(t2, m, <span class="number">-1</span>), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t2[x]); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERR\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="「SDOI2017」天才黑客"><a href="#「SDOI2017」天才黑客" class="headerlink" title="「SDOI2017」天才黑客"></a>「SDOI2017」天才黑客</h3><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/2270" target="_blank" rel="noopener">https://loj.ac/problem/2270</a></li>
</ul>
<h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>如果把边看作点, 容易得到这样一个做法:</p>
<ol>
<li>枚举边, 假设当前枚举到的边为 $(a, b)$.</li>
<li>找到形如 $(b, c)$ 的边, 两者之间连边, 边权为两者 LCP, 也就是 Trie 树上 LCA 到根的距离.</li>
<li>跑 Dijkstra, 对于每个点 $u$, 找到形如 $(a, u)$ 的边更新答案.</li>
</ol>
<p>但是这个算法有一个明显的问题, 遇到原图中点数度数很大的情况就会连很多边…</p>
<p>考虑如何优化这个过程. </p>
<p>对于 Trie 上一个节点 $u$, 将 $u$ 周围一圈节点按 DFS 序排序, 类似于后缀数组, 设 $h_i = \operatorname{LCP}(s_i, s_{i+1})$, 那么</p>
<script type="math/tex; mode=display">\operatorname{LCP}(s_L,\ s_R) = \min \{ h_j \mid L \le j \le R \}</script><p>利用后缀数组中常见套路, 可以利用单调栈求出 LCP 为 $h_i$ 的一段区间, 然后点向区间连边, 区间向点连边即可. 利用线段树优化建图即可.</p>
<p>但是有更加简便的办法. 还是引用 <a href="https://www.cnblogs.com/clrs97/p/7833797.html" target="_blank" rel="noopener">Claris 的博客</a>:</p>
<blockquote>
<p>枚举每个 $h_i$ 作为分界线，那么新图中两侧的点均可以通过不超过 $h_i$ 的代价互相访问.</p>
<p>建立一排前缀虚点和后缀虚点然后对应前后缀之间连边即可.</p>
</blockquote>
<p>具体地说, 前缀入点 <code>prei</code> 和前缀出点 <code>preo</code> 之间边权分别为 $0$, 每个 <code>prei[i]</code> 向 <code>preo[i+1]</code> 连边, 权值为 $h_i$.</p>
<p>这样连边就以较小的代价做了等效的事情. 后缀同理.</p>
<p>可能还是有些抽象, 不过在代码实现里还是很清晰的. 以及一些入点出点的细节也体现在代码里.</p>
<p>时间复杂度 $O(m \log m)$.</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p>你问我为什么执意写树剖求 LCA… 这… 我要是会倍增我不就写倍增了吗 = =</p>
<p>以及边拆为点时, 并不需要额外新增一条边记录初始边权, 直接视作点权在跑 Dijkstra 的过程中更新即可.</p>
<div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2270</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e4</span> + <span class="number">5</span>, MAXK = <span class="number">2e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = MAXN * <span class="number">10</span>, MAXE = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, K, uidx;</span><br><span class="line"><span class="keyword">int</span> U[MAXN], D[MAXN], Ans[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; In[MAXN], Out[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, w; &#125; edges[MAXE];</span><br><span class="line">    <span class="keyword">int</span> head[MAXV], eidx;</span><br><span class="line">    <span class="keyword">int</span> dist[MAXV], val[MAXV];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, w &#125;, head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;Pii, <span class="built_in">vector</span>&lt;Pii&gt;, greater&lt;Pii&gt; &gt; PQ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= uidx; ++i) dist[i] = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="keyword">if</span> (U[i] == <span class="number">1</span>) PQ.push(Pii(dist[i] = val[i], i));</span><br><span class="line">        <span class="keyword">while</span> (!PQ.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = PQ.top().first, u = PQ.top().second; PQ.pop();</span><br><span class="line">            <span class="keyword">if</span> (d != dist[u]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = edges[i].to;</span><br><span class="line">                <span class="keyword">if</span> (dist[v] &gt; val[v] + dist[u] + edges[i].w)</span><br><span class="line">                    PQ.push(Pii(dist[v] = val[v] + dist[u] + edges[i].w, v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">2</span>; u &lt;= n; ++u) &#123;</span><br><span class="line">            Ans[u] = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; In[u].size(); ++i)</span><br><span class="line">                Ans[u] = min(Ans[u], Graph::dist[In[u][i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HLD &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXK];</span><br><span class="line">    <span class="keyword">int</span> head[MAXK], eidx;</span><br><span class="line">    <span class="keyword">int</span> depth[MAXK], pre[MAXK], son[MAXK], size[MAXK];</span><br><span class="line">    <span class="keyword">int</span> topfa[MAXK], dfn[MAXK], dfs_clock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">        son[u] = <span class="number">-1</span>, size[u] = <span class="number">1</span>, pre[u] = fa;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            dfs1(v = edges[i].to, u), size[u] += size[v];</span><br><span class="line">            <span class="keyword">if</span> (son[u] == <span class="number">-1</span> || size[son[u]] &lt; size[v]) son[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">        topfa[u] = top, dfn[u] = ++dfs_clock;</span><br><span class="line">        <span class="keyword">if</span> (~son[u]) dfs2(son[u], top);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) != son[u]) dfs2(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        depth[<span class="number">0</span>] = <span class="number">-1</span>, dfs1(rt, <span class="number">0</span>), dfs2(rt, rt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (topfa[u] != topfa[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth[topfa[u]] &lt; depth[topfa[v]]) swap(u, v);</span><br><span class="line">            u = pre[topfa[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth[u] &gt; depth[v]? v: u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Abs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &lt; <span class="number">0</span>? -x: x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfn[D[Abs(x)]] &lt; dfn[D[Abs(y)]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> preo[MAXN], prei[MAXN], sufi[MAXN], sufo[MAXN], q[MAXN];</span><br><span class="line">        <span class="keyword">int</span> nq = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; In[u].size(); ++i) q[++nq] = In[u][i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; Out[u].size(); ++i) q[++nq] = -Out[u][i];</span><br><span class="line">        <span class="comment">// 区分出入点和出点</span></span><br><span class="line">        sort(q+<span class="number">1</span>, q+<span class="number">1</span>+nq, cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nq; ++i) &#123;</span><br><span class="line">            preo[i] = ++uidx, prei[i] = ++uidx, sufo[i] = ++uidx, sufi[i] = ++uidx;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                Graph::AddEdge(preo[i<span class="number">-1</span>], preo[i], <span class="number">0</span>), Graph::AddEdge(prei[i<span class="number">-1</span>], prei[i], <span class="number">0</span>);</span><br><span class="line">                Graph::AddEdge(sufo[i], sufo[i<span class="number">-1</span>], <span class="number">0</span>), Graph::AddEdge(sufi[i], sufi[i<span class="number">-1</span>], <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (q[i] &gt; <span class="number">0</span>)</span><br><span class="line">                Graph::AddEdge(q[i], prei[i], <span class="number">0</span>), Graph::AddEdge(q[i], sufi[i], <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                q[i] = -q[i], Graph::AddEdge(preo[i], q[i], <span class="number">0</span>), Graph::AddEdge(sufo[i], q[i], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nq; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> lca = LCA(D[q[i]], D[q[i + <span class="number">1</span>]]);</span><br><span class="line">            Graph::AddEdge(prei[i], preo[i + <span class="number">1</span>], depth[lca]);</span><br><span class="line">            Graph::AddEdge(sufi[i + <span class="number">1</span>], sufo[i], depth[lca]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> Ti; read(Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        Graph::init(), HLD::init();</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        read(n), read(m), read(K); uidx = m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            read(U[i]), read(v), read(Graph::val[i]), read(D[i]);</span><br><span class="line">            In[v].push_back(i), Out[U[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u, v, w, i = <span class="number">1</span>; i &lt; K; ++i)</span><br><span class="line">            read(u), read(v), read(w), HLD::AddEdge(u, v);</span><br><span class="line">        <span class="comment">// solve</span></span><br><span class="line">        HLD::solve();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) HLD::build(i);</span><br><span class="line">        Graph::Dijkstra();</span><br><span class="line">        <span class="comment">// output</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans[i]);</span><br><span class="line">        <span class="comment">// clear</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) Graph::val[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) In[i].clear(), Out[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="「SDOI2017」遗忘的集合"><a href="#「SDOI2017」遗忘的集合" class="headerlink" title="「SDOI2017」遗忘的集合"></a>「SDOI2017」遗忘的集合</h3><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/submission/759802" target="_blank" rel="noopener">https://loj.ac/submission/759802</a></li>
</ul>
<h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>如果把所求和已知交换, 那么这道题就是一道生成函数套路题了.</p>
<p>设序列 $a_i$ 表示元素 $i$ 是否存在于集合 $S$ 中. 那么取 $S$ 中元素之和的方案数的生成函数为</p>
<script type="math/tex; mode=display">F(x) = \prod_{i \in S} (\sum_{k=0}^{\infty} x^{ki}) = \prod_{i \in S} \frac{1}{1 - x^i} = \prod_{i=1}^n (\frac{1}{1 - x^i} ) ^ {a_i}</script><p>看到乘积不爽. 两边同时取 $\ln$, 得</p>
<script type="math/tex; mode=display">- \ln F(x) = \sum_{i=1}^n a_i \ln (1-x^i)</script><p>记 $g(x) = \ln (1-x^i)$, 那么对 $g(x)$ 求导得到</p>
<script type="math/tex; mode=display">\frac{(1 - x^i)'}{1 - x^i} = \frac{-i x^{i-1}}{1 - x^i} = g'(x)</script><p>由广义二项式定理, 得</p>
<script type="math/tex; mode=display">-ix^{i-1} \sum_{k=0}^{\infty} x ^{ki} = -\sum_{k=0}^{\infty} i x^{ki +i-1} = g'(x)</script><p>再积分, 得</p>
<script type="math/tex; mode=display">-\sum_{k=0} ^ {\infty} \frac{i}{ki + i} x^{ki + i} = -\sum_{k=1}^{\infty} \frac{1}{k} x ^ {ki} = g(x)</script><p>所以我们就得到了</p>
<script type="math/tex; mode=display">g(x) = \ln (1 - x^i) = -\sum_{k=1}^{\infty} \frac{1}{k} x^{ki}</script><p>代入原式, 可以得到</p>
<script type="math/tex; mode=display">\ln F(x) = \sum_{i=1}^n a_i \sum_{k=1}^{\infty} \frac{1}{k} x^{ki}</script><p>设 $T = ki$, 并交换枚举顺序, 得</p>
<script type="math/tex; mode=display">\ln F(x) = \sum_{T=1}^\infty (\sum_{d \mid T} a_d \frac{d}{T} ) x^T</script><p>至此, 这道题就做完了. 对给定的 $F(x)$ 求 $\ln$ 后莫比乌斯反演即可.</p>
<p>此处并不需要筛出来 $\mu$ 之后 $O(\sqrt n)$ 枚举约数… 直接利用 <a href="http://vfleaking.blog.uoj.ac/blog/87" target="_blank" rel="noopener">VFleaKing 反演课件</a> 里的技巧即可.</p>
<p>时间复杂度 $O(n\log n)$.</p>
<p>其实整个过程叫做 “Euler Transform”? 类似的技巧也在 <a href="https://www.luogu.com.cn/problem/P4389" target="_blank" rel="noopener">Luogu P4389 付公主的背包</a> 用到过.</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><p>先滚过去学了 MTT 才写了这道题 = =</p>
<div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2271</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1</span> &lt;&lt; <span class="number">19</span>, M = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Complex(<span class="keyword">double</span> _x = <span class="number">0.0</span>, <span class="keyword">double</span> _y = <span class="number">0.0</span>): x(_x), y(_y) &#123; &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> + (<span class="keyword">const</span> Complex&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Complex(x + rhs.x, y + rhs.y); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> - (<span class="keyword">const</span> Complex&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Complex(x - rhs.x, y - rhs.y); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> * (<span class="keyword">const</span> Complex&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Complex <span class="title">conj</span><span class="params">(<span class="keyword">const</span> Complex&amp; p)</span> </span>&#123; <span class="keyword">return</span> Complex(p.x, -p.y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> P;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> m = P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % m;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    Complex W[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) W[i] = Complex(<span class="built_in">cos</span>(PI / Lim * i), <span class="built_in">sin</span>(PI / Lim * i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j) &#123;</span><br><span class="line">                    Complex f0 = f[i+j], f1 = W[<span class="number">1L</span>L * j * Lim / Mid] * f[i+j+Mid];</span><br><span class="line">                    f[i+j] = f0 + f1, f[i+j+Mid] = f0 - f1;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MTT</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* f, <span class="keyword">const</span> <span class="keyword">int</span>* g, <span class="keyword">int</span> Lim, <span class="keyword">int</span>* h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Complex A[MAXN], B[MAXN];</span><br><span class="line">        <span class="keyword">static</span> Complex dfta[MAXN], dftb[MAXN], dftc[MAXN], dftd[MAXN];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = Complex(f[i] &amp; M, f[i] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) B[i] = Complex(g[i] &amp; M, g[i] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">        FFT(A, Lim), FFT(B, Lim);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = (Lim - i) &amp; (Lim - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">static</span> Complex da, db, dc, dd;</span><br><span class="line">            da = (A[i] + conj(A[j])) * Complex(<span class="number">0.5</span>, <span class="number">0.0</span>);</span><br><span class="line">            db = (A[i] - conj(A[j])) * Complex(<span class="number">0.0</span>, <span class="number">-0.5</span>);</span><br><span class="line">            dc = (B[i] + conj(B[j])) * Complex(<span class="number">0.5</span>, <span class="number">0.0</span>);</span><br><span class="line">            dd = (B[i] - conj(B[j])) * Complex(<span class="number">0.0</span>, <span class="number">-0.5</span>);</span><br><span class="line">            dfta[j] = da * dc, dftb[j] = da * dd;</span><br><span class="line">            dftc[j] = db * dc, dftd[j] = db * dd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = dfta[i] + dftb[i] * Complex(<span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) B[i] = dftc[i] + dftd[i] * Complex(<span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        FFT(A, Lim), FFT(B, Lim);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> da = LL(A[i].x / Lim + <span class="number">0.5</span>) % P, db = LL(A[i].y / Lim + <span class="number">0.5</span>) % P;</span><br><span class="line">            <span class="keyword">int</span> dc = LL(B[i].x / Lim + <span class="number">0.5</span>) % P, dd = LL(B[i].y / Lim + <span class="number">0.5</span>) % P;</span><br><span class="line">            h[i] = (da + (LL(db + dc) &lt;&lt; <span class="number">15</span>) + (LL(dd) &lt;&lt; <span class="number">30</span>)) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN], ab[MAXN], abb[MAXN];</span><br><span class="line">        g[<span class="number">0</span>] = fpow(f[<span class="number">0</span>], P<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">0</span>, Lim = <span class="number">1</span>, Mid = <span class="number">2</span>; Mid &lt; <span class="number">2</span>*n; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*Mid) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">            init(Lim, L);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) A[i] = f[i], B[i] = g[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">            MTT(A, B, Lim, ab), MTT(ab, B, Lim, abb);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i)</span><br><span class="line">                g[i] = ((B[i] + B[i]) % P - abb[i] + P) % P;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = min(n, Mid); i &lt; Lim; ++i) g[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Der</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) g[i<span class="number">-1</span>] = <span class="number">1L</span>L * i * f[i] % P;</span><br><span class="line">        g[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Int</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        g[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) g[i] = <span class="number">1L</span>L * fpow(i, P<span class="number">-2</span>) * f[i<span class="number">-1</span>] % P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ln</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> df[MAXN], invf[MAXN];</span><br><span class="line">        Der(f, df, n), Inv(f, invf, n);</span><br><span class="line">        <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*n) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">        init(Lim, L);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; Lim; ++i) df[i] = invf[i] = <span class="number">0</span>;</span><br><span class="line">        MTT(df, invf, Lim, invf), Int(invf, g, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> Ans[MAXN], nA;</span><br><span class="line"><span class="keyword">int</span> f[MAXN], lnf[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(P), ++n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) read(f[i]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    Poly::Ln(f, lnf, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) lnf[i] = <span class="number">1L</span>L * i * lnf[i] % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; n; j += i) lnf[j] = (lnf[j] - lnf[i] + P) % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="keyword">if</span> (lnf[i]) Ans[++nA] = i;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, nA);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nA; ++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, Ans[i], <span class="string">" \n"</span>[i==nA]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="「SDOI2017」文本校正"><a href="#「SDOI2017」文本校正" class="headerlink" title="「SDOI2017」文本校正"></a>「SDOI2017」文本校正</h3><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/2272" target="_blank" rel="noopener">https://loj.ac/problem/2272</a></li>
</ul>
<h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>一道毒瘤的字符串匹配题.</p>
<p>假设串 $T$ 被拆分为形如 ABC 的三段, 有一个大力匹配的思路, 即枚举 $3!$ 种情况, 依次判定即可.</p>
<ol>
<li><p>ABC</p>
<p>直接用哈希判断两串是否相等即可…</p>
</li>
<li><p>CAB, BCA</p>
<p>以 CAB 为例, 注意到 AB 在 $T$ 中是连续的一段, 枚举 AB 和 C 的断点, 用哈希判断是否和 $S$ 中对应一段相等即可.</p>
<p>BCA 同理.</p>
</li>
<li><p>CBA</p>
<p>开 始 了.</p>
<p>我们先把 $T$ 倒过来再插入 $S$, 得到一个新串 $S_1 T_n S_2 T_{n-1} \cdots S_n T_1$, 那么 CBA 的判断就是在判断得到的新串是否可以被拆成 3 个偶回文串.</p>
<p>可以在新串上枚举一个拆分点, 现在的问题就是: 判断后缀是否构成一个双回文串.</p>
<p>有一个来自 <wc2017 金策 字符串算法选讲> 的结论</wc2017></p>
<blockquote>
<p>如果 $s = ab$, $a$, $b$ 都是回文串, 则称 $s$ 是一个双回文串.</p>
<p>如果 $s$ 是一个双回文串, 则存在一种拆分方法 $s = ab$, 使得 $a$ 是 $s$ 的最长回文前缀, 或者 $b$ 是 $s$ 的最长回文后缀.</p>
</blockquote>
<p>所以可以用 Manacher 处理出</p>
<ol>
<li><p>当前拆分点向右延伸的最长回文串的结束位置, 也就是最长回文前缀, 代码中为 <code>Rpos[i]</code>.</p>
</li>
<li><p>能够到达新串结尾的回文中心集合, 也就是最长回文后缀, 打标记后丢到队列里.</p>
</li>
</ol>
<p>假设当前枚举到的断点为 $i$, 若 $i$ 位置前是一个偶回文串, 依次用最长回文前缀和最长回文后缀判断 $i$ 位置后是否满足限制即可.</p>
</li>
<li><p>BAC, ACB</p>
<p>以 BAC 为例, 如果枚举 C 的位置, 利用上面的经验, 剩下的部分就是一个判断双回文串的问题…</p>
<p>但是有简单一些的办法.</p>
<p>回忆 Case 3 处理问题的过程, Manacher 其实在做一个最大匹配, 也就是说, 此处 BA 两串一定有一者是长度最大的, 利用 KMP 完成这个最大匹配即可. 剩下部分利用哈希判断就好了.</p>
<p>那么对于 ACB 的情况, 真的是字面意思上倒过来就可以了, 注意最后的答案, 先前的哈希值也要翻转. 当然再写一遍也是可以的, 有常数上的优势.</p>
</li>
</ol>
<p>时间复杂度 $O(n)$.</p>
<p>考场上我当然是选择 $O(n^2)$ 的暴力匹配 = =.</p>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2272</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">Pii Ans[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> S[MAXN], T[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双模数 Hash ...</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hash</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> P1 = <span class="number">998244353</span>, P2 = <span class="number">1e9</span>+<span class="number">7</span>, B = <span class="number">19260817</span>;</span><br><span class="line">    <span class="keyword">int</span> H1, H2;</span><br><span class="line"></span><br><span class="line">    Hash(<span class="keyword">int</span> _H1 = <span class="number">0</span>, <span class="keyword">int</span> _H2 = <span class="number">0</span>): H1(_H1), H2(_H2) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; ch)</span> </span>&#123;</span><br><span class="line">        H1 = (<span class="number">1L</span>L * H1 * B % P1 + ch) % P1, H2 = (<span class="number">1L</span>L * H2 * B % P2 + ch) % P2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Hash <span class="keyword">operator</span> + (<span class="keyword">const</span> Hash&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Hash((H1 + rhs.H1) % P1, (H2 + rhs.H2) % P2);</span><br><span class="line">    &#125;</span><br><span class="line">    Hash <span class="keyword">operator</span> - (<span class="keyword">const</span> Hash&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Hash((H1 - rhs.H1 + P1) % P1, (H2 - rhs.H2 + P2) % P2);</span><br><span class="line">    &#125;</span><br><span class="line">    Hash <span class="keyword">operator</span> * (<span class="keyword">const</span> Hash&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Hash(<span class="number">1L</span>L * H1 * rhs.H1 % P1, <span class="number">1L</span>L * H2 * rhs.H2 % P2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>== (<span class="keyword">const</span> Hash&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> H1 == rhs.H1 &amp;&amp; H2 == rhs.H2; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!= (<span class="keyword">const</span> Hash&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == rhs); &#125;</span><br><span class="line">&#125; A[MAXN], B[MAXN], powB[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Hash <span class="title">Part</span><span class="params">(Hash* H, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123; <span class="keyword">return</span> H[R] - H[L<span class="number">-1</span>] * powB[R-L+<span class="number">1</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ABC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A[n] != B[n]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> Ans[<span class="number">0</span>] = Pii(<span class="number">1</span>, <span class="number">1</span>), Ans[<span class="number">1</span>] = Pii(<span class="number">2</span>, <span class="number">2</span>), Ans[<span class="number">2</span>] = Pii(<span class="number">3</span>, n), <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CAB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (Part(A, <span class="number">1</span>, n - i + <span class="number">1</span>) == Part(B, i, n)</span><br><span class="line">                &amp;&amp; Part(A, n - i + <span class="number">2</span>, n) == Part(B, <span class="number">1</span>, i - <span class="number">1</span>)) &#123;</span><br><span class="line">            Ans[<span class="number">0</span>] = Pii(i, n), Ans[<span class="number">1</span>] = Pii(<span class="number">1</span>, <span class="number">1</span>), Ans[<span class="number">2</span>] = Pii(<span class="number">2</span>, i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BCA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">2</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (Part(A, <span class="number">1</span>, n - i) == Part(B, i + <span class="number">1</span>, n)</span><br><span class="line">                &amp;&amp; Part(A, n - i + <span class="number">1</span>, n) == Part(B, <span class="number">1</span>, i)) &#123;</span><br><span class="line">            Ans[<span class="number">0</span>] = Pii(i + <span class="number">1</span>, i + <span class="number">1</span>), Ans[<span class="number">1</span>] = Pii(i + <span class="number">2</span>, n), Ans[<span class="number">2</span>] = Pii(<span class="number">1</span>, i);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MaxR[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用回文半径判断回文串</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isP</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> Mid - L + <span class="number">1</span> &lt;= MaxR[Mid];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断双回文串, 其实只判定了长度...</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isDP</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L &lt; R &amp;&amp; (R - L) % <span class="number">4</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CBA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> C[MAXN &lt;&lt; <span class="number">1</span>], D[MAXN &lt;&lt; <span class="number">2</span>], nD, nC;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> Rpos[MAXN &lt;&lt; <span class="number">1</span>], Q[MAXN &lt;&lt; <span class="number">2</span>], head, tail;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> vis[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="comment">// C tansform</span></span><br><span class="line">    nD = nC = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) C[++nC] = S[i], C[++nC] = T[n - i + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// Manacher</span></span><br><span class="line">    D[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nC; ++i) D[++nD] = C[i], D[++nD] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nD; i += <span class="number">2</span>) vis[i] = <span class="literal">false</span>, Rpos[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Mid = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nD; ++i) &#123;</span><br><span class="line">        MaxR[i] = (i &lt; mx)? min(MaxR[Mid * <span class="number">2</span> - i], mx - i): <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= MaxR[i] &amp;&amp; D[i + MaxR[i]] == D[i - MaxR[i]]) ++MaxR[i];</span><br><span class="line">        <span class="keyword">if</span> (mx &lt; i + MaxR[i]) mx = i + MaxR[i], Mid = i;</span><br><span class="line">        Rpos[i - MaxR[i] + <span class="number">1</span>] = max(Rpos[i - MaxR[i] + <span class="number">1</span>], i + MaxR[i] - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i + MaxR[i] - <span class="number">1</span> == nD) vis[i - MaxR[i] + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Judge</span></span><br><span class="line">    Q[head = <span class="number">1</span>] = tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nD; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意此处的更新</span></span><br><span class="line">        Rpos[i] = max(Rpos[i], Rpos[i - <span class="number">2</span>] - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) Q[++tail] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// i 是断点, 真的是断点, 换言之, D[i] = -1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= nD; i += <span class="number">4</span>) <span class="keyword">if</span> (isP(<span class="number">0</span>, i)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (head &lt;= tail &amp;&amp; Q[head] &lt; i) ++head;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> Algt, Clgt;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (isDP(i, Rpos[i]) &amp;&amp; isDP(Rpos[i], nD) &amp;&amp; isP(Rpos[i], nD))</span><br><span class="line">            flag = <span class="literal">true</span>, Algt = i / <span class="number">4</span>, Clgt = (nD - Rpos[i]) / <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span> (!flag &amp;&amp; isDP(Q[head], nD) &amp;&amp; isDP(i, Q[head]) &amp;&amp; isP(i, Q[head]))</span><br><span class="line">            flag = <span class="literal">true</span>, Algt = i / <span class="number">4</span>, Clgt = (nD - Q[head]) / <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            Ans[<span class="number">0</span>] = Pii(n - Algt + <span class="number">1</span>, n);</span><br><span class="line">            Ans[<span class="number">1</span>] = Pii(Clgt + <span class="number">1</span>, n - Algt), Ans[<span class="number">2</span>] = Pii(<span class="number">1</span>, Clgt);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Sfail[MAXN], Tfail[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getFail</span><span class="params">(<span class="keyword">int</span>* P, <span class="keyword">int</span>* fail)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; P[i] != P[j + <span class="number">1</span>]) j = fail[j];</span><br><span class="line">        fail[i] = (j += P[i] == P[j + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BAC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Climit = n + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 注意要让 C 匹配上</span></span><br><span class="line">    <span class="keyword">while</span> (Climit &gt; <span class="number">1</span> &amp;&amp; S[Climit - <span class="number">1</span>] == T[Climit - <span class="number">1</span>]) --Climit;</span><br><span class="line">    <span class="keyword">int</span> ptrS = <span class="number">0</span>, ptrT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (ptrS &amp;&amp; S[ptrS+<span class="number">1</span>] != T[i]) ptrS = Sfail[ptrS];</span><br><span class="line">        <span class="keyword">if</span> (S[ptrS + <span class="number">1</span>] == T[i]) ++ptrS;</span><br><span class="line">        <span class="keyword">while</span> (ptrT &amp;&amp; T[ptrT+<span class="number">1</span>] != S[i]) ptrT = Tfail[ptrT];</span><br><span class="line">        <span class="keyword">if</span> (T[ptrT + <span class="number">1</span>] == S[i]) ++ptrT;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; Climit) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (Part(A, ptrS+<span class="number">1</span>, i) == Part(B, <span class="number">1</span>, i - ptrS)) &#123;</span><br><span class="line">            Ans[<span class="number">0</span>] = Pii(i - ptrS + <span class="number">1</span>, i);</span><br><span class="line">            Ans[<span class="number">1</span>] = Pii(<span class="number">1</span>, i - ptrS), Ans[<span class="number">2</span>] = Pii(i + <span class="number">1</span>, n);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Part(A, <span class="number">1</span>, i - ptrT) == Part(B, ptrT + <span class="number">1</span>, i)) &#123;</span><br><span class="line">            Ans[<span class="number">0</span>] = Pii(ptrT + <span class="number">1</span>, i);</span><br><span class="line">            Ans[<span class="number">1</span>] = Pii(<span class="number">1</span>, ptrT), Ans[<span class="number">2</span>] = Pii(i + <span class="number">1</span>, n);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ACB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Alimit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Alimit &lt; n &amp;&amp; S[Alimit + <span class="number">1</span>] == T[Alimit + <span class="number">1</span>]) ++Alimit;</span><br><span class="line">    <span class="keyword">int</span> ptrS = n+<span class="number">1</span>, ptrT = n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (ptrS != n+<span class="number">1</span> &amp;&amp; S[ptrS<span class="number">-1</span>] != T[i]) ptrS = n - Sfail[n-ptrS+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (S[ptrS - <span class="number">1</span>] == T[i]) --ptrS;</span><br><span class="line">        <span class="keyword">while</span> (ptrT != n+<span class="number">1</span> &amp;&amp; T[ptrT<span class="number">-1</span>] != S[i]) ptrT = n - Tfail[n-ptrT+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (T[ptrT - <span class="number">1</span>] == S[i]) --ptrT;</span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span> &gt; Alimit) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (Part(A, i, ptrS - <span class="number">1</span>) == Part(B, i + n - ptrS + <span class="number">1</span>, n)) &#123;</span><br><span class="line">            Ans[<span class="number">0</span>] = Pii(<span class="number">1</span>, i - <span class="number">1</span>), Ans[<span class="number">1</span>] = Pii(i + n - ptrS + <span class="number">1</span>, n);</span><br><span class="line">            Ans[<span class="number">2</span>] = Pii(i, i + n - ptrS);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Part(A, i + n - ptrT + <span class="number">1</span>, n) == Part(B, i, ptrT - <span class="number">1</span>)) &#123;</span><br><span class="line">            Ans[<span class="number">0</span>] = Pii(<span class="number">1</span>, i - <span class="number">1</span>), Ans[<span class="number">1</span>] = Pii(ptrT, n);</span><br><span class="line">            Ans[<span class="number">2</span>] = Pii(i, ptrT - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> Ti; read(Ti);</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    powB[<span class="number">0</span>] = Hash(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; ++i) powB[i] = powB[i<span class="number">-1</span>] * Hash(Hash::B, Hash::B);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        read(n), read(m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(S[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(T[i]);</span><br><span class="line">        <span class="comment">// solve &amp; output</span></span><br><span class="line">        getFail(S, Sfail), getFail(T, Tfail);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            A[i] = A[i<span class="number">-1</span>], A[i].insert(S[i]), B[i] = B[i<span class="number">-1</span>], B[i].insert(T[i]);</span><br><span class="line">        <span class="keyword">if</span> (ABC() || CAB() || BCA() || CBA() || BAC() || ACB()) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, Ans[i].first, Ans[i].second);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>本来想简单地写写, 后来发现自己言简意赅的能力不足 = =</p>
<p>以后尽量少写一点废话吧.</p>
<hr>

  </div>
  <footer class="article-footer">
    
  <div class="cc">
    <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.z" target="_blank" title="署名-非商业性使用-相同方式共享">
      <img src="/images/cc/cc.png">
      
          <img src="/images/cc/by.png">
        
          <img src="/images/cc/nc.png">
        
          <img src="/images/cc/sa.png">
      
      <span>
        本作品采用知识共享 署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。
      </span>
    </a>
  </div>


  </footer>
  
</article>


    <link rel="stylesheet" href="/css/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <div id="gitalk-container"></div>
    <script src="/scripts/gitalk.js"></script>




          <div class="main-footer">
  
    © 2020 DepletedPrism&#39;s Blog
    
	- Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  <script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

  <link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">
  <link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/PhotoSwipe/photoswipe.js"></script>
  <script src="/PhotoSwipe/photoswipe-ui-default.js"></script>


<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>
<script src="/scripts/main.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!--script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

</body>
</html>
--></body></html>