<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    九省联考 2018 大赏
  
</title>

<meta name="description" content="高一玩泥巴的时候陪着学长做过… 然而只是暴力的忠实选手. 结果现在还是暴力的忠实选手.">
<meta property="og:type" content="article">
<meta property="og:title" content="九省联考 2018 大赏">
<meta property="og:url" content="https://depletedprism.github.io/sol/sx/union-2018-sol/index.html">
<meta property="og:site_name" content="DepletedPrism&#39;s Blog">
<meta property="og:description" content="高一玩泥巴的时候陪着学长做过… 然而只是暴力的忠实选手. 结果现在还是暴力的忠实选手.">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-03-11T03:13:32.000Z">
<meta property="article:modified_time" content="2025-10-05T12:58:15.791Z">
<meta property="article:author" content="DepletedPrism">
<meta name="twitter:card" content="summary">


  <link rel="alternative" href="/atom.xml" title="DepletedPrism&#39;s Blog" type="application/atom+xml">



  <link rel="icon" href="/images/favicon.jpg">



<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">


<link rel="stylesheet" href="/styles/main.css">







<meta name="generator" content="Hexo 7.3.0"></head>
<body
  
    class="monochrome"
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">DepletedPrism&#39;s Blog</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">DepletedPrism&#39;s Blog</a></h1>
    
      <p class="subtitle">
        厌离秽土, 欣求净土.
      </p>
    
    <div class="info">
      <div class="content">
        
        
          <div class="author">DepletedPrism</div>
        
      </div>
      
        <div class="avatar">
          
            <a href="/about"><img src="/images/favicon.jpg"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">分类</a>
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a><span class="category-list-count">38</span></li></ul>
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">标签</a>
                <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Calculus/" rel="tag">Calculus</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Combinatorics/" rel="tag">Combinatorics</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/" rel="tag">DP</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Game-Theory/" rel="tag">Game Theory</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Geometry/" rel="tag">Geometry</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Graph/" rel="tag">Graph</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Greedy/" rel="tag">Greedy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Number-Theory/" rel="tag">Number Theory</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Polynomial/" rel="tag">Polynomial</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Probability/" rel="tag">Probability</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/String/" rel="tag">String</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vim/" rel="tag">Vim</a><span class="tag-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">归档</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/9102/">9102</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/">2025</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">42</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">4</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/index.html" title="Homepage" external="false">Homepage</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://github.com/DepletedPrism" title="Github" target="_blank" rel="noopener">Github</a>
              </li>
            
          
            
              <li>
                <a href="https://codeforces.com/profile/DepletedPrism" title="Codeforces" target="_blank" rel="noopener">Codeforces</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          <article id="post-sol/sx/union-2018-sol" class="article article-type-post">
  
    <h1 class="article-header">
      九省联考 2018 大赏
    </h1>
  
  

  <div class="article-info">
    <span class="article-date">
  2020-03-11
</span>

    
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></li></ul>
	</span>


    

    
  </div>
  <div class="article-entry">
    <hr>
<p>高一玩泥巴的时候陪着学长做过… 然而只是暴力的忠实选手.</p>
<p><del>结果现在还是暴力的忠实选手.</del></p>
<span id="more"></span>
<h3 id="「九省联考-2018」一双木棋"><a href="#「九省联考-2018」一双木棋" class="headerlink" title="「九省联考 2018」一双木棋"></a>「九省联考 2018」一双木棋</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/2471">https://loj.ac/problem/2471</a></li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>当年真是菜啊… 看不懂状压.</p>
<p>落子的规则很有意思, 手玩以后可以发现, 落子的形状是一个上三角…</p>
<p>考虑到 $n, m \le 10$, 可以状压表示这个上三角的轮廓. 具体地说, 用一条包含 <code>0</code> / <code>1</code> 的序列表示一条从左下角到右上角的轮廓线. </p>
<p>假如用 <code>1</code> 表示轮廓线中横线, 用 <code>0</code> 表示竖线, 那么起始状态就是 <code>((1 &lt;&lt; m) - 1) &lt;&lt; n</code>, 最终的状态为 <code>(1 &lt;&lt; m) - 1</code>. (从低位到高位, 从左下角到右上角)</p>
<p>此时每落一子就是把形同 <code>10</code> 的位置改为 <code>01</code>. 在扫描状态的同时确定就可以确定落子位置.</p>
<p>接下来就很常规了. 记 $f(S)$ 表示状态 $S$ 最大得分差值. 考虑到转移比较抽象, 于是用记忆化搜索实现, 并记录当前是轮到谁落子, 在转移时对应取 $\max$ / $\min$ 以确保正确性.</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2471</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> A[MAXN][MAXN], B[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">1</span> &lt;&lt; (MAXN &lt;&lt; <span class="number">1</span>)];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">1</span> &lt;&lt; (MAXN &lt;&lt; <span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> sta, <span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[sta]) <span class="keyword">return</span> f[sta];</span><br><span class="line">    <span class="type">int</span>&amp; ret = f[sta];</span><br><span class="line">    ret = s? -INF: INF;</span><br><span class="line">    <span class="type">int</span> x = n, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + m - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sta &gt;&gt; i) &amp; <span class="number">1</span>) ++y; <span class="keyword">else</span> --x;</span><br><span class="line">        <span class="keyword">if</span> (((sta &gt;&gt; i) &amp; <span class="number">3</span>) != <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (s) ret = <span class="built_in">max</span>(ret, <span class="built_in">dfs</span>(sta ^ (<span class="number">3</span> &lt;&lt; i), s ^ <span class="number">1</span>) + A[x][y]);</span><br><span class="line">        <span class="keyword">else</span> ret = <span class="built_in">min</span>(ret, <span class="built_in">dfs</span>(sta ^ (<span class="number">3</span> &lt;&lt; i), s ^ <span class="number">1</span>) - B[x][y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[sta] = <span class="literal">true</span>, ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, A[i] + j);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, B[i] + j);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="type">int</span> ed = (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>;</span><br><span class="line">    vis[ed] = <span class="literal">true</span>, f[ed] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dfs</span>(((<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>) &lt;&lt; n, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="「九省联考-2018」IIIDX"><a href="#「九省联考-2018」IIIDX" class="headerlink" title="「九省联考 2018」IIIDX"></a>「九省联考 2018」IIIDX</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/2472">https://loj.ac/problem/2472</a></li>
</ul>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>可以发现曲目的解锁顺序构成了一个树形结构, 要求当前节点的权值 $\le$ 其子树内的权值.</p>
<p>于是有一个朴素的想法, 即后序遍历这棵树, 把权值从大到小依次填进去.</p>
<p>但是存在相同权值的时候这个贪心会有问题. 为什么?</p>
<p>考虑一组样例 from <a href="https://www.cnblogs.com/HocRiser/p/8742680.html">HocRiser</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 2.0</span><br><span class="line">1 1 1 2</span><br></pre></td></tr></table></figure>
<p>这样在填以 $2$ 为根的子树的时候, 节点 $4$ 的点权为 $2$. 但此时 $4$ 的点权为 $1$, 而把权值 $2$ 丢给 $3$ 可以得到更优的答案…</p>
<p>接下来考虑如何避免相等权值的影响.</p>
<p>首先有一个事实, 可能填入权值的节点一定和已经填入权值的节点相邻.</p>
<p>现在我们维护出节点 $u$ 子树大小 <code>size[u]</code>. 并加入一个 “预约” 操作, 也就是把当前可填但未填的节点 (也就是其父亲都填完了) 的子树大小放入线段树中.</p>
<p>将权值从小到大排序, 每次填入一个权值, 处理出相同权值所在区间 $[L, R]$.</p>
<p>在该区间内从后往前枚举, 设当前是从前到后第 $k$ 个相等权值, 在线段树上二分一个位置 $u$, 并将当前权值填入 $u$. 同时把 $u$ 的子树大小从线段树中删去, 再把 $u$ 儿子 $v$ 的子树大小加入线段树.</p>
<p>线段树上二分时, 找到标号从大到小第一个合法节点 $u$, 使其满足线段树上大于 $u$ 标号的子树大小总和 $&gt; k$.</p>
<p>感性解释一下, 每个节点 $u$ 为其子孙预留了 <code>size[u]</code> 个位置, 填相同权值时需要考虑 “预约” 的影响, 并做出最优的选择. 也就是把靠后的位置, 在合法的情况下填入尽量小的权值. 线段树上二分的过程, 就是在满足限制的同时找到这个 “靠后的位置”.</p>
<p>时间复杂度 $O(n \log n)$.</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2472</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; <span class="type">double</span> K;</span><br><span class="line"><span class="type">int</span> A[MAXN], Ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (nd&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (nd&lt;&lt;1|1)</span></span><br><span class="line">    <span class="type">int</span> datSum[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Mdy</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">const</span> <span class="type">int</span>&amp; pos, <span class="type">const</span> <span class="type">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        datSum[nd] += val;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= Mid) <span class="built_in">Mdy</span>(lc, L, Mid, pos, val);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">Mdy</span>(rc, Mid<span class="number">+1</span>, R, pos, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Qry</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">const</span> <span class="type">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> L;</span><br><span class="line">        <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>, d = datSum[rc];</span><br><span class="line">        <span class="keyword">if</span> (k &gt; d) <span class="keyword">return</span> <span class="built_in">Qry</span>(lc, L, Mid, k - d);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Qry</span>(rc, Mid<span class="number">+1</span>, R, k);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> rc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123; <span class="type">int</span> nxt, to; &#125; edges[MAXN];</span><br><span class="line">    <span class="type">int</span> head[MAXN], eidx, size[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">        size[from] += size[to];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// pre done</span></span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) size[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i; --i) <span class="built_in">AddEdge</span>(<span class="built_in">floor</span>(i / K), i);</span><br><span class="line">        <span class="comment">// solve</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v, i = head[<span class="number">0</span>]; ~i; i = edges[i].nxt)</span><br><span class="line">            v = edges[i].to, SGT::<span class="built_in">Mdy</span>(<span class="number">1</span>, <span class="number">1</span>, n, v, size[v]);</span><br><span class="line">        <span class="built_in">sort</span>(A<span class="number">+1</span>, A<span class="number">+1</span>+n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> L = <span class="number">1</span>; L &lt;= n; ++L) &#123;</span><br><span class="line">            <span class="type">int</span> R = L;</span><br><span class="line">            <span class="keyword">while</span> (R &lt; n &amp;&amp; A[R<span class="number">+1</span>] == A[L]) ++R;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = R - L + <span class="number">1</span>; j; --j) &#123;</span><br><span class="line">                <span class="type">int</span> u = SGT::<span class="built_in">Qry</span>(<span class="number">1</span>, <span class="number">1</span>, n, j);</span><br><span class="line">                Ans[u] = A[L], SGT::<span class="built_in">Mdy</span>(<span class="number">1</span>, <span class="number">1</span>, n, u, -size[u]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">                    v = edges[i].to, SGT::<span class="built_in">Mdy</span>(<span class="number">1</span>, <span class="number">1</span>, n, v, size[v]);</span><br><span class="line">            &#125;</span><br><span class="line">            L = R;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// output</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, Ans[i], <span class="string">&quot; \n&quot;</span>[i == n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lf&quot;</span>, &amp;n, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(A[i]);</span><br><span class="line">    Graph::<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="「九省联考-2018」秘密袭击"><a href="#「九省联考-2018」秘密袭击" class="headerlink" title="「九省联考 2018」秘密袭击"></a>「九省联考 2018」秘密袭击</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/2473">https://loj.ac/problem/2473</a></li>
</ul>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>首先, 有正解 “<a href="https://zhang-rq.github.io/2018/05/04/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%832018-%E7%A7%98%E5%AF%86%E8%A2%AD%E5%87%BBCoaT/">线段树合并, 拉格朗日插值, 生成函数, 以及整体 DP</a>“.</del></p>
<p>考虑到本题时限 5s, 以及正解繁杂常数大, 于是暴力碾标算…</p>
<p>枚举 Access Globe 所操控士兵潜入的城市 $u$, 考虑潜入 $u$ 的方案数.</p>
<p>如果节点 $u$ 可以对答案产生贡献, 那么包含 $u$ 的连通块内一定有 $k-1$ 个满足 $d_i &gt; d_u$ 的节点. 把权值小于 $d_u$ 的节点大小标记为 $0$, 把权值大于 $d_u$ 的节点标记为 $1$, 做一个类似于树形背包的 DP 即可.</p>
<p>那么权值等于 $d_u$ 的呢? 为避免对某个节点重复计算, 在权值相等的时候, 仅考虑编号大于等于 (别忘了自己) $u$ 的节点.</p>
<p>具体地说, 设 $f(i, j)$ 表示深度最小节点为 $i$, 大小和为 $j$ 的连通块个数.</p>
<p>枚举每条边 $(u, v)$, 设 $g(i)$ 表示选择 $u$ 其余节点, 以及 $v$ 的子树内节点, 大小总和为 $i$ 的连通块个数, 显然转移是一个卷积的形式, 最后把 $g(i)$ 累加到 $f(u, i)$ 上就好了.</p>
<p>以及一些卡常的方法.</p>
<ol>
<li>使用 SDOI 2017 苹果树 同样的技巧, DP 数组 $f$ 开成一维, 减少 cache miss.</li>
<li>转移数组 $g$ 使用 <code>long long</code>, 减少取模次数.</li>
<li>考虑到树是一个稀疏图, 于是使用 <code>vector</code> 存图, 相比手写链表访问加快.</li>
</ol>
<p><del>然后没了, 难道要把 <code>g</code> 的转移用 MTT 优化?</del></p>
<p>时间复杂度 $O(nk(n-k))$.</p>
<p><del>如果有机会, 我一定会去学正解</del></p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2473</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1675</span>, P = <span class="number">64123</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, K, W, T, M;</span><br><span class="line">LL g[MAXN];</span><br><span class="line"><span class="type">int</span> A[MAXN], V[MAXN], f[MAXN * MAXN], size[MAXN];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f + u * M, <span class="number">0</span>, T);</span><br><span class="line">    f[u * M + V[u]] = <span class="number">1</span>, size[u] = V[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v: G[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= K &amp;&amp; j &lt;= size[u]; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= K &amp;&amp; k &lt;= size[v]; ++k)</span><br><span class="line">                g[j + k] += <span class="number">1LL</span> * f[u * M + j] * f[v * M + k];</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= K &amp;&amp; j &lt;= size[u]; ++j)</span><br><span class="line">            f[u * M + j] = (f[u * M + j] + g[j]) % P, g[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(K), <span class="built_in">read</span>(W);</span><br><span class="line">    M = K + <span class="number">1</span>, T = M * <span class="built_in">sizeof</span> (<span class="type">int</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u, v, i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">read</span>(u), <span class="built_in">read</span>(v), G[u].<span class="built_in">push_back</span>(v), G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cnt, u = <span class="number">1</span>; u &lt;= n; ++u) &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            V[i] = (A[i] &gt; A[u] || (A[i] == A[u] &amp;&amp; i &gt;= u)), cnt += V[i];</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; K) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(u, <span class="number">0</span>), ans = (ans + A[u] * f[u * M + K] % P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="「九省联考-2018」劈配"><a href="#「九省联考-2018」劈配" class="headerlink" title="「九省联考 2018」劈配"></a>「九省联考 2018」劈配</h3><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/2477">https://loj.ac/problem/2477</a></li>
</ul>
<h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>容易发现, 题目要求我们做的就是一个二分图匹配. 考虑用网络流解决这个问题.</p>
<p>对于第一问, 从 $1$ 到 $n$ 依次考虑每个选手 $i$ 的匹配情况.</p>
<p>如果只有一位选手 $i$, 那么</p>
<ul>
<li>新建源汇 $S$, $T$, 其中 $S$ 对选手 $i$ 连边, 容量为 $1$; 每位导师 $j$ 向 $T$ 连边, 容量为 $b_j$.</li>
<li>枚举选手志愿, $i$ 向该档志愿导师 $j$ 连边, 容量为 $1$.<ul>
<li>如果此时存在增广路, 那么该选手被该档志愿录取</li>
<li>否则继续枚举志愿, 直到选手被录取 / 出局</li>
</ul>
</li>
</ul>
<p>考虑其他选手的影响. 由录取方案的最优性可知, 只有排名比 $i$ 靠前的选手对 $i$ 有影响, 那么每位选手直接在上一位选手的残量网络上建边即可.</p>
<p>未被枚举到的志愿录取时, 需要及时把此档志愿所建的边回退掉, 以避免多出用不到的废边, 从而影响时间复杂度的正确性…</p>
<p>对于第二问, 可以发现答案可以二分 —- 如果选手到了第 $1$ 名, 还不能达到自己的要求, 那肯定会沮丧了.</p>
<p>我们二分一个答案 $x$, 表示选手 $i$ 不沮丧时的 <strong>最小排名</strong>. <code>check</code> 的时候前 $x-1$ 名选手的录取情况并不会改变, 再次基础上加入选手 $i$ 的前 $s_i$ 个志愿, 判断新图是否存在增广路即可.</p>
<p>每次都建一次新图, 并把前 $x-1$ 名选手匹配好有些麻烦, 时间复杂度还很高. 考虑到解决第一问时, 已经把这些匹配求过一遍了, 所以记录选手录取情况的前缀图, 每次 <code>check</code> 调用即可. 因为点数很小, 所以可以保证每次暴力复制的复杂度.</p>
<p>时间复杂度大概是 $O( T(n^2m + n^2 \log n) )$?</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p>由于这道题的特殊性, Dinic 当前弧优化并不适用.</p>
<div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2477</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">205</span>, MAXV = MAXN &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, C, S, T;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; A[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> Ans1[MAXN], Ans2[MAXN], B[MAXN], s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, flow, cap;</span><br><span class="line">    <span class="built_in">Edge</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> _v, <span class="type">int</span> _c): <span class="built_in">to</span>(_v), <span class="built_in">cap</span>(_c) &#123; flow = <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    vector&lt;Edge&gt; edges;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; G[MAXV];</span><br><span class="line">    <span class="type">int</span> depth[MAXV], vis[MAXV], Time;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + m + <span class="number">1</span>; ++i) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(to, c)), edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(from, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> eidx = edges.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        G[from].<span class="built_in">push_back</span>(eidx - <span class="number">1</span>), G[to].<span class="built_in">push_back</span>(eidx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">DelEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> </span>&#123;</span><br><span class="line">        G[from].<span class="built_in">pop_back</span>(), G[to].<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">        Q.<span class="built_in">push</span>(S), vis[S] = ++Time, depth[S] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="type">const</span> Edge&amp; e = edges[G[u][i]];</span><br><span class="line">                <span class="keyword">if</span> (vis[e.to] != Time &amp;&amp; e.cap &gt; e.flow)</span><br><span class="line">                    vis[e.to] = Time, depth[e.to] = depth[u] + <span class="number">1</span>, Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[T] == Time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == T || !a) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="type">int</span> f, flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[u][i]];</span><br><span class="line">            <span class="keyword">if</span> (depth[e.to] == depth[u] + <span class="number">1</span> &amp;&amp; (f = <span class="built_in">DFS</span>(e.to, <span class="built_in">min</span>(a, e.cap-e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                flow += f, a -= f, e.flow += f, edges[G[u][i]^<span class="number">1</span>].flow -= f;</span><br><span class="line">                <span class="keyword">if</span> (!a) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> Mid, <span class="type">const</span> <span class="type">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> Graph now;</span><br><span class="line">    now = G[Mid - <span class="number">1</span>], now.<span class="built_in">AddEdge</span>(S, u, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[u]; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; A[u][j].<span class="built_in">size</span>(); ++k) now.<span class="built_in">AddEdge</span>(u, n + A[u][j][k], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> now.<span class="built_in">BFS</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> Ti; <span class="built_in">read</span>(Ti), <span class="built_in">read</span>(C);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        S = <span class="number">0</span>, T = n + m + <span class="number">1</span>;</span><br><span class="line">        G[<span class="number">0</span>].<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) A[i][j].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">read</span>(B[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x, i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) <span class="built_in">read</span>(x), A[i][x].<span class="built_in">push_back</span>(j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(s[i]);</span><br><span class="line">        <span class="comment">// solve</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) G[<span class="number">0</span>].<span class="built_in">AddEdge</span>(n + i, T, B[i]);</span><br><span class="line">        <span class="comment">// Q1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            Ans1[i] = <span class="number">0</span>;</span><br><span class="line">            G[i] = G[i - <span class="number">1</span>], G[i].<span class="built_in">AddEdge</span>(S, i, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; A[i][j].<span class="built_in">size</span>(); ++k) G[i].<span class="built_in">AddEdge</span>(i, n + A[i][j][k], <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (G[i].<span class="built_in">BFS</span>()) &#123; G[i].<span class="built_in">DFS</span>(S, INF), Ans1[i] = j; <span class="keyword">break</span>; &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; A[i][j].<span class="built_in">size</span>(); ++k) G[i].<span class="built_in">DelEdge</span>(i, n + A[i][j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!Ans1[i]) Ans1[i] = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Q2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            Ans2[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= Ans1[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> L = <span class="number">1</span>, R = i - <span class="number">1</span>, ans = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">                <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(Mid, i)) ans = Mid, L = Mid + <span class="number">1</span>; <span class="keyword">else</span> R = Mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Ans2[i] = (ans == <span class="number">-1</span>)? i: i - ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// output</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, Ans1[i], <span class="string">&quot; \n&quot;</span>[i == n]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, Ans2[i], <span class="string">&quot; \n&quot;</span>[i == n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="「九省联考-2018」林克卡特树"><a href="#「九省联考-2018」林克卡特树" class="headerlink" title="「九省联考 2018」林克卡特树"></a>「九省联考 2018」林克卡特树</h3><p>人生第一道 DP 凸优化…</p>
<h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/2478">https://loj.ac/problem/2478</a></li>
</ul>
<h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先对题意做一步转化, 所求即为选择 $K+1$ 条不相交的链, 所得的最大边权和.</p>
<p>此时有一个朴素的 DP, 设 $f(i, j, k)$ 表示以节点 $i$ 为根的子树内, 选择 $j$ 条链, 且节点 $i$ 度数为 $k \in \{ 0, 1, 2 \}$ 的最大边权和. (度数为 $0$ 的情况就是单独一个节点被视作一条链了)</p>
<p>此时枚举儿子大力讨论即可列出转移… 转移相当繁琐 = =</p>
<p>这个 DP 的时间复杂度为 $O(nk^2)$, 看起来没有什么优化的余地了, 真的是这样吗?</p>
<p>通过某些神秘手段可以得知, 选择 $K+1$ 条链的最优解是上凸的. 换句话说, 以选择链数 $k$ 为横坐标, 最大边权和为纵坐标, 得到的函数图像是上凸的 (其实图像是个点集… 感性理解). 再者就是导函数单调 / 差分单调了…</p>
<p>感性理解一下这个上凸, 刚开始选择一些边作为链, 可以把某些对答案贡献较小情况的避开. 当要求选择的链数逐渐增加时, 这个 “避开” 的应用范围就逐渐缩小, 而不得不减小答案来满足限制.</p>
<p>接着考虑 DP 凸优化.</p>
<p>我们二分一个权值 $s$, 并限定每新增一条链, 就在把边权和减去 $s$. 此时不限定选择多少条链.</p>
<p>丢掉对链个数的限制, 容易得到一个 $O(n)$ 的 DP:</p>
<p>设 $f(i, j)$ 表示以节点 $i$ 为根的子树内, 且节点 $i$ 度数为 $j \in \{ 0, 1, 2 \}$ 的最大边权和, 以及达到该边权和所用的最少链数.</p>
<p>首先有初值</p>
<script type="math/tex; mode=display">f(u, 0) = 0,\ f(u, 1) = 0</script><script type="math/tex; mode=display">f(u, 2) = \max\{ 0, -s \}</script><p>记边 $(u, v)$ 边权为 $w(u, v)$, 那么转移为</p>
<script type="math/tex; mode=display">f(u, 0) = \max\{ f(u, 0),\ f(u, 0) + f(v, 0) \}</script><script type="math/tex; mode=display">f(u, 1) = \max\{ f(u, 1),\ f(u, 1) + f(v, 0),\ f(u, 0) + f(v, 1) + w(u, v) \}</script><script type="math/tex; mode=display">f(u, 2) = \max\{ f(u, 2),\ f(u, 2) + f(v, 0),\ f(u, 1) + f(v, 1) + w(u, v) - s \}</script><p>以及一个节点 DP 完后, 还需要合并答案.</p>
<script type="math/tex; mode=display">f(u, 0) = \max\{ f(u, 0),\ f(u, 1) - s,\ f(u, 2) \}</script><p>这样就能解释通了… 只用度数考虑 <del>会发现解释不通</del></p>
<p>这一步的 DP 就相当于拿一条斜率为 $s$ 的直线去切这个图像, 并得到凸包上一点 $(k, f(1, 0))$. 接着根据 $k$ 和 $K+1$ 的关系来调整斜率, 直到同凸包交点为 $(K+1, f(1, 0))$.</p>
<p>时间复杂度 $O(n \log w)$. 其中 $w$ 为答案上下界之差.</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2478</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    LL a; <span class="type">int</span> b;</span><br><span class="line">    <span class="built_in">Item</span>(LL _a = <span class="number">0</span>, <span class="type">int</span> _b = <span class="number">0</span>): <span class="built_in">a</span>(_a), <span class="built_in">b</span>(_b) &#123; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Item&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; rhs.a || (a == rhs.a &amp;&amp; b &gt; rhs.b);</span><br><span class="line">    &#125;</span><br><span class="line">    Item <span class="keyword">operator</span> + (<span class="type">const</span> Item&amp; rhs) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">Item</span>(a + rhs.a, b + rhs.b); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, K;</span><br><span class="line">Item f[MAXN][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123; <span class="type">int</span> nxt, to, w; &#125; edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, w &#125;, head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">const</span> LL&amp; s)</span> </span>&#123;</span><br><span class="line">        f[u][<span class="number">0</span>] = f[u][<span class="number">1</span>] = <span class="built_in">Item</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        f[u][<span class="number">2</span>] = <span class="built_in">max</span>(<span class="built_in">Item</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">Item</span>(-s, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) == fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(v, u, s);</span><br><span class="line">            f[u][<span class="number">2</span>] = <span class="built_in">max</span>(f[u][<span class="number">2</span>], <span class="built_in">max</span>(f[u][<span class="number">2</span>] + f[v][<span class="number">0</span>], f[u][<span class="number">1</span>] + f[v][<span class="number">1</span>] + <span class="built_in">Item</span>(edges[i].w - s, <span class="number">1</span>)));</span><br><span class="line">            f[u][<span class="number">1</span>] = <span class="built_in">max</span>(f[u][<span class="number">1</span>], <span class="built_in">max</span>(f[u][<span class="number">1</span>] + f[v][<span class="number">0</span>], f[u][<span class="number">0</span>] + f[v][<span class="number">1</span>] + <span class="built_in">Item</span>(edges[i].w)));</span><br><span class="line">            f[u][<span class="number">0</span>] = <span class="built_in">max</span>(f[u][<span class="number">0</span>], f[u][<span class="number">0</span>] + f[v][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此处合并答案</span></span><br><span class="line">        f[u][<span class="number">0</span>] = <span class="built_in">max</span>(f[u][<span class="number">0</span>], <span class="built_in">max</span>(f[u][<span class="number">1</span>] + <span class="built_in">Item</span>(-s, <span class="number">1</span>), f[u][<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::<span class="built_in">init</span>();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(K), ++K;</span><br><span class="line">    LL L = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u, v, w, i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(u), <span class="built_in">read</span>(v), <span class="built_in">read</span>(w);</span><br><span class="line">        L = <span class="built_in">min</span>(L, <span class="number">-1LL</span> * w), R += <span class="built_in">max</span>(<span class="number">0</span>, w);</span><br><span class="line">        Graph::<span class="built_in">AddEdge</span>(u, v, w), Graph::<span class="built_in">AddEdge</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    LL ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        LL Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        Graph::<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, Mid);</span><br><span class="line">        <span class="keyword">if</span> (f[<span class="number">1</span>][<span class="number">0</span>].b &lt;= K) ans = Mid, R = Mid - <span class="number">1</span>; <span class="keyword">else</span> L = Mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Graph::<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, ans);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[<span class="number">1</span>][<span class="number">0</span>].a + ans * K);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="「九省联考-2018」制胡窜"><a href="#「九省联考-2018」制胡窜" class="headerlink" title="「九省联考 2018」制胡窜"></a>「九省联考 2018」制胡窜</h3><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/2479">https://loj.ac/problem/2479</a></li>
</ul>
<h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>有着很复杂的分类讨论, 以及相当繁琐的细节…</p>
<p><del>还是 <a href="http://labelray.top/2019/03/01/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83-2018-%E5%88%B6%E8%83%A1%E7%AA%9C/">Labelray</a> 讲地好哇.</del></p>
<p>还是拿 Labelray 的题解再展开说一点东西.</p>
<p>对于 Case 2.1, 我个人认为最终的答案应为</p>
<script type="math/tex; mode=display">\sum_{i=1}^{n-1} (r_{i+1} - l_n) \cdot (l_{i+1} - l_i)</script><p>化简之后可以得到</p>
<script type="math/tex; mode=display">\sum_{i=1}^{n-1} r_{i+1} (r_{i+1}-r_i) - l_n \cdot \sum_{i=1}^{n-1} (r_{i+1} - r_i)</script><p>以及 Case 3, 在满足限制 $l_n &lt; r_{i+1} &lt; r_1 + len - 1$ 时, 直接在线段树上查询区间 $(l_n, r_1 + len - 1]$, 则会缺失左边界.</p>
<p>具体地说, 由于使用右端点 $r_i$ 的差代替左端点 $l_i$ 的差, 在计算时会漏掉 $r_i &lt; l_n &lt; r_{i+1}$ 的情况, 但此时对应左边一刀切在 $(l_i, l_{i+1})$ 的情况仍然合法. 于是在统计中需要加入 $[1, l_n]$ 的最大端点, 同线段树查询结果合并即可.</p>
<p>时间复杂度 $O(n \log n + q \log n)$.</p>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2479</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>, MAXM = <span class="number">2e5</span> + <span class="number">5</span>, LOG = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1LL</span> * n * (n<span class="number">-1</span>) / <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="type">char</span> S[MAXN];</span><br><span class="line"><span class="type">int</span> rt[MAXM], pos[MAXN], pre[LOG][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="type">int</span> mx, mn; LL s1, s2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Data</span>() &#123; mx = -MAXN, mn = MAXN, s1 = s2 = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">int</span> _mx, <span class="type">int</span> _mn, LL _s1, LL _s2): <span class="built_in">mx</span>(_mx), <span class="built_in">mn</span>(_mn), <span class="built_in">s1</span>(_s1), <span class="built_in">s2</span>(_s2) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Data <span class="keyword">operator</span> + (<span class="type">const</span> Data&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mx == -MAXN &amp;&amp; mn == MAXN) <span class="keyword">return</span> rhs;</span><br><span class="line">        <span class="keyword">if</span> (rhs.mx == -MAXN &amp;&amp; rhs.mn == MAXN) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Data</span>(rhs.mx, mn, s1 + rhs.s1 + <span class="number">1LL</span> * rhs.mn * (rhs.mn - mx),</span><br><span class="line">                s2 + rhs.s2 + (rhs.mn - mx));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> lc, rc; Data d;</span><br><span class="line">        <span class="built_in">Node</span>() &#123; lc = rc = <span class="number">0</span>; d = <span class="built_in">Data</span>(); &#125;</span><br><span class="line">    &#125; dat[MAXM &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> nidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> nd)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> &amp;lc = dat[nd].lc, &amp;rc = dat[nd].rc;</span><br><span class="line">        dat[nd].d = dat[lc].d + dat[rc].d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Mdy</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">const</span> <span class="type">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> <span class="built_in">void</span>( dat[nd].d.mn = dat[nd].d.mx = pos );</span><br><span class="line">        <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= Mid) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dat[nd].lc) dat[nd].lc = ++nidx;</span><br><span class="line">            <span class="built_in">Mdy</span>(dat[nd].lc, L, Mid, pos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dat[nd].rc) dat[nd].rc = ++nidx;</span><br><span class="line">            <span class="built_in">Mdy</span>(dat[nd].rc, Mid<span class="number">+1</span>, R, pos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">maintain</span>(nd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Mrg</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line">        <span class="type">int</span> nd = ++nidx;</span><br><span class="line">        dat[nd].lc = <span class="built_in">Mrg</span>(dat[x].lc, dat[y].lc);</span><br><span class="line">        dat[nd].rc = <span class="built_in">Mrg</span>(dat[x].rc, dat[y].rc);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maintain</span>(nd), nd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Data <span class="title">Qry</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">const</span> <span class="type">int</span>&amp; opL, <span class="type">const</span> <span class="type">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nd) <span class="keyword">return</span> <span class="built_in">Data</span>();</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> dat[nd].d;</span><br><span class="line">        <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> <span class="built_in">Qry</span>(dat[nd].lc, L, Mid, opL, opR);</span><br><span class="line">        <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> <span class="built_in">Qry</span>(dat[nd].rc, Mid<span class="number">+1</span>, R, opL, opR);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Qry</span>(dat[nd].lc, L, Mid, opL, opR) + <span class="built_in">Qry</span>(dat[nd].rc, Mid<span class="number">+1</span>, R, opL, opR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">Qry</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> lgt)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> r1 = dat[nd].d.mn, ln = dat[nd].d.mx - lgt + <span class="number">1</span>;</span><br><span class="line">        Data d = <span class="built_in">Qry</span>(nd, <span class="number">1</span>, n, <span class="number">1</span>, ln);</span><br><span class="line">        LL ret = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Case 1</span></span><br><span class="line">        <span class="keyword">if</span> (d.mx - lgt + <span class="number">1</span> &gt;= r1) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Case 2</span></span><br><span class="line">        <span class="keyword">if</span> (r1 &gt; ln) &#123;</span><br><span class="line">            ret += dat[nd].d.s1 - <span class="number">1LL</span> * ln * dat[nd].d.s2;</span><br><span class="line">            ret += <span class="number">1LL</span> * (r1 - ln) * (n - lgt) + <span class="built_in">C2</span>(r1 - ln);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Case 3</span></span><br><span class="line">        <span class="keyword">if</span> (ln &lt; r1 + lgt - <span class="number">1</span>) &#123;</span><br><span class="line">            Data p = <span class="built_in">Data</span>(d.mx, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) + <span class="built_in">Qry</span>(nd, <span class="number">1</span>, n, ln + <span class="number">1</span>, r1 + lgt - <span class="number">1</span>);</span><br><span class="line">            ret += p.s1 - <span class="number">1LL</span> * ln * p.s2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ri = <span class="built_in">Qry</span>(nd, <span class="number">1</span>, n, <span class="number">1</span>, r1 + lgt - <span class="number">1</span>).mx, ri1 = <span class="built_in">Qry</span>(nd, <span class="number">1</span>, n, r1 + lgt, n).mn;</span><br><span class="line">        <span class="keyword">if</span> (ri != -MAXN &amp;&amp; ri1 != MAXN) ret += <span class="built_in">max</span>(<span class="number">0LL</span>, <span class="number">1LL</span> * (r1 - (ri-lgt<span class="number">+1</span>)) * (ri1 - ln));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SAM &#123;</span><br><span class="line">    <span class="type">int</span> ch[MAXM][<span class="number">10</span>], len[MAXM], lnk[MAXM], nidx, last;</span><br><span class="line">    <span class="type">int</span> cnt[MAXM], idx[MAXM];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; nidx = last = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nd = ++nidx, p = last;</span><br><span class="line">        len[nd] = len[last] + <span class="number">1</span>, SGT::<span class="built_in">Mdy</span>(rt[nd] = ++SGT::nidx, <span class="number">1</span>, n, i);</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !ch[p][val]) ch[p][val] = nd, p = lnk[p];</span><br><span class="line">        <span class="keyword">if</span> (!p) lnk[nd] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> q = ch[p][val];</span><br><span class="line">            <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) lnk[nd] = q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> nxt = ++nidx;</span><br><span class="line">                len[nxt] = len[p] + <span class="number">1</span>, lnk[nxt] = lnk[q];</span><br><span class="line">                <span class="built_in">memcpy</span>(ch[nxt], ch[q], <span class="keyword">sizeof</span> ch[nxt]);</span><br><span class="line">                <span class="keyword">while</span> (p &amp;&amp; ch[p][val] == q) ch[p][val] = nxt, p = lnk[p];</span><br><span class="line">                lnk[nd] = lnk[q] = nxt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last = nd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nidx; ++i) ++cnt[len[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cnt[i] += cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nidx; ++i) idx[cnt[len[i]]--] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u, i = nidx; i &gt; <span class="number">1</span>; --i)</span><br><span class="line">            u = idx[i], rt[lnk[u]] = SGT::<span class="built_in">Mrg</span>(rt[lnk[u]], rt[u]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nidx; ++i) pre[<span class="number">0</span>][i] = lnk[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; LOG; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nidx; ++i)</span><br><span class="line">                pre[j][i] = pre[j<span class="number">-1</span>][pre[j<span class="number">-1</span>][i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Jump</span><span class="params">(<span class="type">int</span> u, <span class="type">const</span> <span class="type">int</span>&amp; lgt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = LOG<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">            <span class="keyword">if</span> (pre[j][u] &amp;&amp; len[pre[j][u]] &gt;= lgt) u = pre[j][u];</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">Qry</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; L, <span class="type">const</span> <span class="type">int</span>&amp; R)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">Jump</span>(pos[R], R - L + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> SGT::<span class="built_in">Qry</span>(rt[u], R - L + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    SAM::<span class="built_in">init</span>();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;n, &amp;q, S<span class="number">+1</span>);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        SAM::<span class="built_in">insert</span>(S[i] - <span class="string">&#x27;0&#x27;</span>, i), pos[i] = SAM::last;</span><br><span class="line">    SAM::<span class="built_in">build</span>();</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> L, R;</span><br><span class="line">        <span class="built_in">read</span>(L), <span class="built_in">read</span>(R);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">C2</span>(n - <span class="number">1</span>) - SAM::<span class="built_in">Qry</span>(L, R));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<hr>

  </div>
  <footer class="article-footer">
    
  <div class="cc">
    <a href="http://creativecommons.org/licenses/by-nc/4.0/deed.z" target="_blank" title="署名-非商业性使用">
      <img src="/images/cc/cc.png">
      
          <img src="/images/cc/by.png">
        
          <img src="/images/cc/nc.png">
        
      <span>
        本作品采用知识共享 署名-非商业性使用 4.0 国际许可协议进行许可。
      </span>
    </a>
  </div>


  </footer>
</article>





          <div class="main-footer">
  
    ©
    
      2019-2025
    
    DepletedPrism&#39;s Blog
    
	- Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  
<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>


  
<link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">

  
<link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">


  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  
<script src="/PhotoSwipe/photoswipe.js"></script>

  
<script src="/PhotoSwipe/photoswipe-ui-default.js"></script>




<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>


<script src="/scripts/main.js"></script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ["$","$"], ["\\(","\\)"] ],
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax();
    for (var i = 0; i < all.length; ++i)
      all[i].SourceElement().parentNode.className += ' has-jax';
  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>


</body>
</html>
