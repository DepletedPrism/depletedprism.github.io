<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    AHOI / HNOI 2018 大赏
  
</title>

<meta name="description" content="其实不想再写 18 年的题了… 再写就没时间写 19 年的了 ( 果然立 flag 就是用来倒的. 话说这套题单看正解, 还挺考验思维的?">
<meta property="og:type" content="article">
<meta property="og:title" content="AHOI &#x2F; HNOI 2018 大赏">
<meta property="og:url" content="https://depletedprism.github.io/sol/sx/AHOI-HNOI-2018-sol/index.html">
<meta property="og:site_name" content="DepletedPrism&#39;s Blog">
<meta property="og:description" content="其实不想再写 18 年的题了… 再写就没时间写 19 年的了 ( 果然立 flag 就是用来倒的. 话说这套题单看正解, 还挺考验思维的?">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-03-14T06:11:32.000Z">
<meta property="article:modified_time" content="2025-10-05T12:58:15.789Z">
<meta property="article:author" content="DepletedPrism">
<meta name="twitter:card" content="summary">


  <link rel="alternative" href="/atom.xml" title="DepletedPrism&#39;s Blog" type="application/atom+xml">



  <link rel="icon" href="/images/favicon.jpg">



<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">


<link rel="stylesheet" href="/styles/main.css">







<meta name="generator" content="Hexo 7.3.0"></head>
<body
  
    class="monochrome"
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">DepletedPrism&#39;s Blog</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">DepletedPrism&#39;s Blog</a></h1>
    
      <p class="subtitle">
        厌离秽土, 欣求净土.
      </p>
    
    <div class="info">
      <div class="content">
        
        
          <div class="author">DepletedPrism</div>
        
      </div>
      
        <div class="avatar">
          
            <a href="/about"><img src="/images/favicon.jpg"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">分类</a>
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a><span class="category-list-count">38</span></li></ul>
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">标签</a>
                <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Calculus/" rel="tag">Calculus</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Combinatorics/" rel="tag">Combinatorics</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/" rel="tag">DP</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Game-Theory/" rel="tag">Game Theory</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Geometry/" rel="tag">Geometry</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Graph/" rel="tag">Graph</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Greedy/" rel="tag">Greedy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Number-Theory/" rel="tag">Number Theory</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Polynomial/" rel="tag">Polynomial</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Probability/" rel="tag">Probability</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/String/" rel="tag">String</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vim/" rel="tag">Vim</a><span class="tag-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">归档</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/9102/">9102</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/">2025</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">42</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">4</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/index.html" title="Homepage" external="false">Homepage</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://github.com/DepletedPrism" title="Github" target="_blank" rel="noopener">Github</a>
              </li>
            
          
            
              <li>
                <a href="https://codeforces.com/profile/DepletedPrism" title="Codeforces" target="_blank" rel="noopener">Codeforces</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          <article id="post-sol/sx/AHOI-HNOI-2018-sol" class="article article-type-post">
  
    <h1 class="article-header">
      AHOI / HNOI 2018 大赏
    </h1>
  
  

  <div class="article-info">
    <span class="article-date">
  2020-03-14
</span>

    
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></li></ul>
	</span>


    

    
  </div>
  <div class="article-entry">
    <hr>
<p>其实不想再写 18 年的题了… 再写就没时间写 19 年的了 (</p>
<p>果然立 flag 就是用来倒的.</p>
<p><del>话说这套题单看正解, 还挺考验思维的?</del></p>
<span id="more"></span>
<p>其实写不写都不重要了.</p>
<h3 id="「AHOI-HNOI2018」寻宝游戏"><a href="#「AHOI-HNOI2018」寻宝游戏" class="headerlink" title="「AHOI / HNOI2018」寻宝游戏"></a>「AHOI / HNOI2018」寻宝游戏</h3><p>挺有意思的一道题.</p>
<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/2494">https://loj.ac/problem/2494</a></li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>先祭上官方题解: <a href="http://matthew99.blog.uoj.ac/blog/3488">http://matthew99.blog.uoj.ac/blog/3488</a>.</p>
<p>着重解释一下什么是 “容易证明, 第 $i$ 位的结果为 $1$, 当且仅当 $x&lt;b_i$.”</p>
<p>首先根据 myy 的题解, 构造出长度为 $n$ 的串 $x$, 以及 $m$ 个长度为 $n$ 的串 $b_i$.</p>
<p>对于二进制下某一位的值, 此时对这一位 <code>| 0</code> 或者 <code>&amp; 1</code>, 并不会对原来的该位上的值造成影响. 那么, 如果第 $i$ 位为 <code>1</code>, 那么在一次形如 <code>&amp; 0</code> 的操作后, 一定存在操作 <code>&amp; 1</code>.</p>
<p>也就是说, 如果把左边看作低位, 那么 $x$ 形如 <code>...1...0...</code>, $b_i$ 形如 <code>...0...1...</code>. 换句话说, $x &lt; b_i$.</p>
<p>大体思路就是这样了, 也不知道考场 AC 的 “逆推” 做法是什么样的. 还有一些值得注意的细节, 也在代码里了.</p>
<p>由于使用了基数排序, 时间复杂度 $O(nm + mq)$.</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2494</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e3</span> + <span class="number">5</span>, MAXM = <span class="number">5e5</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">char</span> S[MAXM];</span><br><span class="line"><span class="type">int</span> idx[MAXM], pos[MAXM], A[MAXM];</span><br><span class="line"><span class="type">int</span> pow2[MAXN], val[MAXM], Ans[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) pow2[i] = <span class="number">2LL</span> * pow2[i<span class="number">-1</span>] % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) A[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> c[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, S<span class="number">+1</span>);</span><br><span class="line">        <span class="comment">// 字符集为 2 的基数排序相当清爽啊</span></span><br><span class="line">        c[<span class="number">0</span>] = <span class="number">0</span>, c[<span class="number">1</span>] = m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">if</span> (S[j] == <span class="string">&#x27;1&#x27;</span>) val[j] = (val[j] + pow2[i - <span class="number">1</span>]) % P; <span class="keyword">else</span> ++c[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j; --j) idx[c[S[A[j]] - <span class="string">&#x27;0&#x27;</span>]--] = A[j];</span><br><span class="line">        <span class="built_in">memcpy</span>(A, idx, (m + <span class="number">1</span>) * <span class="built_in">sizeof</span> (<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) Ans[i] = val[A[i]];</span><br><span class="line">    Ans[m + <span class="number">1</span>] = pow2[n];</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, S<span class="number">+1</span>);</span><br><span class="line">        <span class="type">int</span> L = <span class="number">0</span>, R = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= <span class="number">1</span>; --i) <span class="keyword">if</span> (S[A[i]] == <span class="string">&#x27;0&#x27;</span>) &#123; L = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="keyword">if</span> (S[A[i]] == <span class="string">&#x27;1&#x27;</span>) &#123; R = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, L &lt; R? (Ans[R] - Ans[L] + P) % P: <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="「AHOI-HNOI2018」转盘"><a href="#「AHOI-HNOI2018」转盘" class="headerlink" title="「AHOI / HNOI2018」转盘"></a>「AHOI / HNOI2018」转盘</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/2495">https://loj.ac/problem/2495</a></li>
</ul>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>将选择物品这个过程的顺序倒过来, 也就是在某个时刻 $t$, 从位置 $i$ 开始先前移动, 每个物品在时刻 $T_j$ 消失, 需要在每个物品消失前到达该物品的位置.</p>
<p>此时容易看出, 选择好位置和时刻之后, 一刻不停地走才能得到当前状态下的最优解. 本题做法就此展开.</p>
<p>首先将出现时刻序列 $T_i$ 倍长, 记当前出发位置为 $i$ ($i \in [n, 2n)$), 当前时刻为 $t$, 则标记所有物品的限制可以表示为</p>
<script type="math/tex; mode=display">\forall\ j \in (i-n,\ i],\ t - (i - j) \ge T_j</script><p>即</p>
<script type="math/tex; mode=display">t \ge (T_j - j) + i</script><p>记 $a_j = T_j - j$, 那么答案为</p>
<script type="math/tex; mode=display">\min_{i = n} ^ {2n - 1} \{ \max_{j = i - n + 1} ^ {i} \{ a_j \} + i \}</script><p>对 $i$ 进行一些变换, 得</p>
<script type="math/tex; mode=display">\min_{i = 1} ^ n \{ \max_{j = i} ^ {i + n -1} \{ a_j \} + i \} + (n-1)</script><p>考虑到 $i \le j &lt; i + n$ 这个限制又臭又长, 因为 $a_i = T_i - i &gt; a_{i + n} = T_{i + n} - (i + n) = T_i - i - n$, 所以此时的 $a_j$ 就是个后缀最大值, 即</p>
<script type="math/tex; mode=display">\min_{i = 1} ^ n \{ \max_{j = i} ^ {2 n} \{ a_j \} + i \} + (n-1)</script><p>考虑某一个位置 $j$, 令 $j$ 满足 $a_j$ 为后缀最大值, 那么从 $j-1$ 往前找到第一个满足 $a_i &gt; a_j$ 的位置 $i$, 此时答案为 $a_j + i + 1$.</p>
<p>如果此时 $a_j$ 不是后缀最大值, 那么答案和后缀最大值的情况相同.</p>
<p>就此我们得到了一个单调栈做法, 即维护一个 $a_j$ 值从右到左单调上升的栈, 并设栈中元素为 $p_i$, 令 $p_0 = 0$, 答案即为</p>
<script type="math/tex; mode=display">\min_{i = 1} ^ j \{ a_{p_i} + p_{i-1} + 1\} + n - 1 = \min_{i = 1} ^ j \{ a_{p_i} + p_{i-1}\} + n</script><p>利用线段树维护这个单调栈即可. 还是由于 $a_i = T_i - i, a_{i + n} = T_{i + n} - i - n$, 此时只需要维护 $[1, n]$ 即可.</p>
<p>类似的技巧也在 <a href="https://www.luogu.com.cn/problem/P4198">Luogu P4198 楼房重建</a> 中使用过.</p>
<p>时间复杂度 $O(n \log ^2 n)$.</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2495</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, p;</span><br><span class="line"><span class="type">int</span> A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (nd&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (nd&lt;&lt;1|1)</span></span><br><span class="line">    <span class="type">int</span> datMax[MAXN &lt;&lt; <span class="number">2</span>], dat[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Qry</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">const</span> <span class="type">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> datMax[nd] &gt; k? k + L: INF;</span><br><span class="line">        <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; datMax[rc]) <span class="keyword">return</span> <span class="built_in">min</span>(dat[nd], <span class="built_in">Qry</span>(rc, Mid<span class="number">+1</span>, R, k));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Qry</span>(lc, L, Mid, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> nd, <span class="type">const</span> <span class="type">int</span>&amp; L, <span class="type">const</span> <span class="type">int</span>&amp; R)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        datMax[nd] = <span class="built_in">max</span>(datMax[lc], datMax[rc]);</span><br><span class="line">        dat[nd] = <span class="built_in">Qry</span>(lc, L, Mid, datMax[rc]);</span><br><span class="line">        <span class="comment">// 用右子树的最大值在左子树中查询, 以更新答案</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> <span class="built_in">void</span>( datMax[nd] = A[L] - L );</span><br><span class="line">        <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">build</span>(lc, L, Mid), <span class="built_in">build</span>(rc, Mid<span class="number">+1</span>, R);</span><br><span class="line">        <span class="built_in">maintain</span>(nd, L, R);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Mdy</span><span class="params">(<span class="type">int</span> nd, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">const</span> <span class="type">int</span>&amp; pos, <span class="type">const</span> <span class="type">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> <span class="built_in">void</span>( datMax[nd] = val - L );</span><br><span class="line">        <span class="type">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= Mid) <span class="built_in">Mdy</span>(lc, L, Mid, pos, val);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">Mdy</span>(rc, Mid<span class="number">+1</span>, R, pos, val);</span><br><span class="line">        <span class="built_in">maintain</span>(nd, L, R);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> rc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m), <span class="built_in">read</span>(p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(A[i]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    SGT::<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="type">int</span> x, y, lstans = SGT::<span class="built_in">Qry</span>(<span class="number">1</span>, <span class="number">1</span>, n, SGT::datMax[<span class="number">1</span>] - n) + n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lstans);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">read</span>(x), <span class="built_in">read</span>(y);</span><br><span class="line">        x ^= p * lstans, y ^= p * lstans;</span><br><span class="line">        SGT::<span class="built_in">Mdy</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lstans = SGT::<span class="built_in">Qry</span>(<span class="number">1</span>, <span class="number">1</span>, n, SGT::datMax[<span class="number">1</span>] - n) + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="「AHOI-HNOI2018」毒瘤"><a href="#「AHOI-HNOI2018」毒瘤" class="headerlink" title="「AHOI / HNOI2018」毒瘤"></a>「AHOI / HNOI2018」毒瘤</h3><p>毒瘤.</p>
<h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/2496">https://loj.ac/problem/2496</a></li>
</ul>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先考虑树的情况下怎么做.</p>
<p>设 $f(i, j)$ 表示以节点 $i$ 为根的子树内, 第 $i$ 个点选 ($j = 1$) / 不选 ($j = 0$) 时的方案数, 容易得到转移</p>
<script type="math/tex; mode=display">f(u, 1) \prod_{v \in son(u)} f(v, 0) \\ f(u, 0) = \prod_{v \in son(u)} (\ f(v, 0) + f(v, 1)\ )</script><p>观察到 $n - 1 \le m \le n + 10$ 的限制, 可以得到一个 $O(n 2 ^ {m - n + 1})$, 即依次枚举非树边的选择情况, 以此为限制修改 DP 初始值, 每次都做一次整棵树的 DP.</p>
<p>此时仍有优化的余地, 考虑到非树边很少, 影响到的点很少, 可以对这些点建出虚树, 并在虚树上 DP.</p>
<p>具体地说, 考虑虚树上一条边 $(u, v)$, 其在树边上路径为 $k_1, k_2, \ldots, k_n$ (其中 $k_1 = u$, $k_n = v$), 此时 $v$ 对 $u$ 的答案有贡献. 即</p>
<script type="math/tex; mode=display">f(k_i, 1) := f(k_i, 1) \cdot f(k_{i+1}, 0) \\ f(k_i, 0) := f(k_i, 0) \cdot (\ f(k_{i+1}, 0) + f(k_{i+1}, 1)\ )</script><p>手动展开之后式子有些复杂… 冷静一下可以发现, 其中的系数都是一样的, 直接按照定义预处理出来就好了.</p>
<p>记 $k(u, i, j)$ 表示节点 $u$, 由状态 $i$ 到达状态 $j$, DP 转移时的系数. 则虚树边上的转移可写作</p>
<script type="math/tex; mode=display">f(u, 0) = \prod_{v \in son(u)} (\ k(v, 1, 0) \cdot f(v, 1) + k(v, 0, 0) \cdot f(v, 0)\ ) \\ f(u, 1) = \prod_{v \in son(u)} (\ k(v, 1, 1) \cdot f(v, 1) + k(v, 0, 1) \cdot f(v, 0)\ )</script><p>还应注意到, 虚树上 DP 的初始值并不是 $1$ —- 而是原树上, 子树内不包含虚树上结点的 DP 值.</p>
<p>考虑为什么是这样. 如果原树某个节点, 其子树包含有虚数上节点, 那么此时原树上的答案已经在计算系数的过程中贡献到最终答案了. 因而只考虑子树内不包含虚树上节点的部分即可.</p>
<p>时间复杂度 $O(n + (m-n+1) 2 ^ {m - n + 1})$.</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>实际为了缓存友好, DP 状态的顺序稍有改变.</p>
<div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2496</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">114</span>, P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> U[MAXN], V[MAXN], nE;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="type">int</span> pre[MAXN], dfn[MAXN], A[MAXN], nA;</span><br><span class="line"><span class="type">int</span> f[<span class="number">2</span>][MAXN], g[<span class="number">2</span>][MAXN], K[<span class="number">2</span>][<span class="number">2</span>][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123; <span class="type">int</span> nxt, to; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="type">int</span> head[MAXN], eidx;</span><br><span class="line">    Edge edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Graph</span>() &#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G, T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HLD &#123;</span><br><span class="line">    <span class="type">int</span> son[MAXN], depth[MAXN], size[MAXN], topfa[MAXN], dfs_clock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">        pre[u] = fa, size[u] = <span class="number">1</span>, son[u] = <span class="number">-1</span>;</span><br><span class="line">        dfn[u] = ++dfs_clock, depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v, i = G.head[u]; ~i; i = G.edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = G.edges[i].to) == fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">                <span class="built_in">dfs1</span>(v, u), size[u] += size[v];</span><br><span class="line">                <span class="keyword">if</span> (son[u] == <span class="number">-1</span> || size[son[u]] &lt; size[v]) son[u] = v;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dfn[v] &lt; dfn[u])</span><br><span class="line">                U[++nE] = v, V[nE] = u, vis[u] = vis[v] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> top)</span> </span>&#123;</span><br><span class="line">        topfa[u] = top;</span><br><span class="line">        <span class="keyword">if</span> (~son[u]) <span class="built_in">dfs2</span>(son[u], top), vis[u] |= vis[son[u]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v, i = G.head[u]; ~i; i = G.edges[i].nxt)</span><br><span class="line">            <span class="keyword">if</span> ((v = G.edges[i].to) != pre[u] &amp;&amp; v != son[u])</span><br><span class="line">                <span class="built_in">dfs2</span>(v, v), vis[u] |= vis[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (topfa[u] != topfa[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth[topfa[u]] &lt; depth[topfa[v]]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">            u = pre[topfa[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth[u] &gt; depth[v]? v: u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>), G.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (pre[i]) G.<span class="built_in">AddEdge</span>(pre[i], i);</span><br><span class="line">        <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> VT &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)</span> </span>&#123; <span class="keyword">return</span> dfn[a] &lt; dfn[b]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> stk[MAXN], top;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nE; ++i) A[++nA] = U[i], A[++nA] = V[i];</span><br><span class="line">        <span class="built_in">sort</span>(A<span class="number">+1</span>, A<span class="number">+1</span>+nA, cmp);</span><br><span class="line">        stk[top = <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nA; ++i) <span class="keyword">if</span> (A[i] != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == stk[top]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> lca = HLD::<span class="built_in">LCA</span>(A[i], stk[top]);</span><br><span class="line">            <span class="keyword">if</span> (lca != stk[top]) &#123;</span><br><span class="line">                <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; dfn[lca] &lt; dfn[stk[top<span class="number">-1</span>]])</span><br><span class="line">                    T.<span class="built_in">AddEdge</span>(stk[top<span class="number">-1</span>], stk[top]), --top;</span><br><span class="line">                <span class="keyword">if</span> (top &gt; <span class="number">1</span> &amp;&amp; dfn[lca] &gt; dfn[stk[top<span class="number">-1</span>]])</span><br><span class="line">                    T.<span class="built_in">AddEdge</span>(lca, stk[top]), stk[top] = lca;</span><br><span class="line">                <span class="keyword">else</span> T.<span class="built_in">AddEdge</span>(lca, stk[top--]);</span><br><span class="line">            &#125;</span><br><span class="line">            stk[++top] = A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; top; ++i) T.<span class="built_in">AddEdge</span>(stk[i], stk[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在原树上 DP, 辅助计算系数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DP</span><span class="params">(<span class="type">int</span> u, <span class="type">const</span> <span class="type">int</span>&amp; ban)</span> </span>&#123;</span><br><span class="line">        f[<span class="number">0</span>][u] = f[<span class="number">1</span>][u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v, i = G.head[u]; ~i; i = G.edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = G.edges[i].to) == ban || v == pre[u]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">DP</span>(v, u);</span><br><span class="line">            f[<span class="number">1</span>][u] = <span class="number">1LL</span> * f[<span class="number">1</span>][u] * f[<span class="number">0</span>][v] % P;</span><br><span class="line">            f[<span class="number">0</span>][u] = <span class="number">1LL</span> * f[<span class="number">0</span>][u] * (f[<span class="number">0</span>][v] + f[<span class="number">1</span>][v]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 DP 初始值 g</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DPinit</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">        g[<span class="number">0</span>][u] = g[<span class="number">1</span>][u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v, i = G.head[u]; ~i; i = G.edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = G.edges[i].to) == fa || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">DPinit</span>(v, u);</span><br><span class="line">            g[<span class="number">1</span>][u] = <span class="number">1LL</span> * g[<span class="number">1</span>][u] * g[<span class="number">0</span>][v] % P;</span><br><span class="line">            g[<span class="number">0</span>][u] = <span class="number">1LL</span> * g[<span class="number">0</span>][u] * (g[<span class="number">0</span>][v] + g[<span class="number">1</span>][v]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算系数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Jump</span><span class="params">(<span class="type">int</span> u, <span class="type">const</span> <span class="type">int</span>&amp; fa)</span> </span>&#123;</span><br><span class="line">        K[<span class="number">0</span>][<span class="number">0</span>][u] = K[<span class="number">0</span>][<span class="number">1</span>][u] = K[<span class="number">1</span>][<span class="number">0</span>][u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = u; pre[i] != fa; i = pre[i]) &#123;</span><br><span class="line">            <span class="built_in">DP</span>(pre[i], i);</span><br><span class="line">            <span class="type">int</span> ft = pre[i], k0 = K[<span class="number">0</span>][<span class="number">0</span>][u], k1 = K[<span class="number">0</span>][<span class="number">1</span>][u];</span><br><span class="line">            K[<span class="number">0</span>][<span class="number">0</span>][u] = (<span class="number">1LL</span> * f[<span class="number">0</span>][ft] * k0 % P + <span class="number">1LL</span> * f[<span class="number">1</span>][ft] * K[<span class="number">1</span>][<span class="number">0</span>][u] % P) % P;</span><br><span class="line">            K[<span class="number">0</span>][<span class="number">1</span>][u] = (<span class="number">1LL</span> * f[<span class="number">0</span>][ft] * k1 % P + <span class="number">1LL</span> * f[<span class="number">1</span>][ft] * K[<span class="number">1</span>][<span class="number">1</span>][u] % P) % P;</span><br><span class="line">            K[<span class="number">1</span>][<span class="number">1</span>][u] = <span class="number">1LL</span> * f[<span class="number">0</span>][ft] * k1 % P;</span><br><span class="line">            K[<span class="number">1</span>][<span class="number">0</span>][u] = <span class="number">1LL</span> * f[<span class="number">0</span>][ft] * k0 % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在虚树上 DFS 以初始化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">        A[++nA] = u, <span class="built_in">DPinit</span>(u, fa);</span><br><span class="line">        <span class="keyword">if</span> (fa &amp;&amp; u != fa) <span class="built_in">Jump</span>(u, fa);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v, i = T.head[u]; ~i; i = T.edges[i].nxt)</span><br><span class="line">            <span class="keyword">if</span> ((v = T.edges[i].to) != fa) <span class="built_in">init</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123; <span class="built_in">build</span>(), nA = <span class="number">0</span>, <span class="built_in">init</span>(<span class="number">1</span>, <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚树上 DP</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v, i = T.head[u]; ~i; i = T.edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = T.edges[i].to) == fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(v, u);</span><br><span class="line">            f[<span class="number">0</span>][u] = <span class="number">1LL</span> * f[<span class="number">0</span>][u] *</span><br><span class="line">                (<span class="number">1LL</span> * K[<span class="number">0</span>][<span class="number">0</span>][v] * f[<span class="number">0</span>][v] % P + <span class="number">1LL</span> * K[<span class="number">0</span>][<span class="number">1</span>][v] * f[<span class="number">1</span>][v] % P) % P;</span><br><span class="line">            f[<span class="number">1</span>][u] = <span class="number">1LL</span> * f[<span class="number">1</span>][u] *</span><br><span class="line">                (<span class="number">1LL</span> * K[<span class="number">1</span>][<span class="number">0</span>][v] * f[<span class="number">0</span>][v] % P + <span class="number">1LL</span> * K[<span class="number">1</span>][<span class="number">1</span>][v] * f[<span class="number">1</span>][v] % P) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">read</span>(u), <span class="built_in">read</span>(v), G.<span class="built_in">AddEdge</span>(u, v), G.<span class="built_in">AddEdge</span>(v, u);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    HLD::<span class="built_in">solve</span>(), VT::<span class="built_in">solve</span>();</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; nE); ++s) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nA; ++i)</span><br><span class="line">            f[<span class="number">0</span>][A[i]] = g[<span class="number">0</span>][A[i]], f[<span class="number">1</span>][A[i]] = g[<span class="number">1</span>][A[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nE; ++i)</span><br><span class="line">            <span class="keyword">if</span> ((s &gt;&gt; (i<span class="number">-1</span>)) &amp; <span class="number">1</span>) f[<span class="number">0</span>][U[i]] = f[<span class="number">1</span>][V[i]] = <span class="number">0</span>; <span class="keyword">else</span> f[<span class="number">1</span>][U[i]] = <span class="number">0</span>;</span><br><span class="line">        VT::<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>), ans = (ans + (f[<span class="number">0</span>][<span class="number">1</span>] + f[<span class="number">1</span>][<span class="number">1</span>]) % P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="「AHOI-HNOI2018」游戏"><a href="#「AHOI-HNOI2018」游戏" class="headerlink" title="「AHOI / HNOI2018」游戏"></a>「AHOI / HNOI2018」游戏</h3><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/2508">https://loj.ac/problem/2508</a></li>
</ul>
<h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先将房间按上锁的门分割, 处理出房间 $i$ 能到达的房间位置 $[L_i, R_i]$. 这样判断 $s$ 是否能到达 $t$, 只需要判断 $t$ 是否在区间 $[L_i, R_i]$ 就好了.</p>
<p>有一个显然的暴力, 对于每个位置向左右两个方向扩展, 并逐步更新 $L_i$ / $R_i$.</p>
<p>思考如何优化这个暴力. 考虑到对每个位置扩展时, 很多状态被计算了多次. 而题目中钥匙放置位置, 又存在这样的性质:</p>
<ol>
<li><p>如果房间 $i$ 和房间 $i+1$ 存在锁, 且钥匙在房间 $i$ 左侧 (包含 $i$), 那么房间 $i+1$ 之后的位置一定不能越过这扇门.</p>
</li>
<li><p>如果房间 $i$ 和房间 $i+1$ 存在锁, 且钥匙在房间 $i+1$ 右侧 (包含 $i+1$), 那么房间 $i$ 之前的位置一定不能越过这扇门.</p>
</li>
</ol>
<p>每次遇到一个锁时, 将一个位置向该位置不能到达的地方连边, 建完边后可以得到一个 DAG, 在拓扑排序时更新可到达位置区间即可.</p>
<p>实际实现时, 直接使用按锁分割后的编号, 也就是所谓 “缩点” 了.</p>
<p>虽然拓扑排序更新到达位置区间 $[L_i, R_i]$ 时的复杂度看起来很不对劲, 但其实均摊是线性的… 这也是建图方法所保证的.</p>
<p>时间复杂度 $O(n + m)$.</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2508</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> L[MAXN], R[MAXN];</span><br><span class="line"><span class="type">int</span> Key[MAXN], Idx[MAXN], idx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123; <span class="type">int</span> nxt, to; &#125; edges[MAXN];</span><br><span class="line">    <span class="type">int</span> head[MAXN], in[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">        ++in[to];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= idx; ++i) <span class="keyword">if</span> (!in[i]) Q.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="type">int</span> p1 = Key[L[u] - <span class="number">1</span>], p2 = Key[R[u]];</span><br><span class="line">                <span class="keyword">while</span> (L[u] &lt;= p1 &amp;&amp; p1 &lt;= R[u])</span><br><span class="line">                    flag = <span class="literal">true</span>, L[u] = L[Idx[L[u] - <span class="number">1</span>]], p1 = Key[L[u] - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">while</span> (L[u] &lt;= p2 &amp;&amp; p2 &lt;= R[u])</span><br><span class="line">                    flag = <span class="literal">true</span>, R[u] = R[Idx[R[u] + <span class="number">1</span>]], p2 = Key[R[u]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">                <span class="keyword">if</span> (!(--in[v = edges[i].to])) Q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::<span class="built_in">init</span>();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m), <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x, i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">read</span>(x), <span class="built_in">read</span>(Key[x]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    L[<span class="number">1</span>] = R[<span class="number">1</span>] = idx = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Key[i - <span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            L[++idx] = i;</span><br><span class="line">            <span class="keyword">if</span> (Key[i - <span class="number">1</span>] &lt;= i - <span class="number">1</span>) Graph::<span class="built_in">AddEdge</span>(idx, idx - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> Graph::<span class="built_in">AddEdge</span>(idx - <span class="number">1</span>, idx);</span><br><span class="line">        &#125;</span><br><span class="line">        R[idx] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记 Idx[i] 为实际房间标号 i, 对应按锁分割后块的编号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= idx; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = L[i]; j &lt;= R[i]; ++j) Idx[j] = i;</span><br><span class="line">    Graph::<span class="built_in">Toposort</span>();</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> s, t;</span><br><span class="line">        <span class="built_in">read</span>(s), <span class="built_in">read</span>(t);</span><br><span class="line">        <span class="built_in">puts</span>((L[Idx[s]] &lt;= t &amp;&amp; t &lt;= R[Idx[s]])? <span class="string">&quot;YES&quot;</span>: <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="「AHOI-HNOI2018」排列"><a href="#「AHOI-HNOI2018」排列" class="headerlink" title="「AHOI / HNOI2018」排列"></a>「AHOI / HNOI2018」排列</h3><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/2509">https://loj.ac/problem/2509</a></li>
</ul>
<h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>考虑题目中这个很奇怪的限制在说什么.</p>
<p>既然满足 “如果 $a_{p_j} = p_k$, 那么 $k &lt; j$”, 换句话说, 如果增量构造出这个排列, 在选择 $j$ 时, 一定要先选 $a_j$.</p>
<p>此时将 $a_j$ 向 $j$ 连边, 如果形成环则一定无解, 否则就是一颗以 $0$ 为根的树.</p>
<p>考虑如何构造出最优解, 可以发现, 权值都是固定的, 要做的事就是在合法的范围内, 将尽量大的 $w_i$ 放在后面.</p>
<p>于是可以得到一个贪心策略. 首先找到当前权值最小的位置 $p$, 如果 $p$ 在树上没有父亲, 也就是 $a_p = 0$, 此时一定选择 $p$; 否则在选择 $a_p$ 后立刻选择 $p$.</p>
<p>因此可以将 $p$ 和 $a_p$ 合并, 具体而言, 每次取出最小值, 更新信息并利用并查集合并即可.</p>
<p>剩余的问题就是如何找到这个最小值了. 考虑到合并一些节点之后, 得到的就是一个序列. 假有两个序列 $a$, $b$, 记两个序列的权值分别为 $W_a$, $W_b$, 那么</p>
<script type="math/tex; mode=display">W_a = \sum_{i = p}^{s_a} (p + i)\ w_{a_i} \\\ W_b = \sum_{i = p} ^ {s_b} (p + i)\ w_{b_i}</script><p>考虑两序列拼接的两种方式, 即</p>
<script type="math/tex; mode=display">W_{ab} = \sum_{i = 1} ^ {s_a} (p + i)\ w_{a_i} + \sum_{i = 1} ^ {s_b} (p + i + s_a)\ w_{b_i} \\\ W_{ba} = \sum_{i = 1} ^ {s_b} (p + i)\ w_{b_i} + \sum_{i = 1} ^ {s_a} (p + i + s_b)\ w_{a_i}</script><p>若选择 $ab$ 的形式使得答案更大, 那么有 $W_{ab} &gt; W_{ba}$, 即</p>
<script type="math/tex; mode=display">s_b \sum_{i = 1} ^ {s_a} w_{a_i} < s_a \sum_{i = 1} ^ {s_b} w_{b_i}</script><p>于是万事大吉.</p>
<p>时间复杂度 $O(n \log n)$.</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><p>如果考虑节点 $0$ 在计算答案时的影响, 则需要把 <code>W[0]</code> 设为 INF, 但是这个 INF 太大爆 <code>long long</code> (虽然不影响结果), 太小会 WA = =</p>
<p>那就直接不考虑吧 (</p>
<div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2509</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, s; LL w;</span><br><span class="line">    <span class="built_in">Item</span>(<span class="type">int</span> _u, <span class="type">int</span> _s, LL _w): <span class="built_in">u</span>(_u), <span class="built_in">s</span>(_s), <span class="built_in">w</span>(_w) &#123; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Item&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w * rhs.s &gt; rhs.w * s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> A[MAXN], size[MAXN];</span><br><span class="line">LL W[MAXN];</span><br><span class="line">priority_queue&lt;Item&gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DSU &#123;</span><br><span class="line">    <span class="type">int</span> fa[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) fa[i] = i, size[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123; <span class="keyword">return</span> u == fa[u]? u: fa[u] = <span class="built_in">findfa</span>(fa[u]); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">NoAns</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123; <span class="type">int</span> nxt, to; &#125; edges[MAXN];</span><br><span class="line">    <span class="type">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">bool</span> vis[MAXN];</span><br><span class="line">        <span class="type">int</span> s = vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) == fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (vis[v]) <span class="built_in">NoAns</span>();</span><br><span class="line">            s += <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::<span class="built_in">init</span>();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(W[i]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) Graph::<span class="built_in">AddEdge</span>(A[i], i);</span><br><span class="line">    <span class="keyword">if</span> (Graph::<span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>) != n + <span class="number">1</span>) <span class="built_in">NoAns</span>();</span><br><span class="line">    DSU::<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) Q.<span class="built_in">push</span>(<span class="built_in">Item</span>(i, size[i], W[i]));</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Item x = Q.<span class="built_in">top</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> u = DSU::<span class="built_in">findfa</span>(x.u), fa = DSU::<span class="built_in">findfa</span>(A[u]);</span><br><span class="line">        <span class="keyword">if</span> (size[u] != x.s) <span class="keyword">continue</span>;</span><br><span class="line">        ans += W[u] * size[fa];</span><br><span class="line">        DSU::fa[u] = fa, W[fa] += W[u], size[fa] += size[u];</span><br><span class="line">        <span class="keyword">if</span> (fa) Q.<span class="built_in">push</span>(<span class="built_in">Item</span>(fa, size[fa], W[fa]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="「AHOI-HNOI2018」道路"><a href="#「AHOI-HNOI2018」道路" class="headerlink" title="「AHOI / HNOI2018」道路"></a>「AHOI / HNOI2018」道路</h3><p>这是一道 NOIP 题…</p>
<h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/2510">https://loj.ac/problem/2510</a></li>
</ul>
<h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>观察式子</p>
<script type="math/tex; mode=display">c_i \cdot (a_i + x) \cdot (b_i + y)</script><p>可以发现, 这个式子没有用.</p>
<p>题目给定的其实是一颗以 $1$ 为根, 共 $2n - 1$ 个节点的二叉树, 叶节点都是乡村. 并钦定连向左儿子的边为公路, 连向右儿子的边为铁路.</p>
<p>设 $f(u, i, j)$ 表示节点 $u$, 其到根节点共经过 $i$ 条公路, $j$ 条铁路. 则</p>
<p>对于叶子 $u$, 有</p>
<script type="math/tex; mode=display">f(u, i, j) = c_u \cdot (a_u + i) \cdot (b_u + j)</script><p>对于其他节点 $u$, 记 $u$ 左儿子为 $lc$, 右儿子为 $rc$, 有转移</p>
<script type="math/tex; mode=display">f(u, i, j) = \min \{ f(lc, i + 1, j) + f(rc, i, j),\ f(lc, i, j) + f(rc, i,  j + 1) \}</script><p>答案即为 $f(1, 0, 0)$.</p>
<p>以及一个卡空间的方法. 考虑到每次计算 $f(u, i, j)$ 时, 只是利用了一条链, 不相交的链之间不会互相影响, 若记二叉树最大深度为 $h$, 第一维只需记录 $2h$ 位即可.</p>
<p>时间复杂度 $O(h ^ 2 n)$.</p>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">> 点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2510</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">4e4</span> + <span class="number">5</span>, MAXH = <span class="number">41</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> A[MAXN], B[MAXN], C[MAXN];</span><br><span class="line"><span class="type">int</span> ch[<span class="number">2</span>][(MAXN &gt;&gt; <span class="number">1</span>) | <span class="number">1</span>], dfn[MAXN];</span><br><span class="line">LL f[MAXH][MAXH][(MAXH &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> clk, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> du = dfn[u] = clk;</span><br><span class="line">    <span class="keyword">if</span> (u &gt;= n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= x; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= y; ++j)</span><br><span class="line">                f[i][j][du] = <span class="number">1LL</span> * C[u] * (A[u] + i) * (B[u] + j);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 假装自己在下传 DFS 序.png</span></span><br><span class="line">    <span class="built_in">dfs</span>(ch[<span class="number">0</span>][u], clk + <span class="number">1</span>, x + <span class="number">1</span>, y), <span class="built_in">dfs</span>(ch[<span class="number">1</span>][u], clk + <span class="number">2</span>, x, y + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> d1 = dfn[ch[<span class="number">0</span>][u]], d2 = dfn[ch[<span class="number">1</span>][u]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= x; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= y; ++j)</span><br><span class="line">            f[i][j][du] = <span class="built_in">min</span>(f[i + <span class="number">1</span>][j][d1] + f[i][j][d2], f[i][j][d1] + f[i][j + <span class="number">1</span>][d2]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u, v, i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(u), <span class="built_in">read</span>(v);</span><br><span class="line">        ch[<span class="number">0</span>][i] = u &lt; <span class="number">0</span>? -u + n - <span class="number">1</span>: u, ch[<span class="number">1</span>][i] = v &lt; <span class="number">0</span>? -v + n - <span class="number">1</span>: v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt;= n + n<span class="number">-1</span>; ++i) <span class="built_in">read</span>(A[i]), <span class="built_in">read</span>(B[i]), <span class="built_in">read</span>(C[i]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[<span class="number">0</span>][<span class="number">0</span>][dfn[<span class="number">1</span>]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这周比上周少写了一整套 SDOI = =, 退役稳了.</p>
<hr>

  </div>
  <footer class="article-footer">
    
  <div class="cc">
    <a href="http://creativecommons.org/licenses/by-nc/4.0/deed.z" target="_blank" title="署名-非商业性使用">
      <img src="/images/cc/cc.png">
      
          <img src="/images/cc/by.png">
        
          <img src="/images/cc/nc.png">
        
      <span>
        本作品采用知识共享 署名-非商业性使用 4.0 国际许可协议进行许可。
      </span>
    </a>
  </div>


  </footer>
</article>





          <div class="main-footer">
  
    ©
    
      2019-2025
    
    DepletedPrism&#39;s Blog
    
	- Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  
<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>


  
<link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">

  
<link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">


  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  
<script src="/PhotoSwipe/photoswipe.js"></script>

  
<script src="/PhotoSwipe/photoswipe-ui-default.js"></script>




<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>


<script src="/scripts/main.js"></script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ["$","$"], ["\\(","\\)"] ],
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax();
    for (var i = 0; i < all.length; ++i)
      all[i].SourceElement().parentNode.className += ' has-jax';
  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>


</body>
</html>
