<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DepletedPrism&#39;s Blog</title>
  
  <subtitle>厌离秽土, 欣求净土.</subtitle>
  <link href="https://depletedprism.github.io/atom.xml" rel="self"/>
  
  <link href="https://depletedprism.github.io/"/>
  <updated>2020-06-04T06:50:54.036Z</updated>
  <id>https://depletedprism.github.io/</id>
  
  <author>
    <name>DepletedPrism</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「置顶」算法教程合辑</title>
    <link href="https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/compilation/"/>
    <id>https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/compilation/</id>
    <published>9102-11-14T00:11:23.000Z</published>
    <updated>2020-06-04T06:50:54.036Z</updated>
    
    <content type="html"><![CDATA[<hr><p>这个 idea 来源于 <a href="https://www.cnblogs.com/mlystdcall/p/8078467.html">__stdcall 的教程合辑</a>, 觉得这个很好, 所以学习了.</p><span id="more"></span><p><del>Hexo 博客的强制置顶</del></p><h4 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h4><ul><li><p>树状数组进阶</p><ul><li><a href="https://www.cnblogs.com/RabbitHu/p/BIT.html">https://www.cnblogs.com/RabbitHu/p/BIT.html</a></li></ul></li></ul><h4 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h4><ul><li><p>网络流入门</p><ul><li><a href="https://www.xht37.com/二分图与网络流-学习笔记/">https://www.xht37.com/二分图与网络流-学习笔记/</a></li></ul></li><li><p>上下界网络流</p><ul><li><a href="https://www.cnblogs.com/mlystdcall/p/6734852.html">https://www.cnblogs.com/mlystdcall/p/6734852.html</a></li></ul></li><li><p>基于 Capacity Scaling 的弱多项式复杂度最小费用流算法</p><ul><li><a href="https://ouuan.github.io/post/%E5%9F%BA%E4%BA%8E-capacity-scaling-%E7%9A%84%E5%BC%B1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%B5%81%E7%AE%97%E6%B3%95/">https://ouuan.github.io/post/基于-capacity-scaling-的弱多项式复杂度最小费用流算法</a></li></ul></li><li><p>模拟费用流</p><ul><li><a href="https://www.mina.moe/archives/11762">https://www.mina.moe/archives/11762</a></li></ul></li></ul><h4 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h4><ul><li><p>基础构造</p><ul><li><a href="https://oi.men.ci/linear-basis-notes/">https://oi.men.ci/linear-basis-notes/</a></li></ul></li><li><p>可重集 Kth 异或和</p><ul><li><a href="https://blog.csdn.net/qaq__qaq/article/details/53812883">https://blog.csdn.net/qaq__qaq/article/details/53812883</a></li><li><a href="https://ouuan.github.io/post/%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://ouuan.github.io/post/线性基学习笔记/</a></li></ul></li></ul><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul><li><p>四边形不等式优化</p><ul><li><a href="https://oi-wiki.org/dp/opt/quadrangle/">https://oi-wiki.org/dp/opt/quadrangle/</a></li></ul></li></ul><h4 id="Link-Cut-Tree"><a href="#Link-Cut-Tree" class="headerlink" title="Link Cut Tree"></a>Link Cut Tree</h4><ul><li><p>应用 &amp; 题单</p><ul><li><a href="https://www.cnblogs.com/flashhu/p/9498517.html">https://www.cnblogs.com/flashhu/p/9498517.html</a></li></ul></li></ul><h4 id="左偏树"><a href="#左偏树" class="headerlink" title="左偏树"></a>左偏树</h4><ul><li><p>特点及应用</p><ul><li><a href="https://files-cdn.cnblogs.com/files/shenben/算法合集之《左偏树的特点及其应用》.pdf">https://files-cdn.cnblogs.com/files/shenben/算法合集之《左偏树的特点及其应用》.pdf</a></li></ul></li></ul><h4 id="Min-Max-容斥"><a href="#Min-Max-容斥" class="headerlink" title="Min-Max 容斥"></a>Min-Max 容斥</h4><ul><li><p>证明及应用</p><ul><li><a href="https://www.cnblogs.com/GXZlegend/p/11563330.html">https://www.cnblogs.com/GXZlegend/p/11563330.html</a></li></ul></li></ul><h4 id="Stirling-数及-Stirling-反演"><a href="#Stirling-数及-Stirling-反演" class="headerlink" title="Stirling 数及 Stirling 反演"></a>Stirling 数及 Stirling 反演</h4><ul><li><p>性质及应用</p><ul><li><a href="https://www.cnblogs.com/y2823774827y/p/10700231.html">https://www.cnblogs.com/y2823774827y/p/10700231.html</a></li></ul></li></ul><h4 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h4><ul><li><p>证明及应用</p><ul><li><a href="https://www.cnblogs.com/GXZlegend/p/11407185.html">https://www.cnblogs.com/GXZlegend/p/11407185.html</a></li></ul></li></ul><h4 id="类欧几里得算法"><a href="#类欧几里得算法" class="headerlink" title="类欧几里得算法"></a>类欧几里得算法</h4><ul><li><p>推导及模板</p><ul><li><a href="https://oi-wiki.org/math/euclidean/">https://oi-wiki.org/math/euclidean/</a></li></ul></li></ul><h4 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h4><ul><li><p>生成函数的运算和常见模型</p><ul><li>金策, &lt;生成函数的运算与组合计数问题&gt;. 国家集训队 2015 论文集.</li></ul></li><li><p>图的计数</p><ul><li>汪乐平, &lt;生成函数, 多项式算法与图的计数&gt;. 2019.1.28.</li></ul></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;这个 idea 来源于 &lt;a href=&quot;https://www.cnblogs.com/mlystdcall/p/8078467.html&quot;&gt;__stdcall 的教程合辑&lt;/a&gt;, 觉得这个很好, 所以学习了.&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://depletedprism.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>我的 2021 年终总结</title>
    <link href="https://depletedprism.github.io/%E9%9A%8F%E7%AC%94/2021-summary/"/>
    <id>https://depletedprism.github.io/%E9%9A%8F%E7%AC%94/2021-summary/</id>
    <published>2022-02-01T03:46:35.000Z</published>
    <updated>2022-02-01T10:10:16.985Z</updated>
    
    <content type="html"><![CDATA[<hr><p>连年终总结都拖欠到新年的人是屑 (</p><span id="more"></span><p>但日期不是可以随便改吗.</p><div style="text-align:center;">  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=4966649&auto=0&height=66"></iframe></div><p>最初的想法是在元旦写完这个年终总结, 结果当时沉迷 <em>Narcissus</em>, 于是就搁置了. 现在看来, 这篇随笔称作 <em>我的辛丑年年终总结</em> 更加合适和应景一点.</p><p>22 年一月初时的考虑是, 自己可能受疫情所困只能留校, 然后计划在除夕当晚一个人在寝室安静地写这篇总结. 后来局势变化, 可以普普通通地坐在家中对着屏幕, 依旧安静地开始写总结.</p><p>高三的半年没什么好记录的, 最后能有大学上应该也算是好结局了. 即使这样, 高考之后总归是不满意的, 又没有复读的决心和精力, 那就这样好了. 其实, 就算我高考拿到了于我而言很可观的分数, 也只会是高兴几天, 然后陷入焦虑之中. 或许现在的结果更加适合我.</p><p>看起来很像是安慰自己的观点. 然而, 开学之后, 却感觉这个观点越来越符合现实了. 这个, 算是开学之后那一部分的内容.</p><p>原先是计划在暑假稍微做一点竞赛的康复训练, 事实上到开学也没有写掉几个模板. 相比于高一高二的时候除夕还在写代码的自己, 现在我应该没有剩下多少热情和决心了. 暑假大部分的时间还是用来打之前想打的独立游戏了, 绝大多数都是一直没机会玩的老作品. 现在想想, 那时候整天打游戏而不想做其他无论有意义与否的事情, 也有一点报复性的意味.</p><p>八月中旬的时候突然想去学一点做独立游戏的技术, 估计是打游戏的副作用. 然后接触了一点点的 OpenGL, 大概学到了渲染正方体表面上的简单光照的程度吧. 表述可能会很奇怪, 毕竟早就不再继续了, 学过的一点知识也忘得差不多了. 如果以后自己真的选择了计算机图形学的方向, 这一段经历和这一段话又可以成为怀念的对象了.</p><p>开学. 西电计算机大类的大一上学期的课业安排还是非常宽松的, 我也有其他需要关注的事情. 虽然之前犹豫了一段时间, 但还是计划在大学打打 XCPC. 在高中同其他人吹水, 开玩笑地重复着”不停课还学什么竞赛”的暴论, 但现在恐怕不能够专心只做竞赛一件事了. 所谓”兼顾”者, 可能是我难以具备的能力之一吧.</p><p>新生赛. 无论是网络赛还是现场赛都没有涉及到需要预先学习一些高妙算法的题目. 硬要说的话, 那就排除掉现场赛最后一道 exKMP 好了 (</p><p>在新生赛之前发现了 <a href="https://codeforces.com/blog/entry/92248">Um_nik 的某篇著名博客</a>, 虽然 Um_nik 的观点并不完全适用于 OI, <code>take it too seriously</code> 也没有意思, 但看到这样的观点还是感到警醒.</p><div style="text-align:center;"><img src="/images/2021-summary/Um_nik.jpg" width="206" /> </div><p>新生赛前的一周内稍稍有一点高中打竞赛时的热情, 可惜并没有持续多久. 我以为我可以保持一定的训练强度, 一直坚持到陕西省省赛, 结果省赛因为疫情无限期延后, 原定的 Codeforces 一句话题解计划也没有坚持几天. </p><p>在最开始, 是因为觉得竞赛有意思才去学竞赛, 现在似乎有一点被竞赛的赛程裹挟着往前的意味了. 总归是本末倒置. 虽然是年终总结, 却越写越像年终吐槽, 那就希望新的一年不会再这样好了.</p><p>壬寅年快乐!</p><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;连年终总结都拖欠到新年的人是屑 (&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://depletedprism.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>一些 Codeforces 简单题的一句话题解 - 壹</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/Codeforces-short-sol-01/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/Codeforces-short-sol-01/</id>
    <published>2021-12-16T05:19:11.000Z</published>
    <updated>2021-12-17T07:41:03.319Z</updated>
    
    <content type="html"><![CDATA[<hr><p>今天的 Codeforces 有在下饭吗?</p><p>是原先在 <a href="https://www.luogu.com.cn/blog/depletedprism/CF-short-sol">洛谷的文章</a> 的精神续作, 直接原因是受 <a href="https://www.bilibili.com/video/BV1NX4y1A7B3">某个学长的视频</a> 的启发.</p><span id="more"></span><p>新的在前头, 老的在后面. 当然只有我写过的 = =</p><p><em>不配打 Div. 1, 有些 Div. 1 的题只是因为出现在了 Div. 2 里, 所以有写.</em></p><h2 id="Round-761-Div-2"><a href="#Round-761-Div-2" class="headerlink" title="Round #761 (Div. 2)"></a>Round #761 (Div. 2)</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>首先直接对 $S$ 排序, 此时只有 $S$ 中同时存在 <code>a</code>, <code>b</code>, <code>c</code> 且 $T$ 为 <code>&quot;abc&quot;</code> 时 $T$ 对排序后的 $S$ 有影响, 这个时候把所有的 <code>c</code> 放在所有的 <code>b</code> 前面就好了.</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>令 $c = 1$, 然后直接暴力找 $a$, $b$ 就好了.</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>对于一个数 $a_i$, 经过一次操作后可以得到从 $1$ 到 $\lfloor \frac{a_i - 1}{2} \rfloor$ 的任一整数. 然后从小到大构造排列, 如果原先就存在需要的数, 就用原来的, 否则选择一个最小的满足条件的 $a_i$ 进行一次操作.</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>记 $f(i)$ 表示 <code>? i i+1 i+2</code> 得到的结果.</p><p>首先每三个位置分作一组询问, 得到 $f(i),\ f(i + 3),\ \cdots$, 由于 $k$ 范围的限制, 一定会存在一个 $i$, 使得 $f(i) \neq f(i+3)$. 然后查询 $f(i + 1)$, $f(i + 2)$. 从 $i$ 到 $i + 5$ 之间一定会有一个位置 $p$, 满足 $f(p) \neq f(p - 1)$ 且 $p$ 和 $p+1$ 一定一个是 imposter, 一个是 crewmate. 此时根据 <code>? p p+1 i</code> 就可以知道 $i$ 的成分, 这样再来 $4$ 次就可以知道从 $i$ 到 $i+5$ 中除去 $p$ 和 $p+1$ 的答案, 额外查询 $1$ 个 <code>? imposter crewmate p</code> 就可以得到 $p$ 和 $p+1$ 的答案.</p><p>对于剩下的 $\frac n3 - 2$ 个三元组, 借助于一个确定的 imposter 和一个确定的 crewmate 并根据 $f(i)$ 的值讨论就好了, 每个三元组用 $2$ 次询问.</p><p>总询问次数是 $n + 3$.</p><h2 id="Edu-Round-118-Div-2"><a href="#Edu-Round-118-Div-2" class="headerlink" title="Edu Round #118 (Div. 2)"></a>Edu Round #118 (Div. 2)</h2><h3 id="A-1"><a href="#A-1" class="headerlink" title="A"></a>A</h3><p>注意读题. 当 $x + y$ 是奇数时无解, 否则给出答案 $(\lfloor \frac x2 \rfloor,\ \lceil \frac y2 \rceil)$.</p><h3 id="B-1"><a href="#B-1" class="headerlink" title="B"></a>B</h3><p>贪心. 尽可能把较大的数放在左边, 较小的数放在右边. 如果按照该原则无法构造出符合限制的答案, 那么一定无解.</p><h3 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h3><p><del>学二分, 拿红名.</del> 发送出去的表情数量是随行数单调增加的, 直接二分就好了.</p><h3 id="D-1"><a href="#D-1" class="headerlink" title="D"></a>D</h3><p>和求 GCD 思路差不多的一道题. 首先考虑 $a = b$ 的情况, 直接判断 $a$ 和 $x$ 是否相等. 再令 $a &lt; b$, 并记答案为 $f(a,\ b)$, 枚举一些后继情况之后可以发现</p><script type="math/tex; mode=display">f(a,\ b) = \begin{cases}\text{true} & a \mid b - x \\ \text{false} & b < x\ \text{or}\ a = 0 \\ f(b \bmod a,\ a) & \text{otherwise} \end{cases}</script><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>对于信息 $j$, 如果学生 $i$ 满足 $m_i = j$, 那么对答案有贡献 $\frac{\min\{ k_i,\ t \}}{t}$. 注意到一个重要条件 $k_i \leq 20$. 首先考虑 $t &gt; 20$ 的情况, 容易发现该条件下 $t+1$ 时的答案一定小于 $t$ 时的答案. 于是从 $1$ 到 $20$ 枚举 $t$, 对于每一个 $t$ 选择对答案贡献最多的 $t$ 个信息就好了.</p><p>时间复杂度 $O(n + km\log m)$.</p><h2 id="Round-736-Div-2"><a href="#Round-736-Div-2" class="headerlink" title="Round #736 (Div. 2)"></a>Round #736 (Div. 2)</h2><h3 id="A-2"><a href="#A-2" class="headerlink" title="A"></a>A</h3><p>注意到 $P \geq 5$, 那么 $P - 1$ 一定是个偶数, 直接输出 $(P - 1) / 2$ 和 $P - 1$ 就好了.</p><h3 id="B-2"><a href="#B-2" class="headerlink" title="B"></a>B</h3><p>贪心, 让每个棋子的最终位置尽可能往一边靠就好了.</p><h2 id="Round-736-Div-1"><a href="#Round-736-Div-1" class="headerlink" title="Round #736 (Div. 1)"></a>Round #736 (Div. 1)</h2><h3 id="A-3"><a href="#A-3" class="headerlink" title="A"></a>A</h3><p>注意读题, 查询操作并不会改变图的结构, 所以不是模拟, 是分类讨论 = =</p><p>首先, 孤立的点, 以及编号大于所有相邻结点的点一定不会被删去. 其次, 对于一个结点 $u$, 如果存在相邻的点 $v$ 满足 $v &gt; u$, 那么 $u$ 最终一定被删去. 那么对一个结点 $u$ 记录相邻且编号大于 $u$ 的结点个数, 并依此维护答案就好了.</p><p>时间复杂度 $O(m + q)$.</p><h3 id="B-3"><a href="#B-3" class="headerlink" title="B"></a>B</h3><p>记 $d_i = a_i - a_{i - 1}$, 那么 $a_{L\ldots R}$ 是 friends group 的条件就是 $\gcd(d_{L + 1},\ \ldots,\ d_{R}) \geq 2$. 此时二分区间长度, 并维护区间 GCD 就好了. 可以用 ST 表或是线段树来实现.</p><p>如果用 ST 表, 那么时间复杂度为 $O(n \log n)$.</p><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;今天的 Codeforces 有在下饭吗?&lt;/p&gt;
&lt;p&gt;是原先在 &lt;a href=&quot;https://www.luogu.com.cn/blog/depletedprism/CF-short-sol&quot;&gt;洛谷的文章&lt;/a&gt; 的精神续作, 直接原因是受 &lt;a href=&quot;https://www.bilibili.com/video/BV1NX4y1A7B3&quot;&gt;某个学长的视频&lt;/a&gt; 的启发.&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>HAOI 2020 退役记</title>
    <link href="https://depletedprism.github.io/%E9%9A%8F%E7%AC%94/HAOI-2020/"/>
    <id>https://depletedprism.github.io/%E9%9A%8F%E7%AC%94/HAOI-2020/</id>
    <published>2020-06-21T10:37:33.000Z</published>
    <updated>2020-07-02T14:34:45.506Z</updated>
    
    <content type="html"><![CDATA[<hr><p>这就是, 路的尽头吗.</p><span id="more"></span><h2 id="Day-83"><a href="#Day-83" class="headerlink" title="Day -83"></a>Day -83</h2><div style="text-align:center;"><img src="/images/HAOI-2020/=.png" /> </div><p><em><p style="text-align:center;">图源网络, 进行了简单修改</p></em></p><p>省选未能如期举办, 我的青春结束了.</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h2><p>回家了.</p><p>网上有场 Codeforces Global Round 8, 然后… 然后我就去睡大觉了 (</p><div style="text-align:center;"><img src="/images/HAOI-2020/shuidajiao001.png" /> </div><p>今年 HA 省队均摊到一个学校至多有两个, 如果能进队那确实是运气因素. 无论是从校内竞争或者是校外, 都没有什么优势.</p><p>当然是不会买 D 类的, 看起来是真的要退役.</p><p>勉强 CSP-S 拿到一等之后, 还是打算去准备省选, 于是又停了课. 再次回到机房那天是 12 月 8 号, <del>为了翘掉学校的 12·8 大合唱</del> 去给高一讲了讲前缀和, 差分, 和树状数组什么的. 无论是高一学弟还是我, 唯一的收获就是明白了我确实没有讲课的天分.</p><p>接着停课直到今天, 也就是 6 月 18 日. 期间准备会考, 补充省选知识点, 做练习, 写往年省选套题, 断断续续的校内模拟赛, Codeforces, 也都成为了过往.</p><p>从一月初考完会考满怀希望回到学校, 逐渐看到 -OH 计划, 看到省选日期不断向后推迟, 看到各高校的招生简章, 大概内心中留存的希望, 也像回学校那天看到的落日, 沉到地平线以下去了.</p><p>学 OI 的初心是什么呢?</p><p>最开始得到 NOIP / NOI 的消息, 是在某个不知名的 C/C++ 教程网站上, 介绍 Dev-cpp 时提到的. 当时还在读初三, 虽然向往但清楚自己参与的希望渺茫. 之后中考结束, 在领取录取通知书时得到了参与 OI 的机会. 当年的 NOI 是本校近几年的最好成绩. 听完竞赛的讲座, 感觉自己在两年后, 也能成为其中一员: 能够学习自己感兴趣的内容, 并证明自己的实力.</p><p>在上初中的时候, 曾经写过一篇文章, 大概是讲自己做事常常没有成绩, 甚至半途而废, 并归咎于自己的专注力和投入不够, 并感到懊悔. 语文老师对此的评价是, 不要以功利化的心态, 太在意事情的结果, 而应该注重于事情的过程.</p><p>在如今充斥竞争的环境之下, 没有个人实力作为基础, 这种心态能立住脚的前提也就是逃避现实吧 (</p><p>此时做出怎样的决策, 也就因人而不同了.</p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>出去试机, 这次不是河工大了, 环境也好了许多.</p><p>键盘是标准键盘 (我就是在说 <kbd>Backspace</kbd>), 只是 Dev-cpp 在打开 / 新建文件时会 “Runtime ERROR” = = 还是用 MinGW 配合命令行走天下了. 可惜忘了 Windows 键盘映射怎么搞, 想翻以前的博客才发现网线直接被拔了… 又试了试对拍, 感觉还行.</p><p>看了看位置周围都是稳定进队爷, 最后结果可能是我周围一圈人全都进队然后我光荣退役?</p><p>坐在前面的 guyan 突然转向, 让我写个 MTT, LCT 什么的和他对拍, 人听傻了, 和 junble19768 跑路了.</p><p>准考证总算不是一张纸了, 看来可以胸牌退役了 (<del>胸牌作伴好还乡</del></p><h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>考试日.</p><p>看到一堆熟悉的人名, 可惜都不认识. 键盘映射又忘了, 老年选手预定.</p><p>看一眼发现 MinGW 里 gcc 版本比 NOI Linux 里的还老, cmd 又体验极差, 然后又把 Dev-cpp 装上了. (事后才想起来有 Powershell 可以用…</p><p><strong>8sNm5X91Thq=+35y</strong></p><p>开局看到 “组合数问题”, 脊背发凉. 感觉 T1, T2 挺可做, 后来就没有后来了.</p><p>写了写暴力. T2 白给 30 pts, T3 一脸暴力比正解难写的样子. 想了想 T1, 有点慌, 感觉做不出来就没了. 结果胡出来一个 $O(n \log ^ 2 x)$ 的做法, 写半天过了大样例.</p><p>想不出来线性做法, 算了算得分感觉不大行, T1 估计全场 100 pts, 我拿个 60 pts 有锤子用啊 = =</p><p>感觉 T1 标算会应该是线性, 多个 $\log$ 就不管了, 节约时间就没有拍. 中间有去做其他题. T2 感觉能用 Stirling 数把自然数幂干掉, 推了推却没有结果, 感觉是公式记错或者是方向之类的问题. T3 真就一点也不会, 没根据地糊点代码就溜了.</p><p>交完代码之后立刻发现 T2 限制中 $m = 0$ 就是二项式定理, 没时间写了, 又丢 10 pts, 快乐.</p><p>下考场, 不想找教练就直接回家了.</p><p>Day 1 期望得分: 60 + 30 + 0 = 90 pts.</p><p>参照最终结果, 倒不如把花在 T3 的时间用来给 T1 对拍 / 卡常, 或是想想更可做的 T2.</p><p>感觉 HA 的标准分大概在 150 pts 左右? 技不如人甘拜下风. 虽然不大有进省队的希望, 但还是打算给自己的竞赛生涯来个不遗憾的结尾吧.</p><p>本来想 vp 一场 Edu Round 练手, 结果 <del>到家就去做习题集了, 导数真好玩 (</del> 到家就开始颓废了.</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>考试日.</p><p>终于默写对键盘映射了. <del>Full Power Mode!</del></p><p><strong>Ybd906-sv?4tbqz2</strong></p><p>开局看题. 看完一遍之后会了 0 + 10 + 30, 感觉要翻盘大概 Day 2 要考 200+ pts?</p><p>看起来 T1 蛮可做的. 又看了一遍题之后发现自己读错题了… 写了个 $O(nm!)$ 的 30 pts 签到. 然后就不会了…</p><p>扫了眼 T2 数据范围, 似乎 $O(n ^ 2)$ 会输的很惨. 想了个 $O(n \log v)$ 逐位考虑的做法, 写出来后发现奥妙重重, 连样例都过不了.</p><p>T3 推了推式子就有 50 pts 了. 大概正解就是 Matrix-Tree 定理之类的东西?</p><p>Day 2 期望得分: 30 + 10 + 50 = 90 pts.</p><p>晚上回学校上晚自习, 去原来的班里找了个空位置就回机房了, 应该是在机房的最后一个晚自习了. <del>所以颓了一晚上</del>.</p><h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><p>回班了, 看周围人准备期末考试.</p><h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><p>晚自习的时候知道了成绩, FST 了 (</p><blockquote><p>不对拍就等于没有写.</p><p>—stdcall</p></blockquote><h2 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h2><p>端午放假.</p><p>回去看了看 D1T1 怎么挂的, 改了改结果 AC 了.</p><p>结果 AC 了.</p><p>$O(q \log ^ 2 x)$ AC 了, <del>好像明白自己是怎么退役的了.</del> 仔细算了算, D1T1 拍一下就可以最后一名进队了 (</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>学文化课比学 OI 在心态上平稳许多, 没有什么努力一通之后因为各种原因就一无所有的事情发生吧.</p><p><del>暗示自己高考将翻车, 实际上我把所有能决定自己人生轨迹的考试都考砸了 (</del></p><p>可能以后想到自己再无参与国赛的机会, 或者是在其他人问道 “你进省队了吗” 之类问题的时候, 会有一阵无法消去的无力感.</p><p>那才是心之所向啊.</p><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;这就是, 路的尽头吗.&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://depletedprism.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>CF321E Ciel and Gondolas 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/CF-321E/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/CF-321E/</id>
    <published>2020-06-15T07:42:44.000Z</published>
    <updated>2020-06-19T01:58:40.485Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://codeforces.com/problemset/problem/321/E">https://codeforces.com/problemset/problem/321/E</a></li><li><del><a href="https://m1.oi-archive.org:9000/problem/?oj=bzoj&amp;pid=5311">https://m1.oi-archive.org:9000/problem/?oj=bzoj&amp;pid=5311</a></del></li></ul><p>同时总结一些 DP 优化的方法.</p><span id="more"></span><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li>算法 0: 暴力 DP</li></ul><p>考虑 DP. 设 $f(i, j)$ 表示在前 $i$ 个人中, 选出 $j$ 个队伍的最小花费. 那么有转移</p><script type="math/tex; mode=display">f(i, j) = \min_{j - 1 \le k \le i - 1} \{ f(k, j - 1) + w(k + 1, i) \}</script><p>其中 $w(L, R)$ 表示选择 $[L,\ R]$ 作为一个队伍的花费, 可用利用二维前缀和在 $O(1)$ 的时间内计算. 具体地, 记 $s(i, j)$ 表示 $u$ 的二维前缀和, 那么 $w$ 可表示为</p><script type="math/tex; mode=display">w(L, R) = \frac{1}{2} \sum_{i = L} ^ R \sum_{j = L} ^ R u_{i, j} = \frac{1}{2} \big( s(R, R) - s(R, L - 1) - s(L - 1, R) + s(L - 1, L - 1) \big)</script><p>此时直接计算的时间复杂度为 $O(n ^ 2 k)$. 还有许多优化的空间.</p><ul><li>算法 1: 四边形不等式优化</li></ul><p>观察上面的转移, 对于一个固定的 $j$, 其余部分转移是 1D1D 的形式. 同时, 代价函数 $w$ 同 $j$ 无关, 且满足四边形不等式, 即</p><script type="math/tex; mode=display">\forall\ l_1 \le l_2 \le r_1 \le r_2,\ w(l_1, r_1) + w(l_2, r_2) \le w(l_1, r_2) + w(l_2, r_1)</script><p>如果交换 $f$ 两维的顺序 (也就是该部分的 $f(i, j)$ 在其他部分为 $f(j, i)$), 得到</p><script type="math/tex; mode=display">f(i, j) = \min_{i \le k \le j} \{ f(i - 1, k - 1) + w(k, j) \}</script><p>枚举 $i$, 每次计算 $f(i, j)$ 时 $f(i - 1, j)$ 的值都已确定, 利用决策单调性分治解决即可, 该部分的具体证明和实现可参考 <a href="https://oi-wiki.org/dp/opt/quadrangle/#1d1d">OI Wiki</a>.</p><p>时间复杂度 $O(nk \log n)$.</p><ul><li>算法 2: 凸优化</li></ul><p>考虑凸优化, 或者称之为 “wqs 二分” / 带权二分.</p><p>如果忽略分作 $k$ 组的限制, 设所分组数为 $x$, 对于每个 $x$, 其最小花费是关于 $x$ 的下凸函数. 证明可参考 <a href="https://www.cnblogs.com/Itst/p/12805678.html">Itst: 浅谈满足四边形不等式的序列划分问题的答案凸性</a>.</p><p>此时二分斜率 $s$, 对于剩下的问题, 设 $f(i)$ 表示前 $i$ 个人中, 任意选择组成队伍的个数时的最小花费. 则有转移</p><script type="math/tex; mode=display">f(i) = \min_{1 < j \le i} \{ f(j - 1) + w(j, i) + s \}</script><p>同时要记录选出队伍组数以在二分时确定改变斜率的范围.</p><p>朴素 DP 的时间复杂度为 $O(n ^ 2 \log w)$, 显得有些鸡肋.</p><p>但内层的 DP 还是可以优化的. 实际上, 在 $i$ 一定时, 代价函数 $w$ 关于 $j$ 单调递增, 体现在 $f(i)$ 关于 $i$ 的图像上即为下凸包.</p><p>此时维护凸包即可. 在枚举 $i$ 的过程中, 在 $i$ 之前的凸包上的点没有意义, 直接删去. 那么利用双端队列维护凸包. 在向凸包中加入一个点时, 需要二分出其加入的位置, 因此要记录凸包中每一条边两端点所在位置.</p><p>维护凸包的操作体现在决策中就是 “决策点会向后更新一段连续的区间”.</p><p>时间复杂度 $O(n \log n \log w)$, 其中 $w$ 表示斜率最大值和最小值之差.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li>算法 0</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CF321E</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a &gt; b)? a = b, <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">4e3</span> + <span class="number">5</span>, MAXK = <span class="number">8e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K;</span><br><span class="line"><span class="keyword">int</span> A[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">w</span><span class="params">(<span class="keyword">int</span> r1, <span class="keyword">int</span> c1, <span class="keyword">int</span> r2, <span class="keyword">int</span> c2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (A[r2][c2] - A[r2][c1 - <span class="number">1</span>] - A[r1 - <span class="number">1</span>][c2] + A[r1 - <span class="number">1</span>][c1 - <span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">w</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">w</span>(L, L, R, R); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">read</span>(n), <span class="built_in">read</span>(K);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">      <span class="built_in">read</span>(A[i][j]), A[i][j] += A[i - <span class="number">1</span>][j] + A[i][j - <span class="number">1</span>] - A[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">memset</span>(f[i], <span class="number">0x3f</span>, (K + <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">int</span>));</span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = j - <span class="number">1</span>; k &lt;= i - <span class="number">1</span>; ++k)</span><br><span class="line">        <span class="built_in">ckmin</span>(f[i][j], f[k][j - <span class="number">1</span>] + <span class="built_in">w</span>(k + <span class="number">1</span>, i));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][K]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>算法 1</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CF321E</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a &gt; b)? a = b, <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">4e3</span> + <span class="number">5</span>, MAXK = <span class="number">8e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K;</span><br><span class="line"><span class="keyword">int</span> A[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">w</span><span class="params">(<span class="keyword">int</span> r1, <span class="keyword">int</span> c1, <span class="keyword">int</span> r2, <span class="keyword">int</span> c2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> A[r2][c2] - A[r2][c1 - <span class="number">1</span>] - A[r1 - <span class="number">1</span>][c2] + A[r1 - <span class="number">1</span>][c1 - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">w</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">w</span>(L, L, R, R) / <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>* h, <span class="keyword">const</span> <span class="keyword">int</span>* g, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> kl, <span class="keyword">int</span> kr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, k = kl;</span><br><span class="line">  h[Mid] = g[k - <span class="number">1</span>] + <span class="built_in">w</span>(k, Mid);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = kl + <span class="number">1</span>; i &lt;= <span class="built_in">min</span>(kr, Mid); ++i)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ckmin</span>(h[Mid], g[i - <span class="number">1</span>] + <span class="built_in">w</span>(i, Mid))) k = i;</span><br><span class="line">  <span class="keyword">if</span> (L &lt; Mid) <span class="built_in">solve</span>(h, g, L, Mid - <span class="number">1</span>, kl, k);</span><br><span class="line">  <span class="keyword">if</span> (R &gt; Mid) <span class="built_in">solve</span>(h, g, Mid + <span class="number">1</span>, R, k, kr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">read</span>(n), <span class="built_in">read</span>(K);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">      <span class="built_in">read</span>(A[i][j]), A[i][j] += A[i - <span class="number">1</span>][j] + A[i][j - <span class="number">1</span>] - A[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= K; ++i)</span><br><span class="line">    <span class="built_in">memset</span>(f[i], <span class="number">0x3f</span>, (n + <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">int</span>));</span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i)</span><br><span class="line">    <span class="built_in">solve</span>(f[i], f[i - <span class="number">1</span>], <span class="number">1</span>, n, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[K][n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>算法 2</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CF321E</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (b &lt; a)? a = b, <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">4e3</span> + <span class="number">5</span>, MAXK = <span class="number">8e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K;</span><br><span class="line"><span class="keyword">int</span> A[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, c;</span><br><span class="line">  <span class="built_in">Item</span>() &#123; v = c = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="built_in">Item</span>(<span class="keyword">int</span> _v, <span class="keyword">int</span> _c): <span class="built_in">v</span>(_v), <span class="built_in">c</span>(_c) &#123; &#125;</span><br><span class="line">  Item <span class="keyword">operator</span> + (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Item</span>(v + rhs.v, c + rhs.c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v &lt; rhs.v || (v == rhs.v &amp;&amp; c &lt; rhs.c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(rhs &lt; *<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Que</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> p, L, R;</span><br><span class="line">  <span class="built_in">Que</span>() &#123; p = L = R = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="built_in">Que</span>(<span class="keyword">int</span> _p, <span class="keyword">int</span> _L, <span class="keyword">int</span> _R): <span class="built_in">p</span>(_p), <span class="built_in">L</span>(_L), <span class="built_in">R</span>(_R) &#123; &#125;</span><br><span class="line">&#125; Q[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Item <span class="title">F</span><span class="params">(<span class="keyword">int</span> j, <span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">// 1 &lt;= j &lt; i</span></span><br><span class="line">  <span class="keyword">return</span> f[j] + <span class="built_in">Item</span>((A[i][i] + A[j][j] - <span class="number">2</span> * A[i][j]) / <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line">  Q[++tail] = <span class="built_in">Que</span>(<span class="number">0</span>, <span class="number">1</span>, n), f[<span class="number">0</span>] = <span class="built_in">Item</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail &amp;&amp; Q[head].R &lt; i) ++head;</span><br><span class="line">    <span class="keyword">int</span> p = Q[head].p;</span><br><span class="line">    Q[head].L = i, f[i] = <span class="built_in">Item</span>(<span class="built_in">F</span>(p, i).v + s, f[p].c + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (head &gt; tail)</span><br><span class="line">      Q[++tail] = <span class="built_in">Que</span>(i, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">F</span>(i, n) &lt;= <span class="built_in">F</span>(p, n)) &#123;</span><br><span class="line">      <span class="keyword">while</span> (head &lt;= tail &amp;&amp; <span class="built_in">F</span>(i, Q[tail].L) &lt;= <span class="built_in">F</span>(Q[tail].p, Q[tail].L))</span><br><span class="line">        --tail;</span><br><span class="line">      <span class="keyword">int</span> L = Q[tail].L, R = Q[tail].R; p = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">F</span>(i, Mid) &lt;= <span class="built_in">F</span>(Q[tail].p, Mid)) R = Mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> L = Mid + <span class="number">1</span>, p = Mid;</span><br><span class="line">      &#125;</span><br><span class="line">      Q[tail].R = p;</span><br><span class="line">      <span class="keyword">if</span> (p + <span class="number">1</span> &lt;= n) Q[++tail] = <span class="built_in">Que</span>(i, p + <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[n].c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">read</span>(n), <span class="built_in">read</span>(K);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">      <span class="built_in">read</span>(A[i][j]), A[i][j] += A[i - <span class="number">1</span>][j] + A[i][j - <span class="number">1</span>] - A[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> L = <span class="number">0</span>, R = A[n][n], ans = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">solve</span>(Mid) &lt;= K)</span><br><span class="line">      ans = f[n].v - K * Mid, R = Mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> L = Mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>OI Wiki, <a href="https://oi-wiki.org/dp/opt/quadrangle/">四边形不等式优化</a>.</li><li>Itst, <a href="https://www.cnblogs.com/Itst/p/12805678.html">浅谈满足四边形不等式的序列划分问题的答案凸性</a></li><li>T_Y_P_E, <a href="https://www.cnblogs.com/T-Y-P-E/p/10217028.html#%E4%BB%A3%E7%A0%81">【Codeforces 321E / BZOJ 5311】【DP凸优化】【单调队列】贞鱼</a>.</li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h4 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/321/E&quot;&gt;https://codeforces.com/problemset/problem/321/E&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href=&quot;https://m1.oi-archive.org:9000/problem/?oj=bzoj&amp;amp;pid=5311&quot;&gt;https://m1.oi-archive.org:9000/problem/?oj=bzoj&amp;amp;pid=5311&lt;/a&gt;&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同时总结一些 DP 优化的方法.&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="Dynamic Programming" scheme="https://depletedprism.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>一些简单的模拟费用流问题</title>
    <link href="https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/simulated-flow/"/>
    <id>https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/simulated-flow/</id>
    <published>2020-06-06T05:28:55.000Z</published>
    <updated>2020-06-11T06:49:06.917Z</updated>
    
    <content type="html"><![CDATA[<hr><p>祝贺我又学了一个学不明白的东西 (</p><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>模拟费用流, 大概是利用流的一些性质, 从而用数据结构高效模拟费用流.</p><p>基础理论和模型可以看看文末的参考资料, 这里只是记录我做过的一些题目.</p><span id="more"></span><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>题目顺序随心情.</p><hr><p>首先是一些 “模拟” 费用流的例子.</p><h3 id="CF280D-k-Maximum-Subsequence-Sum"><a href="#CF280D-k-Maximum-Subsequence-Sum" class="headerlink" title="CF280D k-Maximum Subsequence Sum"></a>CF280D k-Maximum Subsequence Sum</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://codeforces.com/problemset/problem/280/D">https://codeforces.com/problemset/problem/280/D</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先有一个费用流做法. 设源汇点 $S$, $T$, 同时将每个位置拆为入点 $i$ 和出点 $i’$.</p><ol><li>连边 $(S, S’)$, 容量为 $k$, 费用为 $0$.</li><li>连边 $(S’, i)$, 容量为 $1$, 费用为 $0$.</li><li>连边 $(i, i’)$, 容量为 $1$, 费用为 $a_i$.</li><li>连边 $(i’, i + 1)$, 容量为 $1$, 费用为 $0$.</li><li>连边 $(i’, T)$, 容量为 $1$, 费用为 $0$.</li></ol><p>此时将费用取反, 求最小费用流即可. 可惜时间复杂度不够优秀.</p><p>注意到每次增广的过程, 本质上是选择序列一段区间中的最大连续子段和, 直接用线段树维护即可.</p><p>同时需要维护反向边, 也就是将该区间翻转并将权值取反. 那么记录子段和时需记录该子段对应区间端点, 以及最小子段和, 用于权值取反后快速计算现有区间最大子段和. 这样区间取反可打标记维护.</p><p>根据这个思路, 单点修改就没什么意思了. 注意每组询问直接独立, 在区间取反后需要撤销影响.</p><p>时间复杂度 $O(n \log n)$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CF280D</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>, MAXM = MAXN &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, top;</span><br><span class="line"><span class="keyword">int</span> A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> L, R, v;</span><br><span class="line">  <span class="built_in">Item</span>() &#123; L = MAXN, R = -MAXN, v = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="built_in">Item</span>(<span class="keyword">int</span> _L, <span class="keyword">int</span> _R, <span class="keyword">int</span> _v): <span class="built_in">L</span>(_L), <span class="built_in">R</span>(_R), <span class="built_in">v</span>(_v) &#123; &#125;</span><br><span class="line">  Item <span class="keyword">operator</span> + (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Item</span>(<span class="built_in">min</span>(L, rhs.L), <span class="built_in">max</span>(R, rhs.R), v + rhs.v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v &lt; rhs.v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; stk[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (nd &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (nd &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Item s, MxL, MxR, MxM, MnL, MnR, MnM;</span><br><span class="line">    <span class="built_in">Node</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">Node</span>(Item v) &#123; s = MxL = MxR = MxM = MnL = MnR = MnM = v; &#125;</span><br><span class="line">    Node <span class="keyword">operator</span> + (<span class="keyword">const</span> Node&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">      Node ret;</span><br><span class="line">      ret.s = s + rhs.s;</span><br><span class="line"></span><br><span class="line">      ret.MxL = <span class="built_in">max</span>(MxL, s + rhs.MxL);</span><br><span class="line">      ret.MxR = <span class="built_in">max</span>(rhs.MxR, rhs.s + MxR);</span><br><span class="line">      ret.MxM = <span class="built_in">max</span>(MxR + rhs.MxL, <span class="built_in">max</span>(MxM, rhs.MxM));</span><br><span class="line"></span><br><span class="line">      ret.MnL = <span class="built_in">min</span>(MnL, s + rhs.MnL);</span><br><span class="line">      ret.MnR = <span class="built_in">min</span>(rhs.MnR, rhs.s + MnR);</span><br><span class="line">      ret.MnM = <span class="built_in">min</span>(MnR + rhs.MnL, <span class="built_in">min</span>(MnM, rhs.MnM));</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; dat[MAXM];</span><br><span class="line">  <span class="keyword">bool</span> res[MAXM];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123; dat[nd] = dat[lc] + dat[rc]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(dat[nd].MxM, dat[nd].MnM);</span><br><span class="line">    <span class="built_in">swap</span>(dat[nd].MxL, dat[nd].MnL), <span class="built_in">swap</span>(dat[nd].MxR, dat[nd].MnR);</span><br><span class="line">    dat[nd].s.v *= <span class="number">-1</span>;</span><br><span class="line">    dat[nd].MxL.v *= <span class="number">-1</span>, dat[nd].MxR.v *= <span class="number">-1</span>, dat[nd].MxM.v *= <span class="number">-1</span>;</span><br><span class="line">    dat[nd].MnL.v *= <span class="number">-1</span>, dat[nd].MnR.v *= <span class="number">-1</span>, dat[nd].MnM.v *= <span class="number">-1</span>;</span><br><span class="line">    res[nd] ^= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (res[nd]) <span class="built_in">push</span>(lc), <span class="built_in">push</span>(rc), res[nd] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>( dat[nd] = <span class="built_in">Item</span>(L, R, A[L]) );</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc, L, Mid), <span class="built_in">build</span>(rc, Mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">maintain</span>(nd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Rev</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> <span class="built_in">push</span>(nd);</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(nd);</span><br><span class="line">    <span class="keyword">if</span> (opL &lt;= Mid) <span class="built_in">Rev</span>(lc, L, Mid, opL, opR);</span><br><span class="line">    <span class="keyword">if</span> (opR &gt; Mid) <span class="built_in">Rev</span>(rc, Mid + <span class="number">1</span>, R, opL, opR);</span><br><span class="line">    <span class="built_in">maintain</span>(nd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; p, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>( dat[nd] = <span class="built_in">Item</span>(L, R, v) );</span><br><span class="line">    <span class="built_in">pushdown</span>(nd);</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= Mid) <span class="built_in">Mdy</span>(lc, L, Mid, p, v); <span class="keyword">else</span> <span class="built_in">Mdy</span>(rc, Mid + <span class="number">1</span>, R, p, v);</span><br><span class="line">    <span class="built_in">maintain</span>(nd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Node <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> dat[nd];</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(nd);</span><br><span class="line">    <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> <span class="built_in">Qry</span>(lc, L, Mid, opL, opR);</span><br><span class="line">    <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> <span class="built_in">Qry</span>(rc, Mid + <span class="number">1</span>, R, opL, opR);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Qry</span>(lc, L, Mid, opL, opR) + <span class="built_in">Qry</span>(rc, Mid + <span class="number">1</span>, R, opL, opR);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">read</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(A[i]);</span><br><span class="line"></span><br><span class="line">  SGT::<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">read</span>(q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> opt, L, R, k, ans; q; --q) &#123;</span><br><span class="line">    <span class="built_in">read</span>(opt), <span class="built_in">read</span>(L);</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (opt) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">read</span>(k), SGT::<span class="built_in">Mdy</span>(<span class="number">1</span>, <span class="number">1</span>, n, L, k);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">read</span>(R), <span class="built_in">read</span>(k), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">          Item v = SGT::<span class="built_in">Qry</span>(<span class="number">1</span>, <span class="number">1</span>, n, L, R).MxM;</span><br><span class="line">          <span class="keyword">if</span> (v.v &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">          ans += v.v, SGT::<span class="built_in">Rev</span>(<span class="number">1</span>, <span class="number">1</span>, n, v.L, v.R), stk[++top] = v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          Item v = stk[top--];</span><br><span class="line">          SGT::<span class="built_in">Rev</span>(<span class="number">1</span>, <span class="number">1</span>, n, v.L, v.R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>: <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ERR\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="Luogu-P6122「NEERC2016」Mole-Tunnels"><a href="#Luogu-P6122「NEERC2016」Mole-Tunnels" class="headerlink" title="Luogu P6122「NEERC2016」Mole Tunnels"></a>Luogu P6122「NEERC2016」Mole Tunnels</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://www.luogu.com.cn/problem/P6122">https://www.luogu.com.cn/problem/P6122</a></li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先有一个费用流思路. 设源汇点分别为 $S$, $T$, 将每只鼹鼠视作流量.</p><ol><li>对于树上每条边, 连边 $(u, \lfloor \frac{u}{2} \rfloor)$, $(\lfloor \frac{u}{2} \rfloor, u)$, 容量为 $\infty$, 费用为 $1$.</li><li>对于树上每个点 $u$, 连边 $(u, T)$, 容量为 $c_u$, 费用为 $0$.</li><li>对于每只鼹鼠, 依次向其树上所在位置 $u$ 连边 $(S, u)$, 容量为 $1$, 费用为 $0$.</li></ol><p>观察每次增广的过程, 都是选择树上一条路径, 为保证费用尽量小, 显然是在要求路径尽量短.</p><p>考虑到题中给定树为二叉树, 其深度为 $O(\log n)$. 枚举新增鼹鼠位置 $s$ 和最终匹配位置的 LCA $t$. 同时对每个节点 $u$ 记录位置 $p(u)$, 表示 $u$ 子树内同 $u$ 匹配的最优位置.</p><p>此时增广的路径即 $s \rightarrow t \rightarrow {p}(t)$, 更新流量计算费用即可.</p><p>${p}(u)$ 可从下向上递推计算. 另外需记录树边中的流量. 为了便于计算路径费用, 将连向祖先的流量视作正数, 相反则视作负数.</p><p>时间复杂度 $O(n \log n)$.</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P6122</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a &gt; b)? a = b, <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> C[MAXN], flow[MAXN], d[MAXN], p[MAXN];</span><br><span class="line"><span class="comment">// flow: u --&gt; pre(u) 流量, d: u --&gt; 匹配位置 距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">augment</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> lc = u &lt;&lt; <span class="number">1</span>, rc = u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">  d[u] = INF, p[u] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (C[u] &gt; <span class="number">0</span>) d[u] = <span class="number">0</span>, p[u] = u;</span><br><span class="line">  <span class="keyword">if</span> (lc &lt;= n &amp;&amp; <span class="built_in">ckmin</span>(d[u], d[lc] + ((flow[lc] &gt; <span class="number">0</span>)? <span class="number">-1</span>: <span class="number">1</span>)))</span><br><span class="line">    p[u] = p[lc];</span><br><span class="line">  <span class="keyword">if</span> (rc &lt;= n &amp;&amp; <span class="built_in">ckmin</span>(d[u], d[rc] + ((flow[rc] &gt; <span class="number">0</span>)? <span class="number">-1</span>: <span class="number">1</span>)))</span><br><span class="line">    p[u] = p[rc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, C + i);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> u = n; u; --u) <span class="built_in">augment</span>(u);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k) &#123;</span><br><span class="line">    <span class="keyword">int</span> s, t = <span class="number">0</span>, cost = INF, ds = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = s; u &gt; <span class="number">0</span>; u /= <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ckmin</span>(cost, ds + d[u])) t = u;</span><br><span class="line">      ds += ((flow[u] &lt; <span class="number">0</span>)? <span class="number">-1</span>: <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ans += cost;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = s; u != t; u /= <span class="number">2</span>) ++flow[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = p[t]; u != t; u /= <span class="number">2</span>) --flow[u];</span><br><span class="line">    --C[p[t]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = p[t]; u != t; u /= <span class="number">2</span>) <span class="built_in">augment</span>(u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = s; u &gt; <span class="number">0</span>; u /= <span class="number">2</span>) <span class="built_in">augment</span>(u);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, ans, <span class="string">&quot; \n&quot;</span>[k == m]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="HDU-6634「2019-Multi-University-Training-Contest」Salty-fish"><a href="#HDU-6634「2019-Multi-University-Training-Contest」Salty-fish" class="headerlink" title="HDU 6634「2019 Multi-University Training Contest」Salty fish"></a>HDU 6634「2019 Multi-University Training Contest」Salty fish</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6634">http://acm.hdu.edu.cn/showproblem.php?pid=6634</a></li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>考虑最大权闭合子图的建图方式. 设源汇点分别为 $S$, $T$.</p><ol><li>对于树上每个节点 $i$, 连边 $(S, i)$, 容量为 $a_i$.</li><li>对于每个摄像头 $j$, 连边 $(j, T)$, 容量为 $c_j$.</li><li>对于摄像头 $j$, 若节点 $i$ 在 $j$ 的监控范围内, 连边 $(i, j)$, 容量为 $\infty$.</li></ol><p>此时答案为 $\sum {a_i} - \text{mincut}$.</p><p>根据最大流-最小割定理, 我们只需要计算出网络的最大流即可. 对于节点 $i$, 其流量一定流向能够监控到 $i$ 的, 且深度尽量小的摄像头. 因为深度大的摄像头更可能监控到深度大的节点. 换言之, 每个摄像头一定选择其范围内深度尽量大的节点.</p><p>那么我们可以对每个节点 $u$, 记录 $f(u, i)$ 表示 $u$ 子树内, 同根节点距离为 $i$ 节点的 $a$ 之和. 由深度从大到小的顺序选择每个摄像头, 从满足要求的最大深度开始向前推进, 更新流量和答案即可.</p><p>注意到 $f(u, i)$ 和深度有关, 可利用长链剖分维护. 此时需要在一个数组中快速修改 / 删除 / 加入一个数, 用 <code>map</code> 维护 $f(u, i)$ 就好了. <del>当然也可以写线段树合并.</del></p><p>时间复杂度 $O\big((n + m) \log n\big)$.</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HDU 6634</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> map&lt;<span class="keyword">int</span>, LL&gt;::iterator IT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> pre[MAXN], A[MAXN], K[MAXN], C[MAXN];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; P[MAXN];</span><br><span class="line"></span><br><span class="line">LL ans;</span><br><span class="line"><span class="keyword">int</span> Idx[MAXN], idx;</span><br><span class="line">map&lt;<span class="keyword">int</span>, LL&gt; M[MAXN]; <span class="comment">// depth, flow</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> depth[MAXN], d[MAXN], son[MAXN];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    d[u] = <span class="number">1</span>, son[u] = <span class="number">-1</span>;</span><br><span class="line">    depth[u] = depth[pre[u]] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">      <span class="built_in">dfs</span>(v = edges[i].to);</span><br><span class="line">      <span class="keyword">if</span> (son[u] == <span class="number">-1</span> || d[son[u]] &lt; d[v])</span><br><span class="line">        son[u] = v, d[u] = d[v] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Idx[u] = (~son[u])? Idx[son[u]]: ++idx;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, LL&gt;&amp; f = M[Idx[u]];</span><br><span class="line">    f[depth[u]] += A[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((v = edges[i].to) == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span> (IT ite = M[Idx[v]].<span class="built_in">begin</span>(); ite != M[Idx[v]].<span class="built_in">end</span>(); ++ite)</span><br><span class="line">        f[ite-&gt;first] += ite-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> k = <span class="number">0</span>; k &lt; P[u].<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span>&amp; i = P[u][k];</span><br><span class="line">      IT ite = f.<span class="built_in">upper_bound</span>(depth[u] + K[i]);</span><br><span class="line">      <span class="keyword">if</span> (ite == f.<span class="built_in">begin</span>()) <span class="keyword">continue</span>;</span><br><span class="line">      --ite;</span><br><span class="line">      <span class="keyword">while</span> (C[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        LL w = <span class="built_in">min</span>((LL) C[i], ite-&gt;second);</span><br><span class="line">        ite-&gt;second -= w, C[i] -= w, ans -= w;</span><br><span class="line">        <span class="keyword">if</span> (ite-&gt;second &gt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (ite == f.<span class="built_in">begin</span>()) &#123; f.<span class="built_in">erase</span>(ite); <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> dep = ite-&gt;first;</span><br><span class="line">        --ite, f.<span class="built_in">erase</span>(dep);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> Ti;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Ti);</span><br><span class="line">  <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) P[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= idx; ++i) M[i].<span class="built_in">clear</span>();</span><br><span class="line">    ans = idx = <span class="number">0</span>, Graph::<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, pre + i), Graph::<span class="built_in">AddEdge</span>(pre[i], i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, A + i), ans += A[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, K + i, C + i), P[u].<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">    Graph::<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="UOJ-318「NOI2017」蔬菜"><a href="#UOJ-318「NOI2017」蔬菜" class="headerlink" title="UOJ #318「NOI2017」蔬菜"></a>UOJ #318「NOI2017」蔬菜</h3><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://uoj.ac/problem/318">https://uoj.ac/problem/318</a></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先有一个朴素的网络流思路. 设源汇点分别为 $S$, $T$, 同时将每天视作一个节点, 记 $p$ 为最大天数.</p><ol><li>对于每个蔬菜 $i$, 记其最大售卖天数 $k$ 为 $\min\{ p, \lceil \frac{c_i}{x_i} \rceil \}$.<ul><li>向第 $1 \sim k - 1$ 天依次连边, 容量为 $x_i$, 费用为 $a_i$.</li><li>向第 $k$ 天连边, 容量为 $c_i - k x_i - 1$, 费用为 $a_i$.</li><li>向第 $k$ 天连边, 容量为 $1$, 费用为 $a_i + s_i$</li></ul></li><li>对于第 $i$ 天<ul><li>连边 $(i, i - 1)$, 容量为 $\infty$, 费用为 $0$.</li><li>连边 $(i, T)$, 容量为 $m$, 费用为 $0$.</li></ul></li></ol><p>观察每次增广时的情况. 在天数不断增加时, 原有流量改变一定不优, 否则在前一天可改变流量使得前一天答案更优. 也就是说, 第 $i$ 天售出的蔬菜一定是第 $i + 1$ 天售出蔬菜的一部分, 且网络中不存在退流.</p><p>同时, 注意到天数对应点之间的连边, 对于每个蔬菜, 尽量选择靠后天数是更优秀的. 从建图解释, 选择靠后天数可通过容量为 $\infty$ 的边增广. 从实际意义解释, 将蔬菜尽量放在快过期的时候卖出更优. 同时要选择权值尽量大的蔬菜卖出.</p><p>那么用堆维护当前可选的蔬菜, 每天的销售情况视作增广 $m$ 的流量, 选择权值最大的蔬菜即可. 同时需要知道当前天对应节点在向 $T$ 的边满流之后, 向前增广的位置. 可以利用并查集维护.</p><p>时间复杂度 $O(n \log n + pm\log n)$.</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UOJ #318</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], X[MAXN], S[MAXN], C[MAXN], Q[MAXN];</span><br><span class="line"></span><br><span class="line">LL Ans[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> idx, v;</span><br><span class="line">  <span class="built_in">Item</span>(<span class="keyword">int</span> _i, <span class="keyword">int</span> _v): <span class="built_in">idx</span>(_i), <span class="built_in">v</span>(_v) &#123; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v &lt; rhs.v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Item&gt; PQ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DSU &#123;</span><br><span class="line">  <span class="keyword">int</span> fa[MAXN];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= _n; ++i) fa[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findfa</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fa[u] == u)? u: fa[u] = <span class="built_in">findfa</span>(fa[u]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;data/ex_vegetables3.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">read</span>(n), <span class="built_in">read</span>(m), <span class="built_in">read</span>(q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">read</span>(A[i]), <span class="built_in">read</span>(S[i]), <span class="built_in">read</span>(C[i]), <span class="built_in">read</span>(X[i]);</span><br><span class="line">  <span class="keyword">int</span> Mx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">    <span class="built_in">read</span>(Q[i]), Mx = <span class="built_in">max</span>(Mx, Q[i]);</span><br><span class="line"></span><br><span class="line">  DSU::<span class="built_in">init</span>(Mx);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    PQ.<span class="built_in">push</span>(<span class="built_in">Item</span>(i, A[i] + S[i]));</span><br><span class="line"></span><br><span class="line">  LL ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>; p &lt;= Mx; ++p) &#123;</span><br><span class="line">    <span class="keyword">int</span> flow = m;</span><br><span class="line">    <span class="keyword">while</span> (flow &gt; <span class="number">0</span> &amp;&amp; !PQ.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">int</span> i = PQ.<span class="built_in">top</span>().idx, v = PQ.<span class="built_in">top</span>().v; PQ.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">int</span> k = (X[i] == <span class="number">0</span>)? Mx: <span class="built_in">min</span>(Mx, (C[i] + X[i] - <span class="number">1</span>) / X[i]);</span><br><span class="line">      k = DSU::<span class="built_in">findfa</span>(k);</span><br><span class="line">      <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      ++cnt[k];</span><br><span class="line">      <span class="keyword">if</span> (cnt[k] == m) DSU::fa[k] = DSU::<span class="built_in">findfa</span>(k - <span class="number">1</span>);</span><br><span class="line">      --flow, --C[i], ans += v;</span><br><span class="line">      <span class="keyword">if</span> (C[i] &gt; <span class="number">0</span>) PQ.<span class="built_in">push</span>(<span class="built_in">Item</span>(i, A[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    Ans[p] = ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, Ans[Q[i]]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="UOJ-480「NOI2019」序列"><a href="#UOJ-480「NOI2019」序列" class="headerlink" title="UOJ #480「NOI2019」序列"></a>UOJ #480「NOI2019」序列</h3><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://uoj.ac/problem/480">https://uoj.ac/problem/480</a></li></ul><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先有一个朴素的费用流思路. 设源汇点分别为 $S$, $T$, 对两序列的每个位置分别建点 $i$, $i’$.</p><ol><li>新建节点 $S’$, 连边 $(S, S’)$, 容量为 $K$, 费用为 $0$.</li><li>对于序列的每个位置 $i$, 连边<ul><li>$(S, i)$, 容量为 $1$, 费用为 $a_i$.</li><li>$(S, i’)$, 容量为 $1$, 费用为 $b_i$.</li><li>$(i, i’)$, 容量为 $1$, 费用为 $0$.</li></ul></li><li>新建节点 $C$, $D$. 用于描述 “至少有 $L$ 个下标在两个序列中都被指定” 的限制.<ul><li>连边 $(C, D)$, 容量为 $K - L$, 费用为 $0$.</li><li>对于每个位置 $i$, 连边 $(i, C)$, $(D, i’)$, 容量为 $1$, 费用为 $0$.</li></ul></li></ol><p>现在考虑如何模拟该费用流.</p><p>存在至多 $K - L$ 个位置不受在两个序列中都被指定的限制. 此时一定先选择 $a_i$, $b_i$ 中权值大的位置, 体现在网络中即边 $(C, D)$ 满流.</p><p>现在还剩下 $L$ 个位置需要选择, 即剩下 $L$ 的流量需要增广. 记录每个位置 $i$ 被选择的情况 $f_i$, 其二进制第 $0$ 位表示 $a_i$ 是否被选择, 或是边 $(S, i)$ 的流量. 第 $1$ 位则表示 $b_i$ 的情况.</p><p>为使总权值最大, 每次需要选择权值尽量大的位置. 那么利用数个大根堆 (<code>r0</code>, <code>r1</code>, <code>r</code>), 分别维护恰在序列 $a_i$ (<code>r0</code>) 或 $b_i$ (<code>r1</code>) 中没有选择的位置, 以及都没有选择的位置 (<code>r</code>). 对于前两种情况, 在选择位置时需要另一序列某一元素配对, 再利用两个堆 (<code>p0</code>, <code>p1</code>) 记录可配对的位置.</p><p>首先单独考虑 $f_i = 3$ 的情况, 此时简直是理想状态, 满足权值尽量大的同时也满足了限制.</p><p>为使总权值尽量大, 则需要将边 $(C, D)$ 的某个流量改流在形同 $(i, i’)$ 的边上. 那么记录此种情况的流量总数 <code>flow</code>, 在允许此种增广时选择一组流经 $(C, D)$ 的流量即可. 也就是在 <code>r0</code>, <code>r1</code> 中选择两个元素.</p><p>剩下的情况无外乎 $f_i$ 为 $0, 1, 2$. 根据其特性选择增广路, 也就是不同的位置匹配, 记录其权值并取权值最大的情况即可.</p><p>细节可能有些多, 还是建议想清楚之后再动键盘. 注意要根据 $f_i$ 的取值删除堆中的不合法元素, 以及及时更新 $f_i$ 和 <code>flow</code>.</p><p>时间复杂度 $O(T \cdot n \log n)$.</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UOJ #480</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K, L;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ItemA</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> idx;</span><br><span class="line">  <span class="built_in">ItemA</span>(<span class="keyword">int</span> _i): <span class="built_in">idx</span>(_i) &#123; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> ItemA&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> A[idx] &lt; A[rhs.idx];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ItemB</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> idx;</span><br><span class="line">  <span class="built_in">ItemB</span>(<span class="keyword">int</span> _i): <span class="built_in">idx</span>(_i) &#123; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> ItemB&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> B[idx] &lt; B[rhs.idx];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ItemAB</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> idx;</span><br><span class="line">  <span class="built_in">ItemAB</span>(<span class="keyword">int</span> _i): <span class="built_in">idx</span>(_i) &#123; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> ItemAB&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> A[idx] + B[idx] &lt; A[rhs.idx] + B[rhs.idx];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> idx[MAXN], f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;data/ex_sequence3.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> Ti; <span class="built_in">read</span>(Ti);</span><br><span class="line">  <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(K), <span class="built_in">read</span>(L);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(B[i]);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;ItemA&gt; r0, p0;</span><br><span class="line">    priority_queue&lt;ItemB&gt; r1, p1;</span><br><span class="line">    priority_queue&lt;ItemAB&gt; r;</span><br><span class="line"></span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = <span class="number">0</span>, idx[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(idx + <span class="number">1</span>, idx + <span class="number">1</span> + n, [](<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y) &#123;</span><br><span class="line">        <span class="keyword">return</span> A[x] &gt; A[y];</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K - L; ++i)</span><br><span class="line">      ans += A[idx[i]], f[idx[i]] |= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(idx + <span class="number">1</span>, idx + <span class="number">1</span> + n, [](<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y) &#123;</span><br><span class="line">        <span class="keyword">return</span> B[x] &gt; B[y];</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K - L; ++i)</span><br><span class="line">      ans += B[idx[i]], f[idx[i]] |= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="built_in"><span class="keyword">switch</span></span> (f[i]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: r0.<span class="built_in">push</span>(i), r1.<span class="built_in">push</span>(i), r.<span class="built_in">push</span>(i); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: r1.<span class="built_in">push</span>(i), p1.<span class="built_in">push</span>(i); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: r0.<span class="built_in">push</span>(i), p0.<span class="built_in">push</span>(i); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: ++flow; <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (L--) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!r.<span class="built_in">empty</span>() &amp;&amp; f[r.<span class="built_in">top</span>().idx] &gt; <span class="number">0</span>) r.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">while</span> (!r0.<span class="built_in">empty</span>() &amp;&amp; (f[r0.<span class="built_in">top</span>().idx] &amp; <span class="number">1</span>)) r0.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">while</span> (!p0.<span class="built_in">empty</span>() &amp;&amp; (f[p0.<span class="built_in">top</span>().idx] ^ <span class="number">2</span>)) p0.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">while</span> (!r1.<span class="built_in">empty</span>() &amp;&amp; (f[r1.<span class="built_in">top</span>().idx] &amp; <span class="number">2</span>)) r1.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">while</span> (!p1.<span class="built_in">empty</span>() &amp;&amp; (f[p1.<span class="built_in">top</span>().idx] ^ <span class="number">1</span>)) p1.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (flow &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = r0.<span class="built_in">top</span>().idx, j = r1.<span class="built_in">top</span>().idx;</span><br><span class="line">        ans += A[i] + B[j], --flow, f[i] |= <span class="number">1</span>, f[j] |= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (f[i] != <span class="number">3</span>) p1.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (f[j] != <span class="number">3</span>) p0.<span class="built_in">push</span>(j);</span><br><span class="line">        flow += (i == j)? <span class="number">1</span>: ((f[i] == <span class="number">3</span>) + (f[j] == <span class="number">3</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> i1, j1, i2, j2, p3;</span><br><span class="line">        LL Mx, v1 = <span class="number">0</span>, v2 = <span class="number">0</span>, v3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!r0.<span class="built_in">empty</span>() &amp;&amp; !p1.<span class="built_in">empty</span>())</span><br><span class="line">          i1 = r0.<span class="built_in">top</span>().idx, j1 = p1.<span class="built_in">top</span>().idx, v1 = A[i1] + B[j1];</span><br><span class="line">        <span class="keyword">if</span> (!p0.<span class="built_in">empty</span>() &amp;&amp; !r1.<span class="built_in">empty</span>())</span><br><span class="line">          i2 = p0.<span class="built_in">top</span>().idx, j2 = r1.<span class="built_in">top</span>().idx, v2 = A[i2] + B[j2];</span><br><span class="line">        <span class="keyword">if</span> (!r.<span class="built_in">empty</span>())</span><br><span class="line">          p3 = r.<span class="built_in">top</span>().idx, v3 = A[p3] + B[p3];</span><br><span class="line">        Mx = <span class="built_in">max</span>(v1, <span class="built_in">max</span>(v2, v3)), ans += Mx;</span><br><span class="line">        <span class="keyword">if</span> (v1 == Mx) &#123;</span><br><span class="line">          f[i1] |= <span class="number">1</span>, f[j1] |= <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span> (f[i1] != <span class="number">3</span>) p1.<span class="built_in">push</span>(i1); <span class="keyword">else</span> ++flow;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v2 == Mx) &#123;</span><br><span class="line">          f[i2] |= <span class="number">1</span>, f[j2] |= <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span> (f[j2] != <span class="number">3</span>) p0.<span class="built_in">push</span>(j2); <span class="keyword">else</span> ++flow;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v3 == Mx)</span><br><span class="line">          r.<span class="built_in">pop</span>(), f[p3] |= <span class="number">3</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><hr><p>以下就是 laofu 课件中 “老鼠进洞” 的模型了. 或者说是, 二分图带权匹配的模型.</p><p>考虑到二分图带权匹配已经是经典问题, 下文就不再赘述朴素的网络流做法.</p><p>laofu 课件中利用较多篇幅, 从 DP 凸性的角度入手解决了这些问题… 作为没有梦想的咸鱼选手, 我暂且还是选择感性理解的方式.</p><h3 id="BZOJ-4977「Lydsy1708-月赛」跳伞求生"><a href="#BZOJ-4977「Lydsy1708-月赛」跳伞求生" class="headerlink" title="BZOJ 4977「Lydsy1708 月赛」跳伞求生"></a>BZOJ 4977「Lydsy1708 月赛」跳伞求生</h3><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><del><a href="http://lydsy.com/JudgeOnline/problem.php?id=4977">http://lydsy.com/JudgeOnline/problem.php?id=4977</a></del></li><li><a href="https://darkbzoj.tk/problem/4977">https://darkbzoj.tk/problem/4977</a></li></ul><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>laofu 课件中的 Problem 3.</p><p>首先思考简化版的问题.</p><blockquote><p>数轴上有 $n$ 只老鼠和 $m$ 个老鼠洞. 第 $i$ 只老鼠的坐标为 $x_i$, 第 $j$ 个老鼠洞的坐标为 $y_i$.<br>现在要让老鼠进洞, 也就是寻找老鼠和洞的匹配.</p><p>假定每只老鼠只能往左走, 每个洞容量为 $1$. 求所有老鼠都进洞的最小总代价（即行走的最小总距离）.</p></blockquote><p>也就是 laofu 课件中的 Problem 1.</p><p>首先将洞的权值视作 $-y_i$, 老鼠的权值视作 $x_i$, 所求即最小权匹配. 将数轴上的所有点排序, 那么用栈记录所有的未匹配洞的位置, 在遇到老鼠时选择栈顶的洞匹配上即可.</p><p>再来考虑这个问题. 此时每个洞带权, 且不要求所有老鼠都进洞, 所求为最大权匹配.</p><p>对于一组匹配, 其对答案的贡献为 $x_i - y_j + w_j$. 考虑到 $w_j$ 的影响, 对所有点按坐标排序后洞的权值并不单调. 那么将栈换作堆维护最值即可.</p><p>但直接选择的匹配并不一定为最优解. 联系费用流中的退流操作, 在选择一组匹配后向堆中增加权值为 $-x_i$ 的元素, 从而体现匹配更改的情况.</p><p>时间复杂度 $O(n \log n)$.</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BZOJ #4977</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x, w;</span><br><span class="line">  <span class="built_in">Point</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">Point</span>(<span class="keyword">int</span> _x, <span class="keyword">int</span> _w): <span class="built_in">x</span>(_x), <span class="built_in">w</span>(_w) &#123; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; rhs.x || (x == rhs.x &amp;&amp; w &lt; rhs.w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; P[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> a, i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a), P[++p] = <span class="built_in">Point</span>(a, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> b, c, i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;b, &amp;c), P[++p] = <span class="built_in">Point</span>(b, c);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(P + <span class="number">1</span>, P + <span class="number">1</span> + p);</span><br><span class="line">  LL ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (P[i].w == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (d.<span class="built_in">empty</span>() || d.<span class="built_in">top</span>() + P[i].x &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      ans += d.<span class="built_in">top</span>() + P[i].x;</span><br><span class="line">      d.<span class="built_in">pop</span>(), d.<span class="built_in">push</span>(-P[i].x);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      d.<span class="built_in">push</span>(-P[i].x + P[i].w);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="UOJ-455【UER-8】雪灾与外卖"><a href="#UOJ-455【UER-8】雪灾与外卖" class="headerlink" title="UOJ #455【UER #8】雪灾与外卖"></a>UOJ #455【UER #8】雪灾与外卖</h3><h4 id="题目链接-6"><a href="#题目链接-6" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://uoj.ac/problem/455">https://uoj.ac/problem/455</a></li></ul><h4 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h4><p>laofu 课件中的 Problem 6.</p><p>不妨先去除每个洞容量的限制, 考虑容量为 $1$ 的情况.</p><p>首先匹配交叉一定不优. 同样将数轴上的点从小到大排序, 对于每只老鼠或是每个洞, 讨论其匹配和反悔的权值即可.</p><p>具体的讨论可参考 <a href="https://whzzt.blog.uoj.ac/blog/4749">UOJ 官方题解</a>, 或者是文末的参考资料 (</p><p>每个洞容量的限制体现在网络流中即边的容量, 直接往之前的堆中丢一个 <code>pair</code> 记录增广的权值和容量即可. 可以证明, 此时对堆操作次数仍为线性.</p><p>在老鼠存在 “分身” 的情况下, 也是可以这样做的.</p><p>时间复杂度 $O(n \log n)$.</p><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UOJ #455</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; Pll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL INFLL = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x, w, c;</span><br><span class="line">  <span class="built_in">Point</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">Point</span>(<span class="keyword">int</span> _x, <span class="keyword">int</span> _w, <span class="keyword">int</span> _c): <span class="built_in">x</span>(_x), <span class="built_in">w</span>(_w), <span class="built_in">c</span>(_c) &#123; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; rhs.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; P[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p;</span><br><span class="line">priority_queue&lt;Pll, vector&lt;Pll&gt;, greater&lt;Pll&gt; &gt; d0, d1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;data/ex_hole7.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x, i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">read</span>(x), P[++p] = <span class="built_in">Point</span>(x, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">  LL sc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x, w, c, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">read</span>(x), <span class="built_in">read</span>(w), <span class="built_in">read</span>(c);</span><br><span class="line">    P[++p] = <span class="built_in">Point</span>(x, w, c), sc += c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sc &lt; n)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(P + <span class="number">1</span>, P + <span class="number">1</span> + p);</span><br><span class="line">  LL ans = <span class="number">0</span>;</span><br><span class="line">  d1.<span class="built_in">push</span>(<span class="built_in">Pll</span>(INFLL, n));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = P[i].x, w = P[i].w;</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="number">-1</span>) &#123;</span><br><span class="line">      Pll t = d1.<span class="built_in">top</span>(); d1.<span class="built_in">pop</span>();</span><br><span class="line">      ans += t.first + x, --t.second;</span><br><span class="line">      <span class="keyword">if</span> (t.second &gt; <span class="number">0</span>) d1.<span class="built_in">push</span>(t);</span><br><span class="line">      d0.<span class="built_in">push</span>(<span class="built_in">Pll</span>(<span class="number">-2LL</span> * x - t.first, <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LL tot = <span class="number">0</span>, c = P[i].c;</span><br><span class="line">      <span class="keyword">while</span> (c &gt; <span class="number">0</span> &amp;&amp; !d0.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Pll t = d0.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span> (t.first + x + w &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        d0.<span class="built_in">pop</span>();</span><br><span class="line">        LL s = <span class="built_in">min</span>((LL) c, t.second);</span><br><span class="line">        ans += s * (t.first + w + x), t.second -= s, c -= s;</span><br><span class="line">        <span class="keyword">if</span> (t.second &gt; <span class="number">0</span>) d0.<span class="built_in">push</span>(t);</span><br><span class="line">        tot += s, d1.<span class="built_in">push</span>(<span class="built_in">Pll</span>(<span class="number">-2LL</span> * x - t.first, s));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (tot &gt; <span class="number">0</span>)</span><br><span class="line">        d0.<span class="built_in">push</span>(<span class="built_in">Pll</span>(-x - w, tot));</span><br><span class="line">      <span class="keyword">if</span> (c &gt; <span class="number">0</span>)</span><br><span class="line">        d1.<span class="built_in">push</span>(<span class="built_in">Pll</span>(-x + w, c));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="LOJ-6405「ICPC-World-Finals-2018」征服世界"><a href="#LOJ-6405「ICPC-World-Finals-2018」征服世界" class="headerlink" title="LOJ #6405「ICPC World Finals 2018」征服世界"></a>LOJ #6405「ICPC World Finals 2018」征服世界</h3><h4 id="题目链接-7"><a href="#题目链接-7" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/6405">https://loj.ac/problem/6405</a></li></ul><h4 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h4><p>laofu 课件中的 Problem 7.</p><p>上一题的模型上树.</p><p>首先每个点都存在军队和需求的限制是假的, 每个位置的军队解决自己的问题显然更优.  把军队视为洞, 军队需求视作老鼠, 可以得到老鼠进洞的模型. 换句话说, 对于 $x_i &gt; y_i$ 的节点, 视作容量为 $x_i - y_i$ 的洞; 对于满足 $x_i &lt; y_i$ 的节点, 视作 $y_i - x_i$ 只老鼠.</p><p>现在需要让所有老鼠进洞并使花费最小. 记 $\mathrm{dist}(u)$ 表示树上节点 $u$ 到根的距离, 那么花费形同 $\def\dist{\mathrm{dist}} \dist(u) + \dist(v) - 2\cdot \dist(\mathrm{LCA}(u, v))$.</p><p>对于每个点 $u$, 将 $\mathrm{dist}(u)$ 视作 $u$ 的权值. 同时, 每只老鼠一定要进洞, 直接将权值减去 $\infty$, 在计算答案时加上就好了.</p><p>剩下的情况和上一题没有太大区别, 另外需要可并堆快速从下向上合并节点的信息.</p><p>时间复杂度 $O(n \log n)$.</p><h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #6405</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, <span class="keyword">int</span>&gt; Pli;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2.5e5</span> + <span class="number">5</span>, MAXM = MAXN &lt;&lt; <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL INFLL = MAXN * <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> X[MAXN], Y[MAXN];</span><br><span class="line"></span><br><span class="line">LL d[MAXN], ans;</span><br><span class="line"><span class="keyword">int</span> rt0[MAXN], rt1[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Heap &#123;</span><br><span class="line">  Pli val[MAXM];</span><br><span class="line">  <span class="keyword">int</span> ch[<span class="number">2</span>][MAXM], dist[MAXM], nidx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">const</span> Pli&amp; v)</span> </span>&#123; <span class="keyword">return</span> val[++nidx] = v, nidx; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Mrg</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line">    <span class="keyword">if</span> (val[x] &gt; val[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    ch[<span class="number">1</span>][x] = <span class="built_in">Mrg</span>(ch[<span class="number">1</span>][x], y);</span><br><span class="line">    <span class="keyword">if</span> (dist[ch[<span class="number">0</span>][x]] &lt; dist[ch[<span class="number">1</span>][x]]) <span class="built_in">swap</span>(ch[<span class="number">0</span>][x], ch[<span class="number">1</span>][x]);</span><br><span class="line">    dist[x] = dist[ch[<span class="number">1</span>][x]] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pop</span><span class="params">(<span class="keyword">int</span>&amp; u)</span> </span>&#123; u = <span class="built_in">Mrg</span>(ch[<span class="number">0</span>][u], ch[<span class="number">1</span>][u]); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Psh</span><span class="params">(<span class="keyword">int</span>&amp; u, <span class="keyword">const</span> Pli&amp; v)</span> </span>&#123; u = <span class="built_in">Mrg</span>(u, <span class="built_in">newnode</span>(v)); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, w; &#125; edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edges[++eidx] = (Edge)&#123; head[from], to, w &#125;, head[from] = eidx;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">const</span> LL&amp; d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (rt0[x] &gt; <span class="number">0</span> &amp;&amp; rt1[y] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      Pli &amp;t0 = Heap::val[rt0[x]], &amp;t1 = Heap::val[rt1[y]];</span><br><span class="line">      <span class="keyword">if</span> (t0.first + t1.first - <span class="number">2</span> * d &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">int</span> s = <span class="built_in">min</span>(t0.second, t1.second);</span><br><span class="line">      ans += s * (t0.first + t1.first - <span class="number">2</span> * d);</span><br><span class="line">      t0.second -= s, t1.second -= s;</span><br><span class="line">      <span class="keyword">if</span> (t0.second == <span class="number">0</span>) Heap::<span class="built_in">Pop</span>(rt0[x]);</span><br><span class="line">      <span class="keyword">if</span> (t1.second == <span class="number">0</span>) Heap::<span class="built_in">Pop</span>(rt1[y]);</span><br><span class="line">      Heap::<span class="built_in">Psh</span>(rt0[x], <span class="built_in">Pli</span>(-t1.first + <span class="number">2</span> * d, s));</span><br><span class="line">      Heap::<span class="built_in">Psh</span>(rt1[y], <span class="built_in">Pli</span>(-t0.first + <span class="number">2</span> * d, s));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (X[u] &gt; <span class="number">0</span>)</span><br><span class="line">      Heap::<span class="built_in">Psh</span>(rt0[u], <span class="built_in">Pli</span>(d[u], X[u]));</span><br><span class="line">    <span class="keyword">if</span> (Y[u] &gt; <span class="number">0</span>)</span><br><span class="line">      Heap::<span class="built_in">Psh</span>(rt1[u], <span class="built_in">Pli</span>(d[u] - INFLL, Y[u])), ans += INFLL * Y[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((v = edges[i].to) == fa) <span class="keyword">continue</span>;</span><br><span class="line">      d[v] = d[u] + edges[i].w, <span class="built_in">dfs</span>(v, u);</span><br><span class="line">      <span class="built_in">Merge</span>(u, v, d[u]), <span class="built_in">Merge</span>(v, u, d[u]);</span><br><span class="line">      rt0[u] = Heap::<span class="built_in">Mrg</span>(rt0[u], rt0[v]);</span><br><span class="line">      rt1[u] = Heap::<span class="built_in">Mrg</span>(rt1[u], rt1[v]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  Graph::<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">read</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> u, v, w, i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">read</span>(u), <span class="built_in">read</span>(v), <span class="built_in">read</span>(w);</span><br><span class="line">    Graph::<span class="built_in">AddEdge</span>(u, v, w), Graph::<span class="built_in">AddEdge</span>(v, u, w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v, i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">read</span>(X[i]), <span class="built_in">read</span>(Y[i]);</span><br><span class="line">    v = <span class="built_in">min</span>(X[i], Y[i]), X[i] -= v, Y[i] -= v;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Graph::<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>陈江伦, &lt;模拟费用流问题&gt;, 2019.1.27.</li><li>boshi, <a href="https://www.mina.moe/archives/11762">模拟费用流的基本模型</a>.</li><li>mangoyang, <a href="https://www.cnblogs.com/mangoyang/p/11563486.html">模拟流的问题小结</a>.</li><li>litble, <a href="https://blog.csdn.net/litble/article/details/88410435">模拟费用流模型总结</a>.</li><li>200815147, <a href="https://blog.csdn.net/baidu_36797646/java/article/details/87071691">LOJ #2306「NOI2017」蔬菜 模拟费用流</a></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;祝贺我又学了一个学不明白的东西 (&lt;/p&gt;
&lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;模拟费用流, 大概是利用流的一些性质, 从而用数据结构高效模拟费用流.&lt;/p&gt;
&lt;p&gt;基础理论和模型可以看看文末的参考资料, 这里只是记录我做过的一些题目.&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://depletedprism.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
    <category term="Greedy" scheme="https://depletedprism.github.io/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>BJOI 2018 简要题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/sx/BJOI-2018-sol/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/sx/BJOI-2018-sol/</id>
    <published>2020-06-01T04:31:45.000Z</published>
    <updated>2020-06-03T00:03:33.771Z</updated>
    
    <content type="html"><![CDATA[<hr><p>这是 6 月份还在写省选题的悲惨故事.</p><span id="more"></span><p>BJOI 2018 Day 1 官方题解: <a href="http://qmqmqm.blog.uoj.ac/blog/3515">http://qmqmqm.blog.uoj.ac/blog/3515</a>.</p><h3 id="「BJOI2018」求和"><a href="#「BJOI2018」求和" class="headerlink" title="「BJOI2018」求和"></a>「BJOI2018」求和</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2491">https://loj.ac/problem/2491</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>注意到只有查询操作, 那么直接对所有可能的 $k$ 计算当前点到根的累计点权和 $s_k$. 对于一次查询 $u$, $v$, 所求即为</p><script type="math/tex; mode=display">s_k(u) + s_k(v) - s_k(\mathrm{LCA}(u,\ v)) - s_k\big( \mathrm{pre}(\mathrm{LCA}(u,\ v)) \big)</script><p>直接求就好了. <del>原来难点在求 LCA 啊</del> (雾</p><p>时间复杂度 $O(nk + m \log n)$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2491</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e5</span> + <span class="number">5</span>, MAXK = <span class="number">51</span>, P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> pre[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HLD &#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">  <span class="keyword">int</span> depth[MAXN], size[MAXN], son[MAXN], topfa[MAXN];</span><br><span class="line">  <span class="keyword">int</span> val[MAXK][MAXN], s[MAXK][MAXN];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">    pre[u] = fa, size[u] = <span class="number">1</span>, son[u] = <span class="number">-1</span>;</span><br><span class="line">    val[<span class="number">0</span>][u] = <span class="number">1</span>, s[<span class="number">0</span>][u] = s[<span class="number">0</span>][fa] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXK; ++i) &#123;</span><br><span class="line">      val[i][u] = <span class="number">1LL</span> * val[i - <span class="number">1</span>][u] * depth[u] % P;</span><br><span class="line">      s[i][u] = (s[i][fa] + val[i][u]) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((v = edges[i].to) == fa) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="built_in">dfs1</span>(v, u), size[u] += size[v];</span><br><span class="line">      <span class="keyword">if</span> (son[u] == <span class="number">-1</span> || size[v] &gt; size[son[u]]) son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">    topfa[u] = top;</span><br><span class="line">    <span class="keyword">if</span> (~son[u]) <span class="built_in">dfs2</span>(son[u], top);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">      <span class="keyword">if</span> ((v = edges[i].to) != pre[u] &amp;&amp; v != son[u]) <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">-1</span>, <span class="built_in">dfs1</span>(rt, <span class="number">0</span>), <span class="built_in">dfs2</span>(rt, rt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (topfa[u] != topfa[v]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (depth[topfa[u]] &lt; depth[topfa[v]]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">      u = pre[topfa[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (depth[u] &gt; depth[v])? v: u;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  Graph::<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">read</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">read</span>(u), <span class="built_in">read</span>(v);</span><br><span class="line">    Graph::<span class="built_in">AddEdge</span>(u, v), Graph::<span class="built_in">AddEdge</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">  HLD::<span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">read</span>(q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> u, v, k; q; --q) &#123;</span><br><span class="line">    <span class="built_in">read</span>(u), <span class="built_in">read</span>(v), <span class="built_in">read</span>(k);</span><br><span class="line">    <span class="keyword">int</span> l = HLD::<span class="built_in">LCA</span>(u, v), *s = HLD::s[k];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (((LL) s[u] + s[v] - s[l] - s[pre[l]]) % P + P) % P);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「BJOI2018」二进制"><a href="#「BJOI2018」二进制" class="headerlink" title="「BJOI2018」二进制"></a>「BJOI2018」二进制</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2492">https://loj.ac/problem/2492</a></li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>考虑到重排操作, 那么某个区间是否可以组成 $3$ 的倍数和区间中 $0$ 和 $1$ 的个数有关.</p><p>记区间内 $0$ 的个数为 $s_0$, $1$ 的个数为 $s_1$, 先考虑哪些情况无法组成 $3$ 的倍数.</p><ol><li><p>$s_1$ 为 $1$, 其余位置都是 $0$.</p><p>此时无论如何重排, 所得结果都是 $2$ 的幂次, 不是 $3$ 的倍数.</p></li><li><p>$s_1$ 为奇数, 且 $s_0 &lt; 2$.</p><p>逐位考虑二进制下的每一位 $1$, 单独拿出来在模 $3$ 意义下的值为 $1$ 或 $2$. 如果要构造出 $3$ 的倍数, 那么一定要将 $1$ 和 $2$ 两两配对. 也就可以得到, $s_1$ 为偶数时一定有解.</p><p>如果 $s_1$ 为奇数时, 若 $s_2 \ge 2$, 则可构造出 $(10101)_2 = (21)_{10}$, 其余 $0$ 放在高位, $1$ 放在低位, 从而组成 $3$ 的倍数. 而其余情况不存在类似的构造方案.</p></li></ol><p>那么我们可以用所有子区间的个数减去不合法的子区间个数来计算答案, 同时, 为了避免重复计算, 认为情况 1 中 $s_0 \ge 2$. 现在的问题在于如何统计无法重排为 $3$ 的倍数的子区间个数.</p><p>考虑 DP, 对于每个区间</p><p>设 $f_L(i)$, $i \in \{ 0, 1, 2 \}$ 分别表示强制包含该区间左端点的, 满足区间内 $s_1 = 1$, 且 $s_0$ 满足 $s_0 = 0$ / $s_0 = 1$ / $s_0 \ge 2$ 的子区间个数.</p><p>$g_L(i, j)$, $i,j \in \{ 0, 1 \}$ 表示强制包含该区间左端点的, 满足区间内 $s_0 = i$, $s_1$ 奇偶性为 $j$ 的子区间个数.</p><p>同理有 $f_R(i)$, $g_R(i, j)$. 转移则直接按照定义合并两个区间, 需要维护每个区间靠左连续 $0$ 个数, 以及靠右连续 $0$ 个数, 并统计跨过两个区间的答案.</p><p>注意到有修改操作, 那么用线段树维护转移即可. 时间复杂度 $O(m \log n)$.</p><p>硬要解释的话, 这道题可以算是序列上的动态 DP?</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2492</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">binom2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1LL</span> * n * (n - <span class="number">1</span>) / <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (nd &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (nd &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> s, s0, s1, l0, r0;</span><br><span class="line">    LL fl[<span class="number">3</span>], fr[<span class="number">3</span>], gl[<span class="number">2</span>][<span class="number">2</span>], gr[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">const</span> <span class="keyword">int</span>&amp; v) &#123;</span><br><span class="line">      <span class="built_in">clear</span>();</span><br><span class="line">      <span class="keyword">if</span> (v) fl[<span class="number">0</span>] = fr[<span class="number">0</span>] = gl[<span class="number">0</span>][<span class="number">1</span>] = gr[<span class="number">0</span>][<span class="number">1</span>] = s = s1 = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> gl[<span class="number">1</span>][<span class="number">0</span>] = gr[<span class="number">1</span>][<span class="number">0</span>] = s0 = l0 = r0 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      s = s0 = s1 = l0 = r0 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) fl[i] = fr[i] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j) gl[i][j] = gr[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; dat[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  Node <span class="keyword">operator</span> + (<span class="keyword">const</span> Node&amp; A, <span class="keyword">const</span> Node&amp; B) &#123;</span><br><span class="line">    Node ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">      ret.fl[i] += A.fl[i], ret.fr[i] += B.fr[i];</span><br><span class="line">      <span class="keyword">if</span> (A.s1 == <span class="number">0</span>) ret.fl[<span class="built_in">min</span>(<span class="number">2</span>, i + A.s0)] += B.fl[i];</span><br><span class="line">      <span class="keyword">if</span> (B.s1 == <span class="number">0</span>) ret.fr[<span class="built_in">min</span>(<span class="number">2</span>, i + B.s0)] += A.fr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (A.s1 == <span class="number">1</span> &amp;&amp; B.l0 &gt; <span class="number">0</span>)</span><br><span class="line">      ++ret.fl[<span class="built_in">min</span>(<span class="number">2</span>, A.s0 + B.l0)], ret.fl[<span class="number">2</span>] += B.l0 - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (B.s1 == <span class="number">1</span> &amp;&amp; A.r0 &gt; <span class="number">0</span>)</span><br><span class="line">      ++ret.fr[<span class="built_in">min</span>(<span class="number">2</span>, B.s0 + A.r0)], ret.fr[<span class="number">2</span>] += A.r0 - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j) &#123;</span><br><span class="line">        ret.gl[i][j] += A.gl[i][j], ret.gr[i][j] += B.gr[i][j];</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= A.s0) ret.gl[i][j] += B.gl[i - A.s0][j ^ (A.s1 &amp; <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= B.s0) ret.gr[i][j] += A.gr[i - B.s0][j ^ (B.s1 &amp; <span class="number">1</span>)];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    ret.l0 = (A.s1 == <span class="number">0</span>)? A.l0 + B.l0: A.l0;</span><br><span class="line">    ret.r0 = (B.s1 == <span class="number">0</span>)? B.r0 + A.r0: B.r0;</span><br><span class="line">    ret.s1 = A.s1 + B.s1, ret.s0 = A.s0 + B.s0, ret.s = A.s + B.s;</span><br><span class="line"></span><br><span class="line">    ret.s += A.gr[<span class="number">0</span>][<span class="number">0</span>] * (B.gl[<span class="number">0</span>][<span class="number">1</span>] + B.gl[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    ret.s += A.gr[<span class="number">0</span>][<span class="number">1</span>] * (B.gl[<span class="number">0</span>][<span class="number">0</span>] + B.gl[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    ret.s += A.gr[<span class="number">1</span>][<span class="number">0</span>] * B.gl[<span class="number">0</span>][<span class="number">1</span>] + A.gr[<span class="number">1</span>][<span class="number">1</span>] * B.gl[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (A.r0 &gt; <span class="number">0</span>)</span><br><span class="line">      ret.s += (A.r0 - <span class="number">1</span>) * B.fl[<span class="number">0</span>] + A.r0 * (B.fl[<span class="number">1</span>] + B.fl[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (B.l0 &gt; <span class="number">0</span>)</span><br><span class="line">      ret.s += (B.l0 - <span class="number">1</span>) * A.fr[<span class="number">0</span>] + B.l0 * (A.fr[<span class="number">1</span>] + A.fr[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123; dat[nd] = dat[lc] + dat[rc]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>( dat[nd] = A[L] );</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc, L, Mid), <span class="built_in">build</span>(rc, Mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">maintain</span>(nd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; p, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>( dat[nd] = <span class="built_in">Node</span>(v) );</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= Mid) <span class="built_in">Mdy</span>(lc, L, Mid, p, v); <span class="keyword">else</span> <span class="built_in">Mdy</span>(rc, Mid + <span class="number">1</span>, R, p, v);</span><br><span class="line">    <span class="built_in">maintain</span>(nd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Node <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> dat[nd];</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> <span class="built_in">Qry</span>(lc, L, Mid, opL, opR);</span><br><span class="line">    <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> <span class="built_in">Qry</span>(rc, Mid + <span class="number">1</span>, R, opL, opR);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Qry</span>(lc, L, Mid, opL, opR) + <span class="built_in">Qry</span>(rc, Mid + <span class="number">1</span>, R, opL, opR);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">read</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(A[i]);</span><br><span class="line"></span><br><span class="line">  SGT::<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">read</span>(q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> opt, L, R; q; --q) &#123;</span><br><span class="line">    <span class="built_in">read</span>(opt), <span class="built_in">read</span>(L);</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (opt) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        A[L] ^= <span class="number">1</span>, SGT::<span class="built_in">Mdy</span>(<span class="number">1</span>, <span class="number">1</span>, n, L, A[L]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">read</span>(R);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">binom2</span>(R - L + <span class="number">2</span>) - SGT::<span class="built_in">Qry</span>(<span class="number">1</span>, <span class="number">1</span>, n, L, R).s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>: <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ERR\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「BJOI2018」染色"><a href="#「BJOI2018」染色" class="headerlink" title="「BJOI2018」染色"></a>「BJOI2018」染色</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2493">https://loj.ac/problem/2493</a></li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>容易发现, 对于不是二分图的无向图, 其答案一定为 <code>NO</code>. 此后只需讨论二分图, 也就是只存在偶环的图.</p><p>但不是所有二分图答案都为 <code>YES</code>. 例如样例 1 中的完全二分图 $K_{3, 3}$.</p><p>对于有一个公共点的两个偶环, 存在一种构造方案使其一定不合法. 这也就意味着, 如果存在度数 $&gt; 3$ 的点, 则答案为 <code>NO</code>. 同时, 度数为 $1$ 的点并不影响答案, 可直接删去.</p><p>图中不同的连通块之间互不影响. 现在依次考虑每一个连通块, 剩余的情况有</p><ol><li><p>不同其他环有交点的偶环.</p><p>无论给定何种颜色集合, pupil 都可构造出颜色交替的合法方案.</p></li><li><p>存在两个度数为 $3$ 的点.</p><p>此时两个度数为 $3$ 的点之间三条不相交的路径. 当且仅当这三条路径长满足 “2 - 2 - 偶数” 的形式时 pupil 一定内构造出合法方案.</p></li></ol><p>详尽具体的证明可参考 <a href="https://qmqmqm.blog.uoj.ac/blog/3515">官方题解</a>, 或是 <a href="https://blog.csdn.net/zxyoi_dreamer/article/details/88255198">zxyoi 的题解</a>.</p><p><del><em>其实证明也就是给出某种方案将不合法的情况卡掉…</em></del></p><p>实现则直接根据以上性质判断. 时间复杂度 $O(n \log n + m)$, 可能会因实现不同而有不同 (</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2493</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e4</span> + <span class="number">5</span>, MAXM = <span class="number">2e4</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="keyword">int</span> deg[MAXN]; <span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DSU &#123;</span><br><span class="line">  <span class="keyword">int</span> fa[MAXN];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">findfa</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fa[u] == u)? u: fa[u] = <span class="built_in">findfa</span>(fa[u]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">findfa</span>(u), v = <span class="built_in">findfa</span>(v);</span><br><span class="line">    <span class="keyword">if</span> (u != v) fa[u] = v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    eidx = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      G[i].<span class="built_in">clear</span>(), deg[i] = <span class="number">0</span>, head[i] = <span class="number">-1</span>, vis[i] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">    ++deg[to];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> Q[MAXN], h, t;</span><br><span class="line">    Q[h = <span class="number">1</span>] = t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">      <span class="keyword">if</span> (deg[u] == <span class="number">1</span>) vis[u] = <span class="literal">true</span>, Q[++t] = u;</span><br><span class="line">    <span class="keyword">while</span> (h &lt;= t) &#123;</span><br><span class="line">      <span class="keyword">int</span> u = Q[h++];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[v = edges[i].to]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ((--deg[v]) == <span class="number">1</span>) vis[v] = <span class="literal">true</span>, Q[++t] = v;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= eidx; i += <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> u = edges[i ^ <span class="number">1</span>].to, v = edges[i].to;</span><br><span class="line">      <span class="keyword">if</span> (!vis[u] &amp;&amp; !vis[v]) DSU::<span class="built_in">join</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Graph::<span class="built_in">Toposort</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">    G[DSU::<span class="built_in">findfa</span>(u)].<span class="built_in">push_back</span>(u);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u) &#123;</span><br><span class="line">    <span class="keyword">if</span> (DSU::fa[u] != u || G[u].<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>, x = <span class="number">-1</span>, y = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; v: G[u]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (deg[v] &gt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (deg[v] == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++c == <span class="number">1</span>) x = v; <span class="keyword">else</span> y = v;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span> || c &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span> &amp;&amp; G[u].<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (G[u].<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 2 - 2 - Even</span></span><br><span class="line">    <span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; v: G[u]) <span class="keyword">if</span> (v != x &amp;&amp; v != y) &#123;</span><br><span class="line">      <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> w, i = Graph::head[v]; ~i; i = Graph::edges[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> ((w = Graph::edges[i].to) == x || w == y) ++l;</span><br><span class="line">      <span class="keyword">if</span> (l == <span class="number">2</span>) ++e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> Ti; <span class="built_in">read</span>(Ti);</span><br><span class="line">  <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line"></span><br><span class="line">    Graph::<span class="built_in">init</span>(), DSU::<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">      <span class="built_in">read</span>(u), <span class="built_in">read</span>(v);</span><br><span class="line">      Graph::<span class="built_in">AddEdge</span>(u, v), Graph::<span class="built_in">AddEdge</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="built_in">check</span>()? <span class="string">&quot;YES&quot;</span>: <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「BJOI2018」双人猜数游戏"><a href="#「BJOI2018」双人猜数游戏" class="headerlink" title="「BJOI2018」双人猜数游戏"></a>「BJOI2018」双人猜数游戏</h3><p>不明真相的吃瓜群众直呼内行.</p><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2511">https://loj.ac/problem/2511</a></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>似乎更像是一道传统题?</p><p>首先可以观察到, Bob 和 Alice 确定答案的依据为, 自己已知的答案集合时候在对手看来是否是唯一的. 每次对手回答知道 / 不知道, 都能在自己的答案集合中排除一些结果. 剩余结果唯一时则得到了答案.</p><p>可能有些抽象, 对于样例 1 的模拟可参考 <a href="https://0x131cc05.github.io/2019/04/07/BJOI2018-%E5%8F%8C%E4%BA%BA%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/">An_Account 的题解</a>.</p><p>考虑用 DP 模拟这个过程. 设 $f(i, m, n)$ 表示当前在第 $i$ 轮, 已经说出 $i - 1$ 次不知道时, $(m, n)$ 是否能确定为答案. 那么最终答案需满足 $f(t + 1, m, n)$ 能够确定为答案.</p><p>显然有转移 $f(i, m, n) = f(i - 2, m, n)$, 表示之前能够确定, 再下一回合仍可确定.</p><p>对于 Bob, 转移则直接枚举 $m + n$ 的合法整数分解, 判断是否唯一存在恰好一组 $(x, y)$ 满足 $x + y = m + n$ 且 $f(i - 1, x, y)$ 为假, 也就是上一次猜测中并不能确定. Alice 则类似.</p><p>还有一种边界情况. 注意到题目要求 “ 一共说了 $t$ 次 ‘不知道’ 以后两个人都知道 $m$ 和 $n$ 是多少了”, 要排除一个人知道, 但另一个人却不知道的情况. 再进行一次类似的转移, 要求其在第 $t + 1$ 轮猜出, 且第 $t - 1$ 轮并不确定.</p><p>答案中 $m$, $n$ 上界并未给定, 但所有数据都可以在较短的时间内求出.</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p>可以适当调整 <code>MAXM</code> 或 <code>MAXN</code> 可以在正确性和时间内平衡. 有时候会 <code>RE</code>, 不用管就是了 (</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2511</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1e4</span> + <span class="number">5</span>, MAXN = <span class="number">5e2</span> + <span class="number">5</span>, MAXT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s, t;</span><br><span class="line"><span class="keyword">char</span> First[MAXT];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> f[MAXT][MAXM][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check1</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="keyword">int</span>&amp; i)</span> </span>&#123; <span class="comment">// Bob</span></span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>, ax = <span class="number">-1</span>, ay = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x = s; <span class="number">2</span> * x &lt;= m + n; ++x) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = m + n - x;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span> || !f[i - <span class="number">1</span>][x][y]) &#123;</span><br><span class="line">      ++cnt, ax = x, ay = y;</span><br><span class="line">      <span class="keyword">if</span> (cnt == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; ax == m &amp;&amp; ay == n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check2</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="keyword">int</span>&amp; i)</span> </span>&#123; <span class="comment">// Alice</span></span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>, ax = <span class="number">-1</span>, ay = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x = s; x * x &lt;= m * n; ++x) <span class="keyword">if</span> (m * n % x == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = m * n / x;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span> || !f[i - <span class="number">1</span>][x][y]) &#123;</span><br><span class="line">      ++cnt, ax = x, ay = y;</span><br><span class="line">      <span class="keyword">if</span> (cnt == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; ax == m &amp;&amp; ay == n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check1</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>, ax = <span class="number">-1</span>, ay = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x = s; <span class="number">2</span> * x &lt;= m + n; ++x) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = m + n - x;</span><br><span class="line">    <span class="keyword">if</span> (f[t + <span class="number">1</span>][x][y] &amp;&amp; !f[t - <span class="number">1</span>][x][y]) &#123;</span><br><span class="line">      ++cnt, ax = x, ay = y;</span><br><span class="line">      <span class="keyword">if</span> (cnt == <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; ax == m &amp;&amp; ay == n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check2</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>, ax = <span class="number">-1</span>, ay = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x = s; x * x &lt;= m * n; ++x) <span class="keyword">if</span> (m * n % x == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = m * n / x;</span><br><span class="line">    <span class="keyword">if</span> (f[t + <span class="number">1</span>][x][y] &amp;&amp; !f[t - <span class="number">1</span>][x][y]) &#123;</span><br><span class="line">      ++cnt, ax = x, ay = y;</span><br><span class="line">      <span class="keyword">if</span> (cnt == <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; ax == m &amp;&amp; ay == n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%s%d&quot;</span>, &amp;s, First, &amp;t);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> fst = (First[<span class="number">0</span>] == <span class="string">&#x27;B&#x27;</span>); <span class="comment">// Alice: 0, Bob: 1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t + <span class="number">1</span>; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = s; <span class="number">2</span> * m &lt; MAXN; ++m)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> n = m; n &lt; MAXN; ++n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>) f[i][m][n] |= f[i - <span class="number">2</span>][m][n];</span><br><span class="line">        f[i][m][n] |= ((i &amp; <span class="number">1</span>) ^ fst)? <span class="built_in">check2</span>(m, n, i): <span class="built_in">check1</span>(m, n, i);</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">// for (int sum = 2 * s; ; ++sum)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> sum = <span class="number">2</span> * s; sum &lt; MAXM; ++sum)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = s; <span class="number">2</span> * m &lt;= sum; ++m) &#123;</span><br><span class="line">      <span class="keyword">int</span> n = sum - m;</span><br><span class="line">      <span class="keyword">if</span> (f[t + <span class="number">1</span>][m][n] &amp;&amp; !(f[t][m][n] || f[t - <span class="number">1</span>][m][n])) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((t &amp; <span class="number">1</span>) ^ fst) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!<span class="built_in">check2</span>(m, n)) <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!<span class="built_in">check1</span>(m, n)) <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, m, n), <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;-1 -1&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「BJOI2018」链上二次求和"><a href="#「BJOI2018」链上二次求和" class="headerlink" title="「BJOI2018」链上二次求和"></a>「BJOI2018」链上二次求和</h3><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2512">https://loj.ac/problem/2512</a></li></ul><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>设 $s_i$ 表示 $a_i$ 的前缀和, $f_i$ 表示 $s_i$ 的前缀和.</p><p>对于每次询问, 其答案为</p><script type="math/tex; mode=display">\sum_{i = L} ^ R \sum_{j = i} ^ n ( s_j - s_{j - i} )= \sum_{i = L} ^ R (f_n - f_{i - 1} - f_{n - i})</script><p>利用线段树维护 $f_i$ 部分和即可在 $O(\log n)$ 的时间复杂度内计算答案.</p><p>关键在于每次修改对 $f_i$ 的影响. 设当前修改区间为 $[L,\ R]$, 增加值为 $d$.</p><p>对于每个位置 $i$, 其被覆盖次数为公差为 $1$ 的等差数列, 令 $s(n) = \sum\limits_{k = 1} ^ n k = \frac{1}{2} n (n + 1)$. 整理可得</p><script type="math/tex; mode=display">f_i = \begin{cases}d \cdot s(i - L + 1) & i \in [L, R] \\d \cdot s(R - L + 1) + d (i - R) (R - L + 1) & i \in (R, n]\end{cases}</script><p>上式可表示为 $a i ^ 2 + bi + c$ 的形式. 利用线段树维护标记 $a$, $b$, $c$ 更新 $f_i$ 的部分和即可.</p><p>时间复杂度 $O(m \log n)$, 常数较大.</p><p>注意操作 1 中并未限定 $u \le v$…</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><p>苟活在现代编译器的底层优化之下…</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2512</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>, iv2 = <span class="number">500000004</span>, iv6 = <span class="number">166666668</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Fix</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a + (a &gt;&gt; <span class="number">31</span> &amp; P); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pls</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Fix</span>(a + b - P); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mns</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Fix</span>(a - b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Z</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Z</span>() &#123; x = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="built_in">Z</span>(<span class="keyword">int</span> _x): <span class="built_in">x</span>(_x) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  Z <span class="keyword">operator</span> + (<span class="keyword">const</span> Z&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">Z</span>(<span class="built_in">pls</span>(x, rhs.x)); &#125;</span><br><span class="line">  Z <span class="keyword">operator</span> - (<span class="keyword">const</span> Z&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">Z</span>(<span class="built_in">mns</span>(x, rhs.x)); &#125;</span><br><span class="line">  Z <span class="keyword">operator</span> * (<span class="keyword">const</span> Z&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">Z</span>(<span class="number">1LL</span> * x * rhs.x % P); &#125;</span><br><span class="line">  Z <span class="keyword">operator</span> / (<span class="keyword">const</span> <span class="keyword">int</span>&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rhs == <span class="number">2</span>) <span class="keyword">return</span> *<span class="keyword">this</span> * <span class="built_in">Z</span>(iv2);</span><br><span class="line">    <span class="keyword">if</span> (rhs == <span class="number">6</span>) <span class="keyword">return</span> *<span class="keyword">this</span> * <span class="built_in">Z</span>(iv6);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  Z <span class="keyword">operator</span> += (<span class="keyword">const</span> Z&amp; rhs) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> + rhs; &#125;</span><br><span class="line">  Z <span class="keyword">operator</span> -= (<span class="keyword">const</span> Z&amp; rhs) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> - rhs; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Z&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x &lt; rhs.x; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> Z&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> rhs &lt; *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Z <span class="title">s0</span><span class="params">(Z L, Z R)</span> </span>&#123; <span class="keyword">return</span> R - L + <span class="number">1</span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Z <span class="title">s1</span><span class="params">(Z n)</span> </span>&#123; <span class="keyword">return</span> (n &gt; <span class="number">0</span>)? n * (n + <span class="number">1</span>) / <span class="number">2</span>: <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Z <span class="title">s1</span><span class="params">(Z L, Z R)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">s1</span>(R) - <span class="built_in">s1</span>(L - <span class="number">1</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Z <span class="title">s2</span><span class="params">(Z n)</span> </span>&#123; <span class="keyword">return</span> (n &gt; <span class="number">0</span>)? n * (n + <span class="number">1</span>) * (n * <span class="number">2</span> + <span class="number">1</span>) / <span class="number">6</span>: <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Z <span class="title">s2</span><span class="params">(Z L, Z R)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">s2</span>(R) - <span class="built_in">s2</span>(L - <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> A[MAXN]; Z f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (nd &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (nd &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line">  Z s[MAXN &lt;&lt; <span class="number">2</span>], ta[MAXN &lt;&lt; <span class="number">2</span>], tb[MAXN &lt;&lt; <span class="number">2</span>], tc[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123; s[nd] = s[lc] + s[rc]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, Z va, Z vb, Z vc)</span> </span>&#123;</span><br><span class="line">    ta[nd] += va, tb[nd] += vb, tc[nd] += vc;</span><br><span class="line">    s[nd] += <span class="built_in">s2</span>(L, R) * va + <span class="built_in">s1</span>(L, R) * vb + <span class="built_in">s0</span>(L, R) * vc;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ta[nd] &gt; <span class="number">0</span> || tb[nd] &gt; <span class="number">0</span> || tc[nd] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">      <span class="built_in">push</span>(lc, L, Mid, ta[nd], tb[nd], tc[nd]);</span><br><span class="line">      <span class="built_in">push</span>(rc, Mid + <span class="number">1</span>, R, ta[nd], tb[nd], tc[nd]);</span><br><span class="line">      ta[nd] = tb[nd] = tc[nd] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>( s[nd] = f[L] );</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc, L, Mid), <span class="built_in">build</span>(rc, Mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">maintain</span>(nd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> opL, <span class="keyword">int</span> opR, Z va, Z vb, Z vc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">push</span>(nd, L, R, va, vb, vc);</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(nd, L, R);</span><br><span class="line">    <span class="keyword">if</span> (opL &lt;= Mid) <span class="built_in">Mdy</span>(lc, L, Mid, opL, opR, va, vb, vc);</span><br><span class="line">    <span class="keyword">if</span> (opR &gt; Mid) <span class="built_in">Mdy</span>(rc, Mid + <span class="number">1</span>, R, opL, opR, va, vb, vc);</span><br><span class="line">    <span class="built_in">maintain</span>(nd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Z <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> opL, <span class="keyword">int</span> opR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> s[nd];</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(nd, L, R);</span><br><span class="line">    <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> <span class="built_in">Qry</span>(lc, L, Mid, opL, opR);</span><br><span class="line">    <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> <span class="built_in">Qry</span>(rc, Mid + <span class="number">1</span>, R, opL, opR);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Qry</span>(lc, L, Mid, opL, opR) + <span class="built_in">Qry</span>(rc, Mid + <span class="number">1</span>, R, opL, opR);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">read</span>(n), <span class="built_in">read</span>(q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">read</span>(A[i]), f[i] = f[i - <span class="number">1</span>] + A[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">  SGT::<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> opt, L, R, v; q; --q) &#123;</span><br><span class="line">    <span class="keyword">static</span> Z d, l;</span><br><span class="line">    <span class="built_in">read</span>(opt), <span class="built_in">read</span>(L), <span class="built_in">read</span>(R);</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R) <span class="built_in">swap</span>(L, R);</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (opt) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">read</span>(v), d = v, l = R - L + <span class="number">1</span>;</span><br><span class="line">        SGT::<span class="built_in">Mdy</span>(<span class="number">1</span>, <span class="number">0</span>, n, L, R,</span><br><span class="line">            d / <span class="number">2</span>, d * <span class="built_in">mns</span>(<span class="number">3</span>, <span class="number">2</span> * L) / <span class="number">2</span>, d * (<span class="built_in">Z</span>(L) * L - <span class="number">3</span> * L + <span class="number">2</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (R &lt; n)</span><br><span class="line">          SGT::<span class="built_in">Mdy</span>(<span class="number">1</span>, <span class="number">0</span>, n, R + <span class="number">1</span>, n, <span class="number">0</span>, d * l, d * l * ((l + <span class="number">1</span>) / <span class="number">2</span> - R));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        d = SGT::<span class="built_in">Qry</span>(<span class="number">1</span>, <span class="number">0</span>, n, n, n) * (R - L + <span class="number">1</span>);</span><br><span class="line">        d -= SGT::<span class="built_in">Qry</span>(<span class="number">1</span>, <span class="number">0</span>, n, L - <span class="number">1</span>, R - <span class="number">1</span>) + SGT::<span class="built_in">Qry</span>(<span class="number">1</span>, <span class="number">0</span>, n, n - R, n - L);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d.x);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>: <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ERR\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「BJOI2018」治疗之雨"><a href="#「BJOI2018」治疗之雨" class="headerlink" title="「BJOI2018」治疗之雨"></a>「BJOI2018」治疗之雨</h3><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2513">https://loj.ac/problem/2513</a></li></ul><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>这是一道常规期望题.</p><p>设 $f_i$ 表示第一个数值为 $i$ 时, 成为最小值 $0$ 的期望步数. 记 $p_{i, j}$ 表示第一个数由 $i$ 变为 $j$ 的概率, 则有</p><script type="math/tex; mode=display">f_i = \begin{cases}\sum\limits_{j = 1} ^ {i + 1} p_{i, j} (f_j + 1) = 1 + \sum\limits_{j = 1} ^ {i + 1} p_{i, j} f_j & i < n \\\sum\limits_{j = 1} ^ n p_{i, j} (f_j + 1) = 1 + \sum\limits_{j = 1} ^ n p_{i, j} f_j & i = n\end{cases}</script><p>为计算 $p_{i, j}$, 首先设 $g_i$ 表示在一次操作中, 第一个数减少 $i$ 的概率, 则有</p><script type="math/tex; mode=display">g_i = \frac{\binom{k}{i} m ^ {k - i} }{(m + 1) ^ k}</script><p>也就是讨论 $k$ 次减小的去向. 注意此处并没有关注边界情况, 在计算 $p_{i, j}$ 的时候会考虑这一点.</p><p>$g_i$ 可以在 $O(n)$ 的时间内递推求解. 此时 $p_{i, j}$ 可表示为</p><script type="math/tex; mode=display">p_{i, j} = \begin{cases}g_{i - j} & i = n \\\frac{1}{m + 1} g_0 & j = i + 1 \\\frac{1}{m + 1} g_{i - j + 1} + \frac{m}{m + 1} g_{i - j} & j < i\end{cases}</script><p>现在就可以用高斯消元求解 $f_i$ 了. 朴素做法的时间复杂度为 $O(n ^ 3)$.</p><p>注意到本体中高斯消元的矩阵比较特殊, 在形式上类似于下三角矩阵. 那么每次将 $A_{i, i}$ 带入到其余行化简时, 有效的位置只有 $O(1)$ 个, 且完成带入后第 $n$ 行可直接确定 $f_n$. 接着利用 $f_n$ 从下向上依次回代即可解出原方程组. 此时的时间复杂度为 $O(n ^ 2)$.</p><p>同时要注意一些情况的特判, 诸如 $k = 0$, $m = 0$…</p><p>时间复杂度 $O(T n ^ 2)$.</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2513</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1505</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1LL</span> * ret * base % P;</span><br><span class="line">    base = <span class="number">1LL</span> * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">fpow</span>(x, P - <span class="number">2</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, p, m, K;</span><br><span class="line"><span class="keyword">int</span> ivm1;</span><br><span class="line"><span class="keyword">int</span> f[MAXN], g[MAXN], A[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">prb</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i == n) <span class="keyword">return</span> g[i - j];</span><br><span class="line">  <span class="keyword">if</span> (j == i + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1LL</span> * ivm1 * g[<span class="number">0</span>] % P;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1LL</span> * ivm1 * (g[i - j + <span class="number">1</span>] + <span class="number">1LL</span> * m * g[i - j] % P) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (K == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (K == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &gt; <span class="number">0</span>) p += (p &lt; n), p -= K, ++ret;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  g[<span class="number">0</span>] = <span class="built_in">fpow</span>(<span class="number">1LL</span> * m * ivm1 % P, K);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">min</span>(n + <span class="number">1</span>, K); ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1LL</span> * (K - i + <span class="number">1</span>) * <span class="built_in">inv</span>(<span class="number">1LL</span> * m * i % P) % P;</span><br><span class="line">    g[i] = <span class="number">1LL</span> * g[i - <span class="number">1</span>] * s % P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">min</span>(i + <span class="number">1</span>, n); ++j)</span><br><span class="line">      A[i][j] = (A[i][j] - <span class="built_in">prb</span>(i, j) + P) % P;</span><br><span class="line">    A[i][n + <span class="number">1</span>] = <span class="number">1</span>, A[i][i] = (A[i][i] + <span class="number">1</span>) % P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="built_in">inv</span>(A[i][i]);</span><br><span class="line">    A[i][i] = <span class="number">1</span>, A[i][n + <span class="number">1</span>] = <span class="number">1LL</span> * A[i][n + <span class="number">1</span>] * d % P;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; n) A[i][i + <span class="number">1</span>] = <span class="number">1LL</span> * A[i][i + <span class="number">1</span>] * d % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123; <span class="comment">// i &lt; n</span></span><br><span class="line">      A[j][i + <span class="number">1</span>] = (A[j][i + <span class="number">1</span>] - <span class="number">1LL</span> * A[j][i] * A[i][i + <span class="number">1</span>] % P + P) % P;</span><br><span class="line">      A[j][n + <span class="number">1</span>] = (A[j][n + <span class="number">1</span>] - <span class="number">1LL</span> * A[j][i] * A[i][n + <span class="number">1</span>] % P + P) % P;</span><br><span class="line">      A[j][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) &#123;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">1LL</span> * A[i - <span class="number">1</span>][i] * A[i][n + <span class="number">1</span>] % P;</span><br><span class="line">    A[i - <span class="number">1</span>][n + <span class="number">1</span>] = (A[i - <span class="number">1</span>][n + <span class="number">1</span>] - d + P) % P, A[i - <span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> A[p][n + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> Ti;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Ti);</span><br><span class="line">  <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;p, &amp;m, &amp;K);</span><br><span class="line">    ivm1 = <span class="built_in">inv</span>(m + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">solve</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, (<span class="built_in">min</span>(n + <span class="number">1</span>, K) + <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      A[i][i] = <span class="number">0</span>, A[i][n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>要退役了, 感觉再不做点 NOI 就没有机会了 = =</p><p>去写 NOI 的题了.</p><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;这是 6 月份还在写省选题的悲惨故事.&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>「UR #19」通用测评号 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/uoj-514/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/uoj-514/</id>
    <published>2020-05-27T05:05:20.000Z</published>
    <updated>2020-05-30T12:47:02.241Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://uoj.ac/problem/514">https://uoj.ac/problem/514</a></li></ul><p>和<a href="https://uoj.ac/problem/449">【集训队作业2018】喂鸽子</a> 几乎一样的题 (</p><span id="more"></span><p>就是算是在总结 喂鸽子 的 $O(n ^ 2 k)$ 解法了.</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>如果将操作视为序列, 大力生成函数, 容易得到 50 pts 的做法, 也就是官方题解中的算法 2. <del>和<a href="https://uoj.ac/problem/390">【UNR #3】百鸽笼</a> 十分相似.</del></p><p>下文称 “放入至少 $b$ 单位的燃料” 为 “半满”, “填满 $a$ 单位的燃料” 为 “填满”.</p><p>首先对题意做一步转化, 只需计算出所有燃料舱全部半满之前, 每个燃料舱填满的概率再求和即可. 注意到燃料舱编号对答案没有影响, 不妨令填满的燃料舱编号为 $1$, 计算最终答案时乘 $n$ 就好了.</p><p>所求即满足第 $1$ 个燃料舱填满时, 不存在燃料舱仍未半满的概率. 考虑容斥, 枚举仍未半满的燃料舱个数 $m$, 同时记 $g_m$ 表示在共计 $m + 1$ 燃料舱中, 第 $1$ 个燃料舱填满时, 存在 $m$ 个燃料舱未半满的概率. (此处可直接将其余燃料舱忽略, 详见<a href="https://loj.ac/problem/2541">「PKUWC2018」猎人杀</a> 中用到的 Trick) 可得</p><script type="math/tex; mode=display">\sum_{m = 1} ^ {n - 1} (-1) ^ {m - 1} \binom{n - 1}{m}\ g_m</script><p>可以通过操作序列入手计算 $g_m$. 那么此处对操作序列的限制为 <strong>恰好</strong> 出现 $a$ 次编号 $1$, 同时有 $m$ 个编号出现次数 <strong>至多</strong> 为 $b - 1$.</p><p>但实际上, 序列中最后一次操作一定填入 $1$, 序列中未确定的位置只有 $i - 1$ 处. 因此其 EGF 为</p><script type="math/tex; mode=display">F(x) = \frac{x ^ {a - 1} }{(a - 1)!} \cdot \left( \sum_{k = 0} ^ {b - 1} \frac{x ^ k}{k!} \right) ^ m = \frac{x ^ {a - 1} }{(a - 1)!}\ G ^ m (x)</script><p>枚举序列长度为 $i$, 那么 $g_m$ 可表示为</p><script type="math/tex; mode=display">g_m = \sum_{i = 0} ^ {m (b - 1)} \frac{1}{(m + 1) ^ i} (i - 1)! \cdot [x ^ {i - 1}]\ \frac{x ^ {a - 1} }{(a - 1)!}\ G ^ m (x)</script><p>现在的问题在于如何快速计算 $G ^ m (x)$.</p><p>注意到 $G(x)$ 和 $e ^ x$ 的相似性, 并且我们知道 $(e ^ x)’ = e ^ x$. 那么可以尝试用类似的方法递推求出 $F(x)$. 具体地, 有</p><script type="math/tex; mode=display">G'(x) = \left( \sum_{k = 0} ^ {b - 1} \frac{x ^ k}{k!} \right)' =  \sum_{k = 1} ^ {b - 1} \frac{k \, x ^ {k - 1} }{k!} = G(x) - \frac{x ^ {b - 1} }{(b - 1)!}</script><p>那么对于 $G ^ m (x)$, 有</p><script type="math/tex; mode=display">\big(G ^ m(x)\big)' = m \cdot G ^ {m - 1} (x) \cdot G'(x) = m \left( G ^ m(x) - \frac{x ^ {b - 1} }{(b - 1)!} G ^ {m - 1} (x) \right)</script><p>同时取项 $x ^ {i - 1}$ 系数, 可得</p><script type="math/tex; mode=display">[x ^ {i - 1}] \big(G ^ m (x)\big)' = i \cdot [x ^ i] G ^ m(x) = m \left( [x ^ {i - 1}] G ^ m (x) - [x ^ {i - 1}] \frac{x ^ {b - 1} }{(b - 1)!} G ^ {m - 1} (x) \right)</script><p>此时 $[x ^ i] G ^ m (x)$ 可通过 $[x ^ {i - 1}]G ^ m(x)$, $[x ^ {i - 1}]G ^ {m - 1} (x)$ 得出, 递推计算即可. 时间复杂度 $O(n ^ 2 b)$.</p><p>这个技巧也在<a href="https://uoj.ac/problem/449">【集训队作业2018】喂鸽子</a> 的某种 $O(n ^ 2 k)$ 做法中用到过.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UOJ #514</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">255</span>, MAXM = MAXN * MAXN, P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fac[MAXM], ifac[MAXM], inv[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">binom</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (n &lt; m)? <span class="number">0</span>: <span class="number">1LL</span> * fac[n] * ifac[m] % P * ifac[n - m] % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1LL</span> * ret * base % P;</span><br><span class="line">    base = <span class="number">1LL</span> * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PolyPre</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">  inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">    inv[i] = <span class="number">1LL</span> * inv[P % i] * (P - P / i) % P;</span><br><span class="line">  ifac[<span class="number">0</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    fac[i] = <span class="number">1LL</span> * fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">    ifac[i] = <span class="number">1LL</span> * ifac[i - <span class="number">1</span>] * inv[i] % P;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a, b;</span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXM], g[MAXN][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">PolyPre</span>(n * a);</span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, g[<span class="number">0</span>][b - <span class="number">1</span>] = ifac[b - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt;= n; ++m) &#123;</span><br><span class="line">    f[m][<span class="number">0</span>] = <span class="number">1</span>, g[m][b - <span class="number">1</span>] = ifac[b - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m * (b - <span class="number">1</span>); ++i) &#123;</span><br><span class="line">      f[m][i] = <span class="number">1LL</span> * m * inv[i] % P * (f[m][i - <span class="number">1</span>] - g[m - <span class="number">1</span>][i - <span class="number">1</span>] + P) % P;</span><br><span class="line">      g[m][i + b - <span class="number">1</span>] = <span class="number">1LL</span> * f[m][i] * ifac[b - <span class="number">1</span>] % P;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt;= n; ++m)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m * (b - <span class="number">1</span>); ++i)</span><br><span class="line">      g[m][i + a - <span class="number">1</span>] = <span class="number">1LL</span> * ifac[a - <span class="number">1</span>] * f[m][i] % P;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; n; ++m) &#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, pw = <span class="built_in">fpow</span>(inv[m + <span class="number">1</span>], a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a; i &lt;= m * (b - <span class="number">1</span>) + a; ++i) &#123;</span><br><span class="line">      s = (s + <span class="number">1LL</span> * fac[i - <span class="number">1</span>] * pw % P * g[m][i - <span class="number">1</span>] % P) % P;</span><br><span class="line">      pw = <span class="number">1LL</span> * pw * inv[m + <span class="number">1</span>] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    s = <span class="number">1LL</span> * s * <span class="built_in">binom</span>(n - <span class="number">1</span>, m) % P;</span><br><span class="line">    ans = (ans + ((m &amp; <span class="number">1</span>)? s: P - s)) % P;</span><br><span class="line">  &#125;</span><br><span class="line">  ans = <span class="number">1LL</span> * ans * n % P;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>yhx-12243, <a href="https://yhx-12243.github.io/OI-transit/records/uoj514.html">[uoj514]通用测评号 题解</a></li><li><a href="https://peehs-moorhsum.blog.uoj.ac/blog/5486">UOJ Round #19 题解</a></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h4 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://uoj.ac/problem/514&quot;&gt;https://uoj.ac/problem/514&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;和&lt;a href=&quot;https://uoj.ac/problem/449&quot;&gt;【集训队作业2018】喂鸽子&lt;/a&gt; 几乎一样的题 (&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="Combinatorics" scheme="https://depletedprism.github.io/tags/Combinatorics/"/>
    
    <category term="Probability &amp; Mean" scheme="https://depletedprism.github.io/tags/Probability-Mean/"/>
    
  </entry>
  
  <entry>
    <title>「UNR #3」百鸽笼 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/uoj-390/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/uoj-390/</id>
    <published>2020-05-25T12:24:28.000Z</published>
    <updated>2020-05-30T12:32:53.691Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://uoj.ac/problem/390">https://uoj.ac/problem/390</a></li></ul><p>这是一道鸽子题.</p><span id="more"></span><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>每次鸽子回到鸽笼时会影响概率大小, 即令 $a_i$ 减 $1$ 时会影响鸽笼总数. 但根据<a href="https://loj.ac/problem/2541">「PKUWC2018」猎人杀</a> 的结论, 认为每次选择鸽笼时, 若有 $a_i &gt; 0$, 则直接令 $a_i$ 减 $1$; 否则再次选择.</p><p>也就是说, 可以认为已经满的鸽笼列仍可入住鸽子, 但对 $a_i$ 没有影响. 此时计算出的结果和原来限制下的结果相同.</p><p>此时将鸽子的入住顺序用一长度为 $m$ 的有标号序列描述, 序列中第 $i$ 个元素表示第 $i$ 次选择, 某只鸽子入住鸽笼的列编号. 容易发现 $m \ge N$, 因为可以重复入住, 但每只鸽子都要回到鸽笼.</p><p>不妨假设当前空出的鸽笼在第 $1$ 列, 那么序列中一定存在 <strong>恰好</strong> $a_1 - 1$ 个 $1$, 同时对于其余每个元素 $i$, <strong>至少</strong> 出现 $a_i$ 次. 类似于<a href="https://uoj.ac/problem/449">【集训队作业2018】喂鸽子</a> 的思路, 可得出该序列个数的 EGF $F(x)$ 为</p><script type="math/tex; mode=display">F(x) = \frac{x ^ {a_1 - 1}}{(a_1 - 1) !} \cdot \prod_{i \neq 1} \left(e ^ x - \sum_{k = 0} ^ {a_i - 1} \frac{x ^ k}{k!}\right)</script><p>那么计算出所有合法序列的数量, 并将最后结果除以序列个数的总数就能够得出空出鸽笼在第 $1$ 列的答案. 同时, 对每个元素做一次类似的操作即可计算最终结果.</p><p>但是 $e ^ x$ 展开后有无穷项系数, 不便于计算. 此时有一个思路 (from <a href="https://yhx-12243.github.io/OI-transit/records/uoj390.html">yhx-12243</a>), 将 $F(x)$ 视为 $x$ 和 $e ^ x$ 的二元生成函数, 那么有</p><script type="math/tex; mode=display">F(x, y) = \frac{x ^ {a_1 - 1}}{(a_1 - 1) !} \cdot \prod_{i \neq 1} \left(y - \sum_{k = 0} ^ {a_i - 1} \frac{x ^ k}{k!} \right),\; y = e ^ x</script><p>对于其中一项 $y ^ i x ^ j = e ^ {ix} x ^ j$, 其对答案的另有除其系数以外的贡献. 取 $e ^ x$ 第 $s$ 项, 则</p><script type="math/tex; mode=display">[x ^ s] e ^ {ix} \cdot x ^ j = \frac{(ix) ^ s}{s!} x ^ j = \frac{i ^ s}{s!}\ x ^ {j + s}</script><p>此时 $F(x, y)$ 各项只同 $x$ 有关. 假定 $s + j = m$, 那么 $F(x, y)$ 第 $m$ 项对答案的贡献为</p><script type="math/tex; mode=display">\frac{m!}{n ^ {m + 1} } \cdot \frac{i ^ s}{s!} = \frac{(s + j)!}{n ^ {s + j + 1} } \cdot \frac{i ^ s}{s!}</script><p>其中 $n ^ {m + 1}$ 长度为 $m$ 的序列总个数. 考虑到 $a_1$ 个鸽笼中必须剩下一个不选, 且该限制不好直接计算. 那么在计算序列总数时直接将 $a_1$ 添加到序列中, 那么每次选择都有 $n$ 种可能, 因此总数为 $n ^ {m + 1}$.</p><p>实际计算时, 我们需要求得每一项的结果的和. 即</p><script type="math/tex; mode=display">\sum_{s = 0} ^ \infty \frac{(s + j)!}{n ^ {s + j + 1} } \cdot \frac{i ^ s}{s!} = \frac{j!}{n ^ {j + 1} } \cdot \sum_{s = 0} ^ \infty \binom{s + j}{s} \left( \frac{i}{n} \right) ^ s 1 ^ {j + 1}</script><p>根据广义二项式定理, 原式可化为</p><script type="math/tex; mode=display">\frac{j!}{n ^ {j + 1} } \left( \frac{1}{1 - \frac{i}{n}} \right) ^ {j + 1} = \frac{j!}{(n - i) ^ {j + 1} }</script><p>只需枚举 $i$, $j$ 即可, 实际计算时还需乘上对应项系数, 同时要考虑 $\frac{x ^ {a_1 - 1} }{(a_1 - 1)!}$ 的影响.</p><p>对于每一种空出鸽笼的位置, 重新计算 $F(x)$ 的时间复杂度过高. 因此可直接计算</p><script type="math/tex; mode=display">\prod_{i = 1} ^ n \left(e ^ x - \sum_{k = 0} ^ {a_i - 1} \frac{x ^ k}{k!}\right)</script><p>每次在原有基础上除 $e ^ x - \sum\limits_{k = 0} ^ {a_i - 1} \dfrac{x ^ k}{k!}$ 即可. 具体实现时将乘法 “倒过来写” 就好了.</p><p>时间复杂度为 $O\big(n ^ 2 \left( \sum a_i\right) \cdot \max \{ a_i \}\big)$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UOJ #390</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e1</span> + <span class="number">5</span>, MAXM = MAXN * MAXN, P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fac[MAXM], ifac[MAXM], inv[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1LL</span> * ret * base % P;</span><br><span class="line">    base = <span class="number">1LL</span> * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PolyPre</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">  inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">    inv[i] = <span class="number">1LL</span> * inv[P % i] * (P - P / i) % P;</span><br><span class="line">  ifac[<span class="number">0</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    fac[i] = <span class="number">1LL</span> * fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">    ifac[i] = <span class="number">1LL</span> * ifac[i - <span class="number">1</span>] * inv[i] % P;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pls</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">const</span> LL&amp; b)</span> </span>&#123; <span class="keyword">return</span> a = (a + b) % P; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mns</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">const</span> LL&amp; b)</span> </span>&#123; <span class="keyword">return</span> a = (a - b + P) % P; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], h[<span class="number">2</span>][MAXN][MAXM], g[MAXN][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, A + i);</span><br><span class="line">  <span class="built_in">PolyPre</span>(MAXM - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> cur = <span class="number">1</span>, df = <span class="number">0</span>;</span><br><span class="line">  h[cur][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(h[cur ^ <span class="number">1</span>], <span class="number">0</span>, <span class="keyword">sizeof</span> h[cur ^ <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= df; ++k) <span class="keyword">if</span> (h[cur][j][k] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">pls</span>(h[cur ^ <span class="number">1</span>][j + <span class="number">1</span>][k], h[cur][j][k]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= A[i + <span class="number">1</span>] - <span class="number">1</span>; ++l)</span><br><span class="line">          <span class="built_in">mns</span>(h[cur ^ <span class="number">1</span>][j][k + l], <span class="number">1LL</span> * ifac[l] * h[cur][j][k] % P);</span><br><span class="line">      &#125;</span><br><span class="line">    cur ^= <span class="number">1</span>, df += A[i + <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">int</span></span> (*f)[MAXM] = h[cur];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt;= n; ++m) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= df - A[m] + <span class="number">1</span>; ++k) &#123;</span><br><span class="line">        <span class="built_in">pls</span>(g[j][k], f[j + <span class="number">1</span>][k]);</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || g[j][k] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= A[m] - <span class="number">1</span>; ++l)</span><br><span class="line">          <span class="built_in">pls</span>(g[j - <span class="number">1</span>][k + l], <span class="number">1LL</span> * ifac[l] * g[j][k] % P);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> j = A[m] - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= df - A[m] + <span class="number">1</span>; ++k, ++j) <span class="keyword">if</span> (g[i][k] &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">pls</span>(ans, <span class="number">1LL</span> * fac[j] * g[i][k] % P * <span class="built_in">fpow</span>(inv[n - i], j + <span class="number">1</span>) % P);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="number">1LL</span> * ans * ifac[A[m] - <span class="number">1</span>] % P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, ans, <span class="string">&quot; \n&quot;</span>[m == n]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>我承认我不可能写地比参考资料好 (</p><ul><li><a href="https://wuhongxun.blog.uoj.ac/blog/3679">UOJ NOI Round #3 Day2 题解</a></li><li>yhx-12243, <a href="https://yhx-12243.github.io/OI-transit/records/uoj390.html">UOJ #390 百鸽笼 题解</a></li><li>lyd729, <a href="https://blog.csdn.net/lyd_7_29/java/article/details/83787557">【UOJ #390】【UNR #3】百鸽笼</a></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h4 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://uoj.ac/problem/390&quot;&gt;https://uoj.ac/problem/390&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是一道鸽子题.&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="Combinatorics" scheme="https://depletedprism.github.io/tags/Combinatorics/"/>
    
    <category term="Probability &amp; Mean" scheme="https://depletedprism.github.io/tags/Probability-Mean/"/>
    
  </entry>
  
  <entry>
    <title>「PKUWC2018」猎人杀 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/loj-2541/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/loj-2541/</id>
    <published>2020-05-25T05:15:02.000Z</published>
    <updated>2020-05-25T12:23:59.582Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2541">https://loj.ac/problem/2541</a></li></ul><p>这是一道经常被拿出来四处安利的题 (</p><span id="more"></span><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>对于某一个时刻, 记 $f_i$ 为第 $i$ 个猎人当前没有死亡, 且在下一次开枪后死亡的概率. 同时, 记 $m$ 为所有猎人 $w_i$ 之和, $d$ 为已死亡猎人之和. 则有</p><script type="math/tex; mode=display">f_i = \frac{w_i}{m - d}</script><p>容易得到</p><script type="math/tex; mode=display">f_i = \frac{w_i}{m} + \frac{d}{m} f_i</script><p>考虑这个式子的实际意义. 即如果向已死亡的猎人射击, 等同于再次射击… 也就是在一猎人死亡后, 仍可认为其能被作为射击目标. 在该意义下计算并不会影响 $f_i$ 的值.</p><p>现在要解决的问题即为, 求恰好 $0$ 人在 $1$ 死亡之后死亡概率. 考虑容斥, 枚举在 $1$ 死亡后存活的猎人集合 $S$, 同时记 $s$ 为集合 $S$ 中的猎人 $w_i$ 之和. 可以得到答案为</p><script type="math/tex; mode=display">\sum_{S} (-1) ^ {|S|} \sum_{t = 0} ^ \infty (1 - \frac{s + w_1}{m}) ^ t \cdot \frac{w_1}{m} = \sum_{S} (-1) ^ {|S|} \frac{w_1}{s + w_1}</script><p>笼统解释一下, 集合 $S$ 中猎人要能在 $1$ 之后存活, 其划分界限一定为 $1$ 死亡的时刻, 并在该时刻前 $S$ 和 $1$ 都不能死亡. 后者利用广义二项式定理即可得出.</p><p>显然枚举集合是不科学的. 注意到 $\sum w_i$ 的值不大, 求出每一个 $s$ 对应的集合容斥系数之和即可. 其生成函数为</p><script type="math/tex; mode=display">F(x) = \prod_{i = 2} ^ n \left(1 - x ^ {w_i} \right)</script><p>分治 FFT 计算即可. 最终的答案为</p><script type="math/tex; mode=display">\sum_{s \ge 0} [x ^ s] F(x) \cdot \frac{w_1}{s + w_1}</script><p>记 $m = \sum\limits_{i = 1} ^ n w_i$, 则时间复杂度为 $O(m \log ^ 2 m)$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>用 <code>vector</code> 代替数组写多项式果然快乐 (</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2541</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LOG = <span class="number">18</span>, MAXN = <span class="number">1</span> &lt;&lt; LOG | <span class="number">1</span>, P = <span class="number">998244353</span>, G = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> W[LOG][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1LL</span> * ret * base % P;</span><br><span class="line">    base = <span class="number">1LL</span> * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">  <span class="keyword">int</span> r[MAXN];</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) <span class="built_in">swap</span>(f[i], f[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>, Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>, ++k) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span>* w = W[k];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j) &#123;</span><br><span class="line">          <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1LL</span> * w[j] * f[i+j+Mid] % P;</span><br><span class="line">          f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> iv = <span class="built_in">fpow</span>(Lim, P - <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1LL</span> * f[i] * iv % P;</span><br><span class="line">      <span class="built_in">reverse</span>(f + <span class="number">1</span>, f + Lim);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PolyPre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> w, i = <span class="number">0</span>, Mid = <span class="number">1</span>; i &lt; LOG; ++i, Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    W[i][<span class="number">0</span>] = <span class="number">1</span>, w = <span class="built_in">fpow</span>(G, (P - <span class="number">1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; Mid; ++j)</span><br><span class="line">      W[i][j] = <span class="number">1LL</span> * w * W[i][j - <span class="number">1</span>] % P;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="keyword">int</span>&gt; poly;</span><br><span class="line"></span><br><span class="line">poly <span class="keyword">operator</span> * (<span class="keyword">const</span> poly&amp; f, <span class="keyword">const</span> poly&amp; g) &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">  <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (Lim &lt; <span class="built_in"><span class="keyword">int</span></span>(f.<span class="built_in">size</span>() + g.<span class="built_in">size</span>())) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) &#123;</span><br><span class="line">    A[i] = (i &lt; (<span class="keyword">int</span>) f.<span class="built_in">size</span>())? f[i]: <span class="number">0</span>;</span><br><span class="line">    B[i] = (i &lt; (<span class="keyword">int</span>) g.<span class="built_in">size</span>())? g[i]: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Poly::<span class="built_in">init</span>(Lim, L), Poly::<span class="built_in">NTT</span>(A, Lim, <span class="number">1</span>), Poly::<span class="built_in">NTT</span>(B, Lim, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = <span class="number">1LL</span> * A[i] * B[i] % P;</span><br><span class="line">  Poly::<span class="built_in">NTT</span>(A, Lim, <span class="number">-1</span>);</span><br><span class="line">  <span class="function">poly <span class="title">h</span><span class="params">(f.size() + g.size() - <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; h.<span class="built_in">size</span>(); ++i) h[i] = A[i];</span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> w[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function">poly <span class="title">solve</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">    <span class="function">poly <span class="title">g</span><span class="params">(w[L] + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> g[<span class="number">0</span>] = <span class="number">1</span>, g[w[L]] = P - <span class="number">1</span>, g;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">solve</span>(L, Mid) * <span class="built_in">solve</span>(Mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, w + i);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">PolyPre</span>();</span><br><span class="line">  poly f = <span class="built_in">solve</span>(<span class="number">2</span>, n);</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) f.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> iv = <span class="built_in">fpow</span>((i + w[<span class="number">1</span>]) % P, P - <span class="number">2</span>);</span><br><span class="line">    ans = (ans + <span class="number">1LL</span> * w[<span class="number">1</span>] * f[i] % P * iv % P) % P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>danihao123, <a href="https://yahyachan.github.io/2018/08/09/loj2541/">LibreOJ 2541 「PKUWC2018」猎人杀</a></li><li>zjp-shadow, <a href="https://www.cnblogs.com/zjp-shadow/p/9097283.html">LOJ #2541. 「PKUWC 2018」猎人杀(容斥, 期望dp, NTT优化)</a></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h4 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://loj.ac/problem/2541&quot;&gt;https://loj.ac/problem/2541&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是一道经常被拿出来四处安利的题 (&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="Polynomial" scheme="https://depletedprism.github.io/tags/Polynomial/"/>
    
    <category term="Probability &amp; Mean" scheme="https://depletedprism.github.io/tags/Probability-Mean/"/>
    
  </entry>
  
  <entry>
    <title>容斥原理 备忘录</title>
    <link href="https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/inclusion-exclusion/"/>
    <id>https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/inclusion-exclusion/</id>
    <published>2020-05-20T01:29:31.000Z</published>
    <updated>2020-05-23T02:53:15.610Z</updated>
    
    <content type="html"><![CDATA[<hr><p>记录以备忘.</p><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>虽然是很基础的东西, 但是不妨回头再看它一眼.</p><p>又因为本文定位于备忘, 所有不会有关于任何公式的证明, <del>其实就是公式的罗列</del>…</p><p>如果真的对证明感兴趣, 不妨去文末的参看资料看看.</p><span id="more"></span><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>设全集 $U$ 中有 $n$ 中不同条件 $P_{i\ldots n}$, 记 $A_i$ 为满足条件 $P_i$ 元素的集合.</p><h3 id="由集合的交计算集合的并"><a href="#由集合的交计算集合的并" class="headerlink" title="由集合的交计算集合的并"></a>由集合的交计算集合的并</h3><script type="math/tex; mode=display">| \bigcup_{i = 1} ^ n A_i | = \sum_{k = 1} ^ n (-1) ^ {k - 1} \sum_{1 \le i_1,\ \cdots,\ i_k \le n} | \bigcap_{j = 1} ^ k A_{i_j} |</script><h3 id="由补集的并计算集合的交"><a href="#由补集的并计算集合的交" class="headerlink" title="由补集的并计算集合的交"></a>由补集的并计算集合的交</h3><script type="math/tex; mode=display">|\bigcap_{i = 1} ^ n A_i| = |U| - |\bigcup_{i = 1} ^ n \bar A_i|</script><p>直接将之前的式子带入, 则有</p><script type="math/tex; mode=display">|\bigcap_{i = 1} ^ n A_i| = |U| - \sum_{k = 1} ^ n (-1) ^ {k - 1} \sum_{1 \le i_1,\ \cdots,\ i_k \le n} | \bigcap_{j = 1} ^ k \bar A_{i_j} |</script><p>进一步可以得到</p><script type="math/tex; mode=display">|\bigcap_{i = 1} ^ n A_i| = \sum_{k = 0} ^ n (-1) ^ k \sum_{1 \le i_1,\ \cdots,\ i_k \le n} |\bigcap_{j = 1} ^ k \bar A_{i_j}|</script><p>至于其他情况, 可用摩根定律进行转化.</p><p>很多时候集合中元素具体是什么不会影响结果, 此时枚举集合大小同时乘一个组合数作为系数就可以得出一些式子.</p><h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><h3 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h3><script type="math/tex; mode=display">g(n) = \sum_{k = n} ^ m \binom{k}{n} f(k) \Leftrightarrow f(n) = \sum_{k = n} ^ m (-1) ^ {k - n} \binom{k}{n} g(n)</script><p>虽然本质是容斥原理, 但是在实际中可能 (?) 会更好用一点.</p><p>此时的 $f(n)$, $g(n)$ 有组合意义, 例如 $f(n)$ 表示在总共 $m$ 个物品中, 恰好选择 $n$ 个满足某个条件元素的方案数, $g(n)$ 表示钦定 $n$ 个满足某个条件元素的方案数.</p><h3 id="子集反演"><a href="#子集反演" class="headerlink" title="子集反演"></a>子集反演</h3><p>记 $f(S)$, $g(S)$ 为两个关于集合 $S$ 的函数, 那么有</p><script type="math/tex; mode=display">f(S) = \sum_{T \subseteq S} g(T) \Leftrightarrow g(S) = \sum_{T \subseteq S} (-1) ^ {|S| - |T|} f(T)</script><p>类似地, 有</p><script type="math/tex; mode=display">f(S) = \sum_{S \subseteq T} g(T) \Leftrightarrow g(S) = \sum_{S \subseteq T} (-1) ^ {|T| - |S|} f(T)</script><h3 id="Min-Max-容斥"><a href="#Min-Max-容斥" class="headerlink" title="Min-Max 容斥"></a>Min-Max 容斥</h3><p>对于一个集合 $S$, 记 $\max\{S\}$ 为集合 $S$ 中最大值, $\min\{S\}$ 为集合 $S$ 中最小值, 那么有</p><script type="math/tex; mode=display">\max\{ S \} = \sum_{T \neq \varnothing,\ T \subseteq S} (-1) ^ {|T| - 1} \min\{ T \}</script><p>同时可以推广到第 $k$ 大值. 记 $\operatorname{kmax}\{S\}$ 为集合 $S$ 中的第 $k$ 大值, 那么有</p><script type="math/tex; mode=display">\operatorname{kmax}\{ S \} = \sum_{|T| \ge k,\ T \subseteq S} (-1) ^ {|T| - k} \binom{|T| - 1}{k - 1} \min\{T\}</script><p>同时由期望的线性性可以得到</p><script type="math/tex; mode=display">E(\max\{S\}) = \sum_{T \neq \varnothing,\ T \subseteq S} (-1) ^ {|T| - 1} E(\min\{T\})</script><p>一个常见的问题为, 询问一个集合中所有元素都出现的期望时间. 此时就可以套用该公式, 从而转为计算子集中元素第一次出现的期望时间.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>Richard A. Brualdi. 组合数学. 机械工业出版社, 2012.4.</li><li>OI Wiki, 容斥原理, <a href="https://oi-wiki.org/math/inclusion-exclusion-principle/">https://oi-wiki.org/math/inclusion-exclusion-principle/</a></li><li>GXZlegend, 二项式反演及其应用, <a href="https://www.cnblogs.com/GXZlegend/p/11407185.html">https://www.cnblogs.com/GXZlegend/p/11407185.html</a></li><li>vfleaking, 炫酷反演魔术, <a href="http://vfleaking.blog.uoj.ac/blog/87">http://vfleaking.blog.uoj.ac/blog/87</a></li><li>GXZlegend, Min-Max容斥及其推广和应用, <a href="https://www.cnblogs.com/GXZlegend/p/11563330.html">https://www.cnblogs.com/GXZlegend/p/11563330.html</a></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;记录以备忘.&lt;/p&gt;
&lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;虽然是很基础的东西, 但是不妨回头再看它一眼.&lt;/p&gt;
&lt;p&gt;又因为本文定位于备忘, 所有不会有关于任何公式的证明, &lt;del&gt;其实就是公式的罗列&lt;/del&gt;…&lt;/p&gt;
&lt;p&gt;如果真的对证明感兴趣, 不妨去文末的参看资料看看.&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://depletedprism.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Combinatorics" scheme="https://depletedprism.github.io/tags/Combinatorics/"/>
    
  </entry>
  
  <entry>
    <title>TJOI 2019 简要题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/sx/TJOI-2019-sol/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/sx/TJOI-2019-sol/</id>
    <published>2020-05-18T12:59:43.000Z</published>
    <updated>2020-05-23T06:59:52.439Z</updated>
    
    <content type="html"><![CDATA[<hr><p><del>我没有在刷水题 (确信</del></p><p>打 扰 了.</p><span id="more"></span><h3 id="「TJOI2019」甲苯先生的字符串"><a href="#「TJOI2019」甲苯先生的字符串" class="headerlink" title="「TJOI2019」甲苯先生的字符串"></a>「TJOI2019」甲苯先生的字符串</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3104">https://loj.ac/problem/3104</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>很套路的矩阵乘法 = =</p><p>设 $f(i, c)$ 表示当前计算到 $s_2$ 中第 $i$ 位, 且第 $i$ 位字符为 $c$. 容易发现转移和 $i$ 无关, 构造矩阵加速转移即可.</p><p>时间复杂度 $O(|s_1| + \log n)$, 同时带有矩阵乘法的常数 ($26 \times 26$).</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3104</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>, MAXM = <span class="number">26</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> g[MAXM][MAXM];</span><br><span class="line">  <span class="built_in">Matrix</span>() &#123; <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g); &#125;</span><br><span class="line">  Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    Matrix ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXM; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; MAXM; ++k) <span class="keyword">if</span> (g[i][k] != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; MAXM; ++j) <span class="keyword">if</span> (rhs.g[k][j] != <span class="number">0</span>)</span><br><span class="line">          ret.g[i][j] = (ret.g[i][j] + <span class="number">1LL</span> * g[i][k] * rhs.g[k][j] % P) % P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXM; ++i) g[i][i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">fpow</span><span class="params">(Matrix base, LL b)</span> </span>&#123;</span><br><span class="line">  Matrix ret; ret.<span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * base;</span><br><span class="line">    base = base * base, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m; LL n;</span><br><span class="line"><span class="keyword">char</span> S[MAXN];</span><br><span class="line"></span><br><span class="line">Matrix f, g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld%s&quot;</span>, &amp;n, S + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  m = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(S + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXM; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; MAXM; ++j) f.g[i][j] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> c1 = S[i] - <span class="string">&#x27;a&#x27;</span>, c2 = S[i + <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    f.g[c1][c2] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  g = <span class="built_in">fpow</span>(f, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXM; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; MAXM; ++j) ans = (ans + g.g[i][j]) % P;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「TJOI2019」甲苯先生的滚榜"><a href="#「TJOI2019」甲苯先生的滚榜" class="headerlink" title="「TJOI2019」甲苯先生的滚榜"></a>「TJOI2019」甲苯先生的滚榜</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3105">https://loj.ac/problem/3105</a></li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>这是一道平衡树模板题.</p><p>唯一需要注意的地方是, 该题中排名指所有元素中, 严格大于某元素的个数. 同常见的 “求 <code>rank</code>“ 有些许不同.</p><p>时间复杂度 $O\big(T (n + m) \log m\big)$.</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3105</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1.5e6</span> + <span class="number">5</span>, MAXM = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">randNum</span><span class="params">(<span class="keyword">unsigned</span>&amp; seed, <span class="keyword">unsigned</span> lst, <span class="keyword">const</span> <span class="keyword">int</span>&amp; m)</span></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> seed = seed * <span class="number">17</span> + lst, seed % m + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> c, p;</span><br><span class="line">  <span class="built_in">Item</span>() &#123; c = p = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="built_in">Item</span>(<span class="keyword">int</span> _c, <span class="keyword">int</span> _p): <span class="built_in">c</span>(_c), <span class="built_in">p</span>(_p) &#123; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; rhs.c || (c == rhs.c &amp;&amp; p &gt; rhs.p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; rhs) &amp;&amp; !(rhs &lt; *<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; A[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, root; <span class="keyword">unsigned</span> seed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Splay &#123;</span><br><span class="line">  Item val[MAXN];</span><br><span class="line">  <span class="keyword">int</span> ch[<span class="number">2</span>][MAXN], pre[MAXN], size[MAXN], cnt[MAXN], nidx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">const</span> Item&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nd = ++nidx;</span><br><span class="line">    ch[<span class="number">0</span>][nd] = ch[<span class="number">1</span>][nd] = pre[nd] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> val[nd] = v, size[nd] = cnt[nd] = <span class="number">1</span>, nd;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; nd)</span> </span>&#123;</span><br><span class="line">    size[nd] = cnt[nd];</span><br><span class="line">    <span class="keyword">if</span> (ch[<span class="number">0</span>][nd]) size[nd] += size[ch[<span class="number">0</span>][nd]];</span><br><span class="line">    <span class="keyword">if</span> (ch[<span class="number">1</span>][nd]) size[nd] += size[ch[<span class="number">1</span>][nd]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">which</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123; <span class="keyword">return</span> pre[u]? ch[<span class="number">1</span>][pre[u]] == u: <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">const</span> <span class="keyword">int</span>&amp; w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u) pre[u] = fa;</span><br><span class="line">    <span class="keyword">if</span> (fa) ch[w][fa] = u; <span class="keyword">else</span> root = u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = pre[u], w = <span class="built_in">which</span>(u);</span><br><span class="line">    <span class="built_in">connect</span>(u, pre[fa], <span class="built_in">which</span>(fa));</span><br><span class="line">    <span class="built_in">connect</span>(ch[w ^ <span class="number">1</span>][u], fa, w), <span class="built_in">connect</span>(fa, u, w ^ <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">maintain</span>(fa);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    v = pre[v];</span><br><span class="line">    <span class="keyword">while</span> (pre[u] != v) &#123;</span><br><span class="line">      <span class="keyword">int</span> fa = pre[u];</span><br><span class="line">      <span class="keyword">if</span> (pre[fa] != v) <span class="built_in">which</span>(u) == <span class="built_in">which</span>(fa)? <span class="built_in">rotate</span>(fa): <span class="built_in">rotate</span>(u);</span><br><span class="line">      <span class="built_in">rotate</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">maintain</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">const</span> Item&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>( root = <span class="built_in">newnode</span>(v) );</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nd = root; nd; nd = ch[val[nd] &lt; v][nd]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val[nd] == v) <span class="keyword">return</span> ++cnt[nd], <span class="built_in">splay</span>(nd, root);</span><br><span class="line">      <span class="keyword">if</span> (!ch[val[nd] &lt; v][nd]) &#123;</span><br><span class="line">        ch[val[nd] &lt; v][nd] = <span class="built_in">newnode</span>(v);</span><br><span class="line">        <span class="keyword">return</span> pre[nidx] = nd, <span class="built_in">splay</span>(nidx, root);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Fnd</span><span class="params">(<span class="keyword">const</span> Item&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nd = root; nd; nd = ch[val[nd] &lt; v][nd])</span><br><span class="line">      <span class="keyword">if</span> (val[nd] == v) <span class="keyword">return</span> <span class="built_in">splay</span>(nd, root);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Rmv</span><span class="params">(<span class="keyword">const</span> Item&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Fnd</span>(v);</span><br><span class="line">    <span class="keyword">if</span> (cnt[root] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>( --cnt[root] );</span><br><span class="line">    <span class="keyword">if</span> (!ch[<span class="number">0</span>][root] &amp;&amp; !ch[<span class="number">1</span>][root])</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>( root = <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span> (!ch[<span class="number">0</span>][root] || !ch[<span class="number">1</span>][root]) &#123;</span><br><span class="line">      <span class="keyword">int</span> w = !ch[<span class="number">0</span>][root];</span><br><span class="line">      <span class="keyword">return</span> root = ch[w][root], <span class="built_in"><span class="keyword">void</span></span>( pre[root] = <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nd = ch[<span class="number">0</span>][root];</span><br><span class="line">    <span class="keyword">while</span> (ch[<span class="number">1</span>][nd] &gt; <span class="number">0</span>) nd = ch[<span class="number">1</span>][nd];</span><br><span class="line">    <span class="built_in">splay</span>(nd, ch[<span class="number">0</span>][root]);</span><br><span class="line">    ch[<span class="number">1</span>][nd] = ch[<span class="number">1</span>][root], pre[nd] = <span class="number">0</span>, root = pre[ch[<span class="number">1</span>][nd]] = nd;</span><br><span class="line">    <span class="built_in">maintain</span>(nd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Rnk</span><span class="params">(<span class="keyword">const</span> Item&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Ins</span>(v), size[ch[<span class="number">1</span>][root]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> Ti, lstans = <span class="number">7</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Ti);</span><br><span class="line">  <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%u&quot;</span>, &amp;m, &amp;n, &amp;seed);</span><br><span class="line"></span><br><span class="line">    Splay::nidx = root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">      A[i] = <span class="built_in">Item</span>(<span class="number">0</span>, <span class="number">0</span>), Splay::<span class="built_in">Ins</span>(A[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x, y; n; --n) &#123;</span><br><span class="line">      x = <span class="built_in">randNum</span>(seed, lstans, m), y = <span class="built_in">randNum</span>(seed, lstans, m);</span><br><span class="line">      Splay::<span class="built_in">Rmv</span>(A[x]), ++A[x].c, A[x].p += y;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lstans = Splay::<span class="built_in">Rnk</span>(A[x]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「TJOI2019」唱、跳、rap-和篮球"><a href="#「TJOI2019」唱、跳、rap-和篮球" class="headerlink" title="「TJOI2019」唱、跳、rap 和篮球"></a>「TJOI2019」唱、跳、rap 和篮球</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3106">https://loj.ac/problem/3106</a></li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>我们可用容斥原理计算讨论 [数据删除] 的队伍数.</p><p>记 $A_i$ 表示满足队伍中存在 $i$ 组讨论 [数据删除] 的集合, 最多情况下讨论 [数据删除] 的组数为 $m = \min \{ a, b, c, d, \lfloor \frac{n}{4} \rfloor \}$. 那么所有 $A_i$ 的补集交即为所求. 根据容斥原理可得</p><script type="math/tex; mode=display">|\bigcap_{i = 1} ^ m \bar A_i| = \sum_{k = 0} ^ m (-1) ^ k \sum_{1 \le i_1,\ \cdots,\ i_k \le n} |\bigcap_{j = 1} ^ k A_{i_j}|</script><p>队伍中每组讨论各在那个位置并不重要, 因此可枚举讨论组数 $k$, 得</p><script type="math/tex; mode=display">\sum_{k = 0} ^ m (-1) ^ k \binom{n - 3k}{k}\ g(n - 4k, a - k, b - k, c - k, d - k)</script><p>系数 $\binom{n - 3k}{k}$ 表示在队伍中选出 $k$ 组讨论的方案数. 可将每组讨论看作一个人, 那么队伍中人数为 $n - 3k$, 从中选择 $k$ 人作为讨论, 从而得到. </p><p>同时, $g(n, a, b, c, d)$ 表示剩余学生的排列数, 也就是可重集合的排列数. 即</p><script type="math/tex; mode=display">g(n, a, b, c, d) = \sum_{x_1 + x_2 + x_3 + x_4 = n} \binom{n}{x_1\; x_2\; x_3\; x_4} = n! \cdot \sum_{x_1 + x_2 + x_3 + x_4 = n} \frac{1}{x_1!\ x_2!\ x_3!\ x_4!}</script><p>其中 $x_1,\ x_2,\ x_3,\ x_4$ 满足 $x_1 \le a,\ x_2 \le b,\ x_3 \le c,\ x_4 \le d$.</p><p>显然是卷积的形式, 利用 NTT 计算 $g$ 即可.</p><p>时间复杂度 $O(n ^ 2 \log n)$. 似乎存在更加优秀的做法?</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3106</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LOG = <span class="number">13</span>, MAXN = <span class="number">1</span> &lt;&lt; LOG | <span class="number">1</span>, P = <span class="number">998244353</span>, G = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> W[LOG][MAXN];</span><br><span class="line"><span class="keyword">int</span> fac[MAXN], ifac[MAXN], inv[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">binom</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (n &lt; m)? <span class="number">0</span>: <span class="number">1LL</span> * fac[n] * ifac[m] % P * ifac[n - m] % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1LL</span> * ret * base % P;</span><br><span class="line">    base = <span class="number">1LL</span> * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">  <span class="keyword">int</span> r[MAXN];</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) <span class="built_in">swap</span>(f[i], f[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>, Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>, ++k) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span>* w = W[k];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j) &#123;</span><br><span class="line">          <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1LL</span> * w[j] * f[i+j+Mid] % P;</span><br><span class="line">          f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> inv = <span class="built_in">fpow</span>(Lim, P - <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1LL</span> * f[i] * inv % P;</span><br><span class="line">      <span class="built_in">reverse</span>(f + <span class="number">1</span>, f + Lim);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PolyPre</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">  inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">    inv[i] = <span class="number">1LL</span> * inv[P % i] * (P - P / i) % P;</span><br><span class="line">  fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    fac[i] = <span class="number">1LL</span> * i * fac[i - <span class="number">1</span>] % P;</span><br><span class="line">    ifac[i] = <span class="number">1LL</span> * inv[i] * ifac[i - <span class="number">1</span>] % P;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> w, i = <span class="number">0</span>, Mid = <span class="number">1</span>; i &lt; LOG; ++i, Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    W[i][<span class="number">0</span>] = <span class="number">1</span>, w = <span class="built_in">fpow</span>(G, (P - <span class="number">1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; Mid; ++j)</span><br><span class="line">      W[i][j] = <span class="number">1LL</span> * w * W[i][j - <span class="number">1</span>] % P;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN], C[MAXN], D[MAXN], f[MAXN];</span><br><span class="line">  <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (Lim &lt;= <span class="number">2</span> * (a + b + c + d)) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">  Poly::<span class="built_in">init</span>(Lim, L);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) &#123;</span><br><span class="line">    A[i] = (i &lt;= a)? ifac[i]: <span class="number">0</span>, B[i] = (i &lt;= b)? ifac[i]: <span class="number">0</span>;</span><br><span class="line">    C[i] = (i &lt;= c)? ifac[i]: <span class="number">0</span>, D[i] = (i &lt;= d)? ifac[i]: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Poly::<span class="built_in">NTT</span>(A, Lim, <span class="number">1</span>), Poly::<span class="built_in">NTT</span>(B, Lim, <span class="number">1</span>);</span><br><span class="line">  Poly::<span class="built_in">NTT</span>(C, Lim, <span class="number">1</span>), Poly::<span class="built_in">NTT</span>(D, Lim, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i)</span><br><span class="line">    f[i] = <span class="number">1LL</span> * A[i] * B[i] % P * C[i] % P * D[i] % P;</span><br><span class="line">  Poly::<span class="built_in">NTT</span>(f, Lim, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1LL</span> * f[n] * fac[n] % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a, b, c, d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>, &amp;n, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (a + b + c + d &lt; n)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">PolyPre</span>(<span class="number">2</span> * n);</span><br><span class="line">  <span class="keyword">int</span> N = <span class="built_in">min</span>(<span class="built_in">min</span>(a, <span class="built_in">min</span>(b, <span class="built_in">min</span>(c, d))), n / <span class="number">4</span>), ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="built_in">g</span>(n - <span class="number">4</span> * i, a - i, b - i, c - i, d - i) % P;</span><br><span class="line">    ans = (ans + <span class="number">1LL</span> * <span class="built_in">binom</span>(n - <span class="number">3</span> * i, i) * ((i &amp; <span class="number">1</span>)? P - s: s) % P) % P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「TJOI2019」大中锋的游乐场"><a href="#「TJOI2019」大中锋的游乐场" class="headerlink" title="「TJOI2019」大中锋的游乐场"></a>「TJOI2019」大中锋的游乐场</h3><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3107">https://loj.ac/problem/3107</a></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>注意到 $k \le 10$, 那么设 $f(i, j)$ 表示从起点 $s$ 出发到第 $i$ 个位置, 汉堡和可乐个数差值为 $j$ 时的最短路, 其中 $-k \le j \le k$.</p><p>直接在 Dijkstra 的过程中计算即可, 注意 $j$ 的范围, 以及不要忘了在起点处更新 $j$. 本质上为分层图最短路.</p><p>时间复杂度 $O(T n k \log m)$.</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3107</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e4</span> + <span class="number">5</span>, MAXM = <span class="number">1e5</span> + <span class="number">5</span>, MAXK = <span class="number">1e1</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, K, s, t;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], d[MAXN][MAXK];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, w; &#125; edges[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edges[++eidx] = (Edge)&#123; head[from], to, w &#125;, head[from] = eidx;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, k, d;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _u, <span class="keyword">int</span> _k, <span class="keyword">int</span> _d): <span class="built_in">u</span>(_u), <span class="built_in">k</span>(_k), <span class="built_in">d</span>(_d) &#123; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> d &gt; rhs.d; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;Node&gt; PQ;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    PQ.<span class="built_in">push</span>(<span class="built_in">Node</span>(s, K + A[s], d[s][K + A[s]] = <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!PQ.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">int</span> u = PQ.<span class="built_in">top</span>().u, k = PQ.<span class="built_in">top</span>().k, w = PQ.<span class="built_in">top</span>().d; PQ.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">if</span> (d[u][k] != w) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edges[i].to, vk = k + A[v];</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt;= vk &amp;&amp; vk &lt;= <span class="number">2</span> * K &amp;&amp; d[v][vk] &gt; d[u][k] + edges[i].w)</span><br><span class="line">          PQ.<span class="built_in">push</span>(<span class="built_in">Node</span>(v, vk, d[v][vk] = d[u][k] + edges[i].w));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span> * K; ++k) ret = <span class="built_in">min</span>(ret, d[t][k]);</span><br><span class="line">    <span class="keyword">return</span> ret &lt; INF? ret: <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> Ti; <span class="built_in">read</span>(Ti);</span><br><span class="line">  <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">    Graph::<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m), <span class="built_in">read</span>(K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="built_in">read</span>(A[i]), A[i] = (A[i] == <span class="number">1</span>)? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, w, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">      <span class="built_in">read</span>(u), <span class="built_in">read</span>(v), <span class="built_in">read</span>(w);</span><br><span class="line">      Graph::<span class="built_in">AddEdge</span>(u, v, w), Graph::<span class="built_in">AddEdge</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">read</span>(s), <span class="built_in">read</span>(t);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Graph::<span class="built_in">Dijkstra</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「TJOI2019」甲苯先生和大中锋的字符串"><a href="#「TJOI2019」甲苯先生和大中锋的字符串" class="headerlink" title="「TJOI2019」甲苯先生和大中锋的字符串"></a>「TJOI2019」甲苯先生和大中锋的字符串</h3><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3108">https://loj.ac/problem/3108</a></li></ul><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先有一个 (可能)? 不太常用的 SAM 性质:</p><blockquote><p>对于每一个状态 $v$ ，一个或多个子串与之匹配。我们记 $longest(v)$ 为其中最长的一个字符串，记 $len(v)$ 为它的长度。类似地，记 $shortest(v)$ 为最短的子串，它的长度为 $minlen(v)$ 。那么对应这个状态的所有字符串都是字符串 $longest(v)$ 的不同的后缀，且所有字符串的长度恰好覆盖区间 $[minlen(v),len(v)]$ 中的每一个整数。</p><p>对于初始状态 $t_0$ 以外的状态 $v$ ，可用后缀链接 $link(v)$ 表达 $minlen(v)$ ：</p><script type="math/tex; mode=display">minlen(v)=len(link(v))+1.</script><p>from <a href="https://oi-wiki.org/string/sam/#_4">OI Wiki</a></p></blockquote><p>那么在建出 SAM 后, 对于一个每个包含出现 $k$ 次子串的状态 $v$, 在长度区间 $\Big(len\big(link(v)\big),\ len(v)\Big]$ 上 $+1$, 最后统计答案即可. 可利用差分实现.</p><p>时间复杂度 $O(Tn)$.</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3108</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span> + <span class="number">5</span>, SIGMA = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K;</span><br><span class="line"><span class="keyword">char</span> S[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SAM &#123;</span><br><span class="line">  <span class="keyword">int</span> ch[MAXN][SIGMA], lnk[MAXN], len[MAXN], size[MAXN], lst, nidx;</span><br><span class="line">  <span class="keyword">int</span> f[MAXN], cnt[MAXN], idx[MAXN];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; l)</span> </span>&#123;</span><br><span class="line">    len[++nidx] = l, lnk[nidx] = <span class="number">0</span>, size[nidx] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memset</span>(ch[nidx], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[nidx]), nidx;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; nidx = <span class="number">0</span>, lst = <span class="built_in">newnode</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nd = <span class="built_in">newnode</span>(len[lst] + <span class="number">1</span>), p = lst;</span><br><span class="line">    size[nd] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; !ch[p][v]) ch[p][v] = nd, p = lnk[p];</span><br><span class="line">    <span class="keyword">if</span> (!p) lnk[nd] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> q = ch[p][v];</span><br><span class="line">      <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) lnk[nd] = q;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> nxt = <span class="built_in">newnode</span>(len[p] + <span class="number">1</span>);</span><br><span class="line">        lnk[nxt] = lnk[q], <span class="built_in">memcpy</span>(ch[nxt], ch[q], <span class="keyword">sizeof</span> ch[nxt]);</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; ch[p][v] == q) ch[p][v] = nxt, p = lnk[p];</span><br><span class="line">        lnk[nd] = lnk[q] = nxt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lst = nd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R)</span> </span>&#123; ++f[L], --f[R + <span class="number">1</span>]; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, (n + <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, (n + <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nidx; ++i) ++cnt[len[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nidx; i; --i) idx[cnt[len[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, i = nidx; i; --i) &#123;</span><br><span class="line">      u = idx[i], size[lnk[u]] += size[u];</span><br><span class="line">      <span class="keyword">if</span> (size[u] == K) <span class="built_in">Mdy</span>(len[lnk[u]] + <span class="number">1</span>, len[u]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>, Mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i)</span><br><span class="line">      <span class="keyword">if</span> (f[i] &gt; Mx) Mx = f[i], ret = i;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> Ti;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Ti);</span><br><span class="line">  <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">    SAM::<span class="built_in">init</span>(), <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, S + <span class="number">1</span>, &amp;K);</span><br><span class="line">    n = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(S + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) SAM::<span class="built_in">Ins</span>(S[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, SAM::<span class="built_in">solve</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「TJOI2019」甲苯先生的线段树"><a href="#「TJOI2019」甲苯先生的线段树" class="headerlink" title="「TJOI2019」甲苯先生的线段树"></a>「TJOI2019」甲苯先生的线段树</h3><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><del><a href="https://loj.ac/problem/3109">https://loj.ac/problem/3109</a></del></li><li><a href="https://codeforces.com/problemset/problem/750/G">https://codeforces.com/problemset/problem/750/G</a></li></ul><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先考虑 $c = 1$ 的情况.</p><p>首先可以观察到一个性质: 对于每一个节点, 除去最高位, 可通过其他位上 0 / 1 的区别, 我们可以确定该节点在不同层上选择左 / 右节点.</p><p>因此, 对于线段树上两个节点 $x$, $y$, 其在线段树上 LCA 为 $x$, $y$ 在二进制表示下, 将高位对齐得到的 LCP.</p><p>同时, 一个节点 $x$ 到根节点路径上编号和为 $2x - \operatorname{popcount}(x)$. 其中 $\operatorname{popcount}(x)$ 表示 $x$ 在二进制表示下 $1$ 的个数. 当然直接在线段树上暴力向上跳也可以.</p><p>简单证明一下, 考虑祖先中出现多出一次左儿子的影响, 体现在二进制表示下即某位改变为 $1$. 将多出的贡献单独拿出来计算, 等同于再次从根节点开始的贡献, 只不过深度改变了. 那么答案为 $2x - \operatorname{popcount}(x)$.</p><p>考虑 $c = 2$ 的情况.</p><p>记第一问求出的答案为 $s$, 有一个重要的性质: 设两节点 $x$, $y$ 的 LCA $z$, $z$ 到 $x$ 链长 $a$, 到 $y$ 链长 $b$. 如果 $a$, $b$, $s$ 确定, 那么 $z$ 的位置唯一.</p><p>简单证明一下. 不妨令 $x &lt; y$. 同时记 $z$ 在二进制表示下有 $t$ 位, 那么 $x$ 在二进制表示下有 $t + a$ 位, $y$ 在二进制表示下有 $t + b$ 位.</p><p>先考虑 $x$, $y$ 前 $t$ 位路径编号和 $s$ 的贡献. 即</p><script type="math/tex; mode=display">\left(\sum_{i = 0} ^ a 2 ^ i + \sum_{i = 0} ^ b 2 ^ i - 1\right)\cdot z = \left( 2 ^ {a + 1} + 2 ^ {b + 1} - 3 \right) \cdot z</script><p>另外有 $x$ 后 $a$ 位, $y$ 后 $b$ 位的贡献. 考虑取最值的两种情况, 即在满足条件的情况下不断向左 / 右走, 可得最小值为 $2 ^ b - 1$, 最大值为 $\left(2 ^ a - 1 - a\right) + \left(2 ^ {b + 1} - 1 - b\right)$.</p><p>因此可将 $s$ 表示为 $s = vz + k$ 的形式, 其中 $v = 2 ^ {a + 1} + 2 ^ {b + 1} - 3$, $k \in [2 ^ b - 1,\ 2 ^ a + 2 ^ {b + 1} - a - b - 3]$. 从而有 $z = \lfloor \frac{s - k}{v} \rfloor$. 注意到 $k &lt; v$, 因此 $z$ 和 $k$ 无关, $z$ 在 $a$, $b$ 确定后唯一.</p><p>此时枚举 $a$, $b$ 的取值, 求满足 $k = s - vz$ 的方案数即可. 根据前文的性质, 此时的问题可转化为, 给定一长为 $a - 1$ 的 0-1 串 $A$ 和一长为 $b$ 的 0-1 串 $B$, 求满足 $2A - \operatorname{popcount}(A) + 2B - \operatorname{popcount}(B) = k$ 的 $A$, $B$ 方案数.</p><p>DP 计算即可. 具体地, 首先枚举 $\operatorname{popcount}(A) + \operatorname{popcount}(B)$ 取值 $w$, 那么限制为 $2(A + B) = k + w$.</p><p>设 $f(i, j, k)$, $k \in \{0,\ 1\}$ 表示考虑前 $i$ 位, 共凑出 $j$ 个 $1$, 且当前位是否存在进位的方案数. 转移即为</p><script type="math/tex; mode=display">f(i, j + p + q, \lfloor \frac{p + q + k}{2} \rfloor) = \sum_{p,\ q} f(i - 1, j, k)</script><p>实现时需要注意, 要强制 $A$ 的第 $a$ 位为 $0$, 以及 $B$ 的第 $b$ 位为 $1$, 同时要满足 $A + B$ 二进制表示下每一位和 $\frac{1}{2}(k + w)$ 相同.</p><p>时间复杂度 $O(d ^ 5)$.</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3109</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXD = <span class="number">5e2</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line">LL f[MAXD &lt;&lt; <span class="number">1</span>][MAXD &lt;&lt; <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Dist</span><span class="params">(<span class="keyword">const</span> LL&amp; x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * x - __builtin_popcountll(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">LCA</span><span class="params">(LL u, LL v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (u != v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (u &lt; v) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lg2</span><span class="params">(LL s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (s &gt; <span class="number">0</span>) s &gt;&gt;= <span class="number">1</span>, ++ret;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(<span class="keyword">const</span> LL&amp; s, <span class="keyword">const</span> <span class="keyword">int</span>&amp; c, <span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> limit = <span class="built_in">max</span>(<span class="built_in">lg2</span>(s), <span class="built_in">max</span>(a - <span class="number">1</span>, b));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= limit; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= c; ++j) f[i][j][<span class="number">0</span>] = f[i][j][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt;= <span class="number">1</span>; ++p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= <span class="number">1</span> &amp;&amp; p == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; q &lt;= <span class="number">1</span>; ++q) <span class="keyword">if</span> (p + q &lt;= c) &#123;</span><br><span class="line">      <span class="keyword">if</span> (((p + q) &amp; <span class="number">1</span>) != (s &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> ((b &lt; <span class="number">1</span> &amp;&amp; q == <span class="number">1</span>) || (b == <span class="number">1</span> &amp;&amp; q == <span class="number">0</span>)) <span class="keyword">continue</span>;</span><br><span class="line">      ++f[<span class="number">0</span>][p + q][(p + q) / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= limit; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= c; ++j)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">1</span>; ++k) <span class="keyword">if</span> (f[i - <span class="number">1</span>][j][k] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt;= <span class="number">1</span>; ++p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= a - <span class="number">1</span> &amp;&amp; p == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; q &lt;= <span class="number">1</span>; ++q) <span class="keyword">if</span> (j + p + q &lt;= c) &#123;</span><br><span class="line">          <span class="keyword">if</span> (((k + p + q) &amp; <span class="number">1</span>) != ((s &gt;&gt; i) &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">if</span> ((i &gt; b - <span class="number">1</span> &amp;&amp; q == <span class="number">1</span>) || (i == b - <span class="number">1</span> &amp;&amp; q == <span class="number">0</span>)) <span class="keyword">continue</span>;</span><br><span class="line">          f[i][j + p + q][(k + p + q) / <span class="number">2</span>] += f[i - <span class="number">1</span>][j][k];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> f[limit][c][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> Ti, c;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Ti);</span><br><span class="line">  <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">    LL x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%lld%d&quot;</span>, &amp;d, &amp;x, &amp;y, &amp;c);</span><br><span class="line">    LL z = <span class="built_in">LCA</span>(x, y), s = <span class="built_in">Dist</span>(x) + <span class="built_in">Dist</span>(y) - <span class="built_in">Dist</span>(z) - <span class="built_in">Dist</span>(z &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, s);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      LL ans = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; d; ++a)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; d; ++b) &#123;</span><br><span class="line">          LL v = (<span class="number">1LL</span> &lt;&lt; (a + <span class="number">1</span>)) + (<span class="number">1LL</span> &lt;&lt; (b + <span class="number">1</span>)) - <span class="number">3</span>;</span><br><span class="line">          <span class="keyword">if</span> (v == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">          z = s / v;</span><br><span class="line">          <span class="keyword">if</span> (z &lt;= <span class="number">0</span> || <span class="built_in">lg2</span>(z) + <span class="built_in">max</span>(a, b) &gt; d) <span class="keyword">continue</span>;</span><br><span class="line">          LL k = s - v * z;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= a + b; ++i)</span><br><span class="line">            <span class="keyword">if</span> ((k + i) % <span class="number">2</span> == <span class="number">0</span>) ans += <span class="built_in">solve</span>((k + i) / <span class="number">2</span>, i, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;del&gt;我没有在刷水题 (确信&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;打 扰 了.&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>SNOI 2019 简要题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/sx/SNOI-2019-sol/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/sx/SNOI-2019-sol/</id>
    <published>2020-05-15T11:00:58.000Z</published>
    <updated>2020-05-17T11:21:48.257Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>这套题我做过, 我记得不是很水的吗?</p><p>from 某神仙</p></blockquote><span id="more"></span><h3 id="「SNOI2019」字符串"><a href="#「SNOI2019」字符串" class="headerlink" title="「SNOI2019」字符串"></a>「SNOI2019」字符串</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3095">https://loj.ac/problem/3095</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这是一道小清新字符串题.</p><p>可以观察到一个性质: 对于串 $s_i$, $s_j$ 之间的比较, 只需比较原串 $a_{i\ldots j}$ 的部分即可, 因为只有这部分两串不同.</p><p>先考虑任意两相邻字符不同的情况. 此时若有 $a_{i + 1} &lt; a_i$, 则一定有 $s_i &lt; s_j\ (i &lt; j)$. 也就是在比较 $s_i$ 和 $s_j$ 的过程中, $a_{i + 1}$ 一定是第一次两串不同的位置, $a_i$ 和 $a_{i + 1}$ 的大小决定了 $s_i$ 和 $s_j$ 的大小关系.</p><p>此时从后向前扫描串 $a$. 每加入一个位置 $i$ 时, 可以直接得出 $s_i$ 和已加入串的大小关系, 利用双端队列维护排序后的结果即可.</p><p>接着考虑相邻相同字符的影响. 如果 $i$, $j$ 都在相同字符的范围之内, 即 $a_{i \ldots j}$ 相同, 那么 $s_i$ 和 $s_j$ 的顺序只能通过 $i$, $j$ 大小决定. 对于此种情况, 直接将所有相邻相同字符合并为一个位置, 对合并后的结果利用上述方法排序, 在内部按照编号大小排序就好了.</p><p>时间复杂度 $O(n)$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3095</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ns;</span><br><span class="line"><span class="keyword">char</span> a[MAXN], s[MAXN];</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; Idx[MAXN];</span><br><span class="line"><span class="keyword">int</span> idx[MAXN], Ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;string/s3.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, a + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j, i = <span class="number">1</span>; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">    j = i;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n &amp;&amp; a[i] == a[j + <span class="number">1</span>]) ++j;</span><br><span class="line">    s[++ns] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; ++k)</span><br><span class="line">      Idx[ns].<span class="built_in">push_back</span>(k);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Q.<span class="built_in">push_front</span>(ns);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = ns - <span class="number">1</span>; i; --i)</span><br><span class="line">    <span class="keyword">if</span> (s[i + <span class="number">1</span>] &lt; s[i]) Q.<span class="built_in">push_front</span>(i); <span class="keyword">else</span> Q.<span class="built_in">push_back</span>(i);</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; v: Q) idx[++c] = v;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> rnk = <span class="number">0</span>, i = <span class="number">1</span>; i &lt;= c; ++i) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; u = idx[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; v: Idx[u]) Ans[++rnk] = v;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, Ans[i], <span class="string">&quot; \n&quot;</span>[i == n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SNOI2019」数论"><a href="#「SNOI2019」数论" class="headerlink" title="「SNOI2019」数论"></a>「SNOI2019」数论</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3096">https://loj.ac/problem/3096</a></li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>考虑到 $P$, $Q$ 的顺序对答案没有影响, 不妨令 $P \le Q$.</p><p>如果不断枚举 $x$, 则 $x$ 在模 $P$, $Q$ 意义下的值一定会出现循环, 且循环节长度 $l$ 为</p><script type="math/tex; mode=display">l = \frac{\operatorname{lcm}(P, Q)}{P} = \frac{Q}{\gcd(P, Q)}</script><p>考虑到若 $x$ 满足 $\left( x \bmod P \in A \right) \land \left( x \bmod Q \in B \right)$, 那么 $x$ 一定能表示为 $x = A_i + k \cdot P$ 的形式, 注意到 $Q$ 的值并不是很大, 可以统计出模 $Q$ 意义下所有环的权值, 最后对于每个 $A_i$ 统计答案.</p><p>枚举 $x$ 在模 $Q$ 意义下的值, 并标记集合 $B$ 中的元素, 记其权值为 $1$. 找出所有环, 并记环的权值为环内元素权值的和.</p><p>形象地说, 每个环就是在图上, 由点 $x$ 向点 $(x + P) \bmod Q$ 连边, 找环的过程就是一遍 DFS.</p><p>最后考虑如何统计答案. 注意到 $x \in [0,\ T)$, 那么 $k \le \lfloor \frac{T - 1 - A_i}{P} \rfloor$. 此时 $x$ 会经过 $\lfloor \frac{k}{l} \rfloor$ 次完整的环, 同时剩余 $k \bmod l$ 的步数尚未行走.</p><p>对于完整的环, 直接记录环上权值总和即可; 对于剩余的部分, 可记录环上权值的前缀和统计. 为避免跨过最后一个节点的讨论, 直接将环上元素复制一遍接到原有环的后面再统计前缀和.</p><p>时间复杂度 $O(n)$.</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3096</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> !b? a: <span class="built_in">gcd</span>(b, a % b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> P, Q, n, m; LL T;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; Cyc[MAXN], s[MAXN];</span><br><span class="line"><span class="keyword">int</span> val[MAXN], w[MAXN], pos[MAXN], col[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; lgt)</span> </span>&#123; <span class="comment">// (pos_u, pos_u + lgt]</span></span><br><span class="line">  <span class="keyword">return</span> s[col[u]][pos[u] + lgt] - s[col[u]][pos[u]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;number/s2.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">read</span>(P), <span class="built_in">read</span>(Q), <span class="built_in">read</span>(n), <span class="built_in">read</span>(m), <span class="built_in">read</span>(T);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(A[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">read</span>(B[i]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (P &gt; Q) <span class="built_in">swap</span>(P, Q), <span class="built_in">swap</span>(n, m), <span class="built_in">swap</span>(A, B);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> nC = <span class="number">0</span>, lgt = Q / <span class="built_in">gcd</span>(P, Q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) val[B[i]] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; Q; ++x) <span class="keyword">if</span> (!col[x]) &#123;</span><br><span class="line">    ++nC;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = x; col[u] != nC; u = (u + P) % Q)</span><br><span class="line">      col[u] = nC, Cyc[nC].<span class="built_in">push_back</span>(u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; v: Cyc[nC])</span><br><span class="line">      w[nC] += val[v];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= nC; ++c) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; Cyc[c].<span class="built_in">size</span>(); ++i)</span><br><span class="line">      pos[Cyc[c][i]] = i;</span><br><span class="line">    <span class="keyword">size_t</span> limit = Cyc[c].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; limit; ++i) Cyc[c].<span class="built_in">push_back</span>(Cyc[c][i]);</span><br><span class="line">    s[c].<span class="built_in">resize</span>(Cyc[c].<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; Cyc[c].<span class="built_in">size</span>(); ++i)</span><br><span class="line">      s[c][i] = ((i &gt; <span class="number">0</span>)? s[c][i - <span class="number">1</span>]: <span class="number">0</span>) + val[Cyc[c][i]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LL ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; a = A[i];</span><br><span class="line">    LL k = (T - <span class="number">1</span> - a) / P;</span><br><span class="line">    ans += (k / lgt) * w[col[a]] + <span class="built_in">sum</span>(a, k % lgt) + val[a];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SNOI2019」通信"><a href="#「SNOI2019」通信" class="headerlink" title="「SNOI2019」通信"></a>「SNOI2019」通信</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3097">https://loj.ac/problem/3097</a></li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先有一个共计 $O(n ^ 2)$ 条边的网络流做法:</p><p>设源汇分别为 $S$, $T$, 同时将每个点 $i$ 拆为两点 $x_i$, $y_i$. 连边</p><ul><li>$S \rightarrow x_i$, 容量为 $1$, 费用为 $0$.</li><li>$S \rightarrow y_i$, 容量为 $1$, 费用为 $W$.</li><li>$y_i \rightarrow T$, 容量为 $1$, 费用为 $0$.</li><li>对于满足 $i &lt; j$ 的点, $x_i \rightarrow y_j$, 容量为 $1$, 费用为 $\lvert a_i - a_j \lvert$.</li></ul><p>考虑如何优化. 注意到建边的瓶颈处, 也就是最后一组连边, 和 $a_i$ 的值有关. 有一个思路为, 对于每一个 $a_i$, 都建一个新点, 按大小顺序在新点间建来回两条边, 容量为 $\infty$, 费用为 $\lvert a_{i + 1} - a_i \rvert$. 同时对于每个 $x_i$ 二分到其所在权值代表的位置 $p$, 连边 $p \rightarrow x_i$; 同理有 $p’ \rightarrow y_i$.</p><p>不过这样的方式有很大的缺陷, 即无法确定从 $x_i$ 到达 $a_i$ 位置的流量, 是否一定流向编号较大的 $y_j$.</p><p>考虑用分治解决这个问题. 设当前分治区间为 $[L,\ R]$, 记 $M$ 为区间中点. 那么只令 $[L,\ M]$ 范围内的点向新点连边, 新点向 $(M,\ R]$ 范围内的点连边. 此时边数为 $O(n \log n)$.</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>SPFA 的队列还是用 STL 好.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3097</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span> + <span class="number">5</span>, MAXV = MAXN &lt;&lt; <span class="number">6</span>, MAXE = MAXV * <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> LL INFLL = <span class="number">0x3f3f3f3f3f3f3f3f</span>LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, W, S, T;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN], nB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, cap, flow, cost; &#125; edges[MAXE &lt;&lt; <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> head[MAXV], eidx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edges[++eidx] = (Edge)&#123; head[from], to, c, <span class="number">0</span>, w &#125;, head[from] = eidx;</span><br><span class="line">    edges[++eidx] = (Edge)&#123; head[to], from, <span class="number">0</span>, <span class="number">0</span>, -w &#125;, head[to] = eidx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MCMF &#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">  LL d[MAXV];</span><br><span class="line">  <span class="keyword">int</span> cur[MAXV], vis[MAXV], Time;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    Q.<span class="built_in">push</span>(S);</span><br><span class="line">    d[S] = <span class="number">0</span>, vis[S] = ++Time;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">int</span> u = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">      vis[u] = Time - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">const</span> Edge&amp; e = edges[i];</span><br><span class="line">        <span class="keyword">if</span> (d[e.to] &gt; d[u] + e.cost &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">          d[e.to] = d[u] + e.cost;</span><br><span class="line">          <span class="keyword">if</span> (vis[e.to] != Time) Q.<span class="built_in">push</span>(e.to), vis[e.to] = Time;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[T] &lt; INFLL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> a, LL&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == T || !a) <span class="keyword">return</span> a;</span><br><span class="line">    vis[u] = Time;</span><br><span class="line">    <span class="keyword">int</span> f, flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">      Edge&amp; e = edges[i];</span><br><span class="line">      <span class="keyword">if</span> (vis[e.to] != Time &amp;&amp; d[e.to] == d[u] + e.cost &amp;&amp;</span><br><span class="line">          (f = <span class="built_in">DFS</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow), cost)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cost += f * e.cost;</span><br><span class="line">        flow += f, a -= f, e.flow += f, edges[i ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">        <span class="keyword">if</span> (!a) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">LL <span class="title">MCMF</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">SPFA</span>()) &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span> cur);</span><br><span class="line">        ++Time, <span class="built_in">DFS</span>(S, INF, ret);</span><br><span class="line">      &#125; <span class="keyword">while</span> (vis[T] == Time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> uidx;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; type, <span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (type == <span class="number">2</span>)? uidx + u: type * n + u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L == R)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">solve</span>(L, Mid), <span class="built_in">solve</span>(Mid + <span class="number">1</span>, R);</span><br><span class="line">  nB = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) B[++nB] = A[i];</span><br><span class="line">  <span class="built_in">sort</span>(B + <span class="number">1</span>, B + <span class="number">1</span> + nB);</span><br><span class="line">  nB = <span class="built_in">unique</span>(B + <span class="number">1</span>, B + <span class="number">1</span> + nB) - B - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nB; ++i) &#123;</span><br><span class="line">    Graph::<span class="built_in">AddEdge</span>(<span class="built_in">idx</span>(<span class="number">2</span>, i), <span class="built_in">idx</span>(<span class="number">2</span>, i + <span class="number">1</span>), INF, B[i + <span class="number">1</span>] - B[i]);</span><br><span class="line">    Graph::<span class="built_in">AddEdge</span>(<span class="built_in">idx</span>(<span class="number">2</span>, i + <span class="number">1</span>), <span class="built_in">idx</span>(<span class="number">2</span>, i), INF, B[i + <span class="number">1</span>] - B[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="built_in">lower_bound</span>(B + <span class="number">1</span>, B + <span class="number">1</span> + nB, A[i]) - B;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= Mid) <span class="comment">// [L, Mid] --&gt; (Mid, R]</span></span><br><span class="line">      Graph::<span class="built_in">AddEdge</span>(<span class="built_in">idx</span>(<span class="number">0</span>, i), <span class="built_in">idx</span>(<span class="number">2</span>, p), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      Graph::<span class="built_in">AddEdge</span>(<span class="built_in">idx</span>(<span class="number">2</span>, p), <span class="built_in">idx</span>(<span class="number">1</span>, i), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  uidx += nB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  Graph::<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;W);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, A + i);</span><br><span class="line"></span><br><span class="line">  uidx = <span class="number">2</span> * n, <span class="built_in">solve</span>(<span class="number">1</span>, n);</span><br><span class="line">  S = <span class="number">0</span>, T = uidx + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    Graph::<span class="built_in">AddEdge</span>(<span class="built_in">idx</span>(<span class="number">1</span>, i), T, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    Graph::<span class="built_in">AddEdge</span>(S, <span class="built_in">idx</span>(<span class="number">0</span>, i), <span class="number">1</span>, <span class="number">0</span>), Graph::<span class="built_in">AddEdge</span>(S, <span class="built_in">idx</span>(<span class="number">1</span>, i), <span class="number">1</span>, W);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, MCMF::<span class="built_in">MCMF</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SNOI2019」纸牌"><a href="#「SNOI2019」纸牌" class="headerlink" title="「SNOI2019」纸牌"></a>「SNOI2019」纸牌</h3><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3098">https://loj.ac/problem/3098</a></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>常规计数题.</p><p>注意到题目给定的两方案相同的定义, “两组牌相同当且仅当它们含有的每一种牌数量都相同”, 那么相同牌组成的顺子不超过 $2$ 组, 因为超过两组就将多余部分视为刻子.</p><p>于是 DP 时直接记录顺子个数即可. 具体的, 设 $f(i, j, k)$ 表示处理完前 $i$ 种牌, 其中有形如 $(i - 1, i, i + 1)$ 的顺子 $j$ 组, 形如 $(i, i + 1, i + 2)$ 的顺子 $k$ 组. 转移时需考虑 $a_i$ 的限制, 此时将 “初始有 $a_i$ 张 $k_i$ 号牌” 的限制看作 “$k_i$ 号牌至少选择 $a_i$ 张”, 同时对于未限制的牌有 $a_i = 0$.</p><p>具体地, 记 $s = i + j + k$, 表示 $i + 1$ 参与组成的顺子个数. 有转移</p><script type="math/tex; mode=display">f(i + 1, k, s) = \begin{cases} f(i, j, k) \cdot \left(\lfloor \dfrac{c - s}{3} \rfloor + 1\right) & s \ge a_{i + 1} \\ f(i, j, k) \cdot \left(\lfloor \dfrac{c - \left(s + 3 \cdot \lceil \frac{a_{i + 1} - s}{3} \rceil\right) }{3} \rfloor + 1\right) & s < a_{i + 1}\end{cases}</script><p>其中 $s \le C$.</p><p>笼统地解释一下, 就是在选择 $i + 1$ 号牌时, 如果不满足限制就选择刻子, 否则不选择刻子.</p><p>可以发现, 在 $a_i$ 一定时, 这个转移个第一维关系不大, 那么可以用一 $9 \times 9$ 的矩阵描述这个转移, 同时利用矩阵快速幂加速运算.</p><p>将 $a_i \neq 0$ 的位置称作关键点, 那么关键点个数为 $X$. 预先处理出 $a_i = 0$ 的情况, 转移两关键点之间的部分; 每次根据 $a_i$ 值重构转移矩阵, 转移关键点位置.</p><p>时间复杂度 $O(X \log n)$, 同时带有矩阵乘法的常数.</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p>注意 $k_i$ 的取值范围, 需要 <code>long long</code>.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3098</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">9</span>, P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> g[MAXM][MAXM];</span><br><span class="line">  <span class="built_in">Matrix</span>() &#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXM; ++i) g[i][i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g); &#125;</span><br><span class="line">  Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    Matrix ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXM; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; MAXM; ++k) <span class="keyword">if</span> (g[i][k] != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; MAXM; ++j) <span class="keyword">if</span> (rhs.g[k][j] != <span class="number">0</span>)</span><br><span class="line">          ret.g[i][j] = (ret.g[i][j] + <span class="number">1LL</span> * g[i][k] * rhs.g[k][j] % P) % P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; f, g, h;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">fpow</span><span class="params">(Matrix base, LL b)</span> </span>&#123;</span><br><span class="line">  Matrix ret; ret.<span class="built_in">unit</span>();</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * base;</span><br><span class="line">    base = base * base, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL n, K; <span class="keyword">int</span> X, C;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld%d%d&quot;</span>, &amp;n, &amp;C, &amp;X);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = i + j + k;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= C) h.g[<span class="number">3</span> * i + j][<span class="number">3</span> * j + k] = (C - s) / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  LL lst = <span class="number">0</span>;</span><br><span class="line">  f.g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> a, i = <span class="number">1</span>; i &lt;= X; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%d&quot;</span>, &amp;K, &amp;a);</span><br><span class="line">    g.<span class="built_in">init</span>(), f = f * <span class="built_in">fpow</span>(h, K - lst - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">3</span>; ++l) &#123;</span><br><span class="line">          <span class="keyword">int</span> s = j + k + l;</span><br><span class="line">          <span class="keyword">if</span> (s &lt; a) s = s + ((a - s + <span class="number">2</span>) / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">          <span class="keyword">if</span> (s &lt;= C) g.g[<span class="number">3</span> * j + k][<span class="number">3</span> * k + l] = (C - s) / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    f = f * g, lst = K;</span><br><span class="line">  &#125;</span><br><span class="line">  f = f * <span class="built_in">fpow</span>(h, n - lst);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f.g[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SNOI2019」积木"><a href="#「SNOI2019」积木" class="headerlink" title="「SNOI2019」积木"></a>「SNOI2019」积木</h3><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3099">https://loj.ac/problem/3099</a></li></ul><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>还是 <a href="https://yhx-12243.github.io/OI-transit/records/lg5372%3Bloj3099.html">yhx-12243 的题解</a> 更为清晰明朗.</p><p>注意到题目中并未要求给出的操作数最少, 只需构造出长度限制可被接受的操作序列即可.</p><p>由上述题解的解释, 每次移动空白格的位置, 本质是找环和沿环行走的过程. 每次保证移动后, 有一个位置和最终状态匹配即可, 此时每个位置只会被搜索到一次.</p><p>时间复杂度 $O(nm)$, 构造的操作序列长度为 $2nm$.</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><p>一些实现的技巧参考了 <a href="https://www.cnblogs.com/PaperCloud/p/11289173.html">PaperCloud</a>.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3099</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(args...) fprintf(stderr, ##args)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;, dy[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, nxt[][<span class="number">2</span>] = &#123;</span><br><span class="line">  &#123; <span class="number">0</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">2</span>, <span class="number">3</span> &#125;, &#123; <span class="number">3</span>, <span class="number">2</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e3</span> + <span class="number">5</span>, SIGMA = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x, y;</span><br><span class="line">  <span class="built_in">Point</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">Point</span>(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y): <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y) &#123; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> Point&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x != rhs.x || y != rhs.y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> S[MAXN], Ans[MAXN];</span><br><span class="line"></span><br><span class="line">Point os, ot;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> MS[MAXN][MAXN], MT[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">InitMap</span><span class="params">(<span class="keyword">int</span> (*A)[MAXN])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> Map[SIGMA];</span><br><span class="line">  Map[<span class="string">&#x27;o&#x27;</span>] = <span class="number">-1</span>, Map[<span class="string">&#x27;&lt;&#x27;</span>] = <span class="number">0</span>, Map[<span class="string">&#x27;&gt;&#x27;</span>] = <span class="number">1</span>, Map[<span class="string">&#x27;n&#x27;</span>] = <span class="number">2</span>, Map[<span class="string">&#x27;u&#x27;</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Point <span class="title">ret</span><span class="params">(<span class="number">-1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, S + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">      A[i][j] = Map[(<span class="keyword">int</span>) S[j]];</span><br><span class="line">      <span class="keyword">if</span> (S[j] == <span class="string">&#x27;o&#x27;</span>) ret = <span class="built_in">Point</span>(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span> </span>&#123; <span class="comment">// os --&gt; n1 --&gt; n2</span></span><br><span class="line">  Point n1 = <span class="built_in">Point</span>(os.x + dx[k], os.y + dy[k]),</span><br><span class="line">        n2 = <span class="built_in">Point</span>(n1.x + dx[MS[n1.x][n1.y]], n1.y + dy[MS[n1.x][n1.y]]);</span><br><span class="line">  MS[os.x][os.y] = nxt[k][<span class="number">0</span>], os = n2;</span><br><span class="line">  MS[n1.x][n1.y] = nxt[k][<span class="number">1</span>], MS[n2.x][n2.y] = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&quot;RLDU&quot;</span>[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">augment</span><span class="params">(<span class="keyword">const</span> Point&amp; p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (os != p) <span class="built_in">move</span>(MT[os.x][os.y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> Point&amp; p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vis[p.x][p.y])</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  vis[p.x][p.y] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123; <span class="comment">// os --&gt; n1 --&gt; n2</span></span><br><span class="line">    Point n1 = <span class="built_in">Point</span>(p.x + dx[k], p.y + dy[k]);</span><br><span class="line">    <span class="keyword">if</span> (n1.x &lt; <span class="number">1</span> || n1.x &gt; n || n1.y &lt; <span class="number">1</span> || n1.y &gt; m || vis[n1.x][n1.y])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    Point n2 = <span class="built_in">Point</span>(n1.x + dx[MT[n1.x][n1.y]], n1.y + dy[MT[n1.x][n1.y]]);</span><br><span class="line">    <span class="keyword">if</span> (MS[n1.x][n1.y] != MT[n1.x][n1.y])</span><br><span class="line">      <span class="built_in">move</span>(k), <span class="built_in">augment</span>(n2), <span class="built_in">move</span>(MT[n2.x][n2.y]);</span><br><span class="line">    <span class="built_in">move</span>(k), vis[n1.x][n1.y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(n2), <span class="built_in">move</span>(MT[n2.x][n2.y]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  os = <span class="built_in">InitMap</span>(MS), ot = <span class="built_in">InitMap</span>(MT);</span><br><span class="line">  <span class="built_in">augment</span>(ot), <span class="built_in">dfs</span>(os), <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SNOI2019」网络"><a href="#「SNOI2019」网络" class="headerlink" title="「SNOI2019」网络"></a>「SNOI2019」网络</h3><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3100">https://loj.ac/problem/3100</a></li></ul><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a><del>解题思路</del></h4><p>这是能令人感到希望的一道题.</p><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;这套题我做过, 我记得不是很水的吗?&lt;/p&gt;
&lt;p&gt;from 某神仙&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>JSOI 2019 简要题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/sx/JSOI-2019-sol/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/sx/JSOI-2019-sol/</id>
    <published>2020-05-13T11:50:18.000Z</published>
    <updated>2020-05-31T03:42:11.117Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>JSOI 都是好题, 还不毒瘤.</p></blockquote><span id="more"></span><h3 id="「JSOI2019」精准预测"><a href="#「JSOI2019」精准预测" class="headerlink" title="「JSOI2019」精准预测"></a>「JSOI2019」精准预测</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3101">https://loj.ac/problem/3101</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这是一道 2-SAT 题.</p><p>首先有一个朴素的想法, 对于每个时刻 $t$ 每个火星人 (?) $x$, 拆为两个点 $(x, t, 0)$, $(x, t, 1)$, 分别代表生存和死亡. 那么由题意有连边</p><script type="math/tex; mode=display">(x, t + 1, 0) \rightarrow (x, t, 0) \\ (x, t, 1) \rightarrow (x, t + 1, 1)</script><p>论据: “火星人是不能够复活的”.</p><p>对于预测 $0$, 有连边</p><script type="math/tex; mode=display">(x, t, 1) \rightarrow (y, t + 1, 1) \\ (y, t + 1, 0) \rightarrow (x, t, 0)</script><p>后者来源为 2-SAT 的性质, 下文同理.</p><p>对于预测 $1$, 有连边</p><script type="math/tex; mode=display">(x, t, 0) \rightarrow (y, t, 1) \\ (y, t, 0) \rightarrow (x, t, 1)</script><p>对于计算答案, 可看作统计点 $(x, T + 1, 0)$ 到达其余形同 $(y, T + 1, 1)$ 点的个数, 即有向图传递闭包, 可利用 <code>bitset</code> 优化复杂度. 同时, 建出的图一定是一个 DAG, 直接 DFS 一遍即可. <del>当然跑强连通分量也是可以的.</del></p><p>同时要注意 $(x, T + 1, 0)$ 可达 $(x, T + 1, 1)$ 的情况, 打标记特判即可.</p><p>此时得到了时间复杂度为 $O(\frac{Tnm}{w})$, 空间复杂度为 $O(Tnm)$ 的优秀做法, 令人感到快乐.</p><p>注意实际有用处的点只有 $2 (n + 2m)$ 个, 即每次预测涉及的点, 以及 $T + 1$ 时刻计算答案的部分. 同时, 可以利用分块求解的技巧. 设块大小为 $B$, 每次只统计块大小 $B$ 规模的答案, 将每次计算后得出的结果合并即可.</p><p>综上, 时间复杂度 $O(\frac{n}{B} \cdot \frac{m(n + m)}{w})$, 空间复杂度 $O\big(B(n + m)\big)$, 此处的 $B$ 可取 $10 ^ 4$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3101</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(args...) fprintf(stderr, ##args)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e4</span> + <span class="number">5</span>, MAXM = <span class="number">1e5</span> + <span class="number">5</span>, BLOCK = <span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = (MAXN + <span class="number">2</span> * MAXM) &lt;&lt; <span class="number">1</span>, MAXE = MAXV + MAXM * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Evnt</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> opt, t, x, y;</span><br><span class="line">  <span class="built_in">Evnt</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">Evnt</span>(<span class="keyword">int</span> _opt, <span class="keyword">int</span> <span class="keyword">_t</span>, <span class="keyword">int</span> _x, <span class="keyword">int</span> _y): <span class="built_in">opt</span>(_opt), <span class="built_in">t</span>(<span class="keyword">_t</span>), <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y) &#123; &#125;</span><br><span class="line">&#125; A[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, T;</span><br><span class="line"><span class="keyword">int</span> Ans[MAXN], GG[MAXV], vis[MAXV], clk;</span><br><span class="line"></span><br><span class="line">bitset&lt;BLOCK&gt; f[MAXV], g;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; Time[MAXN], Idx[<span class="number">2</span>][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXE &lt;&lt; <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> head[MAXV], eidx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[u] == clk) <span class="keyword">return</span>;</span><br><span class="line">    vis[u] = clk;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">      <span class="built_in">dfs</span>(v = edges[i].to), f[u] |= f[v];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ps</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; p, <span class="keyword">const</span> <span class="keyword">int</span>&amp; t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">lower_bound</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), t) - p.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; c, <span class="keyword">const</span> <span class="keyword">int</span>&amp; u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Idx[c][u][p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  Graph::<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">read</span>(T), <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> c, t, x, y, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">read</span>(c), <span class="built_in">read</span>(t), <span class="built_in">read</span>(x), <span class="built_in">read</span>(y);</span><br><span class="line">    A[i] = <span class="built_in">Evnt</span>(c, t, x, y);</span><br><span class="line">    Time[x].<span class="built_in">push_back</span>(t), Time[y].<span class="built_in">push_back</span>(t + (c == <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> uidx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u) Time[u].<span class="built_in">push_back</span>(T + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u) &#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;&amp; Tu = Time[u];</span><br><span class="line">    <span class="built_in">sort</span>(Tu.<span class="built_in">begin</span>(), Tu.<span class="built_in">end</span>());</span><br><span class="line">    Tu.<span class="built_in">erase</span>(<span class="built_in">unique</span>(Tu.<span class="built_in">begin</span>(), Tu.<span class="built_in">end</span>()), Tu.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; Tu.<span class="built_in">size</span>(); ++i)</span><br><span class="line">      Idx[<span class="number">0</span>][u].<span class="built_in">push_back</span>(++uidx), Idx[<span class="number">1</span>][u].<span class="built_in">push_back</span>(++uidx);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; Idx[<span class="number">0</span>][u].<span class="built_in">size</span>(); ++i)</span><br><span class="line">      Graph::<span class="built_in">AddEdge</span>(<span class="built_in">idx</span>(<span class="number">0</span>, u, i + <span class="number">1</span>), <span class="built_in">idx</span>(<span class="number">0</span>, u, i));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; Idx[<span class="number">1</span>][u].<span class="built_in">size</span>(); ++i)</span><br><span class="line">      Graph::<span class="built_in">AddEdge</span>(<span class="built_in">idx</span>(<span class="number">1</span>, u, i), <span class="built_in">idx</span>(<span class="number">1</span>, u, i + <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = A[i].x, y = A[i].y, t = A[i].t;</span><br><span class="line">    <span class="keyword">if</span> (A[i].opt == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> px = <span class="built_in">ps</span>(Time[x], t), py = <span class="built_in">ps</span>(Time[y], t + <span class="number">1</span>);</span><br><span class="line">      Graph::<span class="built_in">AddEdge</span>(<span class="built_in">idx</span>(<span class="number">1</span>, x, px), <span class="built_in">idx</span>(<span class="number">1</span>, y, py));</span><br><span class="line">      Graph::<span class="built_in">AddEdge</span>(<span class="built_in">idx</span>(<span class="number">0</span>, y, py), <span class="built_in">idx</span>(<span class="number">0</span>, x, px));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (A[i].opt == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> px = <span class="built_in">ps</span>(Time[x], t), py = <span class="built_in">ps</span>(Time[y], t);</span><br><span class="line">      Graph::<span class="built_in">AddEdge</span>(<span class="built_in">idx</span>(<span class="number">0</span>, x, px), <span class="built_in">idx</span>(<span class="number">1</span>, y, py));</span><br><span class="line">      Graph::<span class="built_in">AddEdge</span>(<span class="built_in">idx</span>(<span class="number">0</span>, y, py), <span class="built_in">idx</span>(<span class="number">1</span>, x, px));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">1</span>; L &lt;= n; L += BLOCK) &#123;</span><br><span class="line">    <span class="keyword">int</span> R = <span class="built_in">min</span>(n, L + BLOCK - <span class="number">1</span>);</span><br><span class="line">    ++clk, g.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= uidx; ++u) f[u].<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; u: Idx[<span class="number">1</span>][i]) f[u].<span class="built_in">set</span>(i - L);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> u = Idx[<span class="number">0</span>][i].<span class="built_in">back</span>();</span><br><span class="line">      <span class="keyword">if</span> (vis[u] != clk) Graph::<span class="built_in">dfs</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> u = Idx[<span class="number">0</span>][i].<span class="built_in">back</span>();</span><br><span class="line">      <span class="keyword">if</span> (f[u][i - L]) g.<span class="built_in">set</span>(i - L), GG[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!GG[i])</span><br><span class="line">      u = Idx[<span class="number">0</span>][i].<span class="built_in">back</span>(), Ans[i] += (f[u] | g).<span class="built_in">count</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, GG[i]? <span class="number">0</span>: (n - <span class="number">1</span>) - Ans[i], <span class="string">&quot; \n&quot;</span>[i == n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「JSOI2019」神经网络"><a href="#「JSOI2019」神经网络" class="headerlink" title="「JSOI2019」神经网络"></a>「JSOI2019」神经网络</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3102">https://loj.ac/problem/3102</a></li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>这是一道不知道为什么就是写了很久调了很久的题 (</del></p><p>首先有一个重要的性质, 哈密顿回路经过的树边, 一定不是同一棵树上相邻的链组成的. 换言之, 树上相邻两条链在哈密顿回路上并不相邻. 根据这个性质, 可对于每棵树求出分出 $k$ 条链的方案数, 再利用容斥原理计算答案.</p><p>接下来的问题分作两部分</p><ol><li><p>计算每个树中, 分出 $k$ 条链的方案数.</p><p><em>(其实是一个很经典的树形 DP, 譬如<a href="https://loj.ac/problem/2478">「九省联考 2018」林克卡特树</a> 的某档部分分.)</em></p><p>设 $g(u, k, s)$ 表示 $u$ 的子树内, 总共组成 $k$ 条完整的链, 且包含节点 $u$ 的链状态为 $s$ 的方案数. 其中 $s \in \{ 0, 1, 2 \}$, 分别形同 <code>.</code>, <code>/</code>, <code>/\</code>, 也就是节点 $u$ 在子树一侧的链中保留的度数.</p><p>同时, 认为只有形成 $s = 2$ 的局面才认为是一条完整的链, 也就是说, $s = 0,\ 1$ 的情况并未计入总链数. 那么有初值</p><script type="math/tex; mode=display">g(u, 0, 0) = g(u, 0, 1) = g(u, 1, 2) = 1 \\ g(u, 1, 0) = g(u, 1, 1) = g(u, 0, 2) = 0</script><p>转移则枚举形成链条数即可, 具体式子可参考代码. 大体上讲, 转移分作两类</p><ol><li>儿子 $v$ 已形成一条完整的链, 此时直接合并到 $u$.</li><li>儿子 $v$ 未形成完整的链, 此时需找到 $u$ 中对应状态合并.</li></ol><p>注意在合适的时机更新 <code>size</code> 以保证时间复杂度, 以及在合并两条 $1$ 类链时, 要考虑到哈密顿回路上两条链顺序不同的影响, 乘 $2$ 作为系数.</p></li><li><p>容斥计算答案.</p><p>先忽略回路的影响, 计算哈密顿通路的个数. 记当前树中分出链个数为 $i$ 的方案数为 $f_i$, 那么根据容斥原理, 可得出当前树组成哈密顿通路个数的 EGF 为</p><script type="math/tex; mode=display">\sum_{i = 1} ^ n i!\ f_i \sum_{j = 1} ^ i (-1) ^ {i - j} \binom{i - 1}{i - j} \frac{x ^ j}{j!}</script><p>稍微解释一下. 考虑用补集交计算集合交. 枚举 $j$ 表示当前的 $i$ 条链, 包含 $j$ 部分在哈密顿通路上不相邻, 剩余 $i - j$ 部分相邻. 此时不相邻的 $j$ 部分在合并 EGF 时需去除标号影响, 因此乘系数 $\frac{1}{j!}$.</p><p>交换枚举顺序, 得到</p><script type="math/tex; mode=display">\sum_{i = 1} ^ n \left( \frac{1}{i!} \sum_{j = i} ^ n j!\ f_j \binom{j - 1}{j - i} \right) x ^ i</script><p>在得出 $f_i$ 之后容易在 $O(n ^ 2)$ 的时间复杂度内计算. 对于 $m$ 棵树的情况, 直接将每棵树的 EGF 相乘就好了.</p><p>记上述结果为 $H(x) = \sum\limits_{k = 0} ^ \infty \dfrac{h_k}{k!} x ^ k$, 考虑圆排列公式, 得到满足哈密顿回路限制时的 EGF 为</p><script type="math/tex; mode=display">F(x) = \sum_{k = 0} ^ \infty \frac{(k - 1)!}{k!} h_k \cdot x ^ k = \sum_{k = 0} ^ \infty \frac{h_k}{k} x ^ k</script><p>对 $F(x)$ 对应数列的每一项求和即可.</p></li></ol><p>时间复杂度为 $O\Big(\left(\sum k_i\right) ^ 2\Big)$, 瓶颈在于树形 DP.</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3102</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(args...) fprintf(stderr, ##args)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e3</span> + <span class="number">5</span>, P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fac[MAXN], ifac[MAXN], inv[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; n, <span class="keyword">const</span> <span class="keyword">int</span>&amp; m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (n &lt; m)? <span class="number">0</span>: <span class="number">1LL</span> * fac[n] * ifac[m] % P * ifac[n - m] % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PolyPre</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">  inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">    inv[i] = <span class="number">1LL</span> * inv[P % i] * (P - P / i) % P;</span><br><span class="line">  ifac[<span class="number">0</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    fac[i] = <span class="number">1LL</span> * i * fac[i - <span class="number">1</span>] % P;</span><br><span class="line">    ifac[i] = <span class="number">1LL</span> * inv[i] * ifac[i - <span class="number">1</span>] % P;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n, <span class="keyword">int</span>* g, <span class="keyword">const</span> <span class="keyword">int</span>&amp; m, <span class="keyword">int</span>* h)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN];</span><br><span class="line">  <span class="built_in">memset</span>(A, <span class="number">0</span>, (n + m - <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">int</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">      A[i + j] = (A[i + j] + <span class="number">1LL</span> * f[i] * g[j] % P) % P;</span><br><span class="line">  <span class="built_in">memcpy</span>(h, A, (n + m - <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">int</span>));</span><br><span class="line">  <span class="keyword">return</span> n + m - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> f[MAXN], h[MAXN], g[<span class="number">3</span>][MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> head[MAXN], size[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, (n + <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">int</span>)), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> LL tmp[<span class="number">3</span>][MAXN];</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    g[<span class="number">0</span>][u][<span class="number">0</span>] = g[<span class="number">1</span>][u][<span class="number">0</span>] = g[<span class="number">2</span>][u][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    g[<span class="number">0</span>][u][<span class="number">1</span>] = g[<span class="number">1</span>][u][<span class="number">1</span>] = g[<span class="number">2</span>][u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v, e = head[u]; ~e; e = edges[e].nxt) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((v = edges[e].to) == fa) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="built_in">dfs</span>(v, u);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size[u]; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= size[v]; ++j) &#123;</span><br><span class="line">          tmp[<span class="number">0</span>][i + j] += <span class="number">1LL</span> * g[<span class="number">0</span>][u][i] * g[<span class="number">2</span>][v][j] % P;</span><br><span class="line">          tmp[<span class="number">1</span>][i + j] += <span class="number">1LL</span> * g[<span class="number">1</span>][u][i] * g[<span class="number">2</span>][v][j] % P;</span><br><span class="line">          tmp[<span class="number">1</span>][i + j] += <span class="number">1LL</span> * g[<span class="number">0</span>][u][i] * g[<span class="number">1</span>][v][j] % P;</span><br><span class="line">          tmp[<span class="number">2</span>][i + j] += <span class="number">1LL</span> * g[<span class="number">2</span>][u][i] * g[<span class="number">2</span>][v][j] % P;</span><br><span class="line">          tmp[<span class="number">2</span>][i + j + <span class="number">1</span>] += <span class="number">2LL</span> * g[<span class="number">1</span>][u][i] * g[<span class="number">1</span>][v][j] % P;</span><br><span class="line">        &#125;</span><br><span class="line">      size[u] += size[v];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size[u]; ++i)</span><br><span class="line">          g[j][u][i] = tmp[j][i] % P, tmp[j][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> dh = <span class="number">0</span>;</span><br><span class="line">  h[dh++] = <span class="number">1</span>, <span class="built_in">PolyPre</span>(MAXN - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), Graph::<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v), Graph::<span class="built_in">AddEdge</span>(u, v), Graph::<span class="built_in">AddEdge</span>(v, u);</span><br><span class="line">    Graph::<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> s1 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; ++j) &#123;</span><br><span class="line">        <span class="keyword">int</span> s0 = <span class="number">1LL</span> * fac[j] * g[<span class="number">2</span>][<span class="number">1</span>][j] % P * <span class="built_in">C</span>(j - <span class="number">1</span>, i - <span class="number">1</span>) % P;</span><br><span class="line">        s1 = (s1 + (((j - i) &amp; <span class="number">1</span>)? P - s0: s0)) % P;</span><br><span class="line">      &#125;</span><br><span class="line">      f[i] = <span class="number">1LL</span> * s1 * ifac[i] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    dh = <span class="built_in">Mul</span>(f, n + <span class="number">1</span>, h, dh, h);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; dh; ++k)</span><br><span class="line">    ans = (ans + <span class="number">1LL</span> * fac[k - <span class="number">1</span>] * h[k] % P) % P;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「JSOI2019」节日庆典"><a href="#「JSOI2019」节日庆典" class="headerlink" title="「JSOI2019」节日庆典"></a>「JSOI2019」节日庆典</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3103">https://loj.ac/problem/3103</a></li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>这是一道串串题, 但是同市面上套数据结构的串串题不大相同.</p><p>题目所求即对一个串 $S$ 的每个前缀, 求最小循环表示的开始位置. 如果有多个, 输出最小的.</p><p>首先不加证明地给出两个性质</p><blockquote><p>对于前缀 $S_{1 \ldots k}$, 我们称能够成为该前缀最小循环表示开始位置的位置为候选点.</p><ol><li><p>对于两个位置 $i &lt; j$. 如果 $\mathrm{LCP}(S_{i\ldots n},\ S_{j\ldots n}) \le k - j$, 那么 $i$, $j$ 之间肯定有一个不是候选点.</p></li><li><p>对于两个位置 $i &lt; j$, 假设 $\mathrm{LCP}(S_{i\ldots n},\ S_{j\ldots n}) &gt; k - j$, 如果有 $k - j \le j - i$, 那么 $j$ 不是候选点.</p></li></ol></blockquote><p>摘抄自官方题解, 同时官方题解有具体证明. <del>UOJ 用户群有售 (雾</del>. 也可以参考 <a href="https://yhx-12243.github.io/OI-transit/records/lg5334%3Bloj3103.html">yhx-12243 的证明</a>.</p><p>利用性质 1 时, 假定已经维护出前缀 $S_{1 \ldots k-1}$ 的候选点集合, 那么该集合内元素一定满足 $\mathrm{LCP}(S_{i \ldots n},\ S_{j \ldots n}) &gt; (k - 1) - j$. 现在新加入位置 $S_k$, 只需比较 $S_{i + (k - j)}$, $S_{k}$ 的字典序大小即可.</p><p>借助于性质 2, 可以得到候选点个数不会超过 $O(\log n)$, 那么大力维护候选点集合就好了.</p><p>而对于候选点, 可通过 Z-Algorithm 比较循环同构串字典序. 因为其本质是在比较整个串和该串的某个后缀的 LCP. 同时要注意超过长度 $n$, 又从 $1$ 开始的部分.</p><p>时间复杂度 $O(n \log n)$.</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3103</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Z</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n, <span class="keyword">int</span>* z)</span> </span>&#123;</span><br><span class="line">  z[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">0</span>, R = <span class="number">0</span>, i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    z[i] = (i &lt; R)? <span class="built_in">min</span>(R - i + <span class="number">1</span>, z[i - L + <span class="number">1</span>]): <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i + z[i] &lt;= n &amp;&amp; s[z[i] + <span class="number">1</span>] == s[i + z[i]])</span><br><span class="line">      ++z[i];</span><br><span class="line">    <span class="keyword">if</span> (i + z[i] - <span class="number">1</span> &gt; R)</span><br><span class="line">      L = i, R = i + z[i] - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> S[MAXN];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; f;</span><br><span class="line"><span class="keyword">int</span> z[MAXN], Ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">scmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; p, <span class="keyword">const</span> <span class="keyword">int</span>&amp; lgt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (z[p] &gt;= lgt) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// same</span></span><br><span class="line">  <span class="keyword">return</span> (S[z[p] + <span class="number">1</span>] &lt; S[p + z[p]])? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; i, <span class="keyword">const</span> <span class="keyword">int</span>&amp; j, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span> </span>&#123; <span class="comment">// i &lt; j</span></span><br><span class="line">  <span class="keyword">int</span> c1 = <span class="built_in">scmp</span>(i + (k - j + <span class="number">1</span>), j - i);</span><br><span class="line">  <span class="keyword">if</span> (c1 != <span class="number">0</span>) <span class="keyword">return</span> (c1 &gt; <span class="number">0</span>)? j: i;</span><br><span class="line">  <span class="keyword">int</span> c2 = <span class="built_in">scmp</span>(j - i + <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (c2 != <span class="number">0</span>) <span class="keyword">return</span> (c2 &gt; <span class="number">0</span>)? i: j;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;data/celebrate2.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, S + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  n = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(S + <span class="number">1</span>), <span class="built_in">Z</span>(S, n, z);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">g</span><span class="params">(<span class="number">1</span>, k)</span></span>; <span class="comment">// j</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; i: f) &#123; <span class="comment">// i</span></span><br><span class="line">      <span class="comment">// s[i + k - j] &gt;= s[k]</span></span><br><span class="line">      <span class="keyword">while</span> (g.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; S[i + k - g.<span class="built_in">back</span>()] &lt; S[k])</span><br><span class="line">        g.<span class="built_in">pop_back</span>();</span><br><span class="line">      <span class="keyword">if</span> (!g.<span class="built_in">size</span>() || S[i + k - g.<span class="built_in">back</span>()] == S[k]) &#123;</span><br><span class="line">        <span class="comment">// k - j &gt;= j - i --&gt; 2j &lt;= k + i</span></span><br><span class="line">        <span class="keyword">while</span> (g.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; <span class="number">2</span> * g.<span class="built_in">back</span>() &lt;= k + i)</span><br><span class="line">          g.<span class="built_in">pop_back</span>();</span><br><span class="line">        g.<span class="built_in">push_back</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f = g;</span><br><span class="line">    <span class="keyword">int</span>&amp; j = Ans[k]; j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; i: f)</span><br><span class="line">      j = (j == <span class="number">-1</span>)? i: <span class="built_in">check</span>(i, j, k);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, Ans[i], <span class="string">&quot; \n&quot;</span>[i == n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;JSOI 都是好题, 还不毒瘤.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>「UOJ 284」快乐游戏鸡 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/uoj-284/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/uoj-284/</id>
    <published>2020-05-11T01:46:02.000Z</published>
    <updated>2020-05-11T13:21:31.242Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接: <a href="https://uoj.ac/problem/284">https://uoj.ac/problem/284</a></li></ul><p>大体是将询问离线, 利用长链剖分维护子树内的单调栈. <del>还有一火车的细节</del></p><span id="more"></span><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>先考虑在一条链上怎么做.</p><p>首先将所有点按 $1$ 到 $n$ 从左到右排布, 此时得到了一个序列. 对于一次询问 $(s,\ t)$, 从 $s$ 出发走向 $t$ (也只能这样走), 设在这条路径上依次经过节点 $i,\ j$. 如果有 $w_i \ge w_j$, 那么一定不会在 $j$ 上死亡.</p><p>如果我们直接删去这样的 $j$, 那么可以得出一个深度单调递增, 同时 $w$ 严格单调递增的单调栈.</p><p>在维护出单调栈后, 如何计算答案呢?</p><p>记 $f_u$ 为经过单调栈中上一个位置 $u$ 的花费, 如果完全经过单调栈下一位置 $v$, 那么 $s$ 经过 $v$ 的花费为 $f_u + \operatorname{depth}(v) \cdot (w_v - w_u)$.</p><p><em>(此处称之为 “花费” 并不完全准确, 因为此处的 <code>depth</code> 为到根节点的距离. 这样维护目的在于简化计算答案时分类讨论时的式子)</em></p><p>那么答案即可通过栈顶的 $f$ 算出, 并不要漏掉 $s$ 到 $t$ 的距离. 同时 $f$ 直接在加入一个节点时维护即可. 但是此时有多组询问. 直接离线处理, 从右向左, 对于每个节点依次维护单调栈即可.</p><p>再来推广到树的情况.</p><p>对于一轮从 $s$ 到 $t$ 的游戏, 每次都沿着 $s \rightarrow t$ 的路径前进, 直到能够到达 $t$ 的策略, 显然不是最优的: 我们可以在 $s$ 的子树内寻找一条深度较浅的点, 并通过在该点快速积累死亡次数, 从而减少在树上移动的时间.</p><p>而链上的情况并不存在其他儿子的子树, 因此可以不考虑这个问题. 在树的条件下, 维护单调栈的同时需要注意深度的影响.</p><p>栈中插入一个元素, 需满足栈中 $w_i$ 递增. 同时, 只在栈为空, 或是栈顶元素深度大于当前元素时插入. 这样就解决了上面的问题.</p><p>注意到单调栈的大小和子树中最深点的深度有关. 容易想到用长链剖分维护这个单调栈, 也就是直接继承长儿子的单调栈, 同时大力合并其他儿子的单调栈. 在合并时, 直接按照深度从小到大, 将一个栈中的元素插入另一个栈中即可.</p><p>计算答案则在栈内二分. 找到栈中某个点 $p$, 使其满足 $w_p \ge \max \{ {w_{s \rightarrow t} } \}$ (当然此处不包含 $s,t$). 注意不存在此位置的情况. 细节见代码实现.</p><p>而 <a href="https://www.cnblogs.com/penth/p/9801945.html">hzy 的题解</a>, 有一个称作 “队列启发式合并” 的技巧: 在 DFS 维护处理询问时, 按照 DFS 序分配在队列中的空间. 而每次合并后的结果, 一定不会超过 DFS 序所限定的范围, 并且是连续的. 这样就避免了较为繁琐的实现.</p><p>时间复杂度 $O(n\log n + q \log n)$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UOJ #284</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e5</span> + <span class="number">5</span>, LOG = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> idx, t;</span><br><span class="line">  <span class="built_in">Ask</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">Ask</span>(<span class="keyword">int</span> _i, <span class="keyword">int</span> <span class="keyword">_t</span>): <span class="built_in">idx</span>(_i), <span class="built_in">t</span>(<span class="keyword">_t</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> pre[MAXN], W[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Mx[LOG][MAXN], anc[LOG][MAXN];</span><br><span class="line"><span class="keyword">int</span> depth[MAXN], son[MAXN], dfn[MAXN], clk;</span><br><span class="line"></span><br><span class="line">LL Ans[MAXN];</span><br><span class="line">vector&lt;Ask&gt; Q[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN];</span><br><span class="line">  <span class="keyword">int</span> head[MAXN], d[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    depth[u] = depth[pre[u]] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; ++j) <span class="keyword">if</span> (anc[j - <span class="number">1</span>][u] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      anc[j][u] = anc[j - <span class="number">1</span>][anc[j - <span class="number">1</span>][u]];</span><br><span class="line">      Mx[j][u] = <span class="built_in">max</span>(Mx[j - <span class="number">1</span>][u], Mx[j - <span class="number">1</span>][anc[j - <span class="number">1</span>][u]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">      <span class="built_in">dfs</span>(v = edges[i].to);</span><br><span class="line">      <span class="keyword">if</span> (d[v] &gt; d[son[u]]) son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    d[u] = d[son[u]] + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">      Mx[<span class="number">0</span>][u] = W[u], anc[<span class="number">0</span>][u] = pre[u];</span><br><span class="line">    <span class="built_in">dfs</span>(rt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">QryMax</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = LOG - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">    <span class="keyword">if</span> (depth[anc[j][u]] &gt;= depth[v])</span><br><span class="line">      ret = <span class="built_in">max</span>(ret, Mx[j][u]), u = anc[j][u];</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Que &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> d, w;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _d = <span class="number">0</span>, <span class="keyword">int</span> _w = <span class="number">0</span>): <span class="built_in">d</span>(_d), <span class="built_in">w</span>(_w) &#123; &#125;</span><br><span class="line">  &#125; Qu[MAXN], stk[MAXN];</span><br><span class="line"></span><br><span class="line">  LL s[MAXN];</span><br><span class="line">  <span class="keyword">int</span> Head[MAXN], Tail[MAXN];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">newnode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u, <span class="keyword">int</span> head, <span class="keyword">int</span> tail)</span> </span>&#123;</span><br><span class="line">    Head[u] = head, Tail[u] = tail;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">const</span> Node&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;head = Head[u], &amp;tail = Tail[u];</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail &amp;&amp; Qu[head].w &lt;= v.w) ++head;</span><br><span class="line">    <span class="keyword">if</span> (head &gt; tail || Qu[head].d &gt; v.d) &#123;</span><br><span class="line">      s[head - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (head &lt;= tail)</span><br><span class="line">        s[head - <span class="number">1</span>] = s[head] + <span class="number">1LL</span> * Qu[head].d * (Qu[head].w - v.w);</span><br><span class="line">      Qu[--head] = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Mrg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123; <span class="comment">// Qu[u] &lt;-- Qu[v]</span></span><br><span class="line">    <span class="keyword">int</span> &amp;hu = Head[u], &amp;tu = Tail[u], &amp;hv = Head[v], &amp;tv = Tail[v];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (hu &lt;= tu &amp;&amp; Qu[hu].d &lt; Qu[tv].d)</span><br><span class="line">      stk[++top] = Qu[hu++];</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; hv &lt;= tv) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Qu[tv].d &gt; stk[top].d) <span class="built_in">Ins</span>(u, Qu[tv--]);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">Ins</span>(u, stk[top--]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">0</span>) <span class="built_in">Ins</span>(u, stk[top--]);</span><br><span class="line">    <span class="keyword">while</span> (hv &lt;= tv) <span class="built_in">Ins</span>(u, Qu[tv--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> Graph::edges;</span><br><span class="line">  dfn[u] = ++clk;</span><br><span class="line">  <span class="keyword">if</span> (son[u] &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">dfs</span>(son[u]), Que::<span class="built_in">newnode</span>(u, Que::Head[son[u]], Que::Tail[son[u]]);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    Que::<span class="built_in">newnode</span>(u, clk, clk - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v, i = Graph::head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">    <span class="keyword">if</span> ((v = edges[i].to) != son[u]) <span class="built_in">dfs</span>(v), Que::<span class="built_in">Mrg</span>(u, v);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> Ask&amp; a: Q[u]) &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Que;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;head = Head[u], &amp;tail = Tail[u];</span><br><span class="line">    <span class="keyword">int</span> L = head, R = tail, w = <span class="built_in">QryMax</span>(pre[a.t], u);</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">      <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (Qu[Mid].w &lt; w) L = Mid + <span class="number">1</span>; <span class="keyword">else</span> R = Mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Qu[head].w &lt;= w) &#123;</span><br><span class="line">      Ans[a.idx] += s[head] - s[L] + <span class="number">1LL</span> * Qu[head].d * Qu[head].w;</span><br><span class="line">      Ans[a.idx] += <span class="number">1LL</span> * Qu[L].d * (w - Qu[L].w) - <span class="number">1LL</span> * w * depth[u];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Ans[a.idx] += <span class="number">1LL</span> * w * (Qu[L].d - depth[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    Ans[a.idx] += depth[a.t] - depth[u];</span><br><span class="line">  &#125;</span><br><span class="line">  Que::<span class="built_in">Ins</span>(u, Que::<span class="built_in">Node</span>(depth[u], W[u]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;data/ex_rewrite3.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  Graph::<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">read</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(W[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">read</span>(pre[i]), Graph::<span class="built_in">AddEdge</span>(pre[i], i);</span><br><span class="line">  <span class="built_in">read</span>(q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> s, t, i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">    <span class="built_in">read</span>(s), <span class="built_in">read</span>(t), Q[s].<span class="built_in">push_back</span>(<span class="built_in">Ask</span>(i, t));</span><br><span class="line"></span><br><span class="line">  Graph::<span class="built_in">solve</span>(<span class="number">1</span>), <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, Ans[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我再也不做数据结构了.cpp</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>UOJ, <a href="https://vfleaking.blog.uoj.ac/blog/2292">Goodbye Bingshen 题解</a></li><li>hzy, <a href="https://www.cnblogs.com/penth/p/9801945.html">题解-UOJ284 快乐游戏鸡</a></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://uoj.ac/problem/284&quot;&gt;https://uoj.ac/problem/284&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大体是将询问离线, 利用长链剖分维护子树内的单调栈. &lt;del&gt;还有一火车的细节&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="Data Structure" scheme="https://depletedprism.github.io/tags/Data-Structure/"/>
    
    <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>「ZJOI2018」历史 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/uoj-374/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/uoj-374/</id>
    <published>2020-05-10T08:52:45.000Z</published>
    <updated>2020-05-11T13:32:04.339Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接: <a href="https://uoj.ac/problem/374">https://uoj.ac/problem/374</a></li></ul><p>一道非常有意思的 Link-Cut Tree 题.</p><span id="more"></span><p><del>ZJOI2018 唯一可做题</del></p><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>给定一棵有 $n$ 个节点的树, 根节点为 $1$. 在该树基础上建立 LCT, 同时给出第 $i$ 个点 <code>access</code> 的次数为 $a_i$. $m$ 次修改, 修改为将 $a_{x_i}$ 的值增加 $w_i$.</p><p>分别求出初始状态下, 和 $m$ 次修改后, <code>access</code> 操作中改变虚实链次数总和的最大值.</p><p>其中, $n,m \le 4 \times 10 ^ 5,\ a_i, w_i \le 10 ^ 7$.</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>先考虑不带修改怎么做.</p><p>首先每个点 <code>access</code> 操作时只会影响该点到根节点路径上的点, 因此影响一个点到其儿子边的虚实的操作只会发生在该点的子树内. 所以将每个子树分开考虑, 统计答案时直接求和即可.</p><p>注意到来自同一子树内的连续两次 <code>access</code> 操作, 并不会改变该子树根 $v$ 到 $v$ 的父亲 $u$ 这条边的虚实. 记 $u$ 的 <code>access</code> 次数为 $A_0$, 其儿子 $v$ 的子树内部 <code>access</code> 次数和分别为 $A_i$, 且节点 $u$ 共有 $m$ 个儿子. 那么问题可转化为</p><blockquote><p>给定若干个球, 总共有 $0$ 到 $m$ 共 $m + 1$ 种颜色, 第 $i$ 种颜色的球有 $A_i$ 个.</p><p>现在要构造一种球的排列, 使得相邻两个球颜色不同的间隔数尽量多.</p></blockquote><p>有一个贪心的思路: 选择小球个数最多的颜色, 将这些小球排成一列. 同时将其余小球插入这列小球之间. 用更加形式化的语言可描述为</p><p>记 $h = \max\limits_{i = 0} ^ m \{A_i \}$, $t = \sum\limits_{i = 0} ^ m A_i$, 分两种情况讨论.</p><ol><li><p>$2h \le t$, 此时答案为 $t - 1$.</p><p>即所有的小球中存在至多一半的球有相同颜色.</p></li><li><p>$2h \ge t + 1$, 此时答案为 $2 (t - h)$.</p><p>此种情况下按照上述策略贪心, 则不可避免存在多出一部分相同颜色的小球. 无论怎样改变已经放置的小球, 都无法使得不同颜色小球间隔数增加. 统计放置这些相同颜色小球前的间隔数, 即可计算答案.</p></li></ol><p>也就是 $\min \{ t - 1,\ 2(t - h) \}$.</p><p>因而可以得到一个做法: 直接 DFS 整棵树, 分别统计每棵子树对答案贡献. 可以在 $O(n)$ 的时间复杂度内计算.</p><p>观察上述结论中两种情况的性质. 设 $s_u$ 为 $u$ 子树内的 <code>access</code> 次数之和.</p><p>对于带修改的情况, 对于一条边 $(u, fa)$, 将满足 $2s_u \ge s_{fa} + 1$ 的边视作实链, 否则视为虚链. 类比于重链剖分, 虚链的个数有 $O(\log \sum a_i) = O(\log n)$ 个, 且连向 $fa$ 的实链唯一, 实儿子一定是 $u$.</p><p>对于一条实链, 每次单点修改 $u$ 的值时, $fa$ 处的答案不会改变: 此时 $h$ 的值不会发生变化, 且 $t - h$ 的差值不变.</p><p>可以直接用 LCT 来维护, 每次修改后暴力 <code>access</code> 沿当前点到根的路径依次修改即可. 注意实现时的细节, 以及虚实链的改变需要遵循上述条件.</p><p>时间复杂度 $O(n \log n)$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UOJ #374</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(args...) fprintf(stderr, ##args)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a &lt; b)? a = b, <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line">LL ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> LCT &#123;</span><br><span class="line">  <span class="keyword">int</span> ch[<span class="number">2</span>][MAXN], pre[MAXN];</span><br><span class="line">  LL s[MAXN], is[MAXN], val[MAXN];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; nd)</span> </span>&#123;</span><br><span class="line">    s[nd] = is[nd] + val[nd];</span><br><span class="line">    <span class="keyword">if</span> (ch[<span class="number">0</span>][nd]) s[nd] += s[ch[<span class="number">0</span>][nd]];</span><br><span class="line">    <span class="keyword">if</span> (ch[<span class="number">1</span>][nd]) s[nd] += s[ch[<span class="number">1</span>][nd]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">which</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123; <span class="keyword">return</span> pre[u]? ch[<span class="number">1</span>][pre[u]] == u: <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">nroot</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre[u]? ch[<span class="number">0</span>][pre[u]] == u || ch[<span class="number">1</span>][pre[u]] == u: <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = pre[u], w = <span class="built_in">which</span>(u);</span><br><span class="line">    pre[u] = pre[fa];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">nroot</span>(fa)) ch[<span class="built_in">which</span>(fa)][pre[fa]] = u;</span><br><span class="line">    ch[w][fa] = ch[w ^ <span class="number">1</span>][u];</span><br><span class="line">    <span class="keyword">if</span> (ch[w ^ <span class="number">1</span>][u]) pre[ch[w ^ <span class="number">1</span>][u]] = fa;</span><br><span class="line">    ch[w ^ <span class="number">1</span>][u] = fa, pre[fa] = u;</span><br><span class="line">    <span class="built_in">maintain</span>(fa);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">nroot</span>(u)) &#123;</span><br><span class="line">      <span class="keyword">int</span> fa = pre[u];</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">nroot</span>(fa)) <span class="built_in">which</span>(fa) == <span class="built_in">which</span>(u)? <span class="built_in">rotate</span>(fa): <span class="built_in">rotate</span>(u);</span><br><span class="line">      <span class="built_in">rotate</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">maintain</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> LL <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, LL t, LL h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ch[<span class="number">1</span>][u]) <span class="keyword">return</span> <span class="number">2</span> * (t - h);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * val[u] &gt;= t + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">2</span> * (t - val[u]);</span><br><span class="line">    <span class="keyword">return</span> t - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v = u;</span><br><span class="line">    <span class="keyword">for</span> (u = pre[u]; u; v = u, u = pre[u]) &#123; <span class="comment">// start from pre[u]</span></span><br><span class="line">      <span class="built_in">splay</span>(u);</span><br><span class="line">      LL t = s[u] - s[ch[<span class="number">0</span>][u]], h = s[ch[<span class="number">1</span>][u]];</span><br><span class="line">      ans -= <span class="built_in">calc</span>(u, t, h);</span><br><span class="line">      s[u] += w, t += w, is[u] += w;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">2</span> * h &lt; t + <span class="number">1</span>)</span><br><span class="line">        ch[<span class="number">1</span>][u] = <span class="number">0</span>, is[u] += h;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">2</span> * s[v] &gt;= t + <span class="number">1</span>) <span class="comment">// update weight son</span></span><br><span class="line">        ch[<span class="number">1</span>][u] = v, h = s[v], is[u] -= h;</span><br><span class="line">      ans += <span class="built_in">calc</span>(u, t, h);</span><br><span class="line">      <span class="built_in">maintain</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; w)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">splay</span>(u);</span><br><span class="line">    LL t = s[u] - s[ch[<span class="number">0</span>][u]], h = s[ch[<span class="number">1</span>][u]];</span><br><span class="line">    ans -= <span class="built_in">calc</span>(u, t, h);</span><br><span class="line">    val[u] += w, t += w, s[u] += w;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * h &lt; t + <span class="number">1</span>)</span><br><span class="line">      ch[<span class="number">1</span>][u] = <span class="number">0</span>, is[u] += h;</span><br><span class="line">    ans += <span class="built_in">calc</span>(u, t, h);</span><br><span class="line">    <span class="built_in">maintain</span>(u), <span class="built_in">access</span>(u, w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> LCT;</span><br><span class="line">    <span class="keyword">int</span> rson = <span class="number">-1</span>;</span><br><span class="line">    LL &amp;t = s[u], h = val[u]; t = val[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((v = edges[i].to) == pre[u]) <span class="keyword">continue</span>;</span><br><span class="line">      pre[v] = u, <span class="built_in">dfs</span>(v), t += s[v];</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ckmax</span>(h, s[v])) rson = v;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += <span class="built_in">min</span>(t - <span class="number">1</span>, <span class="number">2</span> * (t - h));</span><br><span class="line">    <span class="keyword">if</span> (rson &gt; <span class="number">0</span> &amp;&amp; <span class="number">2</span> * h &gt;= t + <span class="number">1</span>)</span><br><span class="line">      ch[<span class="number">1</span>][u] = rson, is[u] = s[u] - s[rson] - val[u];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      is[u] = s[u] - val[u];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;data/ex_history2.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  Graph::<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">read</span>(n), <span class="built_in">read</span>(q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(LCT::val[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="built_in">read</span>(u), <span class="built_in">read</span>(v), Graph::<span class="built_in">AddEdge</span>(u, v), Graph::<span class="built_in">AddEdge</span>(v, u);</span><br><span class="line"></span><br><span class="line">  Graph::<span class="built_in">dfs</span>(<span class="number">1</span>), <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x, w; q; --q) &#123;</span><br><span class="line">    <span class="built_in">read</span>(x), <span class="built_in">read</span>(w), LCT::<span class="built_in">Mdy</span>(x, w);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>ZJOI2018 day1 solution by ???</li><li>Kelin, <a href="https://blog.csdn.net/BeNoble_/article/details/79706461">[ZJOI2018]历史</a></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://uoj.ac/problem/374&quot;&gt;https://uoj.ac/problem/374&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一道非常有意思的 Link-Cut Tree 题.&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="Data Structure" scheme="https://depletedprism.github.io/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>「集训队作业 2018」喂鸽子 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/uoj-449/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/uoj-449/</id>
    <published>2020-05-06T13:09:31.000Z</published>
    <updated>2020-05-27T04:46:40.732Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接: <a href="https://uoj.ac/problem/449">https://uoj.ac/problem/449</a></li></ul><p>个人现在感觉这是一道有启发意义的期望题.</p><p>大体是利用 Min-Max 容斥计算期望, 以及 NTT 优化时间复杂度.</p><span id="more"></span><p><del>我 喂 我 自 己</del></p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>显然可以使用 Min-Max 容斥.</p><p>记 $X_i$ 为第 $i$ 只鸽子喂饱的期望时间, 也可称作期望喂饱该鸽子的玉米粒个数. 同时记 $S$ 为鸽子的全集, 也就是全部的鸽子. 套用 Min-Max 容斥可得</p><script type="math/tex; mode=display">E(\max_{i \in S}\{X_i\}) = \sum_{T \subset S,\ T \neq \varnothing} (-1) ^ {\mid T \mid - 1} E(\min_{i \in T}\{ X_i \})</script><p>注意到每只鸽子之间并没有区别, 所以直接枚举集合大小即可. 设 $g(m)$ 表示喂 $m$ 只鸽子, 最早喂饱一只的期望时间. 则</p><script type="math/tex; mode=display">E(\max_{i \in S}\{X_i\}) = \sum_{m = 1} ^ n \binom{n}{m} g(m) \cdot \frac{n}{m}</script><p>此处等式右侧需乘上 $\frac{n}{m}$, 表示同时喂 $n$ 只鸽子, 喂到钦定的 $m$ 只鸽子的期望次数.</p><p>现在的问题转为如何快速求出 $g(m)$. 设 $f(m, i)$ 表示喂 $m$ 只鸽子, 喂 $i$ 粒玉米, 不存在任何一只鸽子被喂饱的概率. 那么至多只能喂 $m(k-1)$ 粒, 有</p><script type="math/tex; mode=display">g(m) = \sum_{i = 0} ^ {m(k - 1)} f(m, i) = 1 + \sum_{i = 1} ^ {m(k-1)} f(m, i)</script><p><em>此处将 $f(m, 0)$ 单独列出, 以避免讨论.</em></p><p>对于计算 $f(m, i)$, 有一个朴素的想法是, 用不喂饱任何一只鸽子的方案数除以总共的方案数. 设 $h(m, i)$ 表示喂 $m$ 只鸽子, 喂 $i$ 粒玉米, 不存在任何一只鸽子被喂饱的方案数, 则有</p><script type="math/tex; mode=display">f(m, i) = \frac{1}{m ^ i} h(m, i)</script><p>对于 $h(m, i)$, 可以枚举喂某一只鸽子的玉米粒数, 得出</p><script type="math/tex; mode=display">h(m, i) = \sum_{j = 0} ^ {\min\{ i,\ k - 1 \}} \binom{i}{j}\ h(m - 1, i - j) = i! \cdot \sum_{j = 0} ^ {\min\{ i,\ k - 1\}} \frac{h(m - 1, i - j)}{(i - j)!} \cdot \frac{1}{j!}</script><p>是一个卷积的形式, 用 NTT 计算即可. 和式中的 $\min$ 其实很好处理, 每次计算只取后者的前 $k - 1$ 次项即可.</p><p>时间复杂度 $O(n ^ 2 k \log nk)$.</p><p>另外存在时间复杂度为 $O(n ^ 2 k)$ 的优秀做法. <del>已经拿去喂鸽子了</del>, 不妨参看 <a href="https://yhx-12243.github.io/OI-transit/records/uoj449.html">https://yhx-12243.github.io/OI-transit/records/uoj449.html</a>.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UOJ #449</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">1e3</span> + <span class="number">5</span>, MAXM = <span class="number">5e1</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LOG = <span class="number">17</span>, MAXN = <span class="number">1</span> &lt;&lt; LOG | <span class="number">1</span>, P = <span class="number">998244353</span>, G = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> W[LOG][MAXN];</span><br><span class="line"><span class="keyword">int</span> inv[MAXN], fac[MAXN], ifac[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (n &lt; m)? <span class="number">0</span>: <span class="number">1LL</span> * fac[n] * ifac[m] % P * ifac[n - m] % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1LL</span> * ret * base % P;</span><br><span class="line">    base = <span class="number">1LL</span> * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">  <span class="keyword">int</span> r[MAXN];</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) <span class="built_in">swap</span>(f[i], f[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>, Mid = <span class="number">1</span>; Mid &lt; Lim; ++k, Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span>* w = W[k];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j) &#123;</span><br><span class="line">          <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1LL</span> * w[j] * f[i+j+Mid] % P;</span><br><span class="line">          f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> iv = <span class="built_in">fpow</span>(Lim, P - <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1LL</span> * iv * f[i] % P;</span><br><span class="line">      <span class="built_in">reverse</span>(f + <span class="number">1</span>, f + Lim);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n, <span class="keyword">int</span>* g, <span class="keyword">const</span> <span class="keyword">int</span>&amp; m, <span class="keyword">int</span>* h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">    <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Lim &lt; n + m - <span class="number">1</span>) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i)</span><br><span class="line">      A[i] = (i &lt; n)? f[i]: <span class="number">0</span>, B[i] = (i &lt; m)? g[i]: <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">init</span>(Lim, L), <span class="built_in">NTT</span>(A, Lim, <span class="number">1</span>), <span class="built_in">NTT</span>(B, Lim, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) h[i] = <span class="number">1LL</span> * A[i] * B[i] % P;</span><br><span class="line">    <span class="built_in">NTT</span>(h, Lim, <span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PolyPre</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">  inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">    inv[i] = <span class="number">1LL</span> * inv[P % i] * (P - P / i) % P;</span><br><span class="line">  fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    fac[i] = <span class="number">1LL</span> * i * fac[i - <span class="number">1</span>] % P;</span><br><span class="line">    ifac[i] = <span class="number">1LL</span> * inv[i] * ifac[i - <span class="number">1</span>] % P;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> w, i = <span class="number">0</span>, Mid = <span class="number">1</span>; i &lt; LOG; ++i, Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    W[i][<span class="number">0</span>] = <span class="number">1</span>, w = <span class="built_in">fpow</span>(G, (P - <span class="number">1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; Mid; ++j)</span><br><span class="line">      W[i][j] = <span class="number">1LL</span> * w * W[i][j - <span class="number">1</span>] % P;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K;</span><br><span class="line"><span class="keyword">int</span> g[MAXM], f[MAXM][MAXN], h[MAXM][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;K);</span><br><span class="line">  <span class="built_in">PolyPre</span>(n * K);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// h(m, i) = sum_&#123;j = 0&#125; ^ min(i, k - 1) C(i, j) * h(m - 1, i - j)</span></span><br><span class="line">  h[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt;= n; ++m) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (m - <span class="number">1</span>) * (K - <span class="number">1</span>); ++i)</span><br><span class="line">      A[i] = <span class="number">1LL</span> * h[m - <span class="number">1</span>][i] * ifac[i] % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= K - <span class="number">1</span>; ++i) <span class="comment">// i &lt;= K - 1</span></span><br><span class="line">      B[i] = ifac[i];</span><br><span class="line">    Poly::<span class="built_in">Mul</span>(A, (m - <span class="number">1</span>) * (K - <span class="number">1</span>) + <span class="number">1</span>, B, K, A);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m * (K - <span class="number">1</span>); ++i)</span><br><span class="line">      h[m][i] = <span class="number">1LL</span> * fac[i] * A[i] % P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// f(m, i) = h(m, i) / (i ^ m)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt;= n; ++m)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m * (K - <span class="number">1</span>); ++i)</span><br><span class="line">      f[m][i] = <span class="number">1LL</span> * h[m][i] * <span class="built_in">fpow</span>(inv[m], i) % P;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// g(m) = sum_&#123;i = 0&#125; ^ m (k-1) f(m, i)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt;= n; ++m) &#123;</span><br><span class="line">    g[m] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m * (K - <span class="number">1</span>); ++i)</span><br><span class="line">      g[m] = (g[m] + f[m][i]) % P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1LL</span> * <span class="built_in">C</span>(n, k) * g[k] % P * n % P * inv[k] % P;</span><br><span class="line">    ans = (ans + ((k &amp; <span class="number">1</span>)? s: P - s)) % P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://uoj.ac/problem/449&quot;&gt;https://uoj.ac/problem/449&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;个人现在感觉这是一道有启发意义的期望题.&lt;/p&gt;
&lt;p&gt;大体是利用 Min-Max 容斥计算期望, 以及 NTT 优化时间复杂度.&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="Combinatorics" scheme="https://depletedprism.github.io/tags/Combinatorics/"/>
    
    <category term="Polynomial" scheme="https://depletedprism.github.io/tags/Polynomial/"/>
    
    <category term="Probability &amp; Mean" scheme="https://depletedprism.github.io/tags/Probability-Mean/"/>
    
  </entry>
  
  <entry>
    <title>「清华集训 2017」生成树计数 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/uoj-335/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/uoj-335/</id>
    <published>2020-04-28T07:30:01.000Z</published>
    <updated>2020-04-29T03:27:17.648Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接: <a href="https://uoj.ac/problem/335">https://uoj.ac/problem/335</a></li></ul><p>大概是利用树的 Prufer 序列解决某些计数问题, 第一次见感觉很新鲜.</p><span id="more"></span><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>先来考虑一个简化版的问题:</p><blockquote><p>在一个 $s$ 个点的图中, 存在 $s - n$ 条边, 使图中形成了 $n$ 个连通块, 第 $i$ 个连通块中有 $a_i$ 个点. 再连接 $n - 1$ 条边, 使得图连通.</p><p>求方案数.</p></blockquote><p>Prufer 序列有一个很基本的性质: 将一个有标号无根树用 $[1,\ n]$ 中的 $n - 2$ 个整数唯一表示.</p><p>将 $n$ 个连通块看作点, 那么这些点之间连 $n - 1$ 条边之后得出的连通图就是棵树, 对这棵树构造 Prufer 序列.</p><p>设 $n$ 个连通块的度数分别为 $d_i$, 则所有连通块度数之和为 $2n - 2$. 那么对于一组已经确定的 $d_i$, Prufer 序列的个数为</p><script type="math/tex; mode=display">\binom{n - 2}{d_1 - 1\; d_2 - 1\; \cdots\; d_n - 1}</script><p>可列出式子</p><script type="math/tex; mode=display">\binom{n - 2}{d_1 - 1\; d_2 - 1\; \cdots\; d_n - 1} \prod_{i = 1} ^ n a_i ^ {d_i}</script><p>式子最后的乘积就是考虑连通块内部对外连边的情况.</p><p>考虑用多项式定理去化简. 多项式定理即</p><script type="math/tex; mode=display">(x_1 + x_2 + \cdots + x_m) ^ n = \sum \binom{n}{n_1\ n_2\ \cdots\ n_m}\ x_1 ^ {n_1} x_2 ^ {n_2} \cdots x_m ^ {n_m}</script><p>其中 $\sum\limits_{i = 1} ^ m n_i = n$, $0 \le n_i \le n$.</p><p>记 $c_i = d_i -1$. (此时的 $c_i$ 也可理解为第 $i$ 个点在 Prufer 序列中的出现次数). 那么有</p><script type="math/tex; mode=display">\binom{n - 2}{c_1\ c_2\ \cdots\ c_n} \prod_{i = 1} ^ n a_i ^ {c_i} \cdot \left(\prod_{i = 1} ^ n a_i\right)</script><p><del>如果直接用 ci 的组合意义去考虑, 可以直接得到这个结果.</del></p><p>套多项式定理, 得</p><script type="math/tex; mode=display">(c_1 + c_2 + \cdots + c_n) ^ {n - 2} \prod_{i = 1} ^ n a_i</script><p>最终答案为</p><script type="math/tex; mode=display">s ^ {n - 2} \prod_{i = 1} ^ n a_i</script><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>沿用上面的思路, <del>其实只是套用多项式定理化简前的思路</del>. 那么答案可写作</p><script type="math/tex; mode=display">\sum_{T} \left( \prod_{i = 1} ^ n {d_i} ^ m \right) \left( \sum_{i = 1} ^ n {d_i} ^ m\right) = \binom{n - 2}{c_1\; c_2\; \cdots\; c_n} \sum_{i = 1} ^ n (c_i + 1) ^ m \cdot \prod_{i = 1} ^ n (c_i + 1) ^ m a_i ^ {c_i + 1}</script><p>将组合数拆开, 并从最后的乘积中提出来一项, 得到</p><script type="math/tex; mode=display">\frac{(n - 2)!}{\prod\limits_{i = 1} ^ n (c_i!)} \sum_{i = 1} ^ n (c_i+ 1) ^ {2m} a_i ^ {c_i + 1} \prod_{j \neq i} (c_j + 1) ^ m a_j ^ {c_j+1}</script><p>整理, 得</p><script type="math/tex; mode=display">(n - 2)! \prod_{i = 1} ^ n a_i \cdot \sum_{i = 1} ^ n \frac{1}{c_i!} (c_i + 1) ^ {2m} a_i ^ {c_i} \prod_{j \neq i} \frac{1}{c_j!} (c_j + 1) ^ m a_j ^ {c_j}</script><p>设后半部分 OGF 为 $F(x)$, 那么答案为</p><script type="math/tex; mode=display">(n - 2)! \prod_{i = 1} ^ n a_i \cdot [x ^ {n - 2}]F(x)</script><p>前半部分为常数, 直接计算即可. 现在的问题在于如何快速求 $F(x)$. 不妨设 $A(x)$, $B(x)$ 两个 EGF, 分别为</p><script type="math/tex; mode=display">A(x) = \sum_{k = 0} ^ \infty \frac{1}{k!} (k + 1) ^ {2m} x ^ k</script><script type="math/tex; mode=display">B(x) = \sum_{k = 0} ^ \infty \frac{1}{k!} (k + 1) ^ m x ^ k</script><p>此时的 $F(x)$ 可写作</p><script type="math/tex; mode=display">F(x) = \sum_{i = 1} ^ n \frac{A(a_i x)}{B(a_i x)} \prod_{j \neq i} B(a_j x)</script><p>利用对数解决这个乘积. 得</p><script type="math/tex; mode=display">F(x) = \sum_{i = 1} ^ n \frac{A(a_i x)}{B(a_i x)} \exp \left( \sum_{j \neq i} \ln B(a_j x) \right)</script><p>考虑到 $a_i$ 的影响, 这个好像不能直接做. 做一步转化, 在计算出 $\frac{A(x)}{B(x)}$ 及 $\ln B(x)$ 后, 对于第 $k$ 项系数乘 $\sum\limits_{i = 1} ^ n a_i ^ k$ 即可得出 $\sum\limits_{i = 1} ^ n \frac{A(a_i x)}{B(a_i x)}$ 和 $\sum\limits_{i = 1} ^ n \ln B(a_i x)$.</p><p>仅剩的问题是计算  $\sum\limits_{i = 1} ^ n a_i ^ k$. 设其 OGF 为 $G(x)$, 即</p><script type="math/tex; mode=display">G(x) = \sum_{k = 0} ^ \infty \left( \sum_{i = 1} ^ n a_i ^ k \right) x ^ k = \sum_{i = 1} ^ n \frac{1}{1 - a_i x}</script><p>此时的 $G(x)$ 不便于快速计算. 下面利用对数和导数对 $G(x)$ 进行转化, 使其成为乘积的形式.</p><p>注意到</p><script type="math/tex; mode=display">\ln (1 - a_i x)' = -\frac{a_i}{1 - a_i x}</script><p>而</p><script type="math/tex; mode=display">\frac{1}{1 - a_i x} = \frac{a_i x}{1 - a_i x} + 1</script><p>那么 $G(x)$ 可化作</p><script type="math/tex; mode=display">G(x) = n + \sum_{i = 1} ^ n \frac{a_i x}{1 - a_i x} = n - x \sum_{i = 1} ^ n \ln(1 - a_i x)'</script><p>考虑到求导的线性性, 以及对数的性质, 得到</p><script type="math/tex; mode=display">G(x) = n - x \left( \ln \prod_{i = 1} ^ n (1 - a_i x) \right)'</script><p>分治 FFT 计算即可. 时间复杂度 $O(n \log ^ 2 n)$.</p><p>另外存在基于第二类 Stirling 数的, 时间复杂度为 $O(nm\log ^ 2 n)$ 的做法, 在复杂度和推导过程上都不占优势.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>注意 $n = 1$ 的情况需要特判, UOJ 上有类似的 Hack 数据.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UOJ #335</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LOG = <span class="number">16</span>, MAXN = <span class="number">1</span> &lt;&lt; LOG | <span class="number">1</span>, P = <span class="number">998244353</span>, G = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> W[LOG][MAXN];</span><br><span class="line"><span class="keyword">int</span> inv[MAXN], fac[MAXN], ifac[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1LL</span> * ret * base % P;</span><br><span class="line">        base = <span class="number">1LL</span> * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OutPoly</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;%d%c&quot;</span>, f[i], <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) <span class="built_in">swap</span>(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>, Mid = <span class="number">1</span>; Mid &lt; Lim; ++k, Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span>* w = W[k];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1LL</span> * w[j] * f[i+j+Mid] % P;</span><br><span class="line">                    f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> iv = <span class="built_in">fpow</span>(Lim, P - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1LL</span> * f[i] * iv % P;</span><br><span class="line">            <span class="built_in">reverse</span>(f + <span class="number">1</span>, f + Lim);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">        g[<span class="number">0</span>] = <span class="built_in">fpow</span>(f[<span class="number">0</span>], P - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">0</span>, Lim = <span class="number">1</span>, Mid = <span class="number">2</span>; Mid &lt; <span class="number">2</span>*n; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*Mid) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) A[i] = f[i], B[i] = g[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">init</span>(Lim, L), <span class="built_in">NTT</span>(A, Lim, <span class="number">1</span>), <span class="built_in">NTT</span>(B, Lim, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i)</span><br><span class="line">                g[i] = ((B[i] + B[i]) % P - <span class="number">1LL</span> * A[i] * B[i] % P * B[i] % P + P) % P;</span><br><span class="line">            <span class="built_in">NTT</span>(g, Lim, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">min</span>(n, Mid); i &lt; Lim; ++i) g[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Der</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) g[i - <span class="number">1</span>] = <span class="number">1LL</span> * i * f[i] % P;</span><br><span class="line">        g[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Int</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i; --i) g[i] = <span class="number">1LL</span> * inv[i] * f[i - <span class="number">1</span>] % P;</span><br><span class="line">        g[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ln</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> ivf[MAXN], df[MAXN];</span><br><span class="line">        <span class="built_in">Der</span>(f, df, n), <span class="built_in">Inv</span>(f, ivf, n);</span><br><span class="line">        <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*n) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; Lim; ++i) ivf[i] = df[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">init</span>(Lim, L), <span class="built_in">NTT</span>(df, Lim, <span class="number">1</span>), <span class="built_in">NTT</span>(ivf, Lim, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) df[i] = <span class="number">1LL</span> * df[i] * ivf[i] % P;</span><br><span class="line">        <span class="built_in">NTT</span>(df, Lim, <span class="number">-1</span>), <span class="built_in">Int</span>(df, g, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Exp</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> lng[MAXN], A[MAXN], B[MAXN];</span><br><span class="line">        g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">0</span>, Lim = <span class="number">1</span>, Mid = <span class="number">2</span>; Mid &lt; <span class="number">2</span>*n; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">Ln</span>(g, lng, Mid);</span><br><span class="line">            <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*Mid) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i)</span><br><span class="line">                A[i] = (f[i] - lng[i] + P) % P, B[i] = g[i];</span><br><span class="line">            A[<span class="number">0</span>] = (A[<span class="number">0</span>] + <span class="number">1</span>) % P;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">init</span>(Lim, L), <span class="built_in">NTT</span>(A, Lim, <span class="number">1</span>), <span class="built_in">NTT</span>(B, Lim, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) g[i] = <span class="number">1LL</span> * A[i] * B[i] % P;</span><br><span class="line">            <span class="built_in">NTT</span>(g, Lim, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">min</span>(n, Mid); i &lt; Lim; ++i) g[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n, <span class="keyword">int</span>* g, <span class="keyword">const</span> <span class="keyword">int</span>&amp; m, <span class="keyword">int</span>* h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">        <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt; n + m - <span class="number">1</span>) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i)</span><br><span class="line">            A[i] = (i &lt; n)? f[i]: <span class="number">0</span>, B[i] = (i &lt; m)? g[i]: <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">init</span>(Lim, L), <span class="built_in">NTT</span>(A, Lim, <span class="number">1</span>), <span class="built_in">NTT</span>(B, Lim, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) h[i] = <span class="number">1LL</span> * A[i] * B[i] % P;</span><br><span class="line">        <span class="built_in">NTT</span>(h, Lim, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PolyPre</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">        inv[i] = <span class="number">1LL</span> * inv[P % i] * (P - P / i) % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        fac[i] = <span class="number">1LL</span> * i * fac[i - <span class="number">1</span>] % P;</span><br><span class="line">        ifac[i] = <span class="number">1LL</span> * inv[i] * ifac[i - <span class="number">1</span>] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> w, i = <span class="number">0</span>, Mid = <span class="number">1</span>; i &lt; LOG; ++i, Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        W[i][<span class="number">0</span>] = <span class="number">1</span>, w = <span class="built_in">fpow</span>(G, (P - <span class="number">1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; Mid; ++j)</span><br><span class="line">            W[i][j] = <span class="number">1LL</span> * w * W[i][j - <span class="number">1</span>] % P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tmp[LOG &lt;&lt; <span class="number">1</span>][MAXN], ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123; <span class="comment">// [L, R)</span></span><br><span class="line">    <span class="keyword">if</span> (R - L &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>] = <span class="number">1</span>, f[<span class="number">1</span>] = (P - a[L]) % P, <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, *f0 = tmp[ptr++], *f1 = tmp[ptr++];</span><br><span class="line">    <span class="keyword">int</span> dl = <span class="built_in">solve</span>(f0, L, Mid), dr = <span class="built_in">solve</span>(f1, Mid, R);</span><br><span class="line">    Poly::<span class="built_in">Mul</span>(f0, dl, f1, dr, f), ptr -= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> dl + dr - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN], ivB[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN], g[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">puts</span>((m == <span class="number">0</span>)? <span class="string">&quot;1&quot;</span>: <span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">PolyPre</span>(n);</span><br><span class="line">    <span class="comment">// A, B</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        A[i] = <span class="number">1LL</span> * ifac[i] * <span class="built_in">fpow</span>(i + <span class="number">1</span>, <span class="number">2</span> * m) % P;</span><br><span class="line">        B[i] = <span class="number">1LL</span> * ifac[i] * <span class="built_in">fpow</span>(i + <span class="number">1</span>, m) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    Poly::<span class="built_in">Inv</span>(B, ivB, n + <span class="number">1</span>), Poly::<span class="built_in">Ln</span>(B, B, n + <span class="number">1</span>);</span><br><span class="line">    Poly::<span class="built_in">Mul</span>(A, n + <span class="number">1</span>, ivB, n + <span class="number">1</span>, A);</span><br><span class="line">    <span class="comment">// g</span></span><br><span class="line">    <span class="built_in">solve</span>(g, <span class="number">1</span>, n + <span class="number">1</span>);</span><br><span class="line">    Poly::<span class="built_in">Ln</span>(g, g, n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        g[i] = (P - <span class="number">1LL</span> * g[i] * i % P) % P;</span><br><span class="line">    g[<span class="number">0</span>] = n;</span><br><span class="line">    <span class="comment">// f</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        A[i] = <span class="number">1LL</span> * A[i] * g[i] % P, B[i] = <span class="number">1LL</span> * B[i] * g[i] % P;</span><br><span class="line">    Poly::<span class="built_in">Exp</span>(B, f, n + <span class="number">1</span>);</span><br><span class="line">    Poly::<span class="built_in">Mul</span>(f, n + <span class="number">1</span>, A, n + <span class="number">1</span>, f);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1LL</span> * fac[n - <span class="number">2</span>] * f[n - <span class="number">2</span>] % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ans = <span class="number">1LL</span> * ans * a[i] % P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>OI Wiki, <a href="https://oi-wiki.org/graph/prufer/#_3">Prufer 序列</a></li><li>OwenOwl, <a href="https://www.luogu.com.cn/blog/mcfx0/p4002">[清华集训2017]生成树计数 题解</a></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://uoj.ac/problem/335&quot;&gt;https://uoj.ac/problem/335&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大概是利用树的 Prufer 序列解决某些计数问题, 第一次见感觉很新鲜.&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="Combinatorics" scheme="https://depletedprism.github.io/tags/Combinatorics/"/>
    
    <category term="Polynomial" scheme="https://depletedprism.github.io/tags/Polynomial/"/>
    
  </entry>
  
  <entry>
    <title>BJOI 2019 简要题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/sx/BJOI-2019-sol/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/sx/BJOI-2019-sol/</id>
    <published>2020-04-24T06:41:25.000Z</published>
    <updated>2020-05-14T13:22:22.003Z</updated>
    
    <content type="html"><![CDATA[<hr><p><del>听说大赏的意思好像和我之前认为的不太一样?</del></p><p>没文化啊.png</p><span id="more"></span><h3 id="「BJOI2019」奥术神杖"><a href="#「BJOI2019」奥术神杖" class="headerlink" title="「BJOI2019」奥术神杖"></a>「BJOI2019」奥术神杖</h3><p><del>为什么剧情里总是向过往寻求力量呢 (</del></p><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3089">https://loj.ac/problem/3089</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>1 月份做过结果忘地一干二净</del></p><p>设选择后神杖上的宝石后, 得出的生效的咒语序列为 $a_i$. 如果答案比 $x$ 优, 那么有</p><script type="math/tex; mode=display">\left( \prod_{i = 1} ^ c V_{a_i} \right) ^ {1 / c} > x</script><p>运用一些运算的技巧, 有</p><script type="math/tex; mode=display">\ln \left( \sum_{i = 1} ^ c V_{a_i} \right) > c \ln x</script><script type="math/tex; mode=display">\ln \left( \sum_{i = 1} ^ c (V_{a_i} - c \ln x)\right) > 0</script><p>0-1 分数规划即可. 现在的重点在于计算中间和式的最大值.</p><p>考虑在 AC 自动机上 DP. 设 $f(i, u)$ 表示匹配到 $T$ 中第 $i$ 个位置, 以及 AC 自动机上第 $u$ 个节点在最大值.</p><p>那么根据 $T_i$ 处的字符转移即可, 输出方案可在 DP 时记录每次转移的选择就好了. 注意在处理权值时, 需要将 $u$ 的权值加到 $\operatorname{fail}(u)$ 上, 以及不要忽略多个串在同一节点上的情况.</p><p>记字符集大小为 $c$, 那么时间复杂度为 $O(nsc\log V)$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3089</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a &lt; b)? (a = b, <span class="literal">true</span>): <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">15e2</span> + <span class="number">5</span>, SIGMA = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-9</span>, INFD = <span class="number">1e9</span> * MAXN;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">fabs</span>(p) &lt; EPS)? <span class="number">0</span>: (p &lt; <span class="number">0</span>? <span class="number">-1</span>: <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> T[MAXN], S[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> f[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> g[MAXN][MAXN][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> AC &#123;</span><br><span class="line">  <span class="keyword">int</span> ch[MAXN][SIGMA], fail[MAXN], size[MAXN], nidx;</span><br><span class="line">  <span class="keyword">double</span> A[MAXN], val[MAXN];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; nidx = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">1</span>, lgt = <span class="built_in">strlen</span>(S + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lgt; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> c = S[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span> (!ch[u][c]) ch[u][c] = ++nidx;</span><br><span class="line">      u = ch[u][c];</span><br><span class="line">    &#125;</span><br><span class="line">    val[u] += w, ++size[u];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getfail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> Q[MAXN], head, tail;</span><br><span class="line">    Q[head = <span class="number">1</span>] = tail = <span class="number">0</span>, fail[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; SIGMA; ++c) &#123;</span><br><span class="line">      <span class="keyword">int</span>&amp; v = ch[<span class="number">1</span>][c];</span><br><span class="line">      <span class="keyword">if</span> (v) Q[++tail] = v, fail[v] = <span class="number">1</span>; <span class="keyword">else</span> v = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">      <span class="keyword">int</span> u = Q[head++];</span><br><span class="line">      size[u] += size[fail[u]], val[u] += val[fail[u]];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; SIGMA; ++c) &#123;</span><br><span class="line">        <span class="keyword">int</span>&amp; v = ch[u][c];</span><br><span class="line">        <span class="keyword">if</span> (v) Q[++tail] = v, fail[v] = ch[fail[u]][c];</span><br><span class="line">        <span class="keyword">else</span> v = ch[fail[u]][c];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; Mid, <span class="keyword">bool</span> flag = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= nidx; ++u)</span><br><span class="line">      A[u] = val[u] - Mid * size[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= nidx; ++u) f[i][u] = -INFD;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= nidx; ++u) <span class="keyword">if</span> (f[i - <span class="number">1</span>][u] &gt; -INFD) &#123;</span><br><span class="line">        <span class="keyword">if</span> (T[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; SIGMA; ++c) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span>&amp; v = ch[u][c];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ckmax</span>(f[i][v], f[i - <span class="number">1</span>][u] + A[v]))</span><br><span class="line">              g[i][v][<span class="number">0</span>] = c, g[i][v][<span class="number">1</span>] = u;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">int</span> c = T[i] - <span class="string">&#x27;0&#x27;</span>, &amp;v = ch[u][c];</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">ckmax</span>(f[i][v], f[i - <span class="number">1</span>][u] + A[v]))</span><br><span class="line">            g[i][v][<span class="number">0</span>] = c, g[i][v][<span class="number">1</span>] = u;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">2</span>; u &lt;= nidx; ++u)</span><br><span class="line">      <span class="keyword">if</span> (f[n][u] &gt; f[n][v]) v = u;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> u = v, i = n; i; --i)</span><br><span class="line">        S[i] = g[i][u][<span class="number">0</span>] + <span class="string">&#x27;0&#x27;</span>, u = g[i][u][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dcmp</span>(f[n][v]) &gt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  AC::<span class="built_in">init</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;n, &amp;m, T + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> w, i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, S + <span class="number">1</span>, &amp;w), AC::<span class="built_in">insert</span>(<span class="built_in">log</span>(w));</span><br><span class="line"> </span><br><span class="line">  AC::<span class="built_in">getfail</span>();</span><br><span class="line">  <span class="keyword">double</span> L = <span class="number">0.0</span>, R = <span class="built_in">log</span>(INFD);</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">dcmp</span>(R - L) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">double</span> Mid = (L + R) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (AC::<span class="built_in">check</span>(Mid)) L = Mid; <span class="keyword">else</span> R = Mid;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  AC::<span class="built_in">check</span>(L, <span class="literal">true</span>), <span class="built_in">puts</span>(S + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「BJOI2019」勘破神机"><a href="#「BJOI2019」勘破神机" class="headerlink" title="「BJOI2019」勘破神机"></a>「BJOI2019」勘破神机</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3090">https://loj.ac/problem/3090</a></li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>先假设我们已经知道了第 $n$ 项的答案为 $h_n$. 那么所求即为 $\frac{1}{R - L + 1}$ 乘上</p><script type="math/tex; mode=display">\sum_{n = L} ^ R H(n, k) = \sum_{n = L} ^ R \binom{h_n}{k} = \frac{1}{k!} \sum_{n = L} ^ R {h_n} ^ {\underline k}</script><p>后者是下降幂的形式, 可以联想到</p><script type="math/tex; mode=display">x ^ {\underline{k}} = \sum_{i = 0} ^ k (-1) ^ {k - i} \begin{bmatrix} k \\ i \end{bmatrix} x ^ i</script><p>其中 $\begin{bmatrix} n \\ m \end{bmatrix}$ 表示第一类 Stirling 数. 此处可直接使用有符号第一类 Stirling 数来消去 $-1$.</p><p>那么原式可化作</p><script type="math/tex; mode=display">\frac{1}{k!} \sum_{n = L} ^ R \sum_{i = 0} ^ k (-1) ^ {k - i} \begin{bmatrix} k \\ i \end{bmatrix} {h_n} ^ i = \frac{1}{k!} \sum_{i = 0} ^ k (-1) ^ {k - i} \begin{bmatrix} k \\ i \end{bmatrix} \sum_{n = L} ^ R {h_n} ^ i</script><p>这就启发我们去求 $h_n$ 的通项公式.</p><p>先考虑 $m = 2$ 的情况, 此时是个经典问题. 记 Fibonacci 数列为 $f_n$, 且有 $f_0 = 0,\ f_1 = 1$, 那么 $f_{n + 1}$ 即为 $2 \times n$ 网格的填充方案, 此时直接将 $L, R + 1$.</p><p>根据 Fibonacci 数列的递推公式, 并利用特征方程可以解出 $f_n$ 的通项为</p><script type="math/tex; mode=display">f_n = \frac{1}{\sqrt 5} \left( \frac{1 + \sqrt 5}{2} \right) ^ n - \frac{1}{\sqrt 5} \left( \frac{1 - \sqrt 5}{2} \right) ^ n</script><p>设 $A = \frac{1}{\sqrt 5},\ B = -\frac{1}{\sqrt 5},\ x = \frac{1 + \sqrt 5}{2},\ y = \frac{1 - \sqrt 5}{2}$, 那么 $f_n = A x ^ n + B y ^ n$.</p><p>带入到原式继续化简, 可得</p><script type="math/tex; mode=display">\frac{1}{k!} \sum_{n = L} ^ R \sum_{i = 0} ^ k (-1) ^ {k - i} \begin{bmatrix} k \\ i \end{bmatrix} {h_n} ^ i = \frac{1}{k!} \sum_{i = 0} ^ k (-1) ^ {k - i} \begin{bmatrix} k \\ i \end{bmatrix} \sum_{n = L} ^ R (A x ^ n + B y ^ n) ^ i</script><script type="math/tex; mode=display">\frac{1}{k!} \sum_{i = 0} ^ k (-1) ^ {k - i} \begin{bmatrix} k \\ i \end{bmatrix} \sum_{n = L} ^ R \sum_{j = 0} ^ i \binom{i}{j} A^i B^{i - j} (x^j y^{i - j}) ^ n</script><script type="math/tex; mode=display">\frac{1}{k!} \sum_{i = 0} ^ k (-1) ^ {k - i} \begin{bmatrix} k \\ i \end{bmatrix} \sum_{j = 0} ^ i \binom{i}{j} A^i B^{i - j} \sum_{n = L} ^ R (x^j y^{i - j}) ^ n</script><p>后者为等比数列部分和, 直接计算 $O(\log R)$ 即可. 时间复杂度 $O(k ^ 2 \log R)$.</p><p>此时还有一个问题. 注意到 $5 ^ {(998244353 - 1) / 2} \equiv -1 \pmod {998244353}$, 即模意义下 $\sqrt{5}$ 不存在. 此时可运用称之为 “扩域” 的技巧, 也就是将数表示为 $x + \sqrt 5 y$ 的形式, 用类似于模意义下复数的方式进行运算. 同时, 最终结果一定为整数, 取 $x$ 值即可.</p><p>现在考虑 $m = 3$ 的情况. </p><p>手玩之后可以得出, 除去 $n = 2$ 的情况之外, 仅存在两种方式, 使得长度为偶数的网格被铺满, 且不是若干长度较小的偶数网格拼接而成. 同时, $n$ 为奇数时方案数为 $0$.</p><p>设 $g_n$ 为铺满 $3 \times 2n$ 网格的方案数. 则根据上述性质, 有</p><script type="math/tex; mode=display">g_n = \begin{cases} 0 & n = 0 \\ 3 & n = 1 \\ g_{n - 1} + 2 \sum\limits_{i = 1} ^ n g_{n - i} & n > 1\end{cases}</script><p>利用一些运算的技巧, 可得</p><script type="math/tex; mode=display">g_n = 4 g_{n - 1} - g_{n - 2}</script><p>利用之前的方法, 可以得出</p><script type="math/tex; mode=display">g_n = \left( \frac{3 + \sqrt{3}}{6} \right) (2 + \sqrt{3}) ^ n + \left( \frac{3 - \sqrt{3}}{6} \right) (2 - \sqrt{3}) ^ n</script><p>直接算就完事了.</p><p>时间复杂度 $O(k ^ 2 \log R)$. <del>然而存在时间复杂度更为优秀的神仙做法…</del></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>在利用快速幂计算 $x + \sqrt{5} y$ 的幂时, 不要天真地把指数模 $P - 1$…</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3090</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">5e2</span> + <span class="number">5</span>, P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Mod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span> </span>&#123; <span class="keyword">return</span> x + (x &gt;&gt; <span class="number">31</span> &amp; P); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mns</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Mod</span>(a - b); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pls</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Mod</span>(a + b - P); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1LL</span> * a * b % P; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stl[MAXK][MAXK];</span><br><span class="line"><span class="keyword">int</span> fac[MAXK], ifac[MAXK], inv[MAXK];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (n &lt; m)? <span class="number">0</span>: <span class="built_in">mul</span>(<span class="built_in">mul</span>(fac[n], ifac[m]), ifac[n - m]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="built_in">mul</span>(ret, base);</span><br><span class="line">    base = <span class="built_in">mul</span>(base, base), b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreDone</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">  inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">    inv[i] = <span class="built_in">mul</span>(inv[P % i], P - P / i);</span><br><span class="line">  ifac[<span class="number">0</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    fac[i] = <span class="built_in">mul</span>(i, fac[i - <span class="number">1</span>]), ifac[i] = <span class="built_in">mul</span>(inv[i], ifac[i - <span class="number">1</span>]);</span><br><span class="line">  stl[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">      stl[i][j] = <span class="built_in">mns</span>(stl[i - <span class="number">1</span>][j - <span class="number">1</span>], <span class="built_in">mul</span>(i - <span class="number">1</span>, stl[i - <span class="number">1</span>][j]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL Sqrt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Int</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x, y; <span class="comment">// x + sqrt&#123;Sqrt&#125; y</span></span><br><span class="line">  <span class="built_in">Int</span> (<span class="keyword">int</span> _x = <span class="number">0</span>, <span class="keyword">int</span> _y = <span class="number">0</span>): <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y) &#123; &#125;</span><br><span class="line">  Int <span class="keyword">operator</span> + (<span class="keyword">const</span> Int&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Int</span>(<span class="built_in">pls</span>(x, rhs.x), <span class="built_in">pls</span>(y, rhs.y));</span><br><span class="line">  &#125;</span><br><span class="line">  Int <span class="keyword">operator</span> - (<span class="keyword">const</span> Int&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Int</span>(<span class="built_in">mns</span>(x, rhs.x), <span class="built_in">mns</span>(y, rhs.y));</span><br><span class="line">  &#125;</span><br><span class="line">  Int <span class="keyword">operator</span> * (<span class="keyword">const</span> Int&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> ac = <span class="built_in">mul</span>(x, rhs.x), ad = <span class="built_in">mul</span>(x, rhs.y), bc = <span class="built_in">mul</span>(y, rhs.x);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Int</span>(<span class="built_in">pls</span>(ac, Sqrt * y % P * rhs.y % P), <span class="built_in">pls</span>(bc, ad));</span><br><span class="line">  &#125;</span><br><span class="line">  Int <span class="keyword">operator</span> / (<span class="keyword">const</span> Int&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> ac = <span class="built_in">mul</span>(x, rhs.x), ad = <span class="built_in">mul</span>(x, rhs.y), bc = <span class="built_in">mul</span>(y, rhs.x);</span><br><span class="line">    <span class="keyword">int</span> iv = <span class="built_in">fpow</span>(<span class="built_in">mns</span>(<span class="built_in">mul</span>(rhs.x, rhs.x), Sqrt * rhs.y % P * rhs.y % P), P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Int</span>(<span class="built_in">mns</span>(ac, Sqrt * y % P * rhs.y % P), <span class="built_in">mns</span>(bc, ad)) * iv;</span><br><span class="line">  &#125;</span><br><span class="line">  Int <span class="keyword">operator</span> += (<span class="keyword">const</span> Int&amp; rhs) &#123; <span class="keyword">return</span> x = <span class="built_in">pls</span>(x, rhs.x), y = <span class="built_in">pls</span>(y, rhs.y), *<span class="keyword">this</span>; &#125;</span><br><span class="line">  Int <span class="keyword">operator</span> -= (<span class="keyword">const</span> Int&amp; rhs) &#123; <span class="keyword">return</span> x = <span class="built_in">mns</span>(x, rhs.x), y = <span class="built_in">pls</span>(y, rhs.y), *<span class="keyword">this</span>; &#125;</span><br><span class="line">  Int <span class="keyword">operator</span> *= (<span class="keyword">const</span> Int&amp; rhs) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> * rhs; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Int <span class="title">conj</span><span class="params">(<span class="keyword">const</span> Int&amp; x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Int</span>(x.x, <span class="built_in">mns</span>(<span class="number">0</span>, x.y)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Int <span class="title">fpowInt</span><span class="params">(Int base, LL b)</span> </span>&#123;</span><br><span class="line">  Int ret = <span class="built_in">Int</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> ( ; b &gt; <span class="number">0</span>; base *= base, b &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret *= base;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Int <span class="title">Sum</span><span class="params">(<span class="keyword">const</span> LL&amp; L, <span class="keyword">const</span> LL&amp; R, <span class="keyword">const</span> Int&amp; q)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (q.x == <span class="number">1</span> &amp;&amp; q.y == <span class="number">0</span>) <span class="keyword">return</span> (R - L + <span class="number">1</span>) % P;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">fpowInt</span>(q, R + <span class="number">1</span>) - <span class="built_in">fpowInt</span>(q, L)) / (q - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(LL L, LL R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k, <span class="keyword">const</span> <span class="keyword">int</span>&amp; m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Int pa[MAXK], pb[MAXK], px[MAXK], py[MAXK], A, x;</span><br><span class="line">  <span class="keyword">int</span> lgt = (R - L + <span class="number">1</span>) % P;</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">2</span>)</span><br><span class="line">    Sqrt = <span class="number">5</span>, A = <span class="built_in">Int</span>(<span class="number">0</span>, <span class="number">1</span>) / <span class="number">5</span>, x = <span class="built_in">Int</span>(<span class="number">1</span>, <span class="number">1</span>) / <span class="number">2</span>, ++L, ++R;</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">3</span>)</span><br><span class="line">    Sqrt = <span class="number">3</span>, A = <span class="built_in">Int</span>(<span class="number">3</span>, <span class="number">1</span>) / <span class="number">6</span>, x = <span class="built_in">Int</span>(<span class="number">2</span>, <span class="number">1</span>), L = (L + <span class="number">1</span>) / <span class="number">2</span>, R /= <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  pa[<span class="number">0</span>] = pb[<span class="number">0</span>] = px[<span class="number">0</span>] = py[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">    pa[i] = pa[i - <span class="number">1</span>] * A, pb[i] = pb[i - <span class="number">1</span>] * <span class="built_in">conj</span>(A);</span><br><span class="line">    px[i] = px[i - <span class="number">1</span>] * x, py[i] = py[i - <span class="number">1</span>] * <span class="built_in">conj</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  Int ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">    Int s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">      s += <span class="built_in">Sum</span>(L, R, px[j] * py[i - j]) * pa[j] * pb[i - j] * <span class="built_in">C</span>(i, j);</span><br><span class="line">    ret += s * stl[k][i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">mul</span>(<span class="built_in">fpow</span>(lgt, P - <span class="number">2</span>), <span class="built_in">mul</span>(ifac[k], ret.x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> Ti, m, k;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;Ti, &amp;m);</span><br><span class="line">  <span class="built_in">PreDone</span>(MAXK - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (LL L, R; Ti; --Ti)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%d&quot;</span>, &amp;L, &amp;R, &amp;k), <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">solve</span>(L, R, k, m));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「BJOI2019」送别"><a href="#「BJOI2019」送别" class="headerlink" title="「BJOI2019」送别"></a>「BJOI2019」送别</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3091">https://loj.ac/problem/3091</a></li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a><del>解题思路</del></h4><p>送别 $\times$, 带走 $\checkmark$</p><h3 id="「BJOI2019」排兵布阵"><a href="#「BJOI2019」排兵布阵" class="headerlink" title="「BJOI2019」排兵布阵"></a>「BJOI2019」排兵布阵</h3><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3092">https://loj.ac/problem/3092</a></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>这是一道定位在 NOIP Day 1 T2 的送分题 (</p><p>考虑 DP. 首先每个城堡和对手完全独立, 互不干扰. 设 $f(i, j)$ 表示已考虑完前 $i$ 个城堡, 小 C 剩余 $j$ 名士兵的得分最大值. 有</p><script type="math/tex; mode=display">f(i, j) = \max_{k} \{ f(i - 1, j - k) + w(i, k)\}</script><p>其中 $w(i, k)$ 表示对于城堡 $i$ 派遣 $k$ 名士兵, 所有对局的总得分. 显然有 $O(s)$ 的暴力计算方法, 将对手派遣士兵个数从小到大排序, 依次枚举, 可以 $O(1)$ 的时间内转移.</p><p>时间复杂度 $O(nms)$.</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3092</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a &lt; b)? a = b, <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e2</span> + <span class="number">5</span>, MAXM = <span class="number">2e4</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s, n, m;</span><br><span class="line"><span class="keyword">int</span> A[MAXN][MAXN], f[MAXN][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;s, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> w, i = <span class="number">1</span>; i &lt;= s; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w), A[j][i] = <span class="number">2</span> * w + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> *w, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    w = A[i], <span class="built_in">sort</span>(w + <span class="number">1</span>, w + <span class="number">1</span> + s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= s &amp;&amp; j &gt;= w[k]; ++k)</span><br><span class="line">        <span class="built_in">ckmax</span>(f[i][j], f[i - <span class="number">1</span>][j - w[k]] + k * i);</span><br><span class="line">      <span class="built_in">ckmax</span>(ans, f[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「BJOI2019」光线"><a href="#「BJOI2019」光线" class="headerlink" title="「BJOI2019」光线"></a>「BJOI2019」光线</h3><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3093">https://loj.ac/problem/3093</a></li></ul><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>这是一道物理题, 难点在于推式子.</p><p>设 $f_i$ 表示前 $i$ 层玻璃, 从第 $1$ 层玻璃射入光的透光率. 那么 $f_n$ 即为答案. 此时问题仍不好解决, 因为没有考虑到反射对答案的影响. 那么设 $g_n$ 表示从第 $n$ 层玻璃向上射入光的反射率. 因此有</p><script type="math/tex; mode=display">f_n = a_n \cdot f_{n - 1} \sum_{k = 0} ^ \infty (g_{n - 1} b_n) ^ k = a_n \cdot \frac{f_{n - 1}}{g_{n - 1} b_n}</script><p>表示透过第 $n$ 层的光来自上一层透过的光, 以及反射到上一层, 从而对本层做出贡献的部分.</p><script type="math/tex; mode=display">g_n = b_n + {a_n} ^ 2 g_{n - 1} \sum_{k = 0} ^ \infty (g_{n - 1} b_n) ^ k = b_n + \frac{ {a_n} ^ 2 g_{n - 1}}{g_{n - 1} b_n}</script><p>表示光在第 $n$ 层反射的贡献 ($b_n$), 另外有透过第 $n$ 层 (乘上 $a_n$), 并再次在第 $n - 1$ 层反射回来, 或是多次反射 ($g_{n - 1} \sum\limits_{k = 0} ^ \infty (g_{n - 1} b_n)$), 通过第 $n$ 层玻璃 (在原有基础上乘 $a_n$) 的部分.</p><p>递推计算即可. 时间复杂度 $O(n \log P)$.</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3093</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e5</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>, iv100 = <span class="number">570000004</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!b) x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">exgcd</span>(b, a % b, y, x), y -= a / b * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> x, y;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">exgcd</span>(a, P, x, y), (x % P + P) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN], f[MAXN], g[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">read</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">read</span>(A[i]), <span class="built_in">read</span>(B[i]);</span><br><span class="line">    A[i] = <span class="number">1LL</span> * A[i] * iv100 % P, B[i] = <span class="number">1LL</span> * B[i] * iv100 % P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f[<span class="number">1</span>] = A[<span class="number">1</span>], g[<span class="number">1</span>] = B[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> iv = <span class="built_in">inv</span>((<span class="number">1</span> - <span class="number">1LL</span> * B[i] * g[i - <span class="number">1</span>] % P + P) % P);</span><br><span class="line">    f[i] = <span class="number">1LL</span> * A[i] * f[i - <span class="number">1</span>] % P * iv % P;</span><br><span class="line">    g[i] = (B[i] + <span class="number">1LL</span> * A[i] * A[i] % P * g[i - <span class="number">1</span>] % P * iv % P) % P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「BJOI2019」删数"><a href="#「BJOI2019」删数" class="headerlink" title="「BJOI2019」删数"></a>「BJOI2019」删数</h3><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3094">https://loj.ac/problem/3094</a></li></ul><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>可以发现每个数的位置在查询答案时是没有影响的. 如果将所有数丢到一个桶里, 即统计每个数的出现次数, 形成一个柱状的结构. 那么, 对于一次询问, 相当于将所有数向按值域所在位置向左填充, 或者形象地, 将柱子向左推倒. 此时 $[1,\ n]$ 中未覆盖位置即为答案.</p><p>同时要注意最大数 $&gt; n$, 此部分贡献单独统计 —- 因为一定会被修改, 而不能同前文一样计算向左覆盖的位置. 正确性证明大概是先证明此时得出的结果是所有答案的下界, 并将所有重复填充的位置选择一部分修改, 一定能达到这个下界.</p><p>现在的问题在于如何维护这个过程, 考虑用线段树去维护这个桶, 即维护每个位置被覆盖的次数.</p><p>对于计算答案, 记录区间最小值, 以及最小值出现的次数. 那么, 一个区间能做出贡献, 当且仅当该区间未被覆盖, 即区间最小值为 $0$, 用最小值出现次数更新答案即可. 向上合并时直接将子区间答案合并即可.</p><p>对于 $p &gt; 0$, 维护区间加的标记即可. 注意单独统计贡献的部分无需计算覆盖位置, 以及下传标记时需统计答案.</p><p>对于 $p = 0$, 也就是全局修改. 对应在桶中的影响, 也就是整体位移. 直接记录当前桶中 $0$ 的位置 $p_0$, 每次对应修改 $p_0$ 即可, 那么查询的区间为 $[p_0 + 1,\ p_0 + n]$.</p><p>值得留意的地方依旧是 $&gt; p_0 + n$ 的位置, 注意加上 / 减去边界的覆盖情况.</p><p>时间复杂度 $O(m \log n)$.</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3094</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1.5e5</span> + <span class="number">5</span>, MAXM = MAXN &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p0, N;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], bkt[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (nd &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (nd &lt;&lt; 1 | 1)</span></span><br><span class="line">  <span class="keyword">int</span> Mn[MAXM &lt;&lt; <span class="number">2</span>], Cnt[MAXM &lt;&lt; <span class="number">2</span>], dat[MAXM &lt;&lt; <span class="number">2</span>], tag[MAXM &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; nd)</span> </span>&#123;</span><br><span class="line">    dat[nd] = dat[lc] + dat[rc];</span><br><span class="line">    Mn[nd] = <span class="built_in">min</span>(Mn[lc], Mn[rc]);</span><br><span class="line">    Cnt[nd] = (Mn[lc] == Mn[nd]) * Cnt[lc] + (Mn[rc] == Mn[nd]) * Cnt[rc];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; nd, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    tag[nd] += v, Mn[nd] += v, dat[nd] = (Mn[nd] == <span class="number">0</span>) * Cnt[nd];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; nd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag[nd] != <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">push</span>(lc, tag[nd]), <span class="built_in">push</span>(rc, tag[nd]), tag[nd] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>( Cnt[nd] = dat[nd] = <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc, L, Mid), <span class="built_in">build</span>(rc, Mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">maintain</span>(nd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> <span class="built_in">push</span>(nd, v);</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(nd);</span><br><span class="line">    <span class="keyword">if</span> (opL &lt;= Mid) <span class="built_in">Mdy</span>(lc, L, Mid, opL, opR, v);</span><br><span class="line">    <span class="keyword">if</span> (opR &gt; Mid) <span class="built_in">Mdy</span>(rc, Mid + <span class="number">1</span>, R, opL, opR, v);</span><br><span class="line">    <span class="built_in">maintain</span>(nd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> dat[nd];</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(nd);</span><br><span class="line">    <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> <span class="built_in">Qry</span>(lc, L, Mid, opL, opR);</span><br><span class="line">    <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> <span class="built_in">Qry</span>(rc, Mid + <span class="number">1</span>, R, opL, opR);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Qry</span>(lc, L, Mid, opL, opR) + <span class="built_in">Qry</span>(rc, Mid + <span class="number">1</span>, R, opL, opR);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; v, <span class="keyword">const</span> <span class="keyword">int</span>&amp; d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = (d &gt; <span class="number">0</span>)? v - bkt[v]: v - bkt[v] + <span class="number">1</span>;</span><br><span class="line">  SGT::<span class="built_in">Mdy</span>(<span class="number">1</span>, <span class="number">1</span>, N, p, p, d), bkt[v] += d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(A[i]);</span><br><span class="line"></span><br><span class="line">  N = (m + n) * <span class="number">2</span> + <span class="number">1</span>, p0 = m + n;</span><br><span class="line">  SGT::<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, N);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) A[i] += p0, <span class="built_in">Mdy</span>(A[i], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> p, x; m; --m) &#123;</span><br><span class="line">    <span class="built_in">read</span>(p), <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (A[p] &lt;= p0 + n) <span class="built_in">Mdy</span>(A[p], <span class="number">-1</span>); <span class="keyword">else</span> --bkt[A[p]];</span><br><span class="line">      A[p] = p0 + x;</span><br><span class="line">      <span class="keyword">if</span> (A[p] &lt;= p0 + n) <span class="built_in">Mdy</span>(A[p], <span class="number">1</span>); <span class="keyword">else</span> ++bkt[A[p]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      p = (x &lt; <span class="number">0</span>)? (p0 + <span class="number">1</span>) + n: p0 + n;</span><br><span class="line">      <span class="keyword">if</span> (bkt[p] &gt; <span class="number">0</span>)</span><br><span class="line">        SGT::<span class="built_in">Mdy</span>(<span class="number">1</span>, <span class="number">1</span>, N, p - bkt[p] + <span class="number">1</span>, p, -x);</span><br><span class="line">      p0 -= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, SGT::<span class="built_in">Qry</span>(<span class="number">1</span>, <span class="number">1</span>, N, p0 + <span class="number">1</span>, p0 + n));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;del&gt;听说大赏的意思好像和我之前认为的不太一样?&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;没文化啊.png&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>ZJOI 2015 大赏</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/sx/ZJOI-2015-sol/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/sx/ZJOI-2015-sol/</id>
    <published>2020-04-21T08:57:39.000Z</published>
    <updated>2020-05-25T11:35:17.531Z</updated>
    
    <content type="html"><![CDATA[<hr><p>做这套题纯粹是为了好玩… 结果惨遭吊打 = =</p><span id="more"></span><h3 id="「ZJOI2015」幻想乡战略游戏"><a href="#「ZJOI2015」幻想乡战略游戏" class="headerlink" title="「ZJOI2015」幻想乡战略游戏"></a>「ZJOI2015」幻想乡战略游戏</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2135">https://loj.ac/problem/2135</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>点分树是不可能的, 这辈子不可能写的. 数据结构又不会, 只能写写模板这样子.</del></p><p>考虑重链剖分.</p><p>不妨钦定 $1$ 为根. 记 $s_u$ 为 $u$ 子树内 $d$ 值之和. 对于一条边 $(u, v)$, 如果选择 $v$ 比 $u$ 更优, 也就是最终花费的变化量为负, 即</p><script type="math/tex; mode=display">w(u, v) \cdot (s_u - s_v) - w(u, v) \cdot s_v < 0 \\\ 2 s_v > s_u</script><p>因此有一个在线段树上二分 DFS 序, 找出最优点 $v$ 的做法.</p><p>同时记 $\text{dist}(u)$ 为点 $u$ 到根节点的距离, 那么最小花费可以表示为</p><script type="math/tex; mode=display">\sum_{v = 1} ^ n d_v \cdot \text{dist}(u, v) = \sum_{v = 1} ^ n d_v \cdot \big(\text{dist}(u) + \text{dist}(v) - 2 \text{dist}(\text{LCA}(u, v))\big)</script><script type="math/tex; mode=display">\text{dist}(u) \sum_{v = 1} ^ n d_v + \sum_{v = 1} ^ n d_v \cdot \text{dist}(v) - 2 \sum_{v = 1} ^ n d_v \cdot \text{dist}(\text{LCA}(u, v))</script><p>前两项很好维护, 记录 $d_v$ 和 $d_v \cdot \text{dist}(v)$ 的和即可.</p><p>注意到 $u$ 的子树内的点, 同 $u$ 的 LCA 一定是 $u$, 而其他点和 $u$ 的 LCA 一定在 $u$ 到根的路径上.</p><p>考虑使用重链剖分统计这些可能成为 LCA 的点对答案的贡献.</p><p>每次 $d_v$ 改变时, 从 $v$ 到根节点依次修改, 将变化量 $e$ 加入子树内包含 $v$ 的节点上. 设这些节点为 $u$, $u$ 的父亲节点为 $f$, 此时对答案贡献的变化即为 $e \cdot \big( \text{dist}(u) - \text{dist}(f) \big)$, 即 $u$ 到 $f$ 的边贡献的变化量. 用线段树维护就好了.</p><p>查询直接对统计的这些贡献求和即可.</p><p>时间复杂度 $O(n + q \log ^ 2 n)$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2135</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line">LL A[MAXN], dist[MAXN];</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN], rnk[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, w; &#125; edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, w &#125;, head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (nd&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (nd&lt;&lt;1|1)</span></span><br><span class="line">    LL s[MAXN &lt;&lt; <span class="number">2</span>], w[MAXN &lt;&lt; <span class="number">2</span>], datSum[MAXN &lt;&lt; <span class="number">2</span>], tagAdd[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">        s[nd] = <span class="built_in">max</span>(s[lc], s[rc]);</span><br><span class="line">        datSum[nd] = datSum[lc] + datSum[rc];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushAdd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; nd, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">        s[nd] += v, tagAdd[nd] += v, datSum[nd] += w[nd] * v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tagAdd[nd] != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">pushAdd</span>(lc, tagAdd[nd]), <span class="built_in">pushAdd</span>(rc, tagAdd[nd]), tagAdd[nd] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>( w[nd] = A[L] );</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">build</span>(lc, L, Mid), <span class="built_in">build</span>(rc, Mid+<span class="number">1</span>, R);</span><br><span class="line">        w[nd] = w[lc] + w[rc];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR, <span class="keyword">const</span> <span class="keyword">int</span>&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> <span class="built_in">pushAdd</span>(nd, d);</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">pushdown</span>(nd);</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= Mid) <span class="built_in">Mdy</span>(lc, L, Mid, opL, opR, d);</span><br><span class="line">        <span class="keyword">if</span> (opR &gt; Mid) <span class="built_in">Mdy</span>(rc, Mid+<span class="number">1</span>, R, opL, opR, d);</span><br><span class="line">        <span class="built_in">maintain</span>(nd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> datSum[nd];</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">pushdown</span>(nd);</span><br><span class="line">        <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> <span class="built_in">Qry</span>(lc, L, Mid, opL, opR);</span><br><span class="line">        <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> <span class="built_in">Qry</span>(rc, Mid+<span class="number">1</span>, R, opL, opR);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Qry</span>(lc, L, Mid, opL, opR) + <span class="built_in">Qry</span>(rc, Mid+<span class="number">1</span>, R, opL, opR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Qry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Mid, nd = <span class="number">1</span>, L = <span class="number">1</span>, R = n;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">            Mid = (L + R) / <span class="number">2</span>, <span class="built_in">pushdown</span>(nd);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * s[rc] &gt;= s[<span class="number">1</span>]) nd = rc, L = Mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> nd = lc, R = Mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rnk[L];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HLD &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">int</span> size[MAXN], son[MAXN], pre[MAXN], topfa[MAXN], clk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        pre[u] = fa, son[u] = <span class="number">-1</span>, size[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) == fa) <span class="keyword">continue</span>;</span><br><span class="line">            dist[v] = dist[u] + edges[i].w;</span><br><span class="line">            <span class="built_in">dfs1</span>(v, u), size[u] += size[v];</span><br><span class="line">            <span class="keyword">if</span> (son[u] == <span class="number">-1</span> || size[v] &gt; size[son[u]]) son[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">        topfa[u] = top, rnk[dfn[u] = ++clk] = u;</span><br><span class="line">        A[clk] = dist[u] - dist[pre[u]];</span><br><span class="line">        <span class="keyword">if</span> (~son[u]) <span class="built_in">dfs2</span>(son[u], top);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) != pre[u] &amp;&amp; v != son[u]) <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt = <span class="number">1</span>)</span> </span>&#123; <span class="built_in">dfs1</span>(rt, <span class="number">0</span>), <span class="built_in">dfs2</span>(rt, rt); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; p, <span class="keyword">const</span> <span class="keyword">int</span>&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = p; u &gt; <span class="number">0</span>; u = pre[topfa[u]])</span><br><span class="line">            SGT::<span class="built_in">Mdy</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[topfa[u]], dfn[u], d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; p)</span> </span>&#123;</span><br><span class="line">        LL ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = p; u &gt; <span class="number">0</span>; u = pre[topfa[u]])</span><br><span class="line">            ret += SGT::<span class="built_in">Qry</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[topfa[u]], dfn[u]);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::<span class="built_in">init</span>();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, w, i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(u), <span class="built_in">read</span>(v), <span class="built_in">read</span>(w);</span><br><span class="line">        Graph::<span class="built_in">AddEdge</span>(u, v, w), Graph::<span class="built_in">AddEdge</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    HLD::<span class="built_in">solve</span>(<span class="number">1</span>), SGT::<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    LL sumd = <span class="number">0</span>, sumdd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> rt, u, e; q; --q) &#123;</span><br><span class="line">       <span class="built_in">read</span>(u), <span class="built_in">read</span>(e);</span><br><span class="line">       sumd += e, sumdd += e * dist[u];</span><br><span class="line">       HLD::<span class="built_in">Mdy</span>(u, e), rt = SGT::<span class="built_in">Qry</span>();</span><br><span class="line">       LL ret = sumdd + sumd * dist[rt] - <span class="number">2</span> * HLD::<span class="built_in">Qry</span>(rt);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「ZJOI2015」地震后的幻想乡"><a href="#「ZJOI2015」地震后的幻想乡" class="headerlink" title="「ZJOI2015」地震后的幻想乡"></a>「ZJOI2015」地震后的幻想乡</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2136">https://loj.ac/problem/2136</a></li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>套 Min/Max 容斥结果越想越偏是屑…</del></p><p>这里是一个平民做法.</p><p>考虑如何运用提示给出的公式. 模拟 Kruskal 的过程, 假定第 $k$ 次加入边后恰好得到一棵生成树, 那么对答案的贡献为 $\frac{k}{m + 1}$, 同时概率可以用合法方案数除以总方案数得出.</p><p>注意到一棵生成树的权值是对所有边取 $\max$. 那么对于一个连通图, 在该连通图恰好连通时内部边权的最大值, 和生成树的边权最大值是相同的, 因此可以从图的连通上考虑.</p><p>但是在恰好第 $k$ 次加入边得到连通图的情况不好统计, 做一步转化: 恰好加入第 $k$ 条边后图连通的方案数, 为: 加入这条边前不连通的方案数 - 加入这条边后不连通的方案数.</p><p>考虑用状压 DP 来求这个东西. 设 $f(S, i)$ 为当前选择的点集为 $S$, 已经使用了 $i$ 条边, 点集不连通的方案数.</p><p>记点集的全集为 $U$, $d(S)$ 为同点集 $S$ 相关的边的个数, 那么答案为</p><script type="math/tex; mode=display">\sum_{k = 1} ^ m \frac{k}{m + 1} \left(\frac{f(U, k - 1)}{\binom{d(U)}{k - 1}} - \frac{f(U, k)}{\binom{d(U)}{k}}\right)</script><p>化简, 得</p><script type="math/tex; mode=display">\frac{1}{m + 1} \sum_{k = 1} ^ {m - 1} \frac{f(U, k)}{\binom{d(U)}{k}}</script><p>同时, 点集连通的方案数为 $\binom{d(S)}{i} - f(S, i)$, 其中 $d(S)$ 可以通过枚举子集算出, 而点集连通时的方案数在转移 $f$ 时会用到.</p><p>点集不连通的情况可看作由一个连通非空子集上加边, 并保证新加入的点中存在不连通情况得出的. 因此有</p><script type="math/tex; mode=display">f(S, i) = \sum_{ T \subset S,\ T \neq \varnothing } \sum_{j = 0} ^ {d(T)} \binom{d(S \setminus T)}{i - j} \cdot \left(\binom{d(T)}{j} - f(T, j)\right)</script><p>枚举子集转移即可. 注意转移时, 需要钦定 $S$ 中某个点, 使得 $T$ 必须包含该点, 否则会重复计算一些情况. 实现时可使用 <code>lowbit</code>.</p><p>至于为什么钦点一个点是对的, 可参看 <a href="https://www.luogu.com.cn/blog/command-block/solution-p3343">command_block 的题解</a></p><p>时间复杂度大概是 $O(m3 ^ n)$?</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>轻微压行.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2136</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10</span>, MAXM = MAXN * (MAXN - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">1</span> &lt;&lt; MAXN], d[<span class="number">1</span> &lt;&lt; MAXN];</span><br><span class="line">LL f[<span class="number">1</span> &lt;&lt; MAXN][MAXM], C[MAXM][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v), ++c[<span class="number">1</span> &lt;&lt; (u<span class="number">-1</span>) | <span class="number">1</span> &lt;&lt; (v<span class="number">-1</span>)];</span><br><span class="line">    <span class="comment">// predone</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = C[i][<span class="number">0</span>] = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            C[i][j] = C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j];</span><br><span class="line">    <span class="keyword">int</span> U = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= U; ++s)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = s; t; t = (t<span class="number">-1</span>) &amp; s) d[s] += c[t];</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= U; ++s) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= d[s]; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = (s - <span class="number">1</span>) &amp; s; t; t = (t<span class="number">-1</span>) &amp; s) <span class="keyword">if</span> (t &amp; (s &amp; -s))</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i &amp;&amp; j &lt;= d[t]; ++j)</span><br><span class="line">                f[s][i] += (C[d[t]][j] - f[t][j]) * C[d[s ^ t]][i - j];</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k) ans += f[U][k] / <span class="built_in"><span class="keyword">double</span></span>(C[d[U]][k]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>, ans / (m + <span class="number">1.0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「ZJOI2015」诸神眷顾的幻想乡"><a href="#「ZJOI2015」诸神眷顾的幻想乡" class="headerlink" title="「ZJOI2015」诸神眷顾的幻想乡"></a>「ZJOI2015」诸神眷顾的幻想乡</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2137">https://loj.ac/problem/2137</a></li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>考虑广义 SAM, <del>以及不要读错题, 这题没了</del>.</p><p>显然本质不同子串个数可以通过 SAM 来求.</p><p>注意到一个重要的条件: “一个空地相邻的空地数量不超过 $20$ 个”, 即叶子个数不超过 $20$. 那么从每个叶子开始, 遍历整棵树, 同时建广义 SAM 即可. <del>本质上大概是在 Trie 上建 SAM?</del></p><p>设叶子个数为 $L$, 那么时间复杂度为 $O(nL)$.</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2137</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, C; LL ans;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], deg[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SAM &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = ::MAXN * <span class="number">40</span>, SIGMA = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][SIGMA], lnk[MAXN], len[MAXN], nidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; nidx = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> lst)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = lst;</span><br><span class="line">        <span class="keyword">if</span> (ch[p][val] &amp;&amp; len[ch[p][val]] == len[p] + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> ch[p][val];</span><br><span class="line">        <span class="keyword">int</span> nd = ++nidx, flag = <span class="literal">false</span>;</span><br><span class="line">        len[nd] = len[lst] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !ch[p][val]) ch[p][val] = nd, p = lnk[p];</span><br><span class="line">        <span class="keyword">if</span> (!p) lnk[nd] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> q = ch[p][val];</span><br><span class="line">            <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) lnk[nd] = q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> nxt = ++nidx;</span><br><span class="line">                <span class="keyword">if</span> (p == lst) flag = <span class="literal">true</span>;</span><br><span class="line">                len[nxt] = len[p] + <span class="number">1</span>, lnk[nxt] = lnk[q];</span><br><span class="line">                <span class="built_in">memcpy</span>(ch[nxt], ch[q], <span class="keyword">sizeof</span> ch[nxt]);</span><br><span class="line">                <span class="keyword">while</span> (p &amp;&amp; ch[p][val] == q) ch[p][val] = nxt, p = lnk[p];</span><br><span class="line">                lnk[nd] = lnk[q] = nxt;</span><br><span class="line">                <span class="keyword">if</span> (flag) <span class="keyword">return</span> nxt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += len[nd] - len[lnk[nd]];</span><br><span class="line">        <span class="keyword">return</span> nd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> lst)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nd = SAM::<span class="built_in">Ins</span>(A[u], lst);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) != fa) <span class="built_in">dfs</span>(v, u, nd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    SAM::<span class="built_in">init</span>(), Graph::<span class="built_in">init</span>();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(C);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(u), <span class="built_in">read</span>(v), ++deg[u], ++deg[v];</span><br><span class="line">        Graph::<span class="built_in">AddEdge</span>(u, v), Graph::<span class="built_in">AddEdge</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">        <span class="keyword">if</span> (deg[u] == <span class="number">1</span>) Graph::<span class="built_in">dfs</span>(u, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「ZJOI2015」黑客技术"><a href="#「ZJOI2015」黑客技术" class="headerlink" title="「ZJOI2015」黑客技术"></a>「ZJOI2015」黑客技术</h3><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://uoj.ac/problem/116">https://uoj.ac/problem/116</a></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a><del>解题思路</del></h4><p><del>玩一个上午结果不如随缘乱敲分高是屑…</del></p><p>奥妙啊.</p><h3 id="「ZJOI2015」醉醺醺的幻想乡"><a href="#「ZJOI2015」醉醺醺的幻想乡" class="headerlink" title="「ZJOI2015」醉醺醺的幻想乡"></a>「ZJOI2015」醉醺醺的幻想乡</h3><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2138">https://loj.ac/problem/2138</a></li></ul><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>很厉害的一道题, 以及一个很厉害的题解: <a href="http://c-sunshine.blog.uoj.ac/blog/563">http://c-sunshine.blog.uoj.ac/blog/563</a>.</p><p>如果单位酿酒量 $x$ 只能是整数, 那么就很好解决了: 将费用差分, 根据差分后的结果将原有边拆为 $c_i$, 也就是容量条边.</p><p>但是这里的 $x$ 可以是非负实数, 且最后的结果要求没有精度误差. 因此要使用上述题解的做法. 大体是对费用求导, 然后再积分计算…</p><p>注意到每次跑网络流时得到的是一个一次函数, 容易在残量网络中得出斜率 $k$ 以及截距 $b$, 通过斜截式就比较容易理解代码中的式子.</p><p>以及上述题解代码将半平面上的点和线都写为 <code>pair&lt;frac, frac&gt;</code>, 我的代码将两者区分开了, 这样就会清晰许多.</p><p>记网络流建图时点数为 $V$, 边数为 $E$, 时间复杂度为 $O(n V ^ 2 E)$.</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2138</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e2</span> + <span class="number">5</span>, MAXV = <span class="number">2</span> * MAXN;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eeps = <span class="number">1e-9</span>, EPS = <span class="number">1e-6</span>, INFD = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123; <span class="keyword">return</span> !b? a: <span class="built_in">gcd</span>(b, a % b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">fabs</span>(p) &lt; eeps)? <span class="number">0</span>: (p &lt; <span class="number">0</span>? <span class="number">-1</span>: <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Frac</span> &#123;</span></span><br><span class="line">    LL x, y;</span><br><span class="line">    <span class="built_in">Frac</span>(LL _x = <span class="number">0</span>, LL _y = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_x == <span class="number">0</span>) x = <span class="number">0</span>, y = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> x = _x / <span class="built_in">gcd</span>(_x, _y), y = _y / <span class="built_in">gcd</span>(_x, _y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Frac <span class="keyword">operator</span> + (<span class="keyword">const</span> Frac&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Frac</span>(x * rhs.y + y * rhs.x, y * rhs.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Frac <span class="keyword">operator</span> - (<span class="keyword">const</span> Frac&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Frac</span>(x * rhs.y - y * rhs.x, y * rhs.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Frac <span class="keyword">operator</span> * (<span class="keyword">const</span> Frac&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">Frac</span>(x * rhs.x, y * rhs.y); &#125;</span><br><span class="line">    Frac <span class="keyword">operator</span> / (<span class="keyword">const</span> Frac&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">Frac</span>(x * rhs.y, y * rhs.x); &#125;</span><br><span class="line">    Frac <span class="keyword">operator</span> += (<span class="keyword">const</span> Frac&amp; rhs) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> + rhs; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">val</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">1.0</span> * x / y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">    Frac k, b; <span class="comment">// y = kx + b;</span></span><br><span class="line">    <span class="built_in">Line</span>(Frac _k, Frac _b): <span class="built_in">k</span>(_k), <span class="built_in">b</span>(_b) &#123; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Line&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> k.x == rhs.k.x &amp;&amp; k.y == rhs.k.y &amp;&amp; b.x == rhs.b.x &amp;&amp; b.y == rhs.b.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    Frac x, y;</span><br><span class="line">    <span class="built_in">Point</span>(Frac _x, Frac _y): <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, S, T;</span><br><span class="line"><span class="keyword">int</span> M[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN], C[MAXN], D[MAXN];</span><br><span class="line"></span><br><span class="line">vector&lt;Point&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> to; <span class="keyword">double</span> cap, flow;</span><br><span class="line">        <span class="built_in">Edge</span>(<span class="keyword">int</span> _v, <span class="keyword">double</span> _c, <span class="keyword">double</span> _f): <span class="built_in">to</span>(_v), <span class="built_in">cap</span>(_c), <span class="built_in">flow</span>(_f) &#123; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;Edge&gt; edges;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; G[MAXV];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _n)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _n; ++i) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> c)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(to, c, <span class="number">0.0</span>));</span><br><span class="line">        edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(from, <span class="number">0.0</span>, <span class="number">0.0</span>));</span><br><span class="line">        <span class="keyword">int</span> eidx = edges.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        G[from].<span class="built_in">push_back</span>(eidx - <span class="number">1</span>), G[to].<span class="built_in">push_back</span>(eidx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Dinic &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">size_t</span> cur[MAXV];</span><br><span class="line">    <span class="keyword">int</span> depth[MAXV], vis[MAXV], Time;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        Q.<span class="built_in">push</span>(S), vis[S] = ++Time, depth[S] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> Edge&amp; e = edges[G[u][i]];</span><br><span class="line">                <span class="keyword">if</span> (vis[e.to] != Time &amp;&amp; <span class="built_in">dcmp</span>(e.cap - e.flow) &gt; <span class="number">0</span>)</span><br><span class="line">                    vis[e.to] = Time, depth[e.to] = depth[u] + <span class="number">1</span>, Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[T] == Time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == T || !<span class="built_in">dcmp</span>(a)) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">double</span> f, flow = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span>&amp; i = cur[u]; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[u][i]];</span><br><span class="line">            <span class="keyword">if</span> (depth[e.to] == depth[u] + <span class="number">1</span> &amp;&amp;</span><br><span class="line">                    <span class="built_in">dcmp</span>(f = <span class="built_in">DFS</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                flow += f, a -= f, e.flow += f, edges[G[u][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">dcmp</span>(a)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Maxflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> flow = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">BFS</span>())</span><br><span class="line">            <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span> cur), flow += <span class="built_in">DFS</span>(S, INFD);</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Line <span class="title">calc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; limit)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::<span class="built_in">init</span>(T + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// build graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (B[i] &lt;= limit) Graph::<span class="built_in">AddEdge</span>(S, i, C[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (B[i] &lt;= limit) &#123;</span><br><span class="line">            <span class="keyword">double</span> c = (limit - B[i]) / (<span class="number">2.0</span> * A[i]);</span><br><span class="line">            Graph::<span class="built_in">AddEdge</span>(S, i, <span class="built_in">min</span>(<span class="number">1.0</span> * C[i], c));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        Graph::<span class="built_in">AddEdge</span>(n + j, T, D[j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">if</span> (M[i][j]) Graph::<span class="built_in">AddEdge</span>(i, n + j, INFD);</span><br><span class="line">    <span class="comment">// check</span></span><br><span class="line">    Dinic::<span class="built_in">Maxflow</span>();</span><br><span class="line">    Frac k = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Dinic::vis[i] == Dinic::Time) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (B[i] &lt;= limit) b += C[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (B[i] &lt;= limit) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2.0</span> * A[i] * C[i] + B[i] &gt; limit)</span><br><span class="line">                k += <span class="built_in">Frac</span>(<span class="number">1</span>, <span class="number">2</span> * A[i]), b += <span class="built_in">Frac</span>(-B[i], <span class="number">2</span> * A[i]);</span><br><span class="line">            <span class="keyword">else</span> b += C[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        <span class="keyword">if</span> (Dinic::vis[n + j] == Dinic::Time) b += D[j];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Line</span>(k, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Divide</span><span class="params">(<span class="keyword">const</span> Line&amp; L, <span class="keyword">const</span> Line&amp; R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">    Frac px = (L.b - R.b) / (R.k - L.k);</span><br><span class="line">    Line mL = <span class="built_in">calc</span>(px.<span class="built_in">val</span>() - EPS), mR = <span class="built_in">calc</span>(px.<span class="built_in">val</span>() + EPS);</span><br><span class="line">    <span class="keyword">if</span> (L == mL)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>( P.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(px, px * L.k + L.b)) );</span><br><span class="line">    <span class="built_in">Divide</span>(L, mL), <span class="built_in">Divide</span>(mR, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, A + i, B + i, C + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, D + j);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, M[i] + j);</span><br><span class="line">    <span class="comment">// solve 1</span></span><br><span class="line">    S = <span class="number">0</span>, T = n + m + <span class="number">1</span>;</span><br><span class="line">    Graph::<span class="built_in">init</span>(T + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) Graph::<span class="built_in">AddEdge</span>(S, i, C[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) Graph::<span class="built_in">AddEdge</span>(n + j, T, D[j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">if</span> (M[i][j]) Graph::<span class="built_in">AddEdge</span>(i, n + j, INFD);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%0.lf\n&quot;</span>, Dinic::<span class="built_in">Maxflow</span>());</span><br><span class="line">    <span class="comment">// solve 2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= <span class="number">4</span>; ++x) &#123;</span><br><span class="line">        <span class="keyword">double</span> L = x - <span class="number">1</span>, R = (x &lt;= <span class="number">3</span>)? x: INFD;</span><br><span class="line">        Line l1 = <span class="built_in">calc</span>(L + EPS), l2 = <span class="built_in">calc</span>(R - EPS);</span><br><span class="line">        P.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="built_in">Frac</span>(L), l1.k * <span class="built_in">Frac</span>(L) + l1.b));</span><br><span class="line">        <span class="built_in">Divide</span>(l1, l2);</span><br><span class="line">        P.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="built_in">Frac</span>(R), l2.k * <span class="built_in">Frac</span>(R) + l2.b));</span><br><span class="line">    &#125;</span><br><span class="line">    P.<span class="built_in">pop_back</span>();</span><br><span class="line">    Frac ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; P.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        ans += (P[i].y + P[i - <span class="number">1</span>].y) * (P[i].x - P[i - <span class="number">1</span>].x);</span><br><span class="line">    <span class="keyword">const</span> Point&amp; p = P.<span class="built_in">back</span>();</span><br><span class="line">    ans = p.x * p.y - <span class="built_in">Frac</span>(<span class="number">1</span>, <span class="number">2</span>) * ans;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>, ans.x, ans.y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「ZJOI2015」幻想乡-Wi-Fi-搭建计划"><a href="#「ZJOI2015」幻想乡-Wi-Fi-搭建计划" class="headerlink" title="「ZJOI2015」幻想乡 Wi-Fi 搭建计划"></a>「ZJOI2015」幻想乡 Wi-Fi 搭建计划</h3><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2139">https://loj.ac/problem/2139</a></li></ul><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>对着费用流建半天图还调半天结果发现假了是屑…</del></p><p>首先第一问容易有在 $O(nm)$ 的时间复杂度内计算的方法, 下文不再考虑覆盖不到的景点.</p><p>先考虑架设点只在一边的情况. 有一个结论: 将架设点和景点分别按照 $x$ 坐标排序, 那么在最优的方案下, 选择的架设点覆盖到的景点一定是排序后连续的一段.</p><p>证明大概是利用长方形宽为 $R$, 同时覆盖半径为 $R$, 恰好不能构造出反例吧… 不大会证.png</p><p>有了这个条件, 直接记录选择到第几个架设点 DP 即可.</p><p>那么架设点在两侧的情况, 直接在 DP 时多记录一维, 即在另一侧选择到第几个架设点, 对于一个景点分别考虑在两侧架设的情况.</p><p>具体地, 设 $f(i, j, k)$ 表示已经覆盖到第 $i$ 个景点, 两侧架设点分别选择到 $j$, $k$. 转移比较显然, 看代码理解就好了.</p><p>时间复杂度 $O(nm^3)$, 但是跑不满.</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2139</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ckmin</span><span class="params">(T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123; <span class="keyword">if</span> (a &gt; b) a = b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e2</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Geo &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">Vector</span>(<span class="keyword">int</span> _x = <span class="number">0</span>, <span class="keyword">int</span> _y = <span class="number">0</span>): <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y) &#123; &#125;</span><br><span class="line">        Vector <span class="keyword">operator</span> - (<span class="keyword">const</span> Vector&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Vector</span>(x - rhs.x, y - rhs.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">typedef</span> Vector Point;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point&amp; A, <span class="keyword">const</span> Point&amp; B) &#123;</span><br><span class="line">        <span class="keyword">return</span> (A.x &lt; B.x) || (A.x == B.x &amp;&amp; A.y &lt; B.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">Dot</span><span class="params">(<span class="keyword">const</span> Vector&amp; A, <span class="keyword">const</span> Vector&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1LL</span> * A.x * B.x + <span class="number">1LL</span> * A.y * B.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">Length2</span><span class="params">(<span class="keyword">const</span> Vector&amp; A)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Dot</span>(A, A); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">Dist2</span><span class="params">(<span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Length2</span>(p1 - p2); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Geo;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> &#123;</span></span><br><span class="line">    Point p; <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> p &lt; rhs.p; &#125;</span><br><span class="line">&#125; U[MAXN], D[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m; LL R;</span><br><span class="line">Point P[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;n, &amp;m, &amp;R), R *= R;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x, y, i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), P[i] = <span class="built_in">Point</span>(x, y);</span><br><span class="line">    <span class="keyword">int</span> nU = <span class="number">0</span>, nD = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x, y, c, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;c);</span><br><span class="line">        <span class="keyword">if</span> (y &lt; <span class="number">0</span>) D[++nD] = (Item)&#123; <span class="built_in">Point</span>(x, y), c &#125;;</span><br><span class="line">        <span class="keyword">else</span> U[++nU] = (Item)&#123; <span class="built_in">Point</span>(x, y), c &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">int</span> nP = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; !flag &amp;&amp; j &lt;= nD; ++j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Dist2</span>(P[i], D[j].p) &lt;= R) flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; !flag &amp;&amp; j &lt;= nU; ++j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Dist2</span>(P[i], U[j].p) &lt;= R) flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag) P[++nP] = P[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(P + <span class="number">1</span>, P + nP + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(D + <span class="number">1</span>, D + nD + <span class="number">1</span>), <span class="built_in">sort</span>(U + <span class="number">1</span>, U + nU + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nP; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= nU; ++j) <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= nD; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Dist2</span>(P[i], U[j].p) &lt;= R) <span class="built_in">ckmin</span>(f[i][j][k], f[i - <span class="number">1</span>][j][k]);</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Dist2</span>(P[i], D[k].p) &lt;= R) <span class="built_in">ckmin</span>(f[i][j][k], f[i - <span class="number">1</span>][j][k]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = j + <span class="number">1</span>; l &lt;= nU; ++l)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">Dist2</span>(P[i], U[l].p) &lt;= R) <span class="built_in">ckmin</span>(f[i][l][k], f[i - <span class="number">1</span>][j][k] + U[l].w);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = k + <span class="number">1</span>; l &lt;= nD; ++l)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">Dist2</span>(P[i], D[l].p) &lt;= R) <span class="built_in">ckmin</span>(f[i][j][l], f[i - <span class="number">1</span>][j][k] + D[l].w);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> Mn = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= nU; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= nD; ++k) <span class="built_in">ckmin</span>(Mn, f[nP][j][k]);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n&quot;</span>, nP, Mn);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;做这套题纯粹是为了好玩… 结果惨遭吊打 = =&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
</feed>
