<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DepletedPrism&#39;s Blog</title>
  
  <subtitle>知其然而不知其所以然是可悲的.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://depletedprism.github.io/"/>
  <updated>2020-02-08T08:16:18.437Z</updated>
  <id>https://depletedprism.github.io/</id>
  
  <author>
    <name>DepletedPrism</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「置顶」算法教程合辑</title>
    <link href="https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/compilation/"/>
    <id>https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/compilation/</id>
    <published>9102-11-14T00:11:23.000Z</published>
    <updated>2020-02-08T08:16:18.437Z</updated>
    
    <content type="html"><![CDATA[<hr><p>这个 idea 来源于 <a href="https://www.cnblogs.com/mlystdcall/p/8078467.html" target="_blank" rel="noopener">__stdcall 的教程合辑</a>, 觉得这个很好, 所以学习了.</p><a id="more"></a><p><del>Hexo 博客的强制置顶</del></p><h4 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h4><ul><li>树状数组进阶<ul><li><a href="https://www.cnblogs.com/RabbitHu/p/BIT.html" target="_blank" rel="noopener">https://www.cnblogs.com/RabbitHu/p/BIT.html</a></li></ul></li></ul><h4 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h4><ul><li>网络流入门<ul><li><a href="https://www.xht37.com/二分图与网络流-学习笔记/" target="_blank" rel="noopener">https://www.xht37.com/二分图与网络流-学习笔记/</a></li></ul></li><li>上下界网络流<ul><li><a href="https://www.cnblogs.com/mlystdcall/p/6734852.html" target="_blank" rel="noopener">https://www.cnblogs.com/mlystdcall/p/6734852.html</a></li></ul></li></ul><h4 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h4><ul><li>基础构造<ul><li><a href="https://oi.men.ci/linear-basis-notes/" target="_blank" rel="noopener">https://oi.men.ci/linear-basis-notes/</a></li></ul></li><li>可重集 Kth 异或和<ul><li><a href="https://blog.csdn.net/qaq__qaq/article/details/53812883" target="_blank" rel="noopener">https://blog.csdn.net/qaq__qaq/article/details/53812883</a></li></ul></li></ul><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul><li>四边形不等式优化<ul><li><a href="https://oi-wiki.org/dp/opt/quadrangle/" target="_blank" rel="noopener">https://oi-wiki.org/dp/opt/quadrangle/</a></li></ul></li></ul><h4 id="Link-Cut-Tree"><a href="#Link-Cut-Tree" class="headerlink" title="Link Cut Tree"></a>Link Cut Tree</h4><ul><li>应用 &amp; 题单<ul><li><a href="https://www.cnblogs.com/flashhu/p/9498517.html" target="_blank" rel="noopener">https://www.cnblogs.com/flashhu/p/9498517.html</a></li></ul></li></ul><h4 id="左偏树"><a href="#左偏树" class="headerlink" title="左偏树"></a>左偏树</h4><ul><li>特点及应用<ul><li><a href="https://files-cdn.cnblogs.com/files/shenben/算法合集之《左偏树的特点及其应用》.pdf" target="_blank" rel="noopener">https://files-cdn.cnblogs.com/files/shenben/算法合集之《左偏树的特点及其应用》.pdf</a></li></ul></li></ul><h4 id="Min-Max-容斥"><a href="#Min-Max-容斥" class="headerlink" title="Min-Max 容斥"></a>Min-Max 容斥</h4><ul><li>证明及应用<ul><li><a href="https://www.cnblogs.com/GXZlegend/p/11563330.html" target="_blank" rel="noopener">https://www.cnblogs.com/GXZlegend/p/11563330.html</a></li></ul></li></ul><h4 id="Stirling-数及-Stirling-反演"><a href="#Stirling-数及-Stirling-反演" class="headerlink" title="Stirling 数及 Stirling 反演"></a>Stirling 数及 Stirling 反演</h4><ul><li>性质及应用<ul><li><a href="https://www.cnblogs.com/y2823774827y/p/10700231.html" target="_blank" rel="noopener">https://www.cnblogs.com/y2823774827y/p/10700231.html</a></li></ul></li></ul><h4 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h4><ul><li>证明及应用<ul><li><a href="https://www.cnblogs.com/GXZlegend/p/11407185.html" target="_blank" rel="noopener">https://www.cnblogs.com/GXZlegend/p/11407185.html</a></li></ul></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;这个 idea 来源于 &lt;a href=&quot;https://www.cnblogs.com/mlystdcall/p/8078467.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;__stdcall 的教程合辑&lt;/a&gt;, 觉得这个很好, 所以学习了.&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://depletedprism.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>「十二省联考 2019」字符串问题</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P5284/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P5284/</id>
    <published>2020-02-04T14:24:45.000Z</published>
    <updated>2020-02-05T16:19:50.686Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>谨以此题纪念自己颓废的, 什么都不会的高一 (bushi</p></blockquote><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P5284" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P5284</a></li></ul><p>SAM 优化建图 + 拓扑排序求最长路.</p><p>写这道题啊, 只是感到自己的高一很可笑吧, 连题意都不大能读清, 正解的算法听都没有听过, 输出样例就弃疗离场.</p><a id="more"></a><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>考虑目标串 $T$ 的构造过程, 可以发现 $A,\ B$ 串可以视为节点, 支配关系和前缀可以看作边, $T$ 就对应图中一条路径, 那么把图建出来跑最长路就好了.</p><p>另外可以发现, 如果图上存在环就说明可以构造出无限长的串 $T$, 输出 <code>-1</code>, 否则这就是个 DAG, 最长路跑拓扑排序就好了.</p><p>进一步考虑建边</p><ol><li><p>$A_{id_i} \rightarrow B$</p><p>支配关系是题目给出的, 直接把 $A,\ B$ 串对应节点连起来就好了.</p></li><li><p>$B_j \rightarrow A_i$, 其中 $B_j$ 为 $A_i$ 的前缀</p><p>这里就有些意思了, <del>如果直接暴力建边就可以拿到 10 pts 的好成绩</del></p><p>考虑前缀, 就是反串的后缀, 我们可以想到对 $S$ 的反串建出 SAM, 把串 $A,\ B$ 放到 SAM 上匹配, 这一步可以套路地用倍增解决. 假设匹配到 SAM 上的节点 $u$, 那么就新建一个节点 $v$ 表示当前匹配串, 点权为匹配串长度, 并把 $v$ 挂在 $u$ 上.</p><p>对于 SAM 上的一个节点 $u$, <del>上面挂这一堆节点表示 A, B 串</del>, 我们将这些节点以点权为第一关键字, 是否为 $B$ 串为第二关键字从小到大排序, 并根据这个顺序依次连边.</p><p>另外还需考虑 SAM 上节点 $u$ 和后缀链接 $\text{lnk}(u)$ 的关系, 对于反串中的前缀, 存在一个前缀是另一前缀的前缀, 那么就是从 $\text{lnk}(u)$ 向 $u$ 连边了. 当然, 由于上一步的连边此处 $\text{lnk}(u)$ 的实际节点稍有不同.</p><p><del>具体实现代码里很清晰, 正确性很显然</del></p></li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>细节不多的题还是好码一点的.<br><del>这就是你抄题解还 WA 了一发的原因了 ?</del> (</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P5284</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span>+<span class="number">5</span>, LOG = <span class="number">20</span>, MAXV = MAXN &lt;&lt; <span class="number">2</span>, MAXE = MAXN * <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, na, nb, uidx;</span><br><span class="line"><span class="keyword">char</span> S[MAXN];</span><br><span class="line"><span class="keyword">bool</span> isA[MAXV];</span><br><span class="line"><span class="keyword">int</span> Aidx[MAXN], Bidx[MAXN], lst[MAXN &lt;&lt; <span class="number">1</span>], pos[MAXN], pre[LOG][MAXN &lt;&lt; <span class="number">1</span>], len[MAXV];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SAM &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = ::MAXN &lt;&lt; <span class="number">1</span>, SIGMA = <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][SIGMA], lnk[MAXN], nidx, last;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        last = nidx = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ch[<span class="number">1</span>], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        len[++nidx] = l, lnk[nidx] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ch[nidx], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[nidx]);</span><br><span class="line">        <span class="keyword">return</span> nidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nd = newnode(len[last] + <span class="number">1</span>), p = last;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !ch[p][val]) ch[p][val] = nd, p = lnk[p];</span><br><span class="line">        <span class="keyword">if</span> (!p) lnk[nd] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> q = ch[p][val];</span><br><span class="line">            <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) lnk[nd] = q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> nxt = newnode(len[p] + <span class="number">1</span>);</span><br><span class="line">                lnk[nxt] = lnk[q];</span><br><span class="line">                <span class="built_in">memcpy</span>(ch[nxt], ch[q], <span class="keyword">sizeof</span> ch[nxt]);</span><br><span class="line">                <span class="keyword">while</span> (p &amp;&amp; ch[p][val] == q) ch[p][val] = nxt, p = lnk[p];</span><br><span class="line">                lnk[q] = lnk[nd] = nxt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last = nd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXE];</span><br><span class="line">    <span class="keyword">int</span> head[MAXV], eidx, in[MAXV];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span> in);</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        ++in[to];</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">Toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> LL f[MAXV];</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= uidx; ++i) &#123;</span><br><span class="line">            f[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!in[i]) Q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        LL ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            ans = max(ans, f[u] + len[u]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = edges[i].to;</span><br><span class="line">                f[v] = max(f[v], f[u] + len[u]);</span><br><span class="line">                <span class="keyword">if</span> (!(--in[v])) Q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= uidx; ++i)</span><br><span class="line">            <span class="keyword">if</span> (in[i]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> Ti;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        SAM::init(), Graph::init();</span><br><span class="line">        <span class="built_in">memset</span>(isA, <span class="literal">false</span>, <span class="keyword">sizeof</span> isA);</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// build SAM</span></span><br><span class="line">        n = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(S+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i)</span><br><span class="line">            SAM::insert(S[i] - <span class="string">'a'</span>), pos[i] = SAM::last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= SAM::nidx; ++i)</span><br><span class="line">            pre[<span class="number">0</span>][i] = SAM::lnk[i], G[i].clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; LOG; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= SAM::nidx; ++i) pre[j][i] = pre[j<span class="number">-1</span>][pre[j<span class="number">-1</span>][i]];</span><br><span class="line">        <span class="comment">// find A in SAM</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;na);</span><br><span class="line">        uidx = SAM::nidx;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L, R, i = <span class="number">1</span>; i &lt;= na; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">            <span class="keyword">int</span> lgt = R - L + <span class="number">1</span>, u = pos[L];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = LOG<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">                <span class="keyword">if</span> (pre[j][u] &amp;&amp; len[pre[j][u]] &gt;= lgt) u = pre[j][u];</span><br><span class="line">            len[++uidx] = lgt, Aidx[i] = uidx, isA[uidx] = <span class="literal">true</span>;</span><br><span class="line">            G[u].push_back(uidx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// find B in SAM</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;nb);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L, R, i = <span class="number">1</span>; i &lt;= nb; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">            <span class="keyword">int</span> lgt = R - L + <span class="number">1</span>, u = pos[L];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = LOG<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">                <span class="keyword">if</span> (pre[j][u] &amp;&amp; len[pre[j][u]] &gt;= lgt) u = pre[j][u];</span><br><span class="line">            len[++uidx] = lgt, Bidx[i] = uidx;</span><br><span class="line">            G[u].push_back(uidx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// link edges in SAM</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, u = <span class="number">1</span>; u &lt;= SAM::nidx; ++u) &#123;</span><br><span class="line">            <span class="keyword">int</span> last = u;</span><br><span class="line">            sort(G[u].begin(), G[u].end(),</span><br><span class="line">                    [](<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)&#123; <span class="keyword">return</span> len[a] &lt; len[b] || (len[a] == len[b] &amp;&amp; isA[a] &lt; isA[b]); &#125;);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; G[u].size(); ++i) &#123;</span><br><span class="line">                Graph::AddEdge(last, v = G[u][i]);</span><br><span class="line">                <span class="keyword">if</span> (!isA[v]) last = v;</span><br><span class="line">            &#125;</span><br><span class="line">            lst[u] = last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= SAM::nidx; ++i)</span><br><span class="line">            Graph::AddEdge(lst[SAM::lnk[i]], i);</span><br><span class="line">        <span class="comment">// clean unexisted value</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= uidx; ++u)</span><br><span class="line">            <span class="keyword">if</span> (!isA[u]) len[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// link A, B</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), Graph::AddEdge(Aidx[u], Bidx[v]);</span><br><span class="line">        <span class="comment">// solve &amp; output</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Graph::Toposort());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;谨以此题纪念自己颓废的, 什么都不会的高一 (bushi&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://www.luogu.com.cn/problem/P5284&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.com.cn/problem/P5284&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SAM 优化建图 + 拓扑排序求最长路.&lt;/p&gt;
&lt;p&gt;写这道题啊, 只是感到自己的高一很可笑吧, 连题意都不大能读清, 正解的算法听都没有听过, 输出样例就弃疗离场.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
      <category term="String" scheme="https://depletedprism.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>第一 / 二类 Stirling 数的一些平庸求法</title>
    <link href="https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/stirling-polynomial/"/>
    <id>https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/stirling-polynomial/</id>
    <published>2020-01-28T12:19:12.000Z</published>
    <updated>2020-01-29T07:02:32.444Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>看到洛谷上有求 Stirling 数的神奇板子, 于是就想写 = =</p><p><del>虽然不知道会有什么用处, 其实是不想写题又不敢颓废吧</del></p><p>大概是一些式子推推推然后拉板子算算算…</p><a id="more"></a><h3 id="第一类-Stirling-数"><a href="#第一类-Stirling-数" class="headerlink" title="第一类 Stirling 数"></a>第一类 Stirling 数</h3><p>本文采用 $\begin{bmatrix} n \\ m \end{bmatrix}$ 表示第一类 Stirling 数.</p><h4 id="Part-1-行"><a href="#Part-1-行" class="headerlink" title="Part 1 行"></a>Part 1 行</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P5408" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P5408</a></li></ul><p>我们知道, $x$ 的 $n$ 次上升幂就是第 $n$ 行第一类 Stirling 数的生成函数, 即<br>$$x^{\overline n} = \prod_{i=0}^{n-1} (x + i) = \sum_{i=0}^n \begin{bmatrix} n \\ i \end{bmatrix} x^i$$</p><p>论据如下, 归纳法易证 $$ \begin{bmatrix} n \\ m \end{bmatrix} = \begin{bmatrix} n-1 \\ m-1 \end{bmatrix} + (n-1) \cdot \begin{bmatrix} n-1 \\ m \end{bmatrix}$$</p><p>此时通过分治 FFT 可以在 $O(n \log^2 n)$ 的时间复杂度内计算.</p><p>但是用倍增可以做到 $O(n \log n)$.</p><p>考虑倍增, 有<br>$$x^{\overline {2n}} = x^{\overline{n}} (x+n)^{\overline{n}}$$</p><p>写成这个形式鬼知道怎么推, 于是<br>$$x^{\overline{2n}} = \prod_{i=0}^{n-1} (x+i) \prod_{i=0}^{n-1} (x+i+n)$$</p><p>设 $f(x) = \prod_{i=0}^{n-1} (x+i) = \sum_{i=0}^n a_i x^i$, 如果能根据 $f(x)$ 算 $f(x+n)$ 就可以了.<br>$$f(x+n) = \sum_{i=0}^n a_i (x+n)^i = \sum_{i=0}^n a_i \sum_{j=0}^{i} \binom{i}{j} x^i n^{i-j} $$</p><p>交换 $i$, $j$ 枚举顺序, 得<br>$$f(x+n) = \sum_{i=0}^n x^i \sum_{j=i}^n \binom{j}{i} n^{j-i} a_i$$</p><p>展开, 有<br>$$f(x+n) = \sum_{i=0}^n \frac{x^i}{i!} \sum_{j=i}^n \frac{n^{j-i}}{(j-i)!} j!\ a_j$$</p><p>最后一个和式的卷积形式并不显然, 还要将其中一项翻转…</p><p>写起来有很多细节, 中途出了无数锅, 以及我现在都不知道为什么我写的迭代和开区间会死…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P5408</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">524295</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">167772161</span>, G = <span class="number">3</span>, iG = <span class="number">55924054</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fac[MAXN], ifac[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> m = P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * base * ret % m;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> Lim, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> unit = fpow(type &gt; <span class="number">0</span>? G: iG, (P<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j, w = <span class="number">1L</span>L * w * unit % P) &#123;</span><br><span class="line">                    <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1L</span>L * w * f[i+j+Mid] % P;</span><br><span class="line">                    f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> inv = fpow(Lim, P<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * inv % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> Mid, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">        <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*Mid) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> powk = <span class="number">1</span>, i = <span class="number">0</span>; i &lt; Mid; ++i, powk = <span class="number">1L</span>L * powk * k % P) &#123;</span><br><span class="line">            A[Mid-i<span class="number">-1</span>] = <span class="number">1L</span>L * f[i] * fac[i] % P;</span><br><span class="line">            B[i] = <span class="number">1L</span>L * powk * ifac[i] % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">        init(Lim, L), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = <span class="number">1L</span>L * A[i] * B[i] % P;</span><br><span class="line">        NTT(A, Lim, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) g[i] = <span class="number">1L</span>L * A[Mid-i<span class="number">-1</span>] * ifac[i] % P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="keyword">void</span>( f[<span class="number">0</span>] = <span class="number">1</span> );</span><br><span class="line">        <span class="keyword">int</span> Mid = n / <span class="number">2</span>, Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">        solve(f, Mid);</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt;= n) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">        <span class="comment">// 得到 f(x + Mid)</span></span><br><span class="line">        calc(f, A, Mid+<span class="number">1</span>, Mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Mid; ++i) B[i] = f[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid+<span class="number">1</span>; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">        init(Lim, L), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = <span class="number">1L</span>L * A[i] * B[i] % P;</span><br><span class="line">        NTT(A, Lim, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// n 为奇数时, 有乘 (x + (n-1)) 的情况, 此时直接乘就好了.</span></span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">            f[i] = ((i? A[i<span class="number">-1</span>]: <span class="number">0</span>) + <span class="number">1L</span>L * A[i] * (n<span class="number">-1</span>) % P) % P;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) f[i] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    ifac[<span class="number">0</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = <span class="number">1L</span>L * fac[i<span class="number">-1</span>] * i % P;</span><br><span class="line">    ifac[n] = fpow(fac[n], P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) ifac[i<span class="number">-1</span>] = <span class="number">1L</span>L * ifac[i] * i % P;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    Poly::solve(f, n);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, f[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Part-2-列"><a href="#Part-2-列" class="headerlink" title="Part 2 列"></a>Part 2 列</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P5409" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P5409</a></li></ul><p>首先有第一类 Stirling 数的一个性质, 即<br>$$x^{\underline n} = \prod_{i=0}^{n-1} (x-i) = \sum_{i=0}^n (-1)^{n-i} \begin{bmatrix} n \\ i \end{bmatrix} x^i$$</p><p>同样也是归纳法易证.</p><p>对于 $(1+x)^t$, 由牛顿二项式定理, 可知<br>$$(1+x)^t = \sum_{i=0}^\infty \binom{t}{i} x^i$$</p><p>其中 $\binom{t}{i} = \frac{t (t-1) \cdots (t-i+1)}{i!}$, 不妨写作<br>$$(1+x)^t = \sum_{i=0}^\infty \frac{t^{\underline i}}{i!} x^i$$</p><p>愉快套公式, 得<br>$$(1+x)^t = \sum_{i=0}^\infty \frac{1}{i!} x^i \sum_{j=0}^i (-1)^{i-j} \begin{bmatrix} i \\ j \end{bmatrix} t^j$$</p><p>交换枚举顺序, 得<br>$$(1+x)^t = \sum_{i=0}^\infty t^i \sum_{j=i}^\infty \frac{1}{j!} x^j (-1)^{j-i} \begin{bmatrix}j \\ i \end{bmatrix} $$</p><p>同时, 有<br>$$(1+x)^t = \exp (t \cdot \ln (1+x)) = \sum_{i=0}^\infty \frac{1}{i!} \ln^i (1+x)\ t^i$$</p><p>对应项系数相等, 得<br>$$\frac{1}{i!} \ln^i (1+x) = \sum_{j=i}^\infty \frac{1}{j!} (-1)^{j-i} \begin{bmatrix}j \\ i \end{bmatrix} x^j$$</p><p>可以看到, 其中 $i$ 为给定的值, 利用多项式幂函数算就好了.</p><p>值得注意的是, $[x^0] \ln (1+x)$ 有不等于 $1$ 的可能, 所以要用鲁棒性更强的板子 = =</p><p>时间复杂度是带常数的 $O(n \log n)$, 大概是跑不过 $O(n \log^2 n)$ 的带常数吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P5409</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">131075</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">167772161</span>, G = <span class="number">3</span>, iG = <span class="number">55924054</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fac[MAXN], ifac[MAXN], inv[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> m = P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % m;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> Lim, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> unit = fpow(type &gt; <span class="number">0</span>? G: iG, (P<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j, w = <span class="number">1L</span>L * w * unit % P) &#123;</span><br><span class="line">                    <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1L</span>L * w * f[i+j+Mid] % P;</span><br><span class="line">                    f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> inv = fpow(Lim, P<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * inv * f[i] % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">        g[<span class="number">0</span>] = fpow(f[<span class="number">0</span>], P<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">0</span>, Lim = <span class="number">1</span>, Mid = <span class="number">2</span>; Mid &lt; <span class="number">2</span>*n; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*Mid) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) A[i] = f[i], B[i] = g[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">            init(Lim, L), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i)</span><br><span class="line">                g[i] = ((B[i] + B[i]) % P - <span class="number">1L</span>L * A[i] * B[i] % P * B[i] % P + P) % P;</span><br><span class="line">            NTT(g, Lim, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = min(Mid, n); i &lt; Lim; ++i) g[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Der</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) g[i<span class="number">-1</span>] = <span class="number">1L</span>L * i * f[i] % P;</span><br><span class="line">        g[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Int</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        g[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i; --i) g[i] = <span class="number">1L</span>L * inv[i] * f[i<span class="number">-1</span>] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ln</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">        Der(f, A, n), Inv(f, B, n);</span><br><span class="line">        <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*n) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">        init(Lim, L), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = <span class="number">1L</span>L * A[i] * B[i] % P;</span><br><span class="line">        NTT(A, Lim, <span class="number">-1</span>), Int(A, g, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Exp</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN], lng[MAXN];</span><br><span class="line">        g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">0</span>, Lim = <span class="number">1</span>, Mid = <span class="number">2</span>; Mid &lt; <span class="number">2</span>*n; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            Ln(g, lng, Mid);</span><br><span class="line">            <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*Mid) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) A[i] = (f[i] - lng[i] + P) % P, B[i] = g[i];</span><br><span class="line">            A[<span class="number">0</span>] = (A[<span class="number">0</span>] + <span class="number">1</span>) % P;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">            init(Lim, L), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) g[i] = <span class="number">1L</span>L * A[i] * B[i] % P;</span><br><span class="line">            NTT(g, Lim, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = min(Mid, n); i &lt; Lim; ++i) g[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> lng[MAXN];</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!f[pos]) ++pos;</span><br><span class="line">        <span class="keyword">int</span> Mid = n - pos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) g[i] = f[i+pos];</span><br><span class="line">        <span class="keyword">int</span> base = g[<span class="number">0</span>], inv = fpow(base, P<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) g[i] = <span class="number">1L</span>L * g[i] * inv % P;</span><br><span class="line">        Ln(g, lng, Mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) lng[i] = <span class="number">1L</span>L * lng[i] * K % P;</span><br><span class="line">        Exp(lng, g, Mid);</span><br><span class="line">        base = fpow(base, K);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) g[i] = <span class="number">1L</span>L * g[i] * base % P;</span><br><span class="line">        pos = min(pos * K, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= pos; --i) g[i] = g[i-pos];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos; ++i) g[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K;</span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;K);</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="keyword">int</span> N = n;</span><br><span class="line">    ifac[<span class="number">0</span>] = fac[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) inv[i] = <span class="number">1L</span>L * (P - P / i) * inv[P % i] % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) fac[i] = <span class="number">1L</span>L * i * fac[i<span class="number">-1</span>] % P;</span><br><span class="line">    ifac[N] = fpow(fac[N], P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i; --i) ifac[i<span class="number">-1</span>] = <span class="number">1L</span>L * i * ifac[i] % P;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    Poly::Ln(f, f, n+<span class="number">1</span>); Poly::Pow(f, f, n+<span class="number">1</span>, K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) f[i] = <span class="number">1L</span>L * f[i] * ifac[K] % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        f[i] = <span class="number">1L</span>L * f[i] * fac[i] % P * (((i-K) &amp; <span class="number">1</span>)? P<span class="number">-1</span>: <span class="number">1</span>) % P;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, f[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h3><p>本文采用 $\begin{Bmatrix} n \\ m \end{Bmatrix}$ 表示第二类 Stirling 数.</p><h4 id="Part-1-行-1"><a href="#Part-1-行-1" class="headerlink" title="Part 1 行"></a>Part 1 行</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P5395" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P5395</a></li></ul><p><del>感觉这个是最简单的了</del></p><p>考虑第二类 Stirling 数的组合意义, 也就是把 $n$ 个有区别的小球放入 $m$ 个无区别的盒子里的方案数.</p><p>其实这个东西是可以用容斥算的, 可以得到<br>$$\begin{Bmatrix} n \\ m \end{Bmatrix} = \frac{1}{m!} \sum_{k=0}^n (-1)^{k} \binom{m}{k} (m-k)^n$$</p><p>右边和式的意义为, 在 $m$ 个<strong>有区别</strong>的盒子里挑 $k$ 个空盒子, 然后把 $n$ 个小球丢到盒子里. 因为容斥时假设盒子有区别, 最后还要除以 $m!$.</p><p>把这个式子展开就可以看到卷积的形式了.<br>$$\begin{Bmatrix} n \\ m \end{Bmatrix} = \sum_{k=0}^n \frac{(-1)^k}{k!} \frac{(m-k)^n}{(m-k)!}$$</p><p>通过 NTT 就可以在 $O(n \log n)$ 的时间复杂度内计算.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P5395</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">167772161</span>, G = <span class="number">3</span>, iG = <span class="number">55924054</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> m = P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % m;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> Lim, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> unit = fpow(type &gt; <span class="number">0</span>? G: iG, (P<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j, w = <span class="number">1L</span>L * w * unit % P) &#123;</span><br><span class="line">                    <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1L</span>L * w * f[i+j+Mid] % P;</span><br><span class="line">                    f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> inv = fpow(Lim, P<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * inv % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[MAXN], g[MAXN];</span><br><span class="line"><span class="keyword">int</span> fac[MAXN], ifac[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = <span class="number">1L</span>L * fac[i<span class="number">-1</span>] * i % P;</span><br><span class="line">    ifac[n] = fpow(fac[n], P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) ifac[i<span class="number">-1</span>] = <span class="number">1L</span>L * ifac[i] * i % P;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i] = (i &amp; <span class="number">1</span>)? P - ifac[i]: ifac[i];</span><br><span class="line">        g[i] = <span class="number">1L</span>L * fpow(i, n) * ifac[i] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*n) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">    Poly::init(Lim, L), Poly::NTT(f, Lim, <span class="number">1</span>), Poly::NTT(g, Lim, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * g[i] % P;</span><br><span class="line">    Poly::NTT(f, Lim, <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, f[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Part-2-列-1"><a href="#Part-2-列-1" class="headerlink" title="Part 2 列"></a>Part 2 列</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P5396" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P5396</a></li></ul><p>设第二类 Stirling 数一列的生成函数为 $S_m$, 即<br>$$S_m (x) = \sum_{i=0}^\infty \begin{Bmatrix} i \\ m \end{Bmatrix} x^i$$</p><p>根据第二类 Stirling 数递推式, 可以得到<br>$$S_m (x) = \sum_{i=1}^\infty \begin{Bmatrix} i-1 \\ m-1 \end{Bmatrix} x^i  + m \sum_{i=1}^\infty \begin{Bmatrix} i-1 \\ m \end{Bmatrix} x^i$$</p><p>$$S_m (x) = x \cdot S_{m-1} (x) + m x \cdot S_m (x)$$</p><p>移项并整理, 得<br>$$S_m (x) = \frac{x}{1-mx} S_{m-1} (x) = \frac{x^m}{\prod_{i=1}^m (1-ix)}$$</p><p>分式的分母可以使用分治 FFT 得到, 然后求逆并乘一个单项式 (也就是把系数右移) 即可.</p><p>所以我们就得到了 $O(n \log^2 n)$ 的做法, 然而存在 $O(n\log n)$ 且小常数的倍增优秀做法, 只是我学不动了…</p><p>佐以 O2 食用更佳.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P5396</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">131075</span> &lt;&lt; <span class="number">1</span>, LOG = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">167772161</span>, G = <span class="number">3</span>, iG = <span class="number">55924054</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> m = P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * base * ret % m;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    <span class="keyword">int</span> tmp[LOG][MAXN], ptr = <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> Lim, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> unit = fpow(type &gt; <span class="number">0</span>? G: iG, (P<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j, w = <span class="number">1L</span>L * w * unit % P) &#123;</span><br><span class="line">                    <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1L</span>L * w * f[i+j+Mid] % P;</span><br><span class="line">                    f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> inv = fpow(Lim, P<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * inv % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">        g[<span class="number">0</span>] = fpow(f[<span class="number">0</span>], P<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">0</span>, Lim = <span class="number">1</span>, Mid = <span class="number">2</span>; Mid &lt; <span class="number">2</span>*n; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*Mid) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) A[i] = f[i], B[i] = g[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">            init(Lim, L), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i)</span><br><span class="line">                g[i] = ((B[i] + B[i]) % P - <span class="number">1L</span>L * A[i] * B[i] % P * B[i] % P + P) % P;</span><br><span class="line">            NTT(g, Lim, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = min(Mid, n); i &lt; Lim; ++i) g[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> f[<span class="number">0</span>] = <span class="number">1</span>, <span class="keyword">void</span>( f[<span class="number">1</span>] = P - L );</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, *f0 = tmp[++ptr], *f1 = tmp[++ptr];</span><br><span class="line">        solve(f0, L, Mid), solve(f1, Mid+<span class="number">1</span>, R);</span><br><span class="line">        <span class="keyword">int</span> Lim = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt;= R-L+<span class="number">1</span>) Lim &lt;&lt;= <span class="number">1</span>, ++l;</span><br><span class="line">        init(Lim, l), NTT(f0, Lim, <span class="number">1</span>), NTT(f1, Lim, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f0[i] * f1[i] % P, f0[i] = f1[i] = <span class="number">0</span>;</span><br><span class="line">        NTT(f, Lim, <span class="number">-1</span>), ptr -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K;</span><br><span class="line"><span class="keyword">int</span> f[MAXN], g[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;K);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    Poly::solve(f, <span class="number">1</span>, K);</span><br><span class="line">    Poly::Inv(f, g, n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i+K &lt;= n; ++i) f[i+K] = g[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; ++i) f[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, f[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>Richard A. Brualdi. 组合数学. 机械工业出版社, 2012.4.</li><li><a href="https://www.cnblogs.com/y2823774827y/p/10700231.html" target="_blank" rel="noopener">斯特林数及斯特林反演 by y2823774827y</a></li><li><a href="https://www.luogu.com.cn/blog/NaCly-Fish-blog/solution-p5408" target="_blank" rel="noopener">题解 P5408 【模板】第一类斯特林数·行 by NaCly_Fish</a></li><li><a href="https://www.luogu.com.cn/blog/user7035/solution-p5409" target="_blank" rel="noopener">题解 P5409 【模板】第一类斯特林数·列 by Great_Influence</a></li><li><a href="https://www.luogu.com.cn/blog/user7035/solution-p5396" target="_blank" rel="noopener">题解 P5396 【模板】第二类斯特林数·列 by Great_Influence</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;看到洛谷上有求 Stirling 数的神奇板子, 于是就想写 = =&lt;/p&gt;
&lt;p&gt;&lt;del&gt;虽然不知道会有什么用处, 其实是不想写题又不敢颓废吧&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;大概是一些式子推推推然后拉板子算算算…&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://depletedprism.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Polynomial" scheme="https://depletedprism.github.io/tags/Polynomial/"/>
    
  </entry>
  
  <entry>
    <title>牛顿二项式定理 学习笔记</title>
    <link href="https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/binomial-theorem/"/>
    <id>https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/binomial-theorem/</id>
    <published>2020-01-21T03:52:42.000Z</published>
    <updated>2020-01-26T12:05:06.611Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>数学就是用的时候不够用的东西. = =</p></blockquote><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>牛顿二项式定理是对二项式定理的推广, <del>那直接叫广义二项式定理不好吗</del>, 刚开始看 &lt;组合数学&gt; 的时候见到这个东西, 以为没什么用 = =, 后来…</p><p>当然本文作者没有仔细严谨地学习相关的数学知识, 内容充满谬误, 恳请指正.</p><a id="more"></a><h2 id="陈述"><a href="#陈述" class="headerlink" title="陈述"></a>陈述</h2><h3 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h3><p>对于正整数 $n$ 和任意 $x,\ y$, 有<br>$$(x + y) ^ n = \sum_{k=0}^n\; \binom{n}{k} x^k y ^{n-k}$$</p><p>这就是最常见的二项式定理, 其中 $n$ 可以推广到任意实数, 即</p><h3 id="牛顿二项式定理"><a href="#牛顿二项式定理" class="headerlink" title="牛顿二项式定理"></a>牛顿二项式定理</h3><p>设 $\alpha$ 是实数, 对于所有满足 $0 \leq |x| &lt; |y|$ 的 $x$,  $y$, 有<br>$$(x+y)^\alpha = \sum_{k=0}^\infty\; \binom{\alpha}{k} x^k y^{n-k}$$</p><p>其中<br>$$\binom{\alpha}{k} = \frac{\alpha (\alpha - 1) \cdots (\alpha - k + 1)}{k!} $$</p><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>在此不证.</p><h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><p>看到这个和式上的无穷的时候, <del>顷刻留下了感动的泪水</del>…</p><h3 id="一些拓展"><a href="#一些拓展" class="headerlink" title="一些拓展"></a>一些拓展</h3><p>设 $z = \frac{x}{y}$, 那么上述定理可以转述为</p><p>对于所有满足 $|z| &lt; 1$ 的任意 $z$, 有<br>$$(1+z) ^ \alpha = \sum_{k=0}^\infty\; \binom{\alpha}{k} z^k$$</p><p>设 $n$ 为正整数, 取 $\alpha$ 为负整数 $-n$, 则<br>$$\binom{\alpha}{k} = \binom{-n}{k} = \frac{-n (-n-1) \cdots (-n-k+1)}{k!} = (-1)^k \binom{n+k-1}{k}$$</p><p>所以<br>$$(1+z)^{-n} = \frac{1}{(1+z)^n} = \sum_{k=0}^\infty\; (-1)^k \binom{n+k-1}{k} z^k$$</p><p>为了干掉那个 $-1$, 令 $-z$ 代替 $z$, 得<br>$$(1-z)^{-n} = \frac{1}{(1-z)^n} = \sum_{k=0}^\infty\; \binom{n+k-1}{k} z^k$$</p><p>取 $n=1$, 有 $\binom{n+k-1}{k} = \binom{k}{k} = 1$, 所以<br>$$\frac{1}{1-z} = \sum_{k=0}^\infty\; z^k = 1 + z + z^2 + z^3 + \cdots$$</p><p>类似地, 有<br>$$\frac{1}{1+z} = \sum_{k=0}^\infty\; (-1)^k z^k = 1 - z + z^2 - z^3 \cdots$$</p><p>稍微总结一下</p><p>如果 $n$ 是正整数, $r$ 是非 $0$ 实数, 那么<br>$$(1-rx)^{-n} = \sum_{k=0}^\infty\; \binom{-n}{k} (-rx)^k$$</p><p>或等价地, 有<br>$$\frac{1}{(1-rx)^n} = \sum_{k=0}^\infty\; \binom{n+k-1}{k} r^k x^k$$ 其中 $|x| &lt; \frac{1}{|r|}$.</p><h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><p>可能在生成函数有关的题目会用到这些东西吧…</p><p>$$1 + x + x^2 + \cdots = \frac{1}{1-x} \\<br>1 + x^2 + x^4 + \cdots = 1 + (x)^2 + (x^2)^2 + \cdots = \frac{1}{1 - x^2} \\<br>x + x^2 + x^3 + \cdots = x\; (1 + x + x^2 + \cdots) = \frac{x}{1 - x} \\<br>1 + x + x^2 + x^3 + x^4 = \frac{1 - x^5}{1-x}$$</p><p>最后一个式子似乎是乱入的… 不过还好是显然的, 直接通分验证即可</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="BZOJ-3028-食物"><a href="#BZOJ-3028-食物" class="headerlink" title="BZOJ 3028 食物"></a>BZOJ 3028 食物</h4><ul><li>题目链接: <a href="https://lydsy.com/JudgeOnline/problem.php?id=3028" target="_blank" rel="noopener">https://lydsy.com/JudgeOnline/problem.php?id=3028</a></li></ul><p><del>乐色 OJ 什么都是权限题</del> = =</p><p>首先您要学会生成函数, 然后这就是一道裸题.</p><p>设生成函数为 $g(x)$, 化简后得<br>$$g(x) = \frac{x}{(1-x)^4} = x \sum_{k=0}^\infty\; \binom{k+3}{k} x^k = \sum_{k=0}^\infty\; \binom{k+2}{k-1} x^k$$</p><p>所以第 $n$ 项系数, 即答案, 为 $\binom{n+2}{n-1} = \binom{n+2}{3} = \frac{1}{6} n(n+1)(n+2)$</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>Richard A. Brualdi. 组合数学. 机械工业出版社, 2012.4.</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;数学就是用的时候不够用的东西. = =&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;牛顿二项式定理是对二项式定理的推广, &lt;del&gt;那直接叫广义二项式定理不好吗&lt;/del&gt;, 刚开始看 &amp;lt;组合数学&amp;gt; 的时候见到这个东西, 以为没什么用 = =, 后来…&lt;/p&gt;
&lt;p&gt;当然本文作者没有仔细严谨地学习相关的数学知识, 内容充满谬误, 恳请指正.&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://depletedprism.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Combinatorics" scheme="https://depletedprism.github.io/tags/Combinatorics/"/>
    
  </entry>
  
  <entry>
    <title>「51nod 1348」乘积之和 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/51nod-1348/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/51nod-1348/</id>
    <published>2020-01-18T16:41:47.000Z</published>
    <updated>2020-02-06T03:35:32.288Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接: <a href="https://www.51nod.com/Challenge/Problem.html#problemId=1348" target="_blank" rel="noopener">https://www.51nod.com/Challenge/Problem.html#problemId=1348</a></li></ul><p>分治 FFT 如果使用三模数 NTT, 那么每次合并只需要记录实际模数下的答案…</p><a id="more"></a><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>首先容易发现, 多次询问是个假的限制, 实际上我们可以预先计算出所以答案, 然后每次 $O(1)$ 回答…</p><p>对于每个数, 有选和不选两种选择, 容易构造出生成函数 $g(x)$ 如下, 选择 $k$ 个数的乘积即为 $x^k$ 对应项的系数.<br>$$g(x) = \prod_{i=1}^n (a_i x + 1)$$</p><p>现在的问题就是如何计算这个式子, 有一种无脑且直接的方法就是分治 FFT…</p><p>不过值得注意的是, 这屑题的模数为 $100003 = 2\times 3\times 7\times 2381 + 1$, 并不是友好的 NTT 模数, 于是使用三模数 NTT, (实际上这个模数很小, 用双模数 NTT 就足够了), 统计答案的时候中国剩余定理合并即可.</p><p>然后我就写出了这样的乐色代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span>* a, Num* f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> f[<span class="number">0</span>] = Num(<span class="number">1</span>), <span class="keyword">void</span>( f[<span class="number">1</span>] = Num(a[L]) );</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, Lim = <span class="number">1</span>, K = <span class="number">0</span>;</span><br><span class="line">    Num *f0 = tmp[++idx], *f1 = tmp[++idx];</span><br><span class="line">    divide(L, Mid, a, f0), divide(Mid+<span class="number">1</span>, R, a, f1);</span><br><span class="line">    <span class="keyword">while</span> (Lim &lt;= R-L+<span class="number">1</span>) Lim &lt;&lt;= <span class="number">1</span>, ++K;</span><br><span class="line">    init(Lim, K), NTT(f0, Lim, <span class="number">1</span>), NTT(f1, Lim, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = f0[i] * f1[i], f0[i] = f1[i] = Num(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 注意到这里 f 为在三模数意义下的三个值, 而不是模 100003 意义下的答案 (</span></span><br><span class="line">    NTT(f, Lim, <span class="number">-1</span>), idx -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后接下来就调了好长时间 = =, 终于发现了这个锅,  <del>其实想一想也挺有道理的</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span>* a, <span class="keyword">int</span>* f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> f[<span class="number">0</span>] = <span class="number">1</span>, <span class="keyword">void</span>( f[<span class="number">1</span>] = a[L] );</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, *f0 = tmp[++idx], *f1 = tmp[++idx];</span><br><span class="line">    divide(L, Mid, a, f0), divide(Mid+<span class="number">1</span>, R, a, f1);</span><br><span class="line">    <span class="keyword">int</span> Lim = <span class="number">1</span>, K = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Lim &lt;= R-L+<span class="number">1</span>) Lim &lt;&lt;= <span class="number">1</span>, ++K;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Mid-L+<span class="number">1</span>; ++i) A[i] = Num(f0[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid-L+<span class="number">2</span>; i &lt; Lim; ++i) A[i] = Num(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= R-Mid; ++i) B[i] = Num(f1[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = R-Mid+<span class="number">1</span>; i &lt; Lim; ++i) B[i] = Num(<span class="number">0</span>);</span><br><span class="line">    init(Lim, K), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = A[i] * B[i], f0[i] = f1[i] = <span class="number">0</span>;</span><br><span class="line">    NTT(A, Lim, <span class="number">-1</span>), idx -= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= R-L+<span class="number">1</span>; ++i) f[i] = A[i].Merge();</span><br><span class="line">    <span class="comment">// 只记录模 100003 下的答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 51nod 1348</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e5</span>+<span class="number">5</span>, invP1 = <span class="number">669690699</span>, invP12 = <span class="number">354521948</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P1 = <span class="number">998244353</span>, P2 = <span class="number">1004535809</span>, P3 = <span class="number">469762049</span>, G = <span class="number">3</span>, mod = <span class="number">100003</span>;</span><br><span class="line"><span class="keyword">const</span> LL P12 = <span class="number">1L</span>L * P1 * P2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Num</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    Num() &#123; a = b = c = <span class="number">0</span>; &#125;</span><br><span class="line">    Num(<span class="keyword">int</span> _x): a(_x), b(_x), c(_x) &#123; &#125;</span><br><span class="line">    Num(<span class="keyword">int</span> _a, <span class="keyword">int</span> _b, <span class="keyword">int</span> _c): a(_a), b(_b), c(_c) &#123; &#125;</span><br><span class="line">    <span class="function">Num <span class="title">Mod</span><span class="params">(<span class="keyword">const</span> Num&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Num(x.a + (x.a &gt;&gt; <span class="number">31</span> &amp; P1), x.b + (x.b &gt;&gt; <span class="number">31</span> &amp; P2), x.c + (x.c &gt;&gt; <span class="number">31</span> &amp; P3));</span><br><span class="line">    &#125;</span><br><span class="line">    Num <span class="keyword">operator</span> + (<span class="keyword">const</span> Num&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Mod(Num(a + rhs.a - P1, b + rhs.b - P2, c + rhs.c - P3)); &#125;</span><br><span class="line">    Num <span class="keyword">operator</span> - (<span class="keyword">const</span> Num&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Mod(Num(a - rhs.a, b - rhs.b, c - rhs.c)); &#125;</span><br><span class="line">    Num <span class="keyword">operator</span> * (<span class="keyword">const</span> Num&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Num(<span class="number">1L</span>L * a * rhs.a % P1, <span class="number">1L</span>L * b * rhs.b % P2, <span class="number">1L</span>L * c * rhs.c % P3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Merge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LL x = <span class="number">1L</span>L * (b - a + P2) % P2 * invP1 % P2 * P1 + a;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1L</span>L * (c - x % P3 + P3) % P3 * invP12 % P3 * (P12 % mod) % mod + x) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * base * ret % P;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    Num A[MAXN], B[MAXN];</span><br><span class="line">    <span class="keyword">int</span> r[MAXN], tmp[<span class="number">31</span>][MAXN], idx = <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(Num* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="function">Num <span class="title">unit</span><span class="params">( fpow(type &gt; <span class="number">0</span>? G: fpow(G, P1<span class="number">-2</span>, P1), (P1<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>), P1), </span></span></span><br><span class="line"><span class="function"><span class="params">                      fpow(type &gt; <span class="number">0</span>? G: fpow(G, P2<span class="number">-2</span>, P2), (P2<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>), P2),</span></span></span><br><span class="line"><span class="function"><span class="params">                      fpow(type &gt; <span class="number">0</span>? G: fpow(G, P3<span class="number">-2</span>, P3), (P3<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>), P3) )</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="function">Num <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j, w = w * unit) &#123;</span><br><span class="line">                    Num f0 = f[i+j], f1 = w * f[i+j+Mid];</span><br><span class="line">                    f[i+j] = f0 + f1, f[i+j+Mid] = f0 - f1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function">Num <span class="title">inv</span><span class="params">( fpow(Lim, P1<span class="number">-2</span>, P1), fpow(Lim, P2<span class="number">-2</span>, P2), fpow(Lim, P3<span class="number">-2</span>, P3) )</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = f[i] * inv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span>* a, <span class="keyword">int</span>* f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> f[<span class="number">0</span>] = <span class="number">1</span>, <span class="keyword">void</span>( f[<span class="number">1</span>] = a[L] );</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, *f0 = tmp[++idx], *f1 = tmp[++idx];</span><br><span class="line">        divide(L, Mid, a, f0), divide(Mid+<span class="number">1</span>, R, a, f1);</span><br><span class="line">        <span class="keyword">int</span> Lim = <span class="number">1</span>, K = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt;= R-L+<span class="number">1</span>) Lim &lt;&lt;= <span class="number">1</span>, ++K;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Mid-L+<span class="number">1</span>; ++i) A[i] = Num(f0[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid-L+<span class="number">2</span>; i &lt; Lim; ++i) A[i] = Num(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= R-Mid; ++i) B[i] = Num(f1[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = R-Mid+<span class="number">1</span>; i &lt; Lim; ++i) B[i] = Num(<span class="number">0</span>);</span><br><span class="line">        init(Lim, K), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = A[i] * B[i], f0[i] = f1[i] = <span class="number">0</span>;</span><br><span class="line">        NTT(A, Lim, <span class="number">-1</span>), idx -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= R-L+<span class="number">1</span>; ++i) f[i] = A[i].Merge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    Poly::divide(<span class="number">1</span>, n, A, f);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> K;</span><br><span class="line">        read(K), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[K]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://www.51nod.com/Challenge/Problem.html#problemId=1348&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.51nod.com/Challenge/Problem.html#problemId=1348&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分治 FFT 如果使用三模数 NTT, 那么每次合并只需要记录实际模数下的答案…&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Polynomial" scheme="https://depletedprism.github.io/tags/Polynomial/"/>
    
  </entry>
  
  <entry>
    <title>「BZOJ 5093」图的价值 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/BZOJ-5093/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/BZOJ-5093/</id>
    <published>2020-01-17T14:27:41.000Z</published>
    <updated>2020-01-19T05:16:09.365Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p> 组合数学学不明白祭.</p></blockquote><ul><li>题目链接: <a href="https://lydsy.com/JudgeOnline/problem.php?id=5093" target="_blank" rel="noopener">https://lydsy.com/JudgeOnline/problem.php?id=5093</a></li></ul><p>根据题意列出式子, 并通过第二类 Stirling 数对式子进行化简, 在合适的时间内计算出结果.</p><a id="more"></a><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><ul><li>NTT</li><li><p>第二类 Stirling 数的一些性质</p><ul><li><p>$m^n=\sum_{i=0}^{m} \begin{Bmatrix}n \\ i\end{Bmatrix}\  i! \cdot  \binom{m}{i}$<br>提供了一个计算自然数幂的新思路.</p></li><li><p>$\begin{Bmatrix} n\\ m\end{Bmatrix} =  \sum_{i=0}^{m} \frac{(-1)^i}{i!} \frac{(m-i)^n}{(m-i)!}$<br>显然是一个卷积的形式, 可以在 $O(n \log n)$ 的时间复杂度计算.</p><p>详尽的解释可以在这里找到: <a href="https://www.cnblogs.com/y2823774827y/p/10700231.html" target="_blank" rel="noopener">https://www.cnblogs.com/y2823774827y/p/10700231.html</a></p></li></ul></li></ul><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>考虑单独枚举一个点的度数 $i$, 那么答案可以表示为 $$n \cdot \sum_{i=0}^{n-1} \binom{n-1}{i} i^k \cdot 2^{\frac{1}{2} (n-1)(n-2)}$$</p><p>如何理解呢? 首先, 每个点在枚举时是等价的, 所以最终结果乘 $n$</p><p>其次, 当前点的贡献为 $i^k$, 考虑度数为 $k$, 即在剩余的 $n-1$ 个点中选择 $i$ 个点. 要求无向图无重边, 剩余的边随意, 方案数为 $2^{\frac{1}{2} (n-1)(n-2)}$.</p><p>整理, 得 $$n \cdot 2^{\frac{1}{2} (n-1)(n-2)} \sum_{i=0}^{n-1} \ \binom{n-1}{i} i^k$$</p><p>现在的问题主要在后半部分, 由第二类 Stirling 数的性质, 得 $$\sum_{i=0}^{n-1} \ \binom{n-1}{i} \sum_{j=0}^{i} \  \begin{Bmatrix}k \\ j \end{Bmatrix}\ j!\ \binom{i}{j}$$</p><p>改变 $i, j$ 的枚举顺序, 有 $$\sum_{j=0}^{n-1}\ \begin{Bmatrix} k\\ j \end{Bmatrix} \cdot j! \ \sum_{i = j}^{n - 1}\ \binom{n-1}{i} \binom{i}{j}$$<br>不过要注意到 $\forall \ m &gt; n,\ \begin{Bmatrix} n \\ m \end{Bmatrix} = 0$</p><p>接下来的 trick 来源于 <a href="https://www.cnblogs.com/Tiw-Air-OAO/p/10286501.html" target="_blank" rel="noopener">Tiw’s Blog</a>, 考虑右边和式的组合意义, 即在 $n-1$ 个物品中选取 $i$ 个物品, 并在 $i$ 个物品中选择 $j$ 个的方案数. 可以发现, 这样等同于在 $n-1$ 个物品中选择 $j$ 个, 剩下部分可选可不选, 这样就同 $i$ 无关了. 可得 $$\sum_{j=0}^{n-1}\ \begin{Bmatrix} k\\ j \end{Bmatrix} \cdot j! \ \binom{n-1}{j}\ 2^{ n-1-j } \\ \sum_{j=0}^{n-1}\ \begin{Bmatrix} k\\ j \end{Bmatrix} \ \frac{(n-1)!}{(n-1-j)!}\ 2^{ n-1-j }$$</p><p>接下来就可以写了…</p><p>先计算 $k$ 对应的第二类 Stirling 数, 之后 $O(n)$ 扫一遍统计答案. 式子中间的一项在 $j$ 增加的过程中每次只多出一个乘积, 顺手维护就好了.</p><p>最后答案 $$n \cdot 2^{\frac{1}{2} (n-1)(n-2)} \sum_{j=0}^{n-1}\ \begin{Bmatrix} k\\ j \end{Bmatrix} \ \frac{(n-1)!}{(n-1-j)!}\ 2^{ n-1-j }$$</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">    Problem: 5093</span></span><br><span class="line"><span class="comment">    User: DepletedPrism</span></span><br><span class="line"><span class="comment">    Language: C++</span></span><br><span class="line"><span class="comment">    Result: Accepted</span></span><br><span class="line"><span class="comment">    Time:10104 ms</span></span><br><span class="line"><span class="comment">    Memory:20352 kb</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// BZOJ 5093</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>, G = <span class="number">3</span>, iG = <span class="number">332748118</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> m = P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % m;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> Lim, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> unit = fpow(type &gt; <span class="number">0</span>? G: iG, (P<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j, w = <span class="number">1L</span>L * w * unit % P) &#123;</span><br><span class="line">                    <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1L</span>L * w * f[i+j+Mid] % P;</span><br><span class="line">                    f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> inv = fpow(Lim, P<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * inv % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n, K;</span><br><span class="line"><span class="keyword">int</span> f[MAXN], g[MAXN];</span><br><span class="line"><span class="keyword">int</span> inv[MAXN], fac[MAXN];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;K);</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    inv[<span class="number">0</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i) fac[i] = <span class="number">1L</span>L * fac[i<span class="number">-1</span>] * i % P;</span><br><span class="line">    inv[K] = fpow(fac[K], P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = K; i; --i) inv[i<span class="number">-1</span>] = <span class="number">1L</span>L * i * inv[i] % P;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= K; ++i) &#123;</span><br><span class="line">        f[i] = (i &amp; <span class="number">1</span>)? P-inv[i]: inv[i];</span><br><span class="line">        g[i] = <span class="number">1L</span>L * fpow(i, K) * inv[i] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Lim &lt;= <span class="number">2</span>*K) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">    Poly::init(Lim, L), Poly::NTT(f, Lim, <span class="number">1</span>), Poly::NTT(g, Lim, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * g[i] % P;</span><br><span class="line">    Poly::NTT(f, Lim, <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, b = <span class="number">1L</span>L * (n<span class="number">-1</span>) * (n<span class="number">-2</span>) / <span class="number">2</span> % (P<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> inv2 = fpow(<span class="number">2</span>, P<span class="number">-2</span>), mul = <span class="number">1</span>, pow2 = fpow(<span class="number">2</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; i &lt;= K; ++i) &#123;</span><br><span class="line">        ans = (ans + <span class="number">1L</span>L * f[i] * mul % P * pow2 % P) % P;</span><br><span class="line">        mul = <span class="number">1L</span>L * mul * (n-i<span class="number">-1</span>) % P, pow2 = <span class="number">1L</span>L * pow2 * inv2 % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, <span class="number">1L</span>L * ans * fpow(<span class="number">2</span>, b) % P * n % P);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt; 组合数学学不明白祭.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://lydsy.com/JudgeOnline/problem.php?id=5093&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://lydsy.com/JudgeOnline/problem.php?id=5093&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据题意列出式子, 并通过第二类 Stirling 数对式子进行化简, 在合适的时间内计算出结果.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Combinatorics" scheme="https://depletedprism.github.io/tags/Combinatorics/"/>
    
      <category term="Polynomial" scheme="https://depletedprism.github.io/tags/Polynomial/"/>
    
  </entry>
  
  <entry>
    <title>小学数学之前 n 个正整数的 a 次方之和</title>
    <link href="https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/sum-of-n/"/>
    <id>https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/sum-of-n/</id>
    <published>2020-01-09T05:09:38.000Z</published>
    <updated>2020-01-28T14:58:26.256Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>我不如小学生.png</p></blockquote><p>作为高中生, 被小学奥 (chang) 数 (shi) 针对了.</p><p>于是, 这里集中了形如 $\sum_{i=1}^n i^a,\ (a = 1,\ 2,\ 3,\ \ldots )$, 即前 $n$ 个正整数的 $a$ 次方和的计算公式.</p><a id="more"></a><h2 id="简单结论"><a href="#简单结论" class="headerlink" title="简单结论"></a>简单结论</h2><p>首先, 有以下结论</p><p>$$\sum_{i=1}^n i = \frac{n(n+1)}{2}$$</p><p>$$\sum_{i=1}^n i^2 = \frac{n(n+1)(2n+1)}{6}$$</p><p>$$\sum_{i=1}^n i^{3} = \frac{n^2(n+1)^2}{4}$$</p><p>至此, 本文结束, <del>你不应该在这个乐色结论上浪费太多时间 (</del>.</p><h2 id="结论证明"><a href="#结论证明" class="headerlink" title="结论证明"></a>结论证明</h2><ul><li><p>$a = 1$</p><p>设 $S_n = \sum_{i=1}^n i$, 并容易发现这就是个公差为 $1$ 的等差数列, 直接上求和公式即可.</p><p>但是, 这是小学生的数学, 我们换一种方式</p><p>$$S_n = 1 + 2 + 3 + \cdots + (n-2) + (n-1) + n \\ S_n = n + (n-1) + (n-2) + \cdots + 3 + 2 + 1$$</p><p>显然有</p><p>$$2S_n = (n+1) + (n+1) + (n+1) + \cdots + (n+1) + (n+1) \\ S_n = \frac{n(n+1)}{2}$$</p><p>这是个数列里普通的技巧 “倒序相加”, <del>也就能拿来骗小学生玩了</del></p><p>但是这个方法不能推广到 $a=2$ 的情况, 于是继续换一种方式</p><p>我们有 $(k-1)^2 = k^2 - 2k + 1$, 移项得 $k^2 - (k-1)^2 = 2k - 1$</p><p>所以 $$\sum_{k=1}^n k^2 - \sum_{k=1}^n (k-1)^2 = 2\sum_{k=1}^n k - n$$</p><p>$$\sum_{k=1}^n k^2 - \sum_{k=1}^{n-1} k^2 = 2\sum_{k=1}^n k - n$$</p><p>所以 $$n^2 = 2S_n - n \\ S_n = \frac{n(n+1)}{2}$$</p></li><li><p>$a = 2$</p><p>同样, 设 $S_n = \sum_{i=1}^n i^2$, 有 $(k-1)^3 = k^3 - 3k^2 + 3k - 1$</p><p>移项, 得 $$k^3 - (k-1)^3 = 3k^2 - 3k + 1$$</p><p>所以 $$\sum_{i=1}^n k^3 - \sum_{i=1}^n (k-1)^3 = 3 \sum_{k=1}^n k^2 - 3 \sum_{i=1}^n k + n$$</p><p>$$\sum_{i=1}^n k^3 - \sum_{i=1}^{n-1} k^3 = n^3 = 3 \sum_{k=1}^n k^2 - 3 \sum_{i=1}^n k + n$$</p><p>经过一番代换, 有 $$\sum_{k=1}^n k^2 = \frac{1}{3} n^3 + \frac{1}{2} n^2 + \frac{1}{6} n = \frac{n(n+1)(2n+1)}{6}$$</p></li><li><p>$a = 3$</p><p>同理可得, 留给读者当作练习 (</p><p>$$\sum_{i=1}^n i^3 = \frac{n^2(n+1)^2}{4}$$</p><p>当然, 这个公式有另一种理解方式  $$\sum_{i=1}^n i^3 = (\sum_{i=1}^n i)^2 = \frac{n(n+1)}{2} \cdot \frac{n(n+1)}{2}$$</p><p>这是为什么呢, 可以参考 <a href="https://proofwiki.org/wiki/Sum_of_Sequence_of_Cubes/Proof_by_Nicomachus" target="_blank" rel="noopener">Nicomachus’s Proof</a></p></li><li><p>$a \geq 4$</p><p>可以用很多方法做, 然而我只会拉格朗日插值.</p><ul><li><p>拉格朗日插值</p><p>详见 <a href="https://codeforces.com/problemset/problem/622/F" target="_blank" rel="noopener">CF622F The Sum of the k-th Powers</a>, 好的实现可以在 $O(a)$ 的时间内计算.</p></li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://brilliant.org/wiki/sum-of-n-n2-or-n3/" target="_blank" rel="noopener">https://brilliant.org/wiki/sum-of-n-n2-or-n3/</a></li><li><a href="https://proofwiki.org/wiki/Sum_of_Sequence_of_Cubes" target="_blank" rel="noopener">https://proofwiki.org/wiki/Sum_of_Sequence_of_Cubes</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;我不如小学生.png&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为高中生, 被小学奥 (chang) 数 (shi) 针对了.&lt;/p&gt;
&lt;p&gt;于是, 这里集中了形如 $\sum_{i=1}^n i^a,\ (a = 1,\ 2,\ 3,\ \ldots )$, 即前 $n$ 个正整数的 $a$ 次方和的计算公式.&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://depletedprism.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Polynomial" scheme="https://depletedprism.github.io/tags/Polynomial/"/>
    
  </entry>
  
  <entry>
    <title>「CERC2014」Virus synthesis 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P4762/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P4762/</id>
    <published>2020-01-07T11:01:44.000Z</published>
    <updated>2020-01-07T12:05:19.051Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P4762" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P4762</a></li></ul><p>一道回文自动机 + DP 的题, 感觉能启发思路以及学习到一些技巧, 故记之.</p><a id="more"></a><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>假设字符串 $S$ 的长度为 $n$, 容易想到 $O(n^3)$ 的区间 DP 做法, 但是不大可取 = =, 状态数就已经到达了 $O(n^2)$.</p><p>于是换一种思路, 设 $f(i)$ 表示构造 PAM 上第 $i$ 个节点所代表的回文串, 且 $len(i)$ 为偶数, 所需要的最少操作次数, 那么</p><ul><li><p>对于 $i$ 的子节点 $j$, 有 $f(j) = f(i) + 1$</p><p>因为 PAM 的节点表示一个回文串, 那么 $j$ 代表的回文串可以视为 $i$ 代表的回文串两端多出一个字符. 因为 $i$ 是回文串, 考虑在构造字符串 $i$ 时, 一定会有一次 2 操作, 否则就不是最优解. 那么, 我们就可以在这次 2 操作之前, 在 $i$ 的某端添加一个字符, 这样从 $i$ 到 $j$ 只需要一次操作.</p></li><li><p>假设 $j$ 是 $i$ 的一个回文后缀, 且满足 $2 \cdot len(j) \leq len(i)$, 有  $$f(i) = \min{f(j) + 1 + len(i) / 2 - len(j)}$$</p><p>这里将 $i$ 视为 $j$ 通过 1 操作填到一半, 再通过一次 2 操作构造而来.</p></li></ul><p>然后答案很好统计了, 可以把最终的字符串视为一个回文串和多次 1 操作堆叠而成, 那么 $$ans = \min{f(i) + n - len(i)}$$</p><p>现在的问题就是如何实现转移. </p><p>对于第一个转移, 没什么好说的, 在 PAM 偶节点从上到下 BFS 一遍就好了, (似乎有在线的做法, 在新加入节点时更新 $f(i)$ 的值).</p><p>对于第二个转移, 需要处理出满足 $i$ 满足 $2 \cdot len(j) \leq len(i)$ 的最长回文后缀, 记为 $trans(i)$ 可以通过求 fail 类似的方法维护, 只是在跳 fail 的时候多了一个限制条件, 相同的技巧也在 <a href="https://www.luogu.com.cn/problem/P4287" target="_blank" rel="noopener">[SHOI2011]双倍回文</a> 使用过.</p><h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P4762</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">5</span>, SIGMA = <span class="number">4</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> M[<span class="number">128</span>], f[MAXN];</span><br><span class="line"><span class="keyword">char</span> S[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PAM &#123;</span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][SIGMA], len[MAXN], trans[MAXN], fail[MAXN], last, nidx, ptr;</span><br><span class="line">    <span class="keyword">char</span> S[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="keyword">sizeof</span> ch);</span><br><span class="line">        last = <span class="number">0</span>, nidx = <span class="number">1</span>;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>, fail[<span class="number">0</span>] = <span class="number">1</span>, len[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        S[ptr = <span class="number">0</span>] = <span class="string">'$'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getfail</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (S[ptr-len[u]<span class="number">-1</span>] != S[ptr]) u = fail[u];</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        S[++ptr] = c;</span><br><span class="line">        <span class="keyword">int</span> val = M[(<span class="keyword">int</span>) c], nd = getfail(last);</span><br><span class="line">        <span class="keyword">if</span> (!ch[nd][val]) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = ++nidx;</span><br><span class="line">            len[p] = len[nd] + <span class="number">2</span>;</span><br><span class="line">            fail[p] = ch[getfail(fail[nd])][val];</span><br><span class="line">            <span class="keyword">if</span> (len[p] &lt;= <span class="number">2</span>) trans[p] = fail[p];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> u = trans[nd];</span><br><span class="line">                <span class="comment">// int u = fail[nd];</span></span><br><span class="line">                <span class="comment">// 如果写成以上写法, 复杂度就是假的 = =</span></span><br><span class="line">                <span class="keyword">while</span> (S[ptr-len[u]<span class="number">-1</span>] != S[ptr] || <span class="number">2</span>*(len[u]+<span class="number">2</span>) &gt; len[p]) u = fail[u];</span><br><span class="line">                trans[p] = ch[u][val];</span><br><span class="line">            &#125;</span><br><span class="line">            ch[nd][val] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        last = ch[nd][val];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> Q[MAXN], head, tail, ret;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        ret = n, f[<span class="number">0</span>] = <span class="number">1</span>, Q[head = tail = <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意答案的最大值为 n, 如果不存在长度为偶数的回文串, 那么 min&#123;f&#125; = INF...</span></span><br><span class="line">        <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q[head++];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; SIGMA; ++c) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = ch[u][c];</span><br><span class="line">                <span class="keyword">if</span> (!i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> j = trans[i];</span><br><span class="line">                f[i] = min(f[i], min(f[u] + <span class="number">1</span>, f[j] + <span class="number">1</span> + len[i] / <span class="number">2</span> - len[j]));</span><br><span class="line">                ret = min(ret, f[i] + n - len[i]);</span><br><span class="line">                Q[++tail] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"1.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    M[<span class="string">'A'</span>] = <span class="number">0</span>, M[<span class="string">'C'</span>] = <span class="number">1</span>, M[<span class="string">'G'</span>] = <span class="number">2</span>, M[<span class="string">'T'</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> Ti;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        PAM::init();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S+<span class="number">1</span>);</span><br><span class="line">        n = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(S+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) PAM::insert(S[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, PAM::solve());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h4><p>上述代码成功拿到了 67 pts 的好成绩, 在第一个点跑了很久…</p><p>通过学习其他人的卡常技巧, 算是卡了过去</p><ol><li>用到再初始化 <code>ch</code> 的值</li><li>BFS 遍历 PAM 时, 每个节点只更新一次</li><li>给 $f(i)$ 赋初值为节点的长度 $len(i)$, 并只在 $len(i)$ 为偶数的时候更新 $f(i)$</li><li>使用 <code>ckmin</code> 更新最小值</li></ol><p>话说用 <code>static</code> 把数组开到函数里会快一点? 不明所以.png</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P4762</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">5</span>, SIGMA = <span class="number">4</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> M[<span class="number">128</span>], f[MAXN];</span><br><span class="line"><span class="keyword">char</span> S[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PAM &#123;</span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][SIGMA], len[MAXN], trans[MAXN], fail[MAXN], last, nidx, ptr;</span><br><span class="line">    <span class="keyword">char</span> S[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.</span></span><br><span class="line">        <span class="built_in">memset</span>(ch[<span class="number">0</span>], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">memset</span>(ch[<span class="number">1</span>], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[<span class="number">1</span>]);</span><br><span class="line">        last = <span class="number">0</span>, nidx = <span class="number">1</span>;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>, fail[<span class="number">0</span>] = <span class="number">1</span>, len[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        S[ptr = <span class="number">0</span>] = <span class="string">'$'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getfail</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (S[ptr-len[u]<span class="number">-1</span>] != S[ptr]) u = fail[u];</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        S[++ptr] = c;</span><br><span class="line">        <span class="keyword">int</span> val = M[(<span class="keyword">int</span>) c], nd = getfail(last);</span><br><span class="line">        <span class="keyword">if</span> (!ch[nd][val]) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = ++nidx;</span><br><span class="line">            <span class="comment">// 1.</span></span><br><span class="line">            <span class="built_in">memset</span>(ch[p], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[p]);</span><br><span class="line">            len[p] = len[nd] + <span class="number">2</span>;</span><br><span class="line">            fail[p] = ch[getfail(fail[nd])][val];</span><br><span class="line">            <span class="keyword">if</span> (len[p] &lt;= <span class="number">2</span>) trans[p] = fail[p];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> u = trans[nd];</span><br><span class="line">                <span class="keyword">while</span> (S[ptr-len[u]<span class="number">-1</span>] != S[ptr] || <span class="number">2</span>*(len[u]+<span class="number">2</span>) &gt; len[p]) u = fail[u];</span><br><span class="line">                trans[p] = ch[u][val];</span><br><span class="line">            &#125;</span><br><span class="line">            ch[nd][val] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        last = ch[nd][val];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ckmin</span><span class="params">(T&amp; x, <span class="keyword">const</span> T&amp; y)</span> </span>&#123; <span class="keyword">if</span> (x &gt; y) x = y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> vis[MAXN], Time, Q[MAXN], head, tail, ret;</span><br><span class="line">        ++Time;</span><br><span class="line">        <span class="comment">// 3.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nidx; ++i) f[i] = len[i];</span><br><span class="line">        ret = n, f[<span class="number">0</span>] = <span class="number">1</span>, Q[head = tail = <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q[head++];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; SIGMA; ++c) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = ch[u][c];</span><br><span class="line">                <span class="keyword">if</span> (!i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> j = trans[i];</span><br><span class="line">                f[i] = f[u] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 3.</span></span><br><span class="line">                <span class="keyword">if</span> (len[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                    ckmin(f[i], f[j] + <span class="number">1</span> + len[i] / <span class="number">2</span> - len[j]);</span><br><span class="line">                ckmin(ret, f[i] + n - len[i]);</span><br><span class="line">                <span class="comment">// 2.</span></span><br><span class="line">                <span class="keyword">if</span> (vis[i] != Time) Q[++tail] = i, vis[i] = Time;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"1.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    M[<span class="string">'A'</span>] = <span class="number">0</span>, M[<span class="string">'C'</span>] = <span class="number">1</span>, M[<span class="string">'G'</span>] = <span class="number">2</span>, M[<span class="string">'T'</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> Ti;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        PAM::init();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S+<span class="number">1</span>);</span><br><span class="line">        n = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(S+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) PAM::insert(S[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, PAM::solve());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://www.luogu.com.cn/problem/P4762&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.com.cn/problem/P4762&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一道回文自动机 + DP 的题, 感觉能启发思路以及学习到一些技巧, 故记之.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="String" scheme="https://depletedprism.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>「SCOI2012」喵星球上的点名 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2336/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2336/</id>
    <published>2020-01-02T12:47:48.000Z</published>
    <updated>2020-01-07T11:11:38.568Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P2336" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P2336</a></li></ul><p>一道后缀数组的题, 毒瘤了我大半个晚上, 故写题解以纪念.</p><a id="more"></a><h4 id="一些约定"><a href="#一些约定" class="headerlink" title="一些约定"></a>一些约定</h4><ol><li>字符串下标从 $1$ 开始</li><li>记 $sa[i]$ 表示字符串所有后缀排序后第 $i$ 大的后缀的编号, $rnk[i]$ 表示后缀 $i$ 在 $sa$ 中的下标, 即后缀 $i$ 在所有后缀中的排名</li></ol><h4 id="运用到-SA-的性质"><a href="#运用到-SA-的性质" class="headerlink" title="运用到 SA 的性质"></a>运用到 SA 的性质</h4><ol><li><p>SA 中前缀相同的串排在一起, 也就是说, SA 按照字典序对所有后缀排序</p></li><li><p>两子串最长公共前缀 $$\text{LCP}(sa[i], sa[j]) = \min_{k = i+1}^j { \text{height[k]} }$$</p></li></ol><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>首先, 我们的任务是确定一个字符串是不是一个字符串的子串, 可以联想到的算法有 AC 自动机, 哈希之类的东西… 不过这道题的字符集大小达到了 $10^4$, 感觉 SA 似乎更可做一点.</p><p>那么, 怎么用 SA 确定一个字符串是否是另一个字符串的子串呢? 可以通过 LCP 来做.</p><p>现在有一个显然的事情, 如果一个字符串 $S$ 是 $T$ 的子串, 那么 $T$ 存在一个后缀 $T’$, 使得 $\text{LCP}(S, T’) = |S|$.</p><p>对于一个 $S$ 和一个 $T$, 可以将 $S,\ T$ 拼接成一个新串, 中间用一个从未出现过的字符连接, 通过对新串求后缀数组, 然后再二分判定.</p><p>回到这道题上来, 对于多个 $S$, $T$, 也可以用相同的方式. 对于一个 “点名串” $S$, 包含 $S$ 的字符串一定在 $sa$ 是一段连续的区间. 那么, 现在的问题就是序列上的问题了.</p><ol><li>区间 $[L, R]$ 中不同猫的个数;</li><li>询问完之后猫的点名次数.</li></ol><p><del>存在使用树状数组 / 线段树的做法, 可惜实在学不会, 于是使用了莫队</del></p><p>考虑莫队, 第一个问题比较经典, 开一个桶记录猫在现在维护区间内出现次数, 在出现次数改变为 0 / 1 时更新答案就可以了. 对于第二个问题, 参考了 <a href="https://www.luogu.com.cn/blog/hl666/solution-p2336" target="_blank" rel="noopener">hl666 的题解</a> = =, 每次有新的猫进入区间, 或者一只猫已经完全离开现在的区间时, 更新当前情况下被点到次数的最大值.</p><p>但是这样为什么是对的呢? 考虑一只猫进出区间的两个过程, 虽然我们在进入区间的时候给他算上了最大的可能点名次数, 但是在离开又减去了可能的最大值. 感性理解一下, 差值就像是正确答案…</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>写起来 rnk, sa, idx 翻来覆去 = =</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P2336</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"><span class="comment">// 普通的读入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span>+<span class="number">5</span>, MAXM = <span class="number">1e4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> block;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> idx, L, R;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Ask&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> R / block == rhs.R / block? (L == rhs.L? <span class="number">0</span>: ((R / block) &amp; <span class="number">1</span>) &amp; (L &lt; rhs.L)): R &lt; rhs.R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Q[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, N, q;</span><br><span class="line"><span class="keyword">int</span> A[MAXN];</span><br><span class="line"><span class="keyword">int</span> S[MAXN]; <span class="comment">// 拼接后的数组</span></span><br><span class="line"><span class="keyword">int</span> idx[MAXN]; <span class="comment">// 拼接后第 i 个位置对应原字符串的编号</span></span><br><span class="line"><span class="keyword">int</span> firstpos[MAXN]; <span class="comment">// 点名串对应在 S 中的位置, 二分区间左右端点使用</span></span><br><span class="line"><span class="keyword">int</span> qlen[MAXN]; <span class="comment">// 点名串长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> id)</span> </span>&#123; S[++n] = val, idx[n] = id; &#125; <span class="comment">// 更新 S</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SA &#123;</span><br><span class="line">    <span class="keyword">int</span> sa[MAXN], rnk[MAXN], id[MAXN], px[MAXN], ht[MAXN], cnt[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[x] == id[y] &amp;&amp; id[x+k] == id[y+k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, k, p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) ++cnt[rnk[i] = S[i]];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i) cnt[i] += cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i = n; i; --i) sa[cnt[rnk[i]]--] = i;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n &amp;&amp; p &lt; n; k &lt;&lt;= <span class="number">1</span>, m = p) &#123;</span><br><span class="line">            <span class="keyword">for</span> (p = <span class="number">0</span>, i = n; i &gt; n-k; --i) id[++p] = i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (sa[i] &gt; k) id[++p] = sa[i]-k;</span><br><span class="line">            <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> (<span class="keyword">int</span>) * (m+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) ++cnt[px[i] = rnk[id[i]]];</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i) cnt[i] += cnt[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span> (i = n; i; --i) sa[cnt[px[i]]--] = id[i]; <span class="comment">// 这里打挂过</span></span><br><span class="line">            swap(rnk, id), rnk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++i) rnk[sa[i]] = cmp(sa[i], sa[i<span class="number">-1</span>], k)? p: ++p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) rnk[sa[i]] = i; <span class="comment">// 这里打挂过</span></span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>, i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k) --k;</span><br><span class="line">            <span class="keyword">while</span> (S[i + k] == S[sa[rnk[i]<span class="number">-1</span>] + k]) ++k;</span><br><span class="line">            ht[rnk[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> SA::rnk; <span class="keyword">using</span> SA::sa;</span><br><span class="line"><span class="comment">// SA 倍增实现模板</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ST &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> LOG = <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">int</span> minHt[LOG][MAXN], lg2[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) minHt[<span class="number">0</span>][i] = SA::ht[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; LOG; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span> &lt;= n; ++i)</span><br><span class="line">                minHt[j][i] = min(minHt[j<span class="number">-1</span>][i], minHt[j<span class="number">-1</span>][i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))]);</span><br><span class="line">        lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) lg2[i] = lg2[i/<span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">RMQ</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = lg2[R-L+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> min(minHt[k][L], minHt[k][R-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现 RMQ</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MoAlg &#123;</span><br><span class="line">    <span class="keyword">int</span> L, R, ans1;</span><br><span class="line">    <span class="keyword">int</span> Ans1[MAXN], Ans2[MAXN], cnt[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        pos = idx[pos];</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= N &amp;&amp; ++cnt[pos] == <span class="number">1</span>) ++ans1, Ans2[pos] += q-cur+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 只统计编号在猫范围之内的种类数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        pos = idx[pos];</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= N &amp;&amp; --cnt[pos] == <span class="number">0</span>) --ans1, Ans2[pos] -= q-cur+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 只统计编号在猫范围之内的种类数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        block = <span class="keyword">int</span>( n / <span class="built_in">sqrt</span>(q) );</span><br><span class="line">        sort(Q+<span class="number">1</span>, Q+<span class="number">1</span>+q);</span><br><span class="line">        L = <span class="number">1</span>, R = ans1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> Ask&amp; qr = Q[i];</span><br><span class="line">            <span class="keyword">while</span> (L &gt; qr.L) add(sa[--L], i);</span><br><span class="line">            <span class="keyword">while</span> (R &gt; qr.R) del(sa[R--], i);</span><br><span class="line">            <span class="keyword">while</span> (L &lt; qr.L) del(sa[L++], i);</span><br><span class="line">            <span class="keyword">while</span> (R &lt; qr.R) add(sa[++R], i);</span><br><span class="line">            Ans1[qr.idx] = ans1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> MoAlg::Ans1; <span class="keyword">using</span> MoAlg::Ans2;</span><br><span class="line"><span class="comment">// 莫队</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(N), read(q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k, i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        read(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) read(A[j]), add(A[j]+<span class="number">1</span>, i);</span><br><span class="line">        add(MAXM + <span class="number">2</span>*i<span class="number">-1</span>, N+<span class="number">1</span>);</span><br><span class="line">        read(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) read(A[j]), add(A[j]+<span class="number">1</span>, i);</span><br><span class="line">        add(MAXM + <span class="number">2</span>*i, N+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k, i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        read(k), qlen[i] = k, firstpos[i] = n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) read(A[j]), add(A[j]+<span class="number">1</span>, N + i);</span><br><span class="line">        add(MAXM + <span class="number">2</span>*N + i, N+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    SA::build(MAXM + <span class="number">2</span>*N + q), ST::init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> L, R, qL, qR;</span><br><span class="line">        L = <span class="number">1</span>, R = rnk[firstpos[i]]<span class="number">-1</span>, qL = rnk[firstpos[i]];</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// LCP, 注意到 +1</span></span><br><span class="line">            <span class="keyword">if</span> (ST::RMQ(Mid + <span class="number">1</span>, rnk[firstpos[i]]) &gt;= qlen[i]) qL = Mid, R = Mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> L = Mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        L = rnk[firstpos[i]]+<span class="number">1</span>, R = n, qR = rnk[firstpos[i]];</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// LCP, 注意到 +1</span></span><br><span class="line">            <span class="keyword">if</span> (ST::RMQ(rnk[firstpos[i]] + <span class="number">1</span>, Mid) &gt;= qlen[i]) qR = Mid, L = Mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> R = Mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Q[i] = (Ask)&#123; i, qL, qR &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    MoAlg::solve();</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans1[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, Ans2[i], <span class="string">" \n"</span>[i==N]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="得出的一些调试的经验"><a href="#得出的一些调试的经验" class="headerlink" title="得出的一些调试的经验?"></a>得出的一些调试的经验?</h4><ol><li>如果不保证模板的正确性, 先检查以下板子… = =</li><li><del>抄题解的时候注意一些细节, 以免调试半天发现是细节问题</del></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://www.luogu.com.cn/problem/P2336&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.com.cn/problem/P2336&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一道后缀数组的题, 毒瘤了我大半个晚上, 故写题解以纪念.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="String" scheme="https://depletedprism.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>2019 CSP-S 游记</title>
    <link href="https://depletedprism.github.io/%E9%9A%8F%E7%AC%94/CSP-S-2019/"/>
    <id>https://depletedprism.github.io/%E9%9A%8F%E7%AC%94/CSP-S-2019/</id>
    <published>2019-11-17T10:04:45.000Z</published>
    <updated>2019-12-07T13:11:44.150Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>公无渡河，公竟渡河！</p><p>堕河而死，其奈公何！</p></blockquote><p>新的 OI 赛事又要开始了.</p><a id="more"></a><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>早一天 (Day -1) 就回家了, 看了考场还算满意, 或许是自己的要求不够高? 熟悉的 win7 x86 &amp; 2 GB RAM 令人想起之前的老台式… 不过 win7 内存占用很少, 考场系统除了红蜘蛛以外还算干净, 因此 2 GB 用起来还算流畅.</p><p>软件配置和去年类似, 有 Vim 和 Dev-cpp 我就满足了. Dev-cpp 虽然不好用, 但是作为现场唯一提供的 C++ IDE 还是要尊重一下的 (雾, 毕竟 windows 的 cmd 用起来有种说不出的别扭, 有朝一日在考场用上 Linux, 再用命令行编译吧.</p><p>手写注册表改了改键盘映射, 罪恶的 Caps 和 Esc 回到了科学的位置, 临时背的注册表好像有点锅, 不想修了. 本想在试机的时候刷个板子熟悉一下键盘, 后来因为有家长在等就作罢了.</p><p>HA 省机房槽点还是挺多的, 键盘主键盘区的 Enter 生怕不被误触而做的出奇的大, Backspace 为鼓励不写错而惊人的小… 其次就是空调足以把人热 sha, 通风也不是很好, 整体的空气有一种封闭的感觉.</p><p>到家后开始刷知乎, <del>我也不知道为什么就刷了很久</del>, 晚上意识到自己太颓, 随便找了到自己鸽掉的 NOIP 真题写了一道, 思路不假, 只是可惜实现时还是参考题解, 希望在明天自己的代码思路能更明了一些吧.</p><p>回想了最近复习的流程, 还有些不常打的模板没有写, 因为不常打所以不熟, 然后就不想打 = =. 一意识到自己还有没打好的板子, 有种晕眩的紧张感. (还是不要太紧张好了.) 复习的过程还是有漏洞, 对于以往难写一点的 NOIP 题目, 应该在这周再写写, 同学从 qbxt 带来的模拟题, 也是要写写的. 但是这些事情都没有做, 只好携我两袖清风, 踏上考场了.</p><p>这周在学校的几个晚上不能用电脑, 无聊翻翻紫书权作复习. LRJ 的书果然是 OI 真理啊</p><blockquote><p>但是有一点需要注意: 理解一个题解和自己独立推导出所有细节还是不一样的, 所以在看完一个难题题解之后最好把它做两遍: 一遍是刚看完题解以后 “趁热打铁”, 一遍是等忘掉题解后自己从头推导一遍.</p><p>—— 刘汝佳 &lt;算法竞赛入门经典 (第 2 版)&gt;</p></blockquote><p>附, windows 下修改注册表使得 Esc 和 Caps 互换的注册表文件, <del>还是喜欢 Linux 一行命令解决的简单方式</del>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Kayboard Layout]</span><br><span class="line">&quot;Scancode Map&quot;=hex:00,00,00,00,00,00,00,00,03,00,00,00,3A,00,01,00,01,00,3A,00,00,00,00,00</span><br></pre></td></tr></table></figure><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>七点五十多的时候发现大家都到了, 其实我到得还算早, 只是恰饭浪费了时间… 会合后照例谈笑风生, 开始各路毒奶:</p><blockquote><p>“请问有省四这种奖吗?”</p><p>“我现在开坑 CSP-S 2019 Day 1 题解, CCF 会不会把我禁赛三年啊?”</p><p>“我 Day 1 是不可能 200 分以上的, 我要是考到 200 分以上就女装.”</p><p>“我拿一等我就女装.”‘</p><p>“您是不是 AK Day 1, 明天就不用来了?”</p><p>……</p></blockquote><p><del>啊, 这群人考好点就有戏看了</del>~</p><p>咳咳咳.</p><p><strong>Ren2Zhen0Si1Kao9?</strong></p><p>进场后, 空气比昨天要好很多了, 配置考场环境也没有出什么大问题. </p><p>拿到题后, 强迫自己看完三题题意, 本想直接写 T1 的, <del>怕不是 CF 写多了</del>, 后来还是等半小时后再动键盘.</p><ul><li><p>T1</p><p>看到给出 “格雷码” 的完整构造方案以为这题和 <a href="https://www.luogu.org/problem/P2615" target="_blank" rel="noopener">神奇的幻方</a> 同源, 看完数据范围后才发现直接模拟会挂…</p><p>考虑了一下, 写出了一个构造方案, 感觉可行就直接写代码了, (但是应去手算一下样例的, 这样就可以避免接下来会出现的错误了)</p><p>结果没过第二个样例, 确认代码没什么问题之后就又去读了一遍题, 果然是题目细节有疏漏, 修修补补算是过了三个给定的样例.</p><p>考试时 WA T1 就直接重读题意的想法来自昨天刷知乎得到的经验, 这里想引用一句话</p><blockquote><p>一般这种题写挂就是没读懂题意, 回去重读题意就好了.</p></blockquote><p><del>你看我刷逼乎还是有点用的</del> (大雾)</p><p>最大的遗憾就是没有写暴力拍 T1</p></li><li><p>T2</p><p>看到题目后就有 $O(n^4)$ 的带暴力想法, 本着 <del>NOIP</del> CSP-S 暴力打满的精神就先写暴力, 写出来前两个样例直接过了, 开始考虑怎么优化. 想了一会有 $O(n^3)$ 的 DP. 当时我兴致勃勃的去打这个 $O(n^3)$ 的 DP, 因为我算错复杂度以为这是 $O(n^2)$ 能拿到 $50\ pts$.</p><p>好在写出来之后及时发现时间复杂度是假的, 更好的事情是, 再优化到 $O(n^2)$ 也不算难. 改完没能过样例, 心态有点爆炸, 调整一会心态之后部分重构了, 算是过了第二组大样例.</p><p>临近考试结束, 拿着 $O(n^3)$ 的暴力拍了一下, 即便用脚随的数据很假也算是过了几十组. 脑子一热拿这破机子去跑了 恶 臭 不 堪 的第三组样例, 本机上 RE, 检查了一下认为是本地爆栈的问题就不打算管了, 毕竟我也不会手动开栈这种 “禁赛三年” 的操作… (雾, 你的手动 O2 是怎么学会的)</p><p>感觉这题放在 Day 1 T2 应该不会是难题, 可能是我有关键点没有把握, 没能想出来正解是我的无能. 如果因为 T2 退役也是不会令人懊恼的事了. 竞赛的事情啊, 还是以个人实力为基础吧.</p></li><li><p>T3</p><p>很像是贪心的样子, 不过有贪心策略就能在 $O(n)$ 的时间得到答案, 所以我一直在想枚举一点, 贪心一点的算法. </p><p>只是…没有什么好策略.</p><p>刚开始拿到题目之后, 肤浅地认为这题的分应该好拿, 解决特殊性质和小数据就可以得到不错的分数, 而链和菊花的情况也会好想一点. 后来的事, 就是我想多了.</p><p>$O(T\cdot n!)$ 的带暴力好哇! 虽然写的时候心不在焉, 导致自己调了好久…</p></li></ul><p>离开考场之后见到 star, <del>听完情况之后一脸失望.jpg</del>.</p><p>下午看了看民间数据, 好多人表示 “T1 大样例都过了, 可是交上去却没拿满.”, 有点心慌, 看来对拍一定要写, CSP-S 还是稳一点好. T2 有 $O(n)$ 的 DP 做法, 没想到的原因除去我太菜, 还有时间复杂度死找 log… 最近写比赛总是被数据范围误导, Day 2 要抛开 &amp;&amp; 灵活一点了.</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>昨天周围的人大多没有考得很好（指达到贵乎 $210 pts$ 水平），今天表情都挺阴沉的，可能都在想翻盘的事吧</p><p><strong>@zhuajin1SHIJIAN7</strong></p><ul><li><p>T1</p><blockquote><p>只要我 T1 能写出来，在 HA 我可以绝杀！NOIp 提高组 Day 2 T1 你能秒我，我当场就把这个电脑屏幕，给吃、下、去！</p></blockquote><p>好的，T1 愉快的写炸了</p><p>开考前毒奶“今天不会有数数题吧？”，算是奶到了？开始认为是组合计数、容斥原理之类的东西，加加减减乘乘除除就可以了，以及模拟赛计数题就没有写对几题的经验，开考之后把 T1 先搁置了，愉快地去看 T2 以及 T3 了</p><p>T2，T3 暴力写完之后一直在想 T1 的正解，无果，于是就有了上面那段自嘲的段子。结果到 11:30 的时候 T1 暴力搜索还没有打出来，心态近乎崩溃，有一种挣扎无望的感觉，最后提交代码的时候也只好交了过不了第二个样例的假暴力。</p><p>实际上暴力可以拿到 $40 pts$，没有打的确可惜啊</p></li><li><p>T2<br>一眼看过去有斜率优化 DP 的味道，推了推式子感觉能做，写的时候发现假了，要求新数据的规模能够递增这个限制没有考虑到</p><p>想到 T1 没有 A 掉的把握心有点凉 = =，所以愉快地打起了 $O(n^3)$ 的暴力 DP，没能优化到 $O(n^2)$ 或是 $O(n^2\log n)$，于是 $36 pts$ 滚粗</p><p>考虑 T2 的时候有监考老师过来：“对于 type=0 的所有测试点，保证最后输出的答案 $\leq 4×10^{18}$”。赛后出题人称使用高精是为了防止取模会直接 pass 掉 DP 做法，不过贪心策略也没能想出来，告辞</p></li><li><p>T3<br>动态求重心 X<br>暴力求重心 X<br>大暴力求重心 √</p><p>重心板子执意没有复习，论据：“重心这东西也就点分治用过啊，CSP-S 不会考点分治吧？”诚然，没有考点分治，但是这一点都不影响 CSP-S 考重心 = =</p><p>原来的期望做法为 $O(n)$ 枚举边，$O(n)$ 求重心，总计 $O(n^2)$ 可拿到 $40 pts$，不过忘记了 $O(n)$ 求重心的做法，考场脑补了一会也只给出了 $O(n^2)$ 的做法，于是总计 $O(n^3)$ $25 pts$ 结 束 战 斗</p></li></ul><p>今年的 CSP-S 结束了，明天就要回班里补文化课了。估了一下分数, 可能算是省二左右的分数吧. 如果就此退役, 也没有什么不好. 或许是之前的想法太过于极端了, 偏执地认为不学 OI 就没有什么想要继续去做的事情了, 但是如果真的发生了, 还是会偏向默默接受的态度吧.</p><p>期望得分: $100 + 50 + 10 + 0 + 36 + 25 = 221 pts$</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>CCF 的官方成绩出来了, 比期望得分要高一些, 看教练那里的排名, 借着 HA 省是弱省的优势也能够拿到省一了.</p><p>实际得分: $100 + 50 + 10 + 8 + 36 + 40 = 244 pts$</p><p>Day2 T3 的 $O(n^3)$ 暴力似乎拿到了 $O(n^2)$ 的分数? 感谢 CCF 少爷机 (</p><p>今年的遗憾就是没能 CSP-S 没能上 $300 pts$ 了, Day 2 发挥的尤为不好, 坐在考场上没有蓄势待发, 激情四射的感觉, 从内心似乎有些颓势吧, 思维也不是相当的活跃. 之前总是有一种错觉, 偏执地认为自己是 “大赛型” 选手, 平常写不出来的题, 到考场上或许就能写出来了; 平时容易错的东西, 到考场上也许就可以不出锅了. 其实不是这样.</p><p>原来自己之前只是机械的找题, 写题, 学算法, 没有注重于自己独立思索的能力. 以后要多加注意了. </p><p>省选, 再会了.</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;公无渡河，公竟渡河！&lt;/p&gt;
&lt;p&gt;堕河而死，其奈公何！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;新的 OI 赛事又要开始了.&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://depletedprism.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>最小路径覆盖问题 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2764/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2764/</id>
    <published>2019-10-14T12:57:30.000Z</published>
    <updated>2019-10-14T13:08:42.678Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接：<a href="https://www.luogu.org/problem/P2764" target="_blank" rel="noopener">https://www.luogu.org/problem/P2764</a></li></ul><p>匈牙利算法就是好</p><a id="more"></a><p>尽管洛谷把网络构造方法给明了，但是拦不住我写匈牙利啊 = =</p><p>先不加证明地给出一个定理：</p><blockquote><p>有向无环图的最小路径点覆盖包含的路径条数 = 点数 - 其拆点二分图的最大匹配数。</p></blockquote><p>拆点二分图根据原图构造。</p><p>将原图的每个点 $i$，拆为 $i$，$i’$。对于原图的一条边 $(u,\ v)$，在二分图中连边 $(u,\ v’)$</p><p>输出方案则根据匹配边输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P2764</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span>&amp; <span class="title">x</span>) &#123;</span></span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f |= ch == <span class="string">'-'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">505</span>, MAXM = <span class="number">6005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> nxt, to;</span><br><span class="line">    &#125; edges[MAXM];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN &lt;&lt; <span class="number">1</span>], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head); eidx = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> KM &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">int</span> left[MAXN], T[MAXN], Time;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edges[i].to;</span><br><span class="line">            <span class="keyword">if</span> (T[v] == Time) <span class="keyword">continue</span>;</span><br><span class="line">            T[v] = Time;</span><br><span class="line">            <span class="keyword">if</span> (left[v] == <span class="number">-1</span> || match(left[v])) &#123;</span><br><span class="line">                left[v] = u; left[u] = v;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        u += n;</span><br><span class="line">        <span class="keyword">while</span> (~u) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, u - n);</span><br><span class="line">            T[u-n] = Time;</span><br><span class="line">            u = left[u-n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">km</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(left, <span class="number">-1</span>, <span class="keyword">sizeof</span> left);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            ++Time;</span><br><span class="line">            <span class="keyword">if</span> (match(i)) ++ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n); read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        read(u); read(v);</span><br><span class="line">        Graph::AddEdge(u, v+n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">int</span> ans = KM::km();</span><br><span class="line">    ++KM::Time;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (KM::T[i] != KM::Time) KM::print(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接：&lt;a href=&quot;https://www.luogu.org/problem/P2764&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.org/problem/P2764&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;匈牙利算法就是好&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>汽车加油行驶问题 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P4009/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P4009/</id>
    <published>2019-10-02T15:13:57.000Z</published>
    <updated>2019-10-02T15:38:50.730Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接：<a href="https://www.luogu.org/problem/P4009" target="_blank" rel="noopener">https://www.luogu.org/problem/P4009</a></li></ul><p>流量为 $1$ 的费用流没有必要跑费用流，跑最短路就好了</p><a id="more"></a><p>容易看出来是一道分层图最短路的题，但是以什么为根据分层就不是那么显然了</p><p>我开始想的是根据建造的油库分层，发现不大可做。正解则是根据剩余油量建图，此时建造油库就可以看作在一个非油库的地点花费一定费用加满油。</p><p>这里用 $k$ 表示剩余流量为 $k$，建图过程就成模拟过程了。</p><p>对于一个地点，考虑如下情况：</p><ul><li>存在油库，花费 $A$ 加满油，仅从满油状态向周围移动</li><li>不存在油库<ul><li>花费 $A+C$ 加满油</li><li>枚举剩余油量，向周围移动</li></ul></li></ul><p>还有一个问题，即建造出的油库第二次经过时，建造费用计算两次。但是我为什么要经过两次同一地点并都需要加油呢…</p><p>注意答案取终点时所有可能剩余油量的最小值，坑点为油库都是强买强卖的，经过就一定会加满油。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P4009</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span>&amp; <span class="title">x</span>) &#123;</span></span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f |= ch == <span class="string">'-'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">105</span>, MAXV = (<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">5</span>, MAXE = (<span class="keyword">int</span>)<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K, A, B, C;</span><br><span class="line"><span class="keyword">int</span> G[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, dist; &#125; edges[MAXE];</span><br><span class="line">    <span class="keyword">int</span> head[MAXV], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head); eidx = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dist)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, dist &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Dijkstra &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">int</span> d[MAXV];</span><br><span class="line">    <span class="keyword">bool</span> done[MAXV];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; PQ;</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">        <span class="built_in">memset</span>(done, <span class="literal">false</span>, <span class="keyword">sizeof</span> done);</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        PQ.push(make_pair(-d[s], s));</span><br><span class="line">        <span class="keyword">while</span> (!PQ.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = PQ.top().second; PQ.pop();</span><br><span class="line">            <span class="comment">// printf("%d\n", u);</span></span><br><span class="line">            <span class="keyword">if</span> (done[u]) <span class="keyword">continue</span>;</span><br><span class="line">            done[u] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = edges[i].to;</span><br><span class="line">                <span class="keyword">if</span> (d[v] &gt; d[u] + edges[i].dist)</span><br><span class="line">                    d[v] = d[u] + edges[i].dist, PQ.push(make_pair(-d[v], v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> n*n*type + (x<span class="number">-1</span>)*n + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n); read(K); read(A); read(B); read(C);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) read(G[i][j]);</span><br><span class="line">    <span class="comment">// build graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (G[i][j]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= K; ++k)</span><br><span class="line">                    Graph::AddEdge(idx(k, i, j), idx(K, i, j), A);</span><br><span class="line">                <span class="keyword">if</span> (i &lt; n) Graph::AddEdge(idx(K, i, j), idx(K<span class="number">-1</span>, i+<span class="number">1</span>, j), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (j &lt; n) Graph::AddEdge(idx(K, i, j), idx(K<span class="number">-1</span>, i, j+<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">1</span>) Graph::AddEdge(idx(K, i, j), idx(K<span class="number">-1</span>, i<span class="number">-1</span>, j), B);</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">1</span>) Graph::AddEdge(idx(K, i, j), idx(K<span class="number">-1</span>, i, j<span class="number">-1</span>), B);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= K; ++k)</span><br><span class="line">                    Graph::AddEdge(idx(k, i, j), idx(K, i, j), A+C);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= K; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; n) Graph::AddEdge(idx(k, i, j), idx(k<span class="number">-1</span>, i+<span class="number">1</span>, j), <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (j &lt; n) Graph::AddEdge(idx(k, i, j), idx(k<span class="number">-1</span>, i, j+<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">1</span>) Graph::AddEdge(idx(k, i, j), idx(k<span class="number">-1</span>, i<span class="number">-1</span>, j), B);</span><br><span class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">1</span>) Graph::AddEdge(idx(k, i, j), idx(k<span class="number">-1</span>, i, j<span class="number">-1</span>), B);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    Dijkstra::dijkstra(idx(K, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= K; ++k)</span><br><span class="line">        ans = min(ans, Dijkstra::d[idx(k, n, n)]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接：&lt;a href=&quot;https://www.luogu.org/problem/P4009&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.org/problem/P4009&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;流量为 $1$ 的费用流没有必要跑费用流，跑最短路就好了&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>餐巾计划问题 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P1251/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P1251/</id>
    <published>2019-10-02T14:17:25.000Z</published>
    <updated>2019-10-02T14:58:38.631Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接：<a href="https://www.luogu.org/problem/P1251" target="_blank" rel="noopener">https://www.luogu.org/problem/P1251</a></li></ul><p>上下界最小费用可行流，用了都说好</p><a id="more"></a><p>看到题目后想起来 <code>Rujia Liu</code> 蓝书网络流最后一道例题，不过那道题限制没有这道题多，仅用费用流就可以解决。两题相同的地方为：根据天数建图，并把天数拆点。</p><p>建图前先统一变量名，令 $p$ 是每块新餐巾的费用，$qd$ 是快洗部洗一块餐巾需用天数，$qc$ 是快洗部洗一块餐巾需要的费用，$sd$ 是慢洗部洗一块餐巾需用天数，$sc$ 是慢洗部洗一块餐巾需要的费用。</p><ul><li>建图流程<ul><li>新建附加源、汇点 $s, t$</li><li>对于一天 $i$，拆成 $i$，$i’$，意义为接受餐巾和转移餐巾，<del>或者可以理解为每天的早上和晚上</del></li><li>对于一天 $i$<ul><li>连边 $(s,i)$，容量 $[0,+\infty]$，费用为 $p$，表示购买餐巾</li><li>连边 $(i’, t)$，容量 $[0,+\infty]$，费用为 $0$，表示多余的餐巾可以一直搁着</li><li>连边 $(i, i’)$，容量限定为 $A_i$，即每天需用的餐巾数，费用为 $0$，表示需求</li><li>连边 $(i, i+1)$，容量 $[0,+\infty]$，费用为 $0$，表示今天用不完的餐巾可以明天用</li><li>在天数合法情况下，连边 $(i’, i+qd)$，容量 $[0,A_i]$，费用为 $qc$，表示今天用完的餐巾拿去快洗</li><li>在天数合法情况下，连边 $(i’, i+sd)$，容量 $[0,A_i]$，费用为 $sc$，表示今天用完的餐巾拿去慢洗</li></ul></li></ul></li></ul><p>之后就是套路式上下界了，详见 <a href="https://www.cnblogs.com/mlystdcall/p/6734852.html" target="_blank" rel="noopener">__stdcall 的【教程】上下界网络流建模方法总结</a>，以及膜 __stdcall Orz</p><p>关于坑点就是点数和边数要开够…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P1251</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span>&amp; <span class="title">x</span>) &#123;</span></span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f |= ch == <span class="string">'-'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2005</span>, MAXV = MAXN * <span class="number">2</span>, MAXE = MAXN * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, sd, qd, S, T;</span><br><span class="line">LL p, sc, qc;</span><br><span class="line"><span class="keyword">int</span> A[MAXN]; LL d[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; LL cap, flow, cost; &#125; edges[MAXE &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXV], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head); eidx = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, LL cap, LL cost)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, cap, <span class="number">0</span>, cost &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[to], from, <span class="number">0</span>, <span class="number">0</span>, -cost &#125;;</span><br><span class="line">        head[to] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, LL b, LL c, LL cost)</span> </span>&#123;</span><br><span class="line">        d[to] += b; d[from] -= b;</span><br><span class="line">        AddEdge(from, to, c-b, cost);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MCMF &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">bool</span> inq[MAXV];</span><br><span class="line">    LL d[MAXV], a[MAXV]; <span class="keyword">int</span> pre[MAXV];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(LL&amp; flow, LL&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">        <span class="built_in">memset</span>(inq, <span class="literal">false</span>, <span class="keyword">sizeof</span> inq);</span><br><span class="line">        Q.push(S);</span><br><span class="line">        inq[S] = <span class="literal">true</span>; d[S] = pre[S] = <span class="number">0</span>; a[S] = INF;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            inq[u] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">const</span> Edge&amp; e = edges[i];</span><br><span class="line">                <span class="keyword">if</span> (d[e.to] &gt; d[u] + e.cost &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                    a[e.to] = min(a[u], e.cap - e.flow);</span><br><span class="line">                    d[e.to] = d[u] + e.cost; pre[e.to] = i;</span><br><span class="line">                    <span class="keyword">if</span> (!inq[e.to]) inq[e.to] = <span class="literal">true</span>, Q.push(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d[T] == INF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        flow += a[T]; cost += a[T] * d[T];</span><br><span class="line">        <span class="keyword">int</span> u = T;</span><br><span class="line">        <span class="keyword">while</span> (u != S) &#123;</span><br><span class="line">            edges[pre[u]].flow += a[T];</span><br><span class="line">            edges[pre[u]^<span class="number">1</span>].flow -= a[T];</span><br><span class="line">            u = edges[pre[u]^<span class="number">1</span>].to;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">MCMF</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LL flow = <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (SPFA(flow, cost)) ;</span><br><span class="line">        <span class="keyword">return</span> cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]);</span><br><span class="line">    read(p); read(qd); read(qc); read(sd); read(sc);</span><br><span class="line">    <span class="comment">// build graph</span></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">2</span>*n+<span class="number">1</span>, t = <span class="number">2</span>*n+<span class="number">2</span>;</span><br><span class="line">    S = <span class="number">2</span>*n+<span class="number">3</span>; T = <span class="number">2</span>*n+<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        Graph::AddEdge(i, n+i, A[i], A[i], <span class="number">0</span>);</span><br><span class="line">        Graph::AddEdge(s, i, INF, p);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) Graph::AddEdge(i, i+<span class="number">1</span>, INF, <span class="number">0</span>);</span><br><span class="line">        Graph::AddEdge(n+i, t, INF, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i+qd &lt;= n) Graph::AddEdge(i+n, i+qd, <span class="number">0</span>, A[i], qc);</span><br><span class="line">        <span class="keyword">if</span> (i+sd &lt;= n) Graph::AddEdge(i+n, i+sd, <span class="number">0</span>, A[i], sc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    Graph::AddEdge(t, s, INF, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i] &gt; <span class="number">0</span>) Graph::AddEdge(S, i, d[i], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (d[i] &lt; <span class="number">0</span>) Graph::AddEdge(i, T, -d[i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, MCMF::MCMF());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接：&lt;a href=&quot;https://www.luogu.org/problem/P1251&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.org/problem/P1251&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上下界最小费用可行流，用了都说好&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>圆桌问题 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P3254/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P3254/</id>
    <published>2019-09-28T11:04:14.000Z</published>
    <updated>2019-09-28T11:16:08.035Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接：<a href="https://www.luogu.org/problem/P3254" target="_blank" rel="noopener">https://www.luogu.org/problem/P3254</a></li></ul><p><del>奇奇怪怪的贪心可以写的题</del></p><p>较为明显的二分图模型，带权匹配单位和餐桌，然后没了</p><a id="more"></a><ul><li>建图流程<ul><li>设源点 $S$，汇点 $T$</li><li>对于每个单位 $i$，连边 $(S, i)$，容量为代表数 $A_i$</li><li>对于每个餐桌 $j$，连边 $(j, T)$，容量为餐桌容量 $B_j$</li><li>对于每个单位 $i$，向每个餐桌 $j$ 连边 $(i, j)$，容量为 $1$，表示同一个单位来的代表不在同一个餐桌就餐</li></ul></li></ul><p>输出方案时遍历每个单位的出边，找到满流输出就好了</p><p>坑点：$A$，$B$ 范围不要写反，以及仅当最大流等于代表总数时才有解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3254</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span>&amp; <span class="title">x</span>) &#123;</span></span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f |= ch == <span class="string">'-'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">155</span>, MAXN = <span class="number">275</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = MAXN + MAXM, MAXE = MAXN * MAXM + MAXV;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, S, T;</span><br><span class="line"><span class="keyword">int</span> A[MAXM], B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, cap, flow; &#125; edges[MAXE &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXV], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head); eidx = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, cap, <span class="number">0</span> &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[to], from, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        head[to] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k, <span class="built_in">putchar</span>(<span class="string">'\n'</span>))</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[k]; ~i; i = edges[i].nxt)</span><br><span class="line">                <span class="keyword">if</span> (edges[i].cap &gt;= edges[i].flow &amp;&amp; edges[i].flow &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d "</span>, edges[i].to - m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Dinic &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXV];</span><br><span class="line">    <span class="keyword">int</span> cur[MAXV], depth[MAXV];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        Q.push(S);</span><br><span class="line">        depth[S] = <span class="number">0</span>; vis[S] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">const</span> Edge&amp; e = edges[i];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow)</span><br><span class="line">                    vis[e.to] = <span class="literal">true</span>, depth[e.to] = depth[u] + <span class="number">1</span>, Q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[T];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == T || !a) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> f, flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            Edge&amp; e = edges[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[e.to] == depth[u] + <span class="number">1</span> &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                flow += f; a -= f;</span><br><span class="line">                e.flow += f; edges[i^<span class="number">1</span>].flow -= f;</span><br><span class="line">                <span class="keyword">if</span> (!a) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span> cur);</span><br><span class="line">            flow += DFS(S, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    read(m); read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) read(A[i]), sum += A[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) read(B[j]);</span><br><span class="line">    <span class="comment">// build graph</span></span><br><span class="line">    S = <span class="number">0</span>; T = n+m+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        Graph::AddEdge(S, i, A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        Graph::AddEdge(j+m, T, B[j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            Graph::AddEdge(i, j+m, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">int</span> flow = Dinic::Maxflow();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, flow == sum? <span class="number">1</span>: <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 当 flow == sum 才有解</span></span><br><span class="line">    <span class="keyword">if</span> (flow == sum) Graph::solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接：&lt;a href=&quot;https://www.luogu.org/problem/P3254&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.org/problem/P3254&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;del&gt;奇奇怪怪的贪心可以写的题&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;较为明显的二分图模型，带权匹配单位和餐桌，然后没了&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>方格取数问题 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2774/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2774/</id>
    <published>2019-09-28T10:11:13.000Z</published>
    <updated>2019-09-28T11:18:10.609Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接：<a href="https://www.luogu.org/problem/P2774" target="_blank" rel="noopener">https://www.luogu.org/problem/P2774</a></li></ul><p>满足没有公共边的网格图可以看作二分图，也就是“黑白相间”</p><a id="more"></a><p>如果正向考虑，每个方格要向非四联通的方格连边，边数较多。不如反向考虑，假设选择所有的方格，减去为满足条件剔除的方格。如果让这个答案最大，就需要让挑出的方格权值和最小。</p><p>又由最小联想到最小割，可以通过最大流求出，于是</p><ul><li>建图流程<ul><li>设源点 $S$，$T$</li><li>对于每个白方格 $i$，连边 $(S, i)$，容量为权值 $A_i$，并向四周连边，容量为 INF</li><li>对于每个黑方格 $i$，连边 $(T, i)$，容量为权值 $A_i$</li></ul></li></ul><p>$S$，$T$ 不联通之日，必是满足题目限制之时 <del>(大雾</del></p><p>这题就做完了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P2774</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span>&amp; <span class="title">x</span>) &#123;</span></span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f |= ch == <span class="string">'-'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">105</span>, MAXV = MAXN * MAXN, MAXE = MAXN * MAXN * <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, dy[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, S, T;</span><br><span class="line"><span class="keyword">int</span> A[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, cap, flow; &#125; edges[MAXE &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXV], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head); eidx = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, cap, <span class="number">0</span> &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[to], from, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        head[to] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Dinic &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXV];</span><br><span class="line">    <span class="keyword">int</span> depth[MAXV], cur[MAXV];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        Q.push(S);</span><br><span class="line">        depth[S] = <span class="number">0</span>; vis[S] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">const</span> Edge&amp; e = edges[i];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow)</span><br><span class="line">                    vis[e.to] = <span class="literal">true</span>, depth[e.to] = depth[u] + <span class="number">1</span>, Q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[T];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == T || !a) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> f, flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            Edge&amp; e = edges[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[e.to] == depth[u] + <span class="number">1</span> &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                flow += f; a -= f;</span><br><span class="line">                e.flow += f; edges[i^<span class="number">1</span>].flow -= f;</span><br><span class="line">                <span class="keyword">if</span> (!a) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span> cur);</span><br><span class="line">            flow += DFS(S, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> m * (i<span class="number">-1</span>) + j; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    read(n); read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) read(A[i][j]), sum += A[i][j];</span><br><span class="line">    <span class="comment">// build graph</span></span><br><span class="line">    S = <span class="number">0</span>; T = idx(n, m) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i + j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                Graph::AddEdge(S, idx(i, j), A[i][j]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + dx[k], y = j + dy[k];</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; n || y &lt; <span class="number">1</span> || y &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">                    Graph::AddEdge(idx(i, j), idx(x, y), INF);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Graph::AddEdge(idx(i, j), T, A[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum - Dinic::Maxflow());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接：&lt;a href=&quot;https://www.luogu.org/problem/P2774&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.org/problem/P2774&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;满足没有公共边的网格图可以看作二分图，也就是“黑白相间”&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>最长不下降子序列问题 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2766/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2766/</id>
    <published>2019-09-28T08:52:34.000Z</published>
    <updated>2019-09-28T11:23:13.713Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接：<a href="https://www.luogu.org/problem/P2766" target="_blank" rel="noopener">https://www.luogu.org/problem/P2766</a></li></ul><p>不看题解死都想不出来祭</p><a id="more"></a><p>对于第一问，考虑 DP 求解，不过不同于 $O(n \log n)$  的做法，我们使用 $O(n^2)$ 的做法，以方便维护更多的信息。</p><p>设 $dp[i]$ 为序列 $\text{1~i}$ 的最长不下降子序列长度，显然有转移</p><p>$$dp[i] = \max \{ \ dp[j] + 1 \}$$ </p><p>其中 $A_j \leq A_i,\ j &lt; i$，初始状态有 $dp[i] = 1$，最长长度 $\text{MaxL}$ 为 $\max_{i=1}^{n} dp[i]$</p><p>对于第二三问，考虑网络流求解。</p><p>怎么把序列个数同网络流联系起来呢？我们可以考虑一种方法，使得到汇点的每一份流量，对应一种序列的构造方案。这样询问个数就可以转化为最大流问题了。</p><ul><li>第二问建图流程<ul><li>设源点 $S$，$T$</li><li>对于一个子序列，一个数显然只能统计一次，所以考虑拆点，将位置 $i$ 拆为 $i$，$i’$，连边 $(i, i’)$，容量为 $1$</li><li>对于一个位置 $i$，若<ul><li>$dp[i] = 1$，连边 $(S, i)$，容量为 $1$</li><li>$dp[i] = \text{MaxL}$，连边 $(i’,T)$，容量为 $1$</li></ul></li><li>类似 DP 的过程，对于位置 $i$，若有 $j &lt; i,\ A_i \geq A_j$ 且 $dp[i] = dp[j] + 1$，连边 $(j’,i)$，容量为 $1$</li></ul></li></ul><p>对于到 $T$ 的流量，满足 DP 的条件，也就是一种合法方案，即该网络最大流为第二问答案</p><p>对于第三问，改变 $A_1$，$A_n$ 的流量限制，即</p><ul><li>连边 $(1,1’)$，$(S,1)$，容量为 INF</li><li>若第 $n$ 位有 $dp[n] = \text{MaxL}$，连边 $(n,n’)$，$(n’,T)$，容量为 INF</li></ul><p>在原基础上求流量增加量，加上第二问答案即可</p><p>坑点有第三问连接 $n$ 和 $T$ 时，一定存在条件 $dp[n] = \text{MaxL}$，总之我被坑了 = =</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P2766</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span>&amp; <span class="title">x</span>) &#123;</span></span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f |= ch == <span class="string">'-'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">505</span>, MAXV = MAXN &lt;&lt; <span class="number">1</span>, MAXE = MAXV &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, S, T;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, cap, flow; &#125; edges[MAXE &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXV], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head); eidx = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, cap, <span class="number">0</span> &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[to], from, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        head[to] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Dinic &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXV];</span><br><span class="line">    <span class="keyword">int</span> depth[MAXV], cur[MAXV];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        Q.push(S);</span><br><span class="line">        depth[S] = <span class="number">0</span>; vis[S] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">const</span> Edge&amp; e = edges[i];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow)</span><br><span class="line">                    vis[e.to] = <span class="literal">true</span>, depth[e.to] = depth[u] + <span class="number">1</span>, Q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[T];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == T || !a) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> f, flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            Edge&amp; e = edges[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[e.to] == depth[u] + <span class="number">1</span> &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                flow += f; a -= f;</span><br><span class="line">                e.flow += f; edges[i^<span class="number">1</span>].flow -= f;</span><br><span class="line">                <span class="keyword">if</span> (!a) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span> cur);</span><br><span class="line">            flow += DFS(S, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="keyword">int</span> MaxL = <span class="number">0</span>;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="comment">// dp</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt;= A[j]) dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        MaxL = max(MaxL, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Q1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, MaxL);</span><br><span class="line">    <span class="comment">// build graph for Q2</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    S = <span class="number">0</span>; T = <span class="number">2</span>*n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == <span class="number">1</span>) Graph::AddEdge(S, i, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == MaxL) Graph::AddEdge(i+n, T, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        Graph::AddEdge(i, i+n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt;= A[j] &amp;&amp; dp[i] == dp[j] + <span class="number">1</span>)</span><br><span class="line">                Graph::AddEdge(j+n, i, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// Q2</span></span><br><span class="line">    <span class="keyword">int</span> flow = Dinic::Maxflow();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, flow);</span><br><span class="line">    <span class="comment">// extra edges for Q3</span></span><br><span class="line">    Graph::AddEdge(<span class="number">1</span>, <span class="number">1</span>+n, INF); Graph::AddEdge(S, <span class="number">1</span>, INF);</span><br><span class="line">    <span class="keyword">if</span> (dp[n] == MaxL) Graph::AddEdge(n, n+n, INF), Graph::AddEdge(n+n, T, INF);</span><br><span class="line">    <span class="comment">// Q3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, flow + Dinic::Maxflow());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接：&lt;a href=&quot;https://www.luogu.org/problem/P2766&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.org/problem/P2766&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不看题解死都想不出来祭&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>魔术球问题 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2765/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2765/</id>
    <published>2019-09-28T04:40:58.000Z</published>
    <updated>2019-09-28T09:05:37.552Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接：<a href="https://www.luogu.org/problem/P2765" target="_blank" rel="noopener">https://www.luogu.org/problem/P2765</a></li></ul><p><del>似乎可以用奇奇怪怪的贪心来写</del></p><p>可以发现，球放在哪里和柱子是没有关系的，对于一个编号为 <code>now</code> 的球，如果现有柱子上的球不能满足组成完全平方数的条件，就新建一个柱子存放 <code>now</code>，否则就放在可以存在的位置上。由贪心的思想，得到的结果一定是最优的。</p><a id="more"></a><p>那么，怎么用网络流的模型来实现呢？</p><p>考虑每个球只能使用一次，容易想到拆点，在代码中体现为 <code>now --&gt; 2*now, 2*now + 1</code>，这样对于拆出的两点，编号 /2 就是原编号，输出方案时比较方便。</p><ul><li>建图流程<ul><li>设源点 $S$，汇点 $T$</li><li>将球 $A$ 拆为 $A’$，$A’’$，连边 $(S, A’)$，$(A’’,T)$，容量为 $1$</li><li>对于球 $A$，$B$，若有编号之和为完全平方数的情况，连边 $(B’,A’’)$，容量为 $1$</li></ul></li></ul><p>若加入一个球后新增流量大于 $0$，则说明该球可以放在已经存在的柱子上，否则新建柱子存放。</p><p>如果新建柱子数超过 $n$，此时能放的球数达到最大。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu P2765</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">65</span>, MAXV = (<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">5</span>, MAXE = (<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, S, T;</span><br><span class="line"><span class="keyword">bool</span> done[MAXV];</span><br><span class="line"><span class="keyword">int</span> List[MAXN], pre[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, cap, flow; &#125; edges[MAXE &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXV], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head); eidx = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, cap, <span class="number">0</span> &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[to], from, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        head[to] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Dinic &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXV];</span><br><span class="line">    <span class="keyword">int</span> depth[MAXV], cur[MAXV];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        Q.push(S);</span><br><span class="line">        depth[S] = <span class="number">0</span>; vis[S] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">const</span> Edge&amp; e = edges[i];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow)</span><br><span class="line">                    vis[e.to] = <span class="literal">true</span>, depth[e.to] = depth[u] + <span class="number">1</span>, Q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[T];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == T || !a) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> f, flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            Edge&amp; e = edges[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[e.to] == depth[u] + <span class="number">1</span> &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                flow += f; a -= f;</span><br><span class="line">                e.flow += f; edges[i^<span class="number">1</span>].flow -= f;</span><br><span class="line">                <span class="keyword">if</span> (e.to != T) pre[u/<span class="number">2</span>] = e.to/<span class="number">2</span>;</span><br><span class="line">                <span class="comment">// 某个球放在哪里，只和前一个球的编号相关</span></span><br><span class="line">                <span class="keyword">if</span> (!a) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span> cur);</span><br><span class="line">            flow += DFS(S, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="comment">// build graph</span></span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>, cntP = <span class="number">0</span>;</span><br><span class="line">    S = <span class="number">0</span>; T = MAXV - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cntP &lt;= n) &#123;</span><br><span class="line">        ++now;</span><br><span class="line">        Graph::AddEdge(S, now*<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        Graph::AddEdge(now*<span class="number">2</span>+<span class="number">1</span>, T, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 向源点与汇点连边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">sqrt</span>(now) + <span class="number">1</span>; i*i &lt; now*<span class="number">2</span>; ++i)</span><br><span class="line">            Graph::AddEdge((i*i-now)*<span class="number">2</span>, now*<span class="number">2</span>+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 枚举构成完全平方数的情况</span></span><br><span class="line">        <span class="keyword">int</span> flow = Dinic::Maxflow();</span><br><span class="line">        <span class="keyword">if</span> (!flow) List[++cntP] = now;</span><br><span class="line">        <span class="comment">// 新建一个柱子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, now - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i, <span class="built_in">putchar</span>(<span class="string">'\n'</span>)) <span class="keyword">if</span> (!done[List[i]])</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = List[i]; u; u = pre[u])</span><br><span class="line">            <span class="keyword">if</span> (!done[u]) &#123; done[u] = <span class="literal">true</span>, <span class="built_in">printf</span>(<span class="string">"%d "</span>, u); &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接：&lt;a href=&quot;https://www.luogu.org/problem/P2765&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.org/problem/P2765&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;del&gt;似乎可以用奇奇怪怪的贪心来写&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;可以发现，球放在哪里和柱子是没有关系的，对于一个编号为 &lt;code&gt;now&lt;/code&gt; 的球，如果现有柱子上的球不能满足组成完全平方数的条件，就新建一个柱子存放 &lt;code&gt;now&lt;/code&gt;，否则就放在可以存在的位置上。由贪心的思想，得到的结果一定是最优的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>试题库问题 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2763/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2763/</id>
    <published>2019-09-26T23:59:57.000Z</published>
    <updated>2019-09-28T05:34:30.052Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接：<a href="https://www.luogu.org/problem/P2763" target="_blank" rel="noopener">https://www.luogu.org/problem/P2763</a></li></ul><p>较为明显的二分图模型，依照题意对试题和类型匹配</p><ul><li>建图流程<ul><li>设源点 $S$，汇点 $T$</li><li>对于每个类型 $i$，连边 $(S, i)$，容量为 $V_i$</li><li>对于每道试题 $j$，连边 $(j, T)$，容量为 $1$，表示每道试题仅能使用一次</li><li>对于类型 $i$ 拥有的试题 $j$，连边 $(i,j)$，容量为 $1$</li></ul></li></ul><p>无解的情况就是无法选择足够的试题，体现在网络流中为最大流不足 $\sum_{i=1}^{k}V_i$</p><p>输出方案时，遍历每个类型到试题的边，如果流量为 $1$ 就是该类型中挑选的试题</p><p>坑点有给定类型需要题目数量为 $0$，把我第一次写的输出方案的方法 Hack 了…</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P2763</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span>&amp; <span class="title">x</span>) &#123;</span></span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f |= ch == <span class="string">'-'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">25</span>, MAXN = <span class="number">1005</span>, MAXV = MAXK + MAXN, MAXE = MAXV + MAXN * MAXK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k, n, S, T;</span><br><span class="line"><span class="keyword">int</span> V[MAXK];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A[MAXK];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, cap, flow; &#125; edges[MAXE &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXV], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head); eidx = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, cap, <span class="number">0</span> &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[to], from, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        head[to] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 输出方案我写丑了 = =</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j, <span class="built_in">putchar</span>(<span class="string">'\n'</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="built_in">printf</span>(<span class="string">"%d:"</span>, j);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[j]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">const</span> Edge&amp; e = edges[i]; <span class="keyword">int</span> v = e.to - k;</span><br><span class="line">                <span class="keyword">if</span> (cnt &lt; V[j] &amp;&amp; <span class="number">1</span> &lt;= v &amp;&amp; v &lt;= n &amp;&amp; !vis[v] &amp;&amp; e.cap &gt;= e.flow)</span><br><span class="line">                    vis[v] = <span class="literal">true</span>, <span class="built_in">printf</span>(<span class="string">" %d"</span>, v), ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Dinic &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXV];</span><br><span class="line">    <span class="keyword">int</span> depth[MAXV], cur[MAXV];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        Q.push(S);</span><br><span class="line">        depth[S] = <span class="number">0</span>; vis[S] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">const</span> Edge&amp; e = edges[i];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow)</span><br><span class="line">                    vis[e.to] = <span class="literal">true</span>, depth[e.to] = depth[u] + <span class="number">1</span>, Q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[T];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == T || !a) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> f, flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            Edge&amp; e = edges[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[e.to] == depth[u] + <span class="number">1</span> &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                flow += f; a -= f;</span><br><span class="line">                e.flow += f; edges[i^<span class="number">1</span>].flow -= f;</span><br><span class="line">                <span class="keyword">if</span> (!a) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span> cur);</span><br><span class="line">            flow += DFS(S, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    read(k); read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) read(V[i]), sum += V[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, tmp; read(x);</span><br><span class="line">        <span class="keyword">while</span> (x--) &#123; read(tmp); A[tmp].push_back(j); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// build graph</span></span><br><span class="line">    S = <span class="number">0</span>; T = n+k+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">        <span class="keyword">if</span> (V[i]) Graph::AddEdge(S, i, V[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        Graph::AddEdge(j+k, T, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; A[i].size(); ++j)</span><br><span class="line">            Graph::AddEdge(i, A[i][j]+k, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">bool</span> flag = Dinic::Maxflow() == sum;</span><br><span class="line">    <span class="keyword">if</span> (flag) Graph::print();</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No Solution!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接：&lt;a href=&quot;https://www.luogu.org/problem/P2763&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.org/problem/P2763&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;较为明显的二分图模型，依照题意对试题和类型匹配&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建图流程&lt;ul&gt;
&lt;li&gt;设源点 $S$，汇点 $T$&lt;/li&gt;
&lt;li&gt;对于每个类型 $i$，连边 $(S, i)$，容量为 $V_i$&lt;/li&gt;
&lt;li&gt;对于每道试题 $j$，连边 $(j, T)$，容量为 $1$，表示每道试题仅能使用一次&lt;/li&gt;
&lt;li&gt;对于类型 $i$ 拥有的试题 $j$，连边 $(i,j)$，容量为 $1$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无解的情况就是无法选择足够的试题，体现在网络流中为最大流不足 $\sum_{i=1}^{k}V_i$&lt;/p&gt;
&lt;p&gt;输出方案时，遍历每个类型到试题的边，如果流量为 $1$ 就是该类型中挑选的试题&lt;/p&gt;
&lt;p&gt;坑点有给定类型需要题目数量为 $0$，把我第一次写的输出方案的方法 Hack 了…&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>飞行员配对方案问题 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2756/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2756/</id>
    <published>2019-09-26T23:50:40.000Z</published>
    <updated>2019-09-28T08:50:46.842Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接：<a href="https://www.luogu.org/problem/P2756" target="_blank" rel="noopener">https://www.luogu.org/problem/P2756</a></li></ul><p>较为明显的二分图模型，最佳飞行员配对方案为二分图最大匹配，将英国飞行员视为左部点，外籍飞行员是为右部点，大力匹配就好了</p><p>使用匈牙利输出方案会简单一点吧，对于每条匹配边，用<code>left[i]</code> 记录，如果不等于 $-1$，即匹配上，直接输出就好了</p><a id="more"></a><p><del>网络流题显然不能用网络流写啊</del></p><p><del>没有 <code>namespace</code> 的早期码风</del></p><p>现在重写了，改到了时间戳写法，有些情况下可以快很多，抛弃 <code>memset</code> 后状态大多跑不满，但带上 <code>memset</code> 后…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P2756</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span>&amp; <span class="title">x</span>) &#123;</span></span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f |= ch == <span class="string">'-'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">205</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, from, to; &#125; edges[MAXN * MAXN];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head); eidx = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge) &#123; head[from], from, to &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Hungarian &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">int</span> left[MAXN], check[MAXN], Time;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edges[i].to;</span><br><span class="line">            <span class="keyword">if</span> (check[v] != Time) &#123;</span><br><span class="line">                check[v] = Time;</span><br><span class="line">                <span class="keyword">if</span> (left[v] == <span class="number">-1</span> || match(left[v])) &#123;</span><br><span class="line">                    left[v] = u;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(left, <span class="number">-1</span>, <span class="keyword">sizeof</span> left);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            ++Time;</span><br><span class="line">            <span class="keyword">if</span> (match(i)) ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m+<span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span> (left[i] != <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, left[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    Graph::init();</span><br><span class="line">    read(m); read(n);</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">while</span> (read(u), read(v), ~u) Graph::AddEdge(u, v);</span><br><span class="line">    Hungarian::solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接：&lt;a href=&quot;https://www.luogu.org/problem/P2756&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.org/problem/P2756&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;较为明显的二分图模型，最佳飞行员配对方案为二分图最大匹配，将英国飞行员视为左部点，外籍飞行员是为右部点，大力匹配就好了&lt;/p&gt;
&lt;p&gt;使用匈牙利输出方案会简单一点吧，对于每条匹配边，用&lt;code&gt;left[i]&lt;/code&gt; 记录，如果不等于 $-1$，即匹配上，直接输出就好了&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>「CTSC1999」家园 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2754/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2754/</id>
    <published>2019-09-26T23:27:30.000Z</published>
    <updated>2019-09-28T11:19:29.593Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接：<a href="https://www.luogu.org/problem/P2754" target="_blank" rel="noopener">https://www.luogu.org/problem/P2754</a></li></ul><p><del>详见蓝书第五章之网络流例题部分</del></p><p>先考虑无解的情况，即无论如何地球和月球的不连通的，而关于联通性可以用并查集维护，如果将所有路线分别用并查集合并后，地球和月球仍不联通，那么就无解了</p><p>在有解的情况下，显然有运输时间越长，所有人就越可能转移到月球，因此可以二分。但每次二分都要重新建图，那我们可以随时间推进，将现有的图按时间分层，每次引入新的一层点，并在原有基础上求最大流，直到流量大于等于 $k$ 时退出。</p><a id="more"></a><ul><li><p>建图流程</p><ul><li><p>设地球为 $S$，第 $day$ 天的月球为  $T$</p></li><li><p>对于每天的路线，连接 $(day-1) \times n + u$，$day\times n + v$，流量为太空船容量</p></li><li>对于每天每个太空站 $i$，连接 $(day-1) \times n + i$，$day\times n + i$，表示停留在太空站 $i$</li></ul></li></ul><p>注意代码中有 <code>n += 2</code> 地球编号为 $1$，空间站编号为 $1\text{~}n-1$，月球编号为 $n$</p><p>第一次写并查集判断无解情况时，<code>findfa(1) == findfa(n)</code> 写成 <code>fa[1] == fa[n]</code>…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P2754</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span>&amp; <span class="title">x</span>) &#123;</span></span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f |= ch == <span class="string">'-'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">15</span>, MAXM = <span class="number">25</span>, MAXK = <span class="number">55</span>, MAXV = (<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">5</span>, MAXE = (<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, S, T;</span><br><span class="line"><span class="keyword">int</span> H[MAXM];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Trip[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, cap, flow; &#125; edges[MAXE &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXV], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head); eidx = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, cap, <span class="number">0</span> &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[to], from, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        head[to] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Dinic &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXV];</span><br><span class="line">    <span class="keyword">int</span> depth[MAXV], cur[MAXV];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        Q.push(S);</span><br><span class="line">        depth[S] = <span class="number">0</span>; vis[S] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">const</span> Edge&amp; e = edges[i];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow)</span><br><span class="line">                    vis[e.to] = <span class="literal">true</span>, depth[e.to] = depth[u] + <span class="number">1</span>, Q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[T];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == T || !a) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> f, flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            Edge&amp; e = edges[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[e.to] == depth[u] + <span class="number">1</span> &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                flow += f; a -= f;</span><br><span class="line">                e.flow += f; edges[i^<span class="number">1</span>].flow -= f;</span><br><span class="line">                <span class="keyword">if</span> (!a) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span> cur);</span><br><span class="line">            flow += DFS(S, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DSU &#123;</span><br><span class="line">    <span class="keyword">int</span> fa[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fa[x] = (fa[x] == x? x: findfa(fa[x]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = findfa(x); y = findfa(y);</span><br><span class="line">        <span class="keyword">if</span> (x != y) fa[y] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> k = <span class="number">1</span>; k &lt; Trip[i].size(); ++k)</span><br><span class="line">                join(Trip[i][k<span class="number">-1</span>], Trip[i][k]);</span><br><span class="line">        <span class="keyword">return</span> findfa(<span class="number">1</span>) == findfa(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n); read(m); read(k); n += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x, tmp, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        read(H[i]); read(x);</span><br><span class="line">        <span class="keyword">while</span> (x--) &#123; read(tmp); <span class="keyword">if</span> (++tmp == <span class="number">0</span>) tmp = n; Trip[i].push_back(tmp); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!DSU::solve()) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> day = <span class="number">1</span>, flow = <span class="number">0</span>; S = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            Graph::AddEdge(i + (day<span class="number">-1</span>)*n, i + day*n, INF);</span><br><span class="line">        <span class="comment">// 一直待在空间站的合法操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = Trip[i].size();</span><br><span class="line">            <span class="keyword">int</span> from = Trip[i][(day<span class="number">-1</span>)%size], to = Trip[i][day%size];</span><br><span class="line">            <span class="comment">// printf("day %d: %d u: %d v: %d\n", day, i, from, to);</span></span><br><span class="line">            Graph::AddEdge(from + (day<span class="number">-1</span>)*n, to + day*n, H[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        T = day*n + n;</span><br><span class="line">        <span class="comment">// T 为第 day 天的月球</span></span><br><span class="line">        flow += Dinic::Maxflow();</span><br><span class="line">        <span class="keyword">if</span> (flow &gt;= k) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// if (day &gt;= 10) break;</span></span><br><span class="line">        ++day;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, day);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接：&lt;a href=&quot;https://www.luogu.org/problem/P2754&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.org/problem/P2754&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;del&gt;详见蓝书第五章之网络流例题部分&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;先考虑无解的情况，即无论如何地球和月球的不连通的，而关于联通性可以用并查集维护，如果将所有路线分别用并查集合并后，地球和月球仍不联通，那么就无解了&lt;/p&gt;
&lt;p&gt;在有解的情况下，显然有运输时间越长，所有人就越可能转移到月球，因此可以二分。但每次二分都要重新建图，那我们可以随时间推进，将现有的图按时间分层，每次引入新的一层点，并在原有基础上求最大流，直到流量大于等于 $k$ 时退出。&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
  </entry>
  
</feed>
