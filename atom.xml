<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DepletedPrism&#39;s Blog</title>
  
  <subtitle>知其然而不知其所以然是可悲的.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://depletedprism.github.io/"/>
  <updated>2020-04-12T11:42:25.622Z</updated>
  <id>https://depletedprism.github.io/</id>
  
  <author>
    <name>DepletedPrism</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「置顶」算法教程合辑</title>
    <link href="https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/compilation/"/>
    <id>https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/compilation/</id>
    <published>9102-11-14T00:11:23.000Z</published>
    <updated>2020-04-12T11:42:25.622Z</updated>
    
    <content type="html"><![CDATA[<hr><p>这个 idea 来源于 <a href="https://www.cnblogs.com/mlystdcall/p/8078467.html" target="_blank" rel="noopener">__stdcall 的教程合辑</a>, 觉得这个很好, 所以学习了.</p><a id="more"></a><p><del>Hexo 博客的强制置顶</del></p><h4 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h4><ul><li><p>树状数组进阶</p><ul><li><a href="https://www.cnblogs.com/RabbitHu/p/BIT.html" target="_blank" rel="noopener">https://www.cnblogs.com/RabbitHu/p/BIT.html</a></li></ul></li></ul><h4 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h4><ul><li><p>网络流入门</p><ul><li><a href="https://www.xht37.com/二分图与网络流-学习笔记/" target="_blank" rel="noopener">https://www.xht37.com/二分图与网络流-学习笔记/</a></li></ul></li><li><p>上下界网络流</p><ul><li><a href="https://www.cnblogs.com/mlystdcall/p/6734852.html" target="_blank" rel="noopener">https://www.cnblogs.com/mlystdcall/p/6734852.html</a></li></ul></li><li><p>基于 Capacity Scaling 的弱多项式复杂度最小费用流算法</p><ul><li><a href="https://ouuan.github.io/post/%E5%9F%BA%E4%BA%8E-capacity-scaling-%E7%9A%84%E5%BC%B1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%B5%81%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">https://ouuan.github.io/post/基于-capacity-scaling-的弱多项式复杂度最小费用流算法</a></li></ul></li></ul><h4 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h4><ul><li><p>基础构造</p><ul><li><a href="https://oi.men.ci/linear-basis-notes/" target="_blank" rel="noopener">https://oi.men.ci/linear-basis-notes/</a></li></ul></li><li><p>可重集 Kth 异或和</p><ul><li><a href="https://blog.csdn.net/qaq__qaq/article/details/53812883" target="_blank" rel="noopener">https://blog.csdn.net/qaq__qaq/article/details/53812883</a></li><li><a href="https://ouuan.github.io/post/%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">https://ouuan.github.io/post/线性基学习笔记/</a></li></ul></li></ul><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul><li><p>四边形不等式优化</p><ul><li><a href="https://oi-wiki.org/dp/opt/quadrangle/" target="_blank" rel="noopener">https://oi-wiki.org/dp/opt/quadrangle/</a></li></ul></li></ul><h4 id="Link-Cut-Tree"><a href="#Link-Cut-Tree" class="headerlink" title="Link Cut Tree"></a>Link Cut Tree</h4><ul><li><p>应用 &amp; 题单</p><ul><li><a href="https://www.cnblogs.com/flashhu/p/9498517.html" target="_blank" rel="noopener">https://www.cnblogs.com/flashhu/p/9498517.html</a></li></ul></li></ul><h4 id="左偏树"><a href="#左偏树" class="headerlink" title="左偏树"></a>左偏树</h4><ul><li><p>特点及应用</p><ul><li><a href="https://files-cdn.cnblogs.com/files/shenben/算法合集之《左偏树的特点及其应用》.pdf" target="_blank" rel="noopener">https://files-cdn.cnblogs.com/files/shenben/算法合集之《左偏树的特点及其应用》.pdf</a></li></ul></li></ul><h4 id="Min-Max-容斥"><a href="#Min-Max-容斥" class="headerlink" title="Min-Max 容斥"></a>Min-Max 容斥</h4><ul><li><p>证明及应用</p><ul><li><a href="https://www.cnblogs.com/GXZlegend/p/11563330.html" target="_blank" rel="noopener">https://www.cnblogs.com/GXZlegend/p/11563330.html</a></li></ul></li></ul><h4 id="Stirling-数及-Stirling-反演"><a href="#Stirling-数及-Stirling-反演" class="headerlink" title="Stirling 数及 Stirling 反演"></a>Stirling 数及 Stirling 反演</h4><ul><li><p>性质及应用</p><ul><li><a href="https://www.cnblogs.com/y2823774827y/p/10700231.html" target="_blank" rel="noopener">https://www.cnblogs.com/y2823774827y/p/10700231.html</a></li></ul></li></ul><h4 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h4><ul><li><p>证明及应用</p><ul><li><a href="https://www.cnblogs.com/GXZlegend/p/11407185.html" target="_blank" rel="noopener">https://www.cnblogs.com/GXZlegend/p/11407185.html</a></li></ul></li></ul><h4 id="类欧几里得算法"><a href="#类欧几里得算法" class="headerlink" title="类欧几里得算法"></a>类欧几里得算法</h4><ul><li><p>推导及模板</p><ul><li><a href="https://oi-wiki.org/math/euclidean/" target="_blank" rel="noopener">https://oi-wiki.org/math/euclidean/</a></li></ul></li></ul><h4 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h4><ul><li><p>生成函数的运算和常见模型</p><ul><li>金策, &lt;生成函数的运算与组合计数问题&gt;. 国家集训队 2015 论文集.</li></ul></li><li><p>图的计数</p><ul><li>汪乐平, &lt;生成函数, 多项式算法与图的计数&gt;. 2019.1.28.</li></ul></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;这个 idea 来源于 &lt;a href=&quot;https://www.cnblogs.com/mlystdcall/p/8078467.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;__stdcall 的教程合辑&lt;/a&gt;, 觉得这个很好, 所以学习了.&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://depletedprism.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>「置顶」HAOI 2020 退役记</title>
    <link href="https://depletedprism.github.io/%E9%9A%8F%E7%AC%94/HAOI-2020/"/>
    <id>https://depletedprism.github.io/%E9%9A%8F%E7%AC%94/HAOI-2020/</id>
    <published>4096-03-27T16:21:14.000Z</published>
    <updated>2020-04-15T04:31:02.368Z</updated>
    
    <content type="html"><![CDATA[<hr><div style="text-align:center;"><img src="/images/HAOI-2020/=.png"> </div><p><em><p style="text-align:center;">图源网络, 进行了简单修改</p></em></p><p>省选未能如期举办, 我的青春结束了.</p><a id="more"></a><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;div style=&quot;text-align:center;&quot;&gt;&lt;img src=&quot;/images/HAOI-2020/=.png&quot;&gt; &lt;/div&gt;

&lt;p&gt;&lt;em&gt;&lt;p style=&quot;text-align:center;&quot;&gt;图源网络, 进行了简单修改&lt;/p&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;省选未能如期举办, 我的青春结束了.&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://depletedprism.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>「UNR #3」百鸽笼 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/uoj-390/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/uoj-390/</id>
    <published>2020-05-25T12:24:28.000Z</published>
    <updated>2020-05-25T23:41:38.158Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://uoj.ac/problem/390" target="_blank" rel="noopener">https://uoj.ac/problem/390</a></li></ul><p>这是一道鸽子题.</p><a id="more"></a><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>每次鸽子回到鸽笼时会影响概率大小, 即令 $a_i$ 减 $1$ 时会影响鸽笼总数. 但根据 <a href="https://loj.ac/problem/2541" target="_blank" rel="noopener">「PKUWC2018」猎人杀</a> 的结论, 认为每次选择鸽笼时, 若有 $a_i &gt; 0$, 则直接令 $a_i$ 减 $1$; 否则再次选择.</p><p>也就是说, 可以认为已经满的鸽笼列仍可入住鸽子, 但对 $a_i$ 没有影响. 此时计算出的结果和原来限制下的结果相同.</p><p>此时将鸽子的入住顺序用一长度为 $m$ 的有标号序列描述, 序列中第 $i$ 个元素表示第 $i$ 次选择, 某只鸽子入住鸽笼的列编号. 容易发现 $m \ge N$, 因为可以重复入住, 但每只鸽子都要回到鸽笼.</p><p>不妨假设当前空出的鸽笼在第 $1$ 列, 那么序列中一定存在 <strong>恰好</strong> $a_1 - 1$ 个 $1$, 同时对于其余每个元素 $i$, <strong>至少</strong> 出现 $a_i$ 次. 类似于<a href="https://uoj.ac/problem/449" target="_blank" rel="noopener">【集训队作业2018】喂鸽子</a> 的思路, 可得出该序列个数的 EGF $F(x)$ 为</p><script type="math/tex; mode=display">F(x) = \frac{x ^ {a_1 - 1}}{(a_1 - 1) !} \cdot \prod_{i \neq 1} \left(e ^ x - \sum_{k = 0} ^ {a_i - 1} \frac{x ^ k}{k!}\right)</script><p>那么计算出所有合法序列的数量, 并将最后结果除以序列个数的总数就能够得出空出鸽笼在第 $1$ 列的答案. 同时, 对每个元素做一次类似的操作即可计算最终结果.</p><p>但是 $e ^ x$ 展开后有无穷项系数, 不便于计算. 此时有一个思路 (from <a href="https://yhx-12243.github.io/OI-transit/records/uoj390.html" target="_blank" rel="noopener">yhx-12243</a>), 将 $F(x)$ 视为 $x$ 和 $e ^ x$ 的二元生成函数, 那么有</p><script type="math/tex; mode=display">F(x, y) = \frac{x ^ {a_1 - 1}}{(a_1 - 1) !} \cdot \prod_{i \neq 1} \left(y - \sum_{k = 0} ^ {a_i - 1} \frac{x ^ k}{k!} \right),\; y = e ^ x</script><p>对于其中一项 $y ^ i x ^ j = e ^ {ix} x ^ j$, 其对答案的另有除其系数以外的贡献. 取 $e ^ x$ 第 $s$ 项, 则</p><script type="math/tex; mode=display">[x ^ s] e ^ {ix} \cdot x ^ j = \frac{(ix) ^ s}{s!} x ^ j = \frac{i ^ s}{s!}\ x ^ {j + s}</script><p>此时 $F(x, y)$ 各项只同 $x$ 有关. 假定 $s + j = m$, 那么 $F(x, y)$ 第 $m$ 项对答案的贡献为</p><script type="math/tex; mode=display">\frac{m!}{n ^ {m + 1} } \cdot \frac{i ^ s}{s!} = \frac{(s + j)!}{n ^ {s + j + 1} } \cdot \frac{i ^ s}{s!}</script><p>其中 $n ^ {m + 1}$ 长度为 $m$ 的序列总个数. 考虑到 $a_1$ 个鸽笼中必须剩下一个不选, 且该限制不好直接计算. 那么在计算序列总数时直接将 $a_1$ 添加到序列中, 那么每次选择都有 $n$ 种可能, 因此总数为 $n ^ {m + 1}$.</p><p>实际计算时, 我们需要求得每一项的结果的和. 即</p><script type="math/tex; mode=display">\sum_{s = 0} ^ \infty \frac{(s + j)!}{n ^ {s + j + 1} } \cdot \frac{i ^ s}{s!} = \frac{j!}{n ^ {j + 1} } \cdot \sum_{s = 0} ^ \infty \binom{s + j}{s} \left( \frac{i}{n} \right) ^ s 1 ^ {j + 1}</script><p>根据广义二项式定理, 原式可化为</p><script type="math/tex; mode=display">\frac{j!}{n ^ {j + 1} } \left( \frac{1}{1 - \frac{i}{n}} \right) ^ {j + 1} = \frac{j!}{(n - i) ^ {j + 1} }</script><p>只需枚举 $i$, $j$ 即可, 实际计算时还需乘上对应项系数, 同时要考虑 $\frac{x ^ {a_1 - 1} }{(a_1 - 1)!}$ 的影响.</p><p>对于每一种空出鸽笼的位置, 重新计算 $F(x)$ 的时间复杂度过高. 因此可直接计算</p><script type="math/tex; mode=display">\prod_{i = 1} ^ n \left(e ^ x - \sum_{k = 0} ^ {a_i - 1} \frac{x ^ k}{k!}\right)</script><p>每次在原有基础上除 $e ^ x - \sum\limits_{k = 0} ^ {a_i - 1} \dfrac{x ^ k}{k!}$ 即可. 具体实现时将乘法 “倒过来写” 就好了.</p><p>时间复杂度为 $O\big(n ^ 2 \left( \sum a_i\right) \cdot \max \{ a_i \}\big)$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UOJ #390</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e1</span> + <span class="number">5</span>, MAXM = MAXN * MAXN, P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fac[MAXM], ifac[MAXM], inv[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % P;</span><br><span class="line">    base = <span class="number">1L</span>L * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PolyPre</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">  inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">    inv[i] = <span class="number">1L</span>L * inv[P % i] * (P - P / i) % P;</span><br><span class="line">  ifac[<span class="number">0</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    fac[i] = <span class="number">1L</span>L * fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">    ifac[i] = <span class="number">1L</span>L * ifac[i - <span class="number">1</span>] * inv[i] % P;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pls</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">const</span> LL&amp; b)</span> </span>&#123; <span class="keyword">return</span> a = (a + b) % P; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mns</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">const</span> LL&amp; b)</span> </span>&#123; <span class="keyword">return</span> a = (a - b + P) % P; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], h[<span class="number">2</span>][MAXN][MAXM], g[MAXN][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, A + i);</span><br><span class="line">  PolyPre(MAXM - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> cur = <span class="number">1</span>, df = <span class="number">0</span>;</span><br><span class="line">  h[cur][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(h[cur ^ <span class="number">1</span>], <span class="number">0</span>, <span class="keyword">sizeof</span> h[cur ^ <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= df; ++k) <span class="keyword">if</span> (h[cur][j][k] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        pls(h[cur ^ <span class="number">1</span>][j + <span class="number">1</span>][k], h[cur][j][k]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= A[i + <span class="number">1</span>] - <span class="number">1</span>; ++l)</span><br><span class="line">          mns(h[cur ^ <span class="number">1</span>][j][k + l], <span class="number">1L</span>L * ifac[l] * h[cur][j][k] % P);</span><br><span class="line">      &#125;</span><br><span class="line">    cur ^= <span class="number">1</span>, df += A[i + <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> (*f)[MAXM] = h[cur];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt;= n; ++m) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= df - A[m] + <span class="number">1</span>; ++k) &#123;</span><br><span class="line">        pls(g[j][k], f[j + <span class="number">1</span>][k]);</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || g[j][k] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= A[m] - <span class="number">1</span>; ++l)</span><br><span class="line">          pls(g[j - <span class="number">1</span>][k + l], <span class="number">1L</span>L * ifac[l] * g[j][k] % P);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> j = A[m] - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= df - A[m] + <span class="number">1</span>; ++k, ++j) <span class="keyword">if</span> (g[i][k] &gt; <span class="number">0</span>)</span><br><span class="line">        pls(ans, <span class="number">1L</span>L * fac[j] * g[i][k] % P * fpow(inv[n - i], j + <span class="number">1</span>) % P);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="number">1L</span>L * ans * ifac[A[m] - <span class="number">1</span>] % P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, ans, <span class="string">" \n"</span>[m == n]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>我承认我不可能写地比参考资料好 (</p><ul><li><a href="https://wuhongxun.blog.uoj.ac/blog/3679" target="_blank" rel="noopener">UOJ NOI Round #3 Day2 题解</a></li><li>yhx-12243, <a href="https://yhx-12243.github.io/OI-transit/records/uoj390.html" target="_blank" rel="noopener">UOJ #390 百鸽笼 题解</a></li><li>lyd729, <a href="https://blog.csdn.net/lyd_7_29/java/article/details/83787557" target="_blank" rel="noopener">【UOJ #390】【UNR #3】百鸽笼</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h4 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://uoj.ac/problem/390&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://uoj.ac/problem/390&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是一道鸽子题.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Combinatorics" scheme="https://depletedprism.github.io/tags/Combinatorics/"/>
    
      <category term="Probability &amp; Mean" scheme="https://depletedprism.github.io/tags/Probability-Mean/"/>
    
  </entry>
  
  <entry>
    <title>「PKUWC2018」猎人杀 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/loj-2541/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/loj-2541/</id>
    <published>2020-05-25T05:15:02.000Z</published>
    <updated>2020-05-25T12:23:59.582Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2541" target="_blank" rel="noopener">https://loj.ac/problem/2541</a></li></ul><p>这是一道经常被拿出来四处安利的题 (</p><a id="more"></a><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>对于某一个时刻, 记 $f_i$ 为第 $i$ 个猎人当前没有死亡, 且在下一次开枪后死亡的概率. 同时, 记 $m$ 为所有猎人 $w_i$ 之和, $d$ 为已死亡猎人之和. 则有</p><script type="math/tex; mode=display">f_i = \frac{w_i}{m - d}</script><p>容易得到</p><script type="math/tex; mode=display">f_i = \frac{w_i}{m} + \frac{d}{m} f_i</script><p>考虑这个式子的实际意义. 即如果向已死亡的猎人射击, 等同于再次射击… 也就是在一猎人死亡后, 仍可认为其能被作为射击目标. 在该意义下计算并不会影响 $f_i$ 的值.</p><p>现在要解决的问题即为, 求恰好 $0$ 人在 $1$ 死亡之后死亡概率. 考虑容斥, 枚举在 $1$ 死亡后存活的猎人集合 $S$, 同时记 $s$ 为集合 $S$ 中的猎人 $w_i$ 之和. 可以得到答案为</p><script type="math/tex; mode=display">\sum_{S} (-1) ^ {|S|} \sum_{t = 0} ^ \infty (1 - \frac{s + w_1}{m}) ^ t \cdot \frac{w_1}{m} = \sum_{S} (-1) ^ {|S|} \frac{w_1}{s + w_1}</script><p>笼统解释一下, 集合 $S$ 中猎人要能在 $1$ 之后存活, 其划分界限一定为 $1$ 死亡的时刻, 并在该时刻前 $S$ 和 $1$ 都不能死亡. 后者利用广义二项式定理即可得出.</p><p>显然枚举集合是不科学的. 注意到 $\sum w_i$ 的值不大, 求出每一个 $s$ 对应的集合容斥系数之和即可. 其生成函数为</p><script type="math/tex; mode=display">F(x) = \prod_{i = 2} ^ n \left(1 - x ^ {w_i} \right)</script><p>分治 FFT 计算即可. 最终的答案为</p><script type="math/tex; mode=display">\sum_{s \ge 0} [x ^ s] F(x) \cdot \frac{w_1}{s + w_1}</script><p>记 $m = \sum\limits_{i = 1} ^ n w_i$, 则时间复杂度为 $O(m \log ^ 2 m)$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>用 <code>vector</code> 代替数组写多项式果然快乐 (</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2541</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LOG = <span class="number">18</span>, MAXN = <span class="number">1</span> &lt;&lt; LOG | <span class="number">1</span>, P = <span class="number">998244353</span>, G = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> W[LOG][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % P;</span><br><span class="line">    base = <span class="number">1L</span>L * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">  <span class="keyword">int</span> r[MAXN];</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>, Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>, ++k) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span>* w = W[k];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j) &#123;</span><br><span class="line">          <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1L</span>L * w[j] * f[i+j+Mid] % P;</span><br><span class="line">          f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> iv = fpow(Lim, P - <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * iv % P;</span><br><span class="line">      reverse(f + <span class="number">1</span>, f + Lim);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PolyPre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> w, i = <span class="number">0</span>, Mid = <span class="number">1</span>; i &lt; LOG; ++i, Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    W[i][<span class="number">0</span>] = <span class="number">1</span>, w = fpow(G, (P - <span class="number">1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; Mid; ++j)</span><br><span class="line">      W[i][j] = <span class="number">1L</span>L * w * W[i][j - <span class="number">1</span>] % P;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; poly;</span><br><span class="line"></span><br><span class="line">poly <span class="keyword">operator</span> * (<span class="keyword">const</span> poly&amp; f, <span class="keyword">const</span> poly&amp; g) &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">  <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (Lim &lt; <span class="keyword">int</span>(f.size() + g.size())) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) &#123;</span><br><span class="line">    A[i] = (i &lt; (<span class="keyword">int</span>) f.size())? f[i]: <span class="number">0</span>;</span><br><span class="line">    B[i] = (i &lt; (<span class="keyword">int</span>) g.size())? g[i]: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Poly::init(Lim, L), Poly::NTT(A, Lim, <span class="number">1</span>), Poly::NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = <span class="number">1L</span>L * A[i] * B[i] % P;</span><br><span class="line">  Poly::NTT(A, Lim, <span class="number">-1</span>);</span><br><span class="line">  <span class="function">poly <span class="title">h</span><span class="params">(f.size() + g.size() - <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; h.size(); ++i) h[i] = A[i];</span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> w[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function">poly <span class="title">solve</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">    <span class="function">poly <span class="title">g</span><span class="params">(w[L] + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> g[<span class="number">0</span>] = <span class="number">1</span>, g[w[L]] = P - <span class="number">1</span>, g;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> solve(L, Mid) * solve(Mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, w + i);</span><br><span class="line"></span><br><span class="line">  PolyPre();</span><br><span class="line">  poly f = solve(<span class="number">2</span>, n);</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) f.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> iv = fpow((i + w[<span class="number">1</span>]) % P, P - <span class="number">2</span>);</span><br><span class="line">    ans = (ans + <span class="number">1L</span>L * w[<span class="number">1</span>] * f[i] % P * iv % P) % P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>danihao123, <a href="https://yahyachan.github.io/2018/08/09/loj2541/" target="_blank" rel="noopener">LibreOJ 2541 「PKUWC2018」猎人杀</a></li><li>zjp-shadow, <a href="https://www.cnblogs.com/zjp-shadow/p/9097283.html" target="_blank" rel="noopener">LOJ #2541. 「PKUWC 2018」猎人杀(容斥, 期望dp, NTT优化)</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h4 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://loj.ac/problem/2541&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://loj.ac/problem/2541&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是一道经常被拿出来四处安利的题 (&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Polynomial" scheme="https://depletedprism.github.io/tags/Polynomial/"/>
    
      <category term="Probability &amp; Mean" scheme="https://depletedprism.github.io/tags/Probability-Mean/"/>
    
  </entry>
  
  <entry>
    <title>容斥原理 备忘录</title>
    <link href="https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/inclusion-exclusion/"/>
    <id>https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/inclusion-exclusion/</id>
    <published>2020-05-20T01:29:31.000Z</published>
    <updated>2020-05-23T02:53:15.610Z</updated>
    
    <content type="html"><![CDATA[<hr><p>记录以备忘.</p><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>虽然是很基础的东西, 但是不妨回头再看它一眼.</p><p>又因为本文定位于备忘, 所有不会有关于任何公式的证明, <del>其实就是公式的罗列</del>…</p><p>如果真的对证明感兴趣, 不妨去文末的参看资料看看.</p><a id="more"></a><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>设全集 $U$ 中有 $n$ 中不同条件 $P_{i\ldots n}$, 记 $A_i$ 为满足条件 $P_i$ 元素的集合.</p><h3 id="由集合的交计算集合的并"><a href="#由集合的交计算集合的并" class="headerlink" title="由集合的交计算集合的并"></a>由集合的交计算集合的并</h3><script type="math/tex; mode=display">| \bigcup_{i = 1} ^ n A_i | = \sum_{k = 1} ^ n (-1) ^ {k - 1} \sum_{1 \le i_1,\ \cdots,\ i_k \le n} | \bigcap_{j = 1} ^ k A_{i_j} |</script><h3 id="由补集的并计算集合的交"><a href="#由补集的并计算集合的交" class="headerlink" title="由补集的并计算集合的交"></a>由补集的并计算集合的交</h3><script type="math/tex; mode=display">|\bigcap_{i = 1} ^ n A_i| = |U| - |\bigcup_{i = 1} ^ n \bar A_i|</script><p>直接将之前的式子带入, 则有</p><script type="math/tex; mode=display">|\bigcap_{i = 1} ^ n A_i| = |U| - \sum_{k = 1} ^ n (-1) ^ {k - 1} \sum_{1 \le i_1,\ \cdots,\ i_k \le n} | \bigcap_{j = 1} ^ k \bar A_{i_j} |</script><p>进一步可以得到</p><script type="math/tex; mode=display">|\bigcap_{i = 1} ^ n A_i| = \sum_{k = 0} ^ n (-1) ^ k \sum_{1 \le i_1,\ \cdots,\ i_k \le n} |\bigcap_{j = 1} ^ k \bar A_{i_j}|</script><p>至于其他情况, 可用摩根定律进行转化.</p><p>很多时候集合中元素具体是什么不会影响结果, 此时枚举集合大小同时乘一个组合数作为系数就可以得出一些式子.</p><h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><h3 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h3><script type="math/tex; mode=display">g(n) = \sum_{k = n} ^ m \binom{k}{n} f(k) \Leftrightarrow f(n) = \sum_{k = n} ^ m (-1) ^ {k - n} \binom{k}{n} g(n)</script><p>虽然本质是容斥原理, 但是在实际中可能 (?) 会更好用一点.</p><p>此时的 $f(n)$, $g(n)$ 有组合意义, 例如 $f(n)$ 表示在总共 $m$ 个物品中, 恰好选择 $n$ 个满足某个条件元素的方案数, $g(n)$ 表示钦定 $n$ 个满足某个条件元素的方案数.</p><h3 id="子集反演"><a href="#子集反演" class="headerlink" title="子集反演"></a>子集反演</h3><p>记 $f(S)$, $g(S)$ 为两个关于集合 $S$ 的函数, 那么有</p><script type="math/tex; mode=display">f(S) = \sum_{T \subseteq S} g(T) \Leftrightarrow g(S) = \sum_{T \subseteq S} (-1) ^ {|S| - |T|} f(T)</script><p>类似地, 有</p><script type="math/tex; mode=display">f(S) = \sum_{S \subseteq T} g(T) \Leftrightarrow g(S) = \sum_{S \subseteq T} (-1) ^ {|T| - |S|} f(T)</script><h3 id="Min-Max-容斥"><a href="#Min-Max-容斥" class="headerlink" title="Min-Max 容斥"></a>Min-Max 容斥</h3><p>对于一个集合 $S$, 记 $\max\{S\}$ 为集合 $S$ 中最大值, $\min\{S\}$ 为集合 $S$ 中最小值, 那么有</p><script type="math/tex; mode=display">\max\{ S \} = \sum_{T \neq \varnothing,\ T \subseteq S} (-1) ^ {|T| - 1} \min\{ T \}</script><p>同时可以推广到第 $k$ 大值. 记 $\operatorname{kmax}\{S\}$ 为集合 $S$ 中的第 $k$ 大值, 那么有</p><script type="math/tex; mode=display">\operatorname{kmax}\{ S \} = \sum_{|T| \ge k,\ T \subseteq S} (-1) ^ {|T| - k} \binom{|T| - 1}{k - 1} \min\{T\}</script><p>同时由期望的线性性可以得到</p><script type="math/tex; mode=display">E(\max\{S\}) = \sum_{T \neq \varnothing,\ T \subseteq S} (-1) ^ {|T| - 1} E(\min\{T\})</script><p>一个常见的问题为, 询问一个集合中所有元素都出现的期望时间. 此时就可以套用该公式, 从而转为计算子集中元素第一次出现的期望时间.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>Richard A. Brualdi. 组合数学. 机械工业出版社, 2012.4.</li><li>OI Wiki, 容斥原理, <a href="https://oi-wiki.org/math/inclusion-exclusion-principle/" target="_blank" rel="noopener">https://oi-wiki.org/math/inclusion-exclusion-principle/</a></li><li>GXZlegend, 二项式反演及其应用, <a href="https://www.cnblogs.com/GXZlegend/p/11407185.html" target="_blank" rel="noopener">https://www.cnblogs.com/GXZlegend/p/11407185.html</a></li><li>vfleaking, 炫酷反演魔术, <a href="http://vfleaking.blog.uoj.ac/blog/87" target="_blank" rel="noopener">http://vfleaking.blog.uoj.ac/blog/87</a></li><li>GXZlegend, Min-Max容斥及其推广和应用, <a href="https://www.cnblogs.com/GXZlegend/p/11563330.html" target="_blank" rel="noopener">https://www.cnblogs.com/GXZlegend/p/11563330.html</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;记录以备忘.&lt;/p&gt;
&lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;虽然是很基础的东西, 但是不妨回头再看它一眼.&lt;/p&gt;
&lt;p&gt;又因为本文定位于备忘, 所有不会有关于任何公式的证明, &lt;del&gt;其实就是公式的罗列&lt;/del&gt;…&lt;/p&gt;
&lt;p&gt;如果真的对证明感兴趣, 不妨去文末的参看资料看看.&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://depletedprism.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Combinatorics" scheme="https://depletedprism.github.io/tags/Combinatorics/"/>
    
  </entry>
  
  <entry>
    <title>TJOI 2019 简要题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/TJOI-2019-sol/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/TJOI-2019-sol/</id>
    <published>2020-05-18T12:59:43.000Z</published>
    <updated>2020-05-23T06:59:52.439Z</updated>
    
    <content type="html"><![CDATA[<hr><p><del>我没有在刷水题 (确信</del></p><p>打 扰 了.</p><a id="more"></a><h3 id="「TJOI2019」甲苯先生的字符串"><a href="#「TJOI2019」甲苯先生的字符串" class="headerlink" title="「TJOI2019」甲苯先生的字符串"></a>「TJOI2019」甲苯先生的字符串</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3104" target="_blank" rel="noopener">https://loj.ac/problem/3104</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>很套路的矩阵乘法 = =</p><p>设 $f(i, c)$ 表示当前计算到 $s_2$ 中第 $i$ 位, 且第 $i$ 位字符为 $c$. 容易发现转移和 $i$ 无关, 构造矩阵加速转移即可.</p><p>时间复杂度 $O(|s_1| + \log n)$, 同时带有矩阵乘法的常数 ($26 \times 26$).</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3104</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>, MAXM = <span class="number">26</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> g[MAXM][MAXM];</span><br><span class="line">  Matrix() &#123; <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g); &#125;</span><br><span class="line">  Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    Matrix ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXM; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; MAXM; ++k) <span class="keyword">if</span> (g[i][k] != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; MAXM; ++j) <span class="keyword">if</span> (rhs.g[k][j] != <span class="number">0</span>)</span><br><span class="line">          ret.g[i][j] = (ret.g[i][j] + <span class="number">1L</span>L * g[i][k] * rhs.g[k][j] % P) % P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXM; ++i) g[i][i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">fpow</span><span class="params">(Matrix base, LL b)</span> </span>&#123;</span><br><span class="line">  Matrix ret; ret.init();</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * base;</span><br><span class="line">    base = base * base, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m; LL n;</span><br><span class="line"><span class="keyword">char</span> S[MAXN];</span><br><span class="line"></span><br><span class="line">Matrix f, g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld%s"</span>, &amp;n, S + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  m = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(S + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXM; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; MAXM; ++j) f.g[i][j] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> c1 = S[i] - <span class="string">'a'</span>, c2 = S[i + <span class="number">1</span>] - <span class="string">'a'</span>;</span><br><span class="line">    f.g[c1][c2] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  g = fpow(f, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXM; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; MAXM; ++j) ans = (ans + g.g[i][j]) % P;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「TJOI2019」甲苯先生的滚榜"><a href="#「TJOI2019」甲苯先生的滚榜" class="headerlink" title="「TJOI2019」甲苯先生的滚榜"></a>「TJOI2019」甲苯先生的滚榜</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3105" target="_blank" rel="noopener">https://loj.ac/problem/3105</a></li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>这是一道平衡树模板题.</p><p>唯一需要注意的地方是, 该题中排名指所有元素中, 严格大于某元素的个数. 同常见的 “求 <code>rank</code>“ 有些许不同.</p><p>时间复杂度 $O\big(T (n + m) \log m\big)$.</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3105</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1.5e6</span> + <span class="number">5</span>, MAXM = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">randNum</span><span class="params">(<span class="keyword">unsigned</span>&amp; seed, <span class="keyword">unsigned</span> lst, <span class="keyword">const</span> <span class="keyword">int</span>&amp; m)</span></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> seed = seed * <span class="number">17</span> + lst, seed % m + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> c, p;</span><br><span class="line">  Item() &#123; c = p = <span class="number">0</span>; &#125;</span><br><span class="line">  Item(<span class="keyword">int</span> _c, <span class="keyword">int</span> _p): c(_c), p(_p) &#123; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; rhs.c || (c == rhs.c &amp;&amp; p &gt; rhs.p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; rhs) &amp;&amp; !(rhs &lt; *<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; A[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, root; <span class="keyword">unsigned</span> seed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Splay &#123;</span><br><span class="line">  Item val[MAXN];</span><br><span class="line">  <span class="keyword">int</span> ch[<span class="number">2</span>][MAXN], pre[MAXN], size[MAXN], cnt[MAXN], nidx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">const</span> Item&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nd = ++nidx;</span><br><span class="line">    ch[<span class="number">0</span>][nd] = ch[<span class="number">1</span>][nd] = pre[nd] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> val[nd] = v, size[nd] = cnt[nd] = <span class="number">1</span>, nd;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; nd)</span> </span>&#123;</span><br><span class="line">    size[nd] = cnt[nd];</span><br><span class="line">    <span class="keyword">if</span> (ch[<span class="number">0</span>][nd]) size[nd] += size[ch[<span class="number">0</span>][nd]];</span><br><span class="line">    <span class="keyword">if</span> (ch[<span class="number">1</span>][nd]) size[nd] += size[ch[<span class="number">1</span>][nd]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">which</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123; <span class="keyword">return</span> pre[u]? ch[<span class="number">1</span>][pre[u]] == u: <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">const</span> <span class="keyword">int</span>&amp; w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u) pre[u] = fa;</span><br><span class="line">    <span class="keyword">if</span> (fa) ch[w][fa] = u; <span class="keyword">else</span> root = u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = pre[u], w = which(u);</span><br><span class="line">    connect(u, pre[fa], which(fa));</span><br><span class="line">    connect(ch[w ^ <span class="number">1</span>][u], fa, w), connect(fa, u, w ^ <span class="number">1</span>);</span><br><span class="line">    maintain(fa);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    v = pre[v];</span><br><span class="line">    <span class="keyword">while</span> (pre[u] != v) &#123;</span><br><span class="line">      <span class="keyword">int</span> fa = pre[u];</span><br><span class="line">      <span class="keyword">if</span> (pre[fa] != v) which(u) == which(fa)? rotate(fa): rotate(u);</span><br><span class="line">      rotate(u);</span><br><span class="line">    &#125;</span><br><span class="line">    maintain(u);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">const</span> Item&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="keyword">void</span>( root = newnode(v) );</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nd = root; nd; nd = ch[val[nd] &lt; v][nd]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val[nd] == v) <span class="keyword">return</span> ++cnt[nd], splay(nd, root);</span><br><span class="line">      <span class="keyword">if</span> (!ch[val[nd] &lt; v][nd]) &#123;</span><br><span class="line">        ch[val[nd] &lt; v][nd] = newnode(v);</span><br><span class="line">        <span class="keyword">return</span> pre[nidx] = nd, splay(nidx, root);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Fnd</span><span class="params">(<span class="keyword">const</span> Item&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nd = root; nd; nd = ch[val[nd] &lt; v][nd])</span><br><span class="line">      <span class="keyword">if</span> (val[nd] == v) <span class="keyword">return</span> splay(nd, root);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Rmv</span><span class="params">(<span class="keyword">const</span> Item&amp; v)</span> </span>&#123;</span><br><span class="line">    Fnd(v);</span><br><span class="line">    <span class="keyword">if</span> (cnt[root] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">void</span>( --cnt[root] );</span><br><span class="line">    <span class="keyword">if</span> (!ch[<span class="number">0</span>][root] &amp;&amp; !ch[<span class="number">1</span>][root])</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">void</span>( root = <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span> (!ch[<span class="number">0</span>][root] || !ch[<span class="number">1</span>][root]) &#123;</span><br><span class="line">      <span class="keyword">int</span> w = !ch[<span class="number">0</span>][root];</span><br><span class="line">      <span class="keyword">return</span> root = ch[w][root], <span class="keyword">void</span>( pre[root] = <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nd = ch[<span class="number">0</span>][root];</span><br><span class="line">    <span class="keyword">while</span> (ch[<span class="number">1</span>][nd] &gt; <span class="number">0</span>) nd = ch[<span class="number">1</span>][nd];</span><br><span class="line">    splay(nd, ch[<span class="number">0</span>][root]);</span><br><span class="line">    ch[<span class="number">1</span>][nd] = ch[<span class="number">1</span>][root], pre[nd] = <span class="number">0</span>, root = pre[ch[<span class="number">1</span>][nd]] = nd;</span><br><span class="line">    maintain(nd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Rnk</span><span class="params">(<span class="keyword">const</span> Item&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Ins(v), size[ch[<span class="number">1</span>][root]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> Ti, lstans = <span class="number">7</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Ti);</span><br><span class="line">  <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%u"</span>, &amp;m, &amp;n, &amp;seed);</span><br><span class="line"></span><br><span class="line">    Splay::nidx = root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">      A[i] = Item(<span class="number">0</span>, <span class="number">0</span>), Splay::Ins(A[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x, y; n; --n) &#123;</span><br><span class="line">      x = randNum(seed, lstans, m), y = randNum(seed, lstans, m);</span><br><span class="line">      Splay::Rmv(A[x]), ++A[x].c, A[x].p += y;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lstans = Splay::Rnk(A[x]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「TJOI2019」唱、跳、rap-和篮球"><a href="#「TJOI2019」唱、跳、rap-和篮球" class="headerlink" title="「TJOI2019」唱、跳、rap 和篮球"></a>「TJOI2019」唱、跳、rap 和篮球</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3106" target="_blank" rel="noopener">https://loj.ac/problem/3106</a></li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>我们可用容斥原理计算讨论 [数据删除] 的队伍数.</p><p>记 $A_i$ 表示满足队伍中存在 $i$ 组讨论 [数据删除] 的集合, 最多情况下讨论 [数据删除] 的组数为 $m = \min \{ a, b, c, d, \lfloor \frac{n}{4} \rfloor \}$. 那么所有 $A_i$ 的补集交即为所求. 根据容斥原理可得</p><script type="math/tex; mode=display">|\bigcap_{i = 1} ^ m \bar A_i| = \sum_{k = 0} ^ m (-1) ^ k \sum_{1 \le i_1,\ \cdots,\ i_k \le n} |\bigcap_{j = 1} ^ k A_{i_j}|</script><p>队伍中每组讨论各在那个位置并不重要, 因此可枚举讨论组数 $k$, 得</p><script type="math/tex; mode=display">\sum_{k = 0} ^ m (-1) ^ k \binom{n - 3k}{k}\ g(n - 4k, a - k, b - k, c - k, d - k)</script><p>系数 $\binom{n - 3k}{k}$ 表示在队伍中选出 $k$ 组讨论的方案数. 可将每组讨论看作一个人, 那么队伍中人数为 $n - 3k$, 从中选择 $k$ 人作为讨论, 从而得到. </p><p>同时, $g(n, a, b, c, d)$ 表示剩余学生的排列数, 也就是可重集合的排列数. 即</p><script type="math/tex; mode=display">g(n, a, b, c, d) = \sum_{x_1 + x_2 + x_3 + x_4 = n} \binom{n}{x_1\; x_2\; x_3\; x_4} = n! \cdot \sum_{x_1 + x_2 + x_3 + x_4 = n} \frac{1}{x_1!\ x_2!\ x_3!\ x_4!}</script><p>其中 $x_1,\ x_2,\ x_3,\ x_4$ 满足 $x_1 \le a,\ x_2 \le b,\ x_3 \le c,\ x_4 \le d$.</p><p>显然是卷积的形式, 利用 NTT 计算 $g$ 即可.</p><p>时间复杂度 $O(n ^ 2 \log n)$. 似乎存在更加优秀的做法?</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3106</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LOG = <span class="number">13</span>, MAXN = <span class="number">1</span> &lt;&lt; LOG | <span class="number">1</span>, P = <span class="number">998244353</span>, G = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> W[LOG][MAXN];</span><br><span class="line"><span class="keyword">int</span> fac[MAXN], ifac[MAXN], inv[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">binom</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (n &lt; m)? <span class="number">0</span>: <span class="number">1L</span>L * fac[n] * ifac[m] % P * ifac[n - m] % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % P;</span><br><span class="line">    base = <span class="number">1L</span>L * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">  <span class="keyword">int</span> r[MAXN];</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>, Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>, ++k) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span>* w = W[k];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j) &#123;</span><br><span class="line">          <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1L</span>L * w[j] * f[i+j+Mid] % P;</span><br><span class="line">          f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> inv = fpow(Lim, P - <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * inv % P;</span><br><span class="line">      reverse(f + <span class="number">1</span>, f + Lim);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PolyPre</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">  inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">    inv[i] = <span class="number">1L</span>L * inv[P % i] * (P - P / i) % P;</span><br><span class="line">  fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    fac[i] = <span class="number">1L</span>L * i * fac[i - <span class="number">1</span>] % P;</span><br><span class="line">    ifac[i] = <span class="number">1L</span>L * inv[i] * ifac[i - <span class="number">1</span>] % P;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> w, i = <span class="number">0</span>, Mid = <span class="number">1</span>; i &lt; LOG; ++i, Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    W[i][<span class="number">0</span>] = <span class="number">1</span>, w = fpow(G, (P - <span class="number">1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; Mid; ++j)</span><br><span class="line">      W[i][j] = <span class="number">1L</span>L * w * W[i][j - <span class="number">1</span>] % P;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN], C[MAXN], D[MAXN], f[MAXN];</span><br><span class="line">  <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (Lim &lt;= <span class="number">2</span> * (a + b + c + d)) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">  Poly::init(Lim, L);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) &#123;</span><br><span class="line">    A[i] = (i &lt;= a)? ifac[i]: <span class="number">0</span>, B[i] = (i &lt;= b)? ifac[i]: <span class="number">0</span>;</span><br><span class="line">    C[i] = (i &lt;= c)? ifac[i]: <span class="number">0</span>, D[i] = (i &lt;= d)? ifac[i]: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Poly::NTT(A, Lim, <span class="number">1</span>), Poly::NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">  Poly::NTT(C, Lim, <span class="number">1</span>), Poly::NTT(D, Lim, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i)</span><br><span class="line">    f[i] = <span class="number">1L</span>L * A[i] * B[i] % P * C[i] % P * D[i] % P;</span><br><span class="line">  Poly::NTT(f, Lim, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1L</span>L * f[n] * fac[n] % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a, b, c, d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;n, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (a + b + c + d &lt; n)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span>;</span><br><span class="line">  PolyPre(<span class="number">2</span> * n);</span><br><span class="line">  <span class="keyword">int</span> N = min(min(a, min(b, min(c, d))), n / <span class="number">4</span>), ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> s = g(n - <span class="number">4</span> * i, a - i, b - i, c - i, d - i) % P;</span><br><span class="line">    ans = (ans + <span class="number">1L</span>L * binom(n - <span class="number">3</span> * i, i) * ((i &amp; <span class="number">1</span>)? P - s: s) % P) % P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「TJOI2019」大中锋的游乐场"><a href="#「TJOI2019」大中锋的游乐场" class="headerlink" title="「TJOI2019」大中锋的游乐场"></a>「TJOI2019」大中锋的游乐场</h3><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3107" target="_blank" rel="noopener">https://loj.ac/problem/3107</a></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>注意到 $k \le 10$, 那么设 $f(i, j)$ 表示从起点 $s$ 出发到第 $i$ 个位置, 汉堡和可乐个数差值为 $j$ 时的最短路, 其中 $-k \le j \le k$.</p><p>直接在 Dijkstra 的过程中计算即可, 注意 $j$ 的范围, 以及不要忘了在起点处更新 $j$. 本质上为分层图最短路.</p><p>时间复杂度 $O(T n k \log m)$.</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3107</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e4</span> + <span class="number">5</span>, MAXM = <span class="number">1e5</span> + <span class="number">5</span>, MAXK = <span class="number">1e1</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, K, s, t;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], d[MAXN][MAXK];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, w; &#125; edges[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edges[++eidx] = (Edge)&#123; head[from], to, w &#125;, head[from] = eidx;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, k, d;</span><br><span class="line">    Node(<span class="keyword">int</span> _u, <span class="keyword">int</span> _k, <span class="keyword">int</span> _d): u(_u), k(_k), d(_d) &#123; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> d &gt; rhs.d; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;Node&gt; PQ;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    PQ.push(Node(s, K + A[s], d[s][K + A[s]] = <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!PQ.empty()) &#123;</span><br><span class="line">      <span class="keyword">int</span> u = PQ.top().u, k = PQ.top().k, w = PQ.top().d; PQ.pop();</span><br><span class="line">      <span class="keyword">if</span> (d[u][k] != w) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edges[i].to, vk = k + A[v];</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt;= vk &amp;&amp; vk &lt;= <span class="number">2</span> * K &amp;&amp; d[v][vk] &gt; d[u][k] + edges[i].w)</span><br><span class="line">          PQ.push(Node(v, vk, d[v][vk] = d[u][k] + edges[i].w));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span> * K; ++k) ret = min(ret, d[t][k]);</span><br><span class="line">    <span class="keyword">return</span> ret &lt; INF? ret: <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> Ti; read(Ti);</span><br><span class="line">  <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">    Graph::init();</span><br><span class="line"></span><br><span class="line">    read(n), read(m), read(K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      read(A[i]), A[i] = (A[i] == <span class="number">1</span>)? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, w, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">      read(u), read(v), read(w);</span><br><span class="line">      Graph::AddEdge(u, v, w), Graph::AddEdge(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    read(s), read(t);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Graph::Dijkstra());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「TJOI2019」甲苯先生和大中锋的字符串"><a href="#「TJOI2019」甲苯先生和大中锋的字符串" class="headerlink" title="「TJOI2019」甲苯先生和大中锋的字符串"></a>「TJOI2019」甲苯先生和大中锋的字符串</h3><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3108" target="_blank" rel="noopener">https://loj.ac/problem/3108</a></li></ul><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先有一个 (可能)? 不太常用的 SAM 性质:</p><blockquote><p>对于每一个状态 $v$ ，一个或多个子串与之匹配。我们记 $longest(v)$ 为其中最长的一个字符串，记 $len(v)$ 为它的长度。类似地，记 $shortest(v)$ 为最短的子串，它的长度为 $minlen(v)$ 。那么对应这个状态的所有字符串都是字符串 $longest(v)$ 的不同的后缀，且所有字符串的长度恰好覆盖区间 $[minlen(v),len(v)]$ 中的每一个整数。</p><p>对于初始状态 $t_0$ 以外的状态 $v$ ，可用后缀链接 $link(v)$ 表达 $minlen(v)$ ：</p><script type="math/tex; mode=display">minlen(v)=len(link(v))+1.</script><p>from <a href="https://oi-wiki.org/string/sam/#_4" target="_blank" rel="noopener">OI Wiki</a></p></blockquote><p>那么在建出 SAM 后, 对于一个每个包含出现 $k$ 次子串的状态 $v$, 在长度区间 $\Big(len\big(link(v)\big),\ len(v)\Big]$ 上 $+1$, 最后统计答案即可. 可利用差分实现.</p><p>时间复杂度 $O(Tn)$.</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3108</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span> + <span class="number">5</span>, SIGMA = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K;</span><br><span class="line"><span class="keyword">char</span> S[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SAM &#123;</span><br><span class="line">  <span class="keyword">int</span> ch[MAXN][SIGMA], lnk[MAXN], len[MAXN], size[MAXN], lst, nidx;</span><br><span class="line">  <span class="keyword">int</span> f[MAXN], cnt[MAXN], idx[MAXN];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; l)</span> </span>&#123;</span><br><span class="line">    len[++nidx] = l, lnk[nidx] = <span class="number">0</span>, size[nidx] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memset</span>(ch[nidx], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[nidx]), nidx;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; nidx = <span class="number">0</span>, lst = newnode(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nd = newnode(len[lst] + <span class="number">1</span>), p = lst;</span><br><span class="line">    size[nd] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; !ch[p][v]) ch[p][v] = nd, p = lnk[p];</span><br><span class="line">    <span class="keyword">if</span> (!p) lnk[nd] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> q = ch[p][v];</span><br><span class="line">      <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) lnk[nd] = q;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> nxt = newnode(len[p] + <span class="number">1</span>);</span><br><span class="line">        lnk[nxt] = lnk[q], <span class="built_in">memcpy</span>(ch[nxt], ch[q], <span class="keyword">sizeof</span> ch[nxt]);</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; ch[p][v] == q) ch[p][v] = nxt, p = lnk[p];</span><br><span class="line">        lnk[nd] = lnk[q] = nxt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lst = nd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R)</span> </span>&#123; ++f[L], --f[R + <span class="number">1</span>]; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, (n + <span class="number">1</span>) * <span class="keyword">sizeof</span> (<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, (n + <span class="number">1</span>) * <span class="keyword">sizeof</span> (<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nidx; ++i) ++cnt[len[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nidx; i; --i) idx[cnt[len[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, i = nidx; i; --i) &#123;</span><br><span class="line">      u = idx[i], size[lnk[u]] += size[u];</span><br><span class="line">      <span class="keyword">if</span> (size[u] == K) Mdy(len[lnk[u]] + <span class="number">1</span>, len[u]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>, Mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i)</span><br><span class="line">      <span class="keyword">if</span> (f[i] &gt; Mx) Mx = f[i], ret = i;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> Ti;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Ti);</span><br><span class="line">  <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">    SAM::init(), <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, S + <span class="number">1</span>, &amp;K);</span><br><span class="line">    n = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(S + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) SAM::Ins(S[i] - <span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, SAM::solve());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「TJOI2019」甲苯先生的线段树"><a href="#「TJOI2019」甲苯先生的线段树" class="headerlink" title="「TJOI2019」甲苯先生的线段树"></a>「TJOI2019」甲苯先生的线段树</h3><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><del><a href="https://loj.ac/problem/3109" target="_blank" rel="noopener">https://loj.ac/problem/3109</a></del></li><li><a href="https://codeforces.com/problemset/problem/750/G" target="_blank" rel="noopener">https://codeforces.com/problemset/problem/750/G</a></li></ul><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先考虑 $c = 1$ 的情况.</p><p>首先可以观察到一个性质: 对于每一个节点, 除去最高位, 可通过其他位上 0 / 1 的区别, 我们可以确定该节点在不同层上选择左 / 右节点.</p><p>因此, 对于线段树上两个节点 $x$, $y$, 其在线段树上 LCA 为 $x$, $y$ 在二进制表示下, 将高位对齐得到的 LCP.</p><p>同时, 一个节点 $x$ 到根节点路径上编号和为 $2x - \operatorname{popcount}(x)$. 其中 $\operatorname{popcount}(x)$ 表示 $x$ 在二进制表示下 $1$ 的个数. 当然直接在线段树上暴力向上跳也可以.</p><p>简单证明一下, 考虑祖先中出现多出一次左儿子的影响, 体现在二进制表示下即某位改变为 $1$. 将多出的贡献单独拿出来计算, 等同于再次从根节点开始的贡献, 只不过深度改变了. 那么答案为 $2x - \operatorname{popcount}(x)$.</p><p>考虑 $c = 2$ 的情况.</p><p>记第一问求出的答案为 $s$, 有一个重要的性质: 设两节点 $x$, $y$ 的 LCA $z$, $z$ 到 $x$ 链长 $a$, 到 $y$ 链长 $b$. 如果 $a$, $b$, $s$ 确定, 那么 $z$ 的位置唯一.</p><p>简单证明一下. 不妨令 $x &lt; y$. 同时记 $z$ 在二进制表示下有 $t$ 位, 那么 $x$ 在二进制表示下有 $t + a$ 位, $y$ 在二进制表示下有 $t + b$ 位.</p><p>先考虑 $x$, $y$ 前 $t$ 位路径编号和 $s$ 的贡献. 即</p><script type="math/tex; mode=display">\left(\sum_{i = 0} ^ a 2 ^ i + \sum_{i = 0} ^ b 2 ^ i - 1\right)\cdot z = \left( 2 ^ {a + 1} + 2 ^ {b + 1} - 3 \right) \cdot z</script><p>另外有 $x$ 后 $a$ 位, $y$ 后 $b$ 位的贡献. 考虑取最值的两种情况, 即在满足条件的情况下不断向左 / 右走, 可得最小值为 $2 ^ b - 1$, 最大值为 $\left(2 ^ a - 1 - a\right) + \left(2 ^ {b + 1} - 1 - b\right)$.</p><p>因此可将 $s$ 表示为 $s = vz + k$ 的形式, 其中 $v = 2 ^ {a + 1} + 2 ^ {b + 1} - 3$, $k \in [2 ^ b - 1,\ 2 ^ a + 2 ^ {b + 1} - a - b - 3]$. 从而有 $z = \lfloor \frac{s - k}{v} \rfloor$. 注意到 $k &lt; v$, 因此 $z$ 和 $k$ 无关, $z$ 在 $a$, $b$ 确定后唯一.</p><p>此时枚举 $a$, $b$ 的取值, 求满足 $k = s - vz$ 的方案数即可. 根据前文的性质, 此时的问题可转化为, 给定一长为 $a - 1$ 的 0-1 串 $A$ 和一长为 $b$ 的 0-1 串 $B$, 求满足 $2A - \operatorname{popcount}(A) + 2B - \operatorname{popcount}(B) = k$ 的 $A$, $B$ 方案数.</p><p>DP 计算即可. 具体地, 首先枚举 $\operatorname{popcount}(A) + \operatorname{popcount}(B)$ 取值 $w$, 那么限制为 $2(A + B) = k + w$.</p><p>设 $f(i, j, k)$, $k \in \{0,\ 1\}$ 表示考虑前 $i$ 位, 共凑出 $j$ 个 $1$, 且当前位是否存在进位的方案数. 转移即为</p><script type="math/tex; mode=display">f(i, j + p + q, \lfloor \frac{p + q + k}{2} \rfloor) = \sum_{p,\ q} f(i - 1, j, k)</script><p>实现时需要注意, 要强制 $A$ 的第 $a$ 位为 $0$, 以及 $B$ 的第 $b$ 位为 $1$, 同时要满足 $A + B$ 二进制表示下每一位和 $\frac{1}{2}(k + w)$ 相同.</p><p>时间复杂度 $O(d ^ 5)$.</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3109</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXD = <span class="number">5e2</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line">LL f[MAXD &lt;&lt; <span class="number">1</span>][MAXD &lt;&lt; <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Dist</span><span class="params">(<span class="keyword">const</span> LL&amp; x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * x - __builtin_popcountll(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">LCA</span><span class="params">(LL u, LL v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (u != v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (u &lt; v) swap(u, v);</span><br><span class="line">    u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lg2</span><span class="params">(LL s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (s &gt; <span class="number">0</span>) s &gt;&gt;= <span class="number">1</span>, ++ret;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(<span class="keyword">const</span> LL&amp; s, <span class="keyword">const</span> <span class="keyword">int</span>&amp; c, <span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> limit = max(lg2(s), max(a - <span class="number">1</span>, b));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= limit; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= c; ++j) f[i][j][<span class="number">0</span>] = f[i][j][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt;= <span class="number">1</span>; ++p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= <span class="number">1</span> &amp;&amp; p == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; q &lt;= <span class="number">1</span>; ++q) <span class="keyword">if</span> (p + q &lt;= c) &#123;</span><br><span class="line">      <span class="keyword">if</span> (((p + q) &amp; <span class="number">1</span>) != (s &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> ((b &lt; <span class="number">1</span> &amp;&amp; q == <span class="number">1</span>) || (b == <span class="number">1</span> &amp;&amp; q == <span class="number">0</span>)) <span class="keyword">continue</span>;</span><br><span class="line">      ++f[<span class="number">0</span>][p + q][(p + q) / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= limit; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= c; ++j)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">1</span>; ++k) <span class="keyword">if</span> (f[i - <span class="number">1</span>][j][k] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt;= <span class="number">1</span>; ++p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= a - <span class="number">1</span> &amp;&amp; p == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; q &lt;= <span class="number">1</span>; ++q) <span class="keyword">if</span> (j + p + q &lt;= c) &#123;</span><br><span class="line">          <span class="keyword">if</span> (((k + p + q) &amp; <span class="number">1</span>) != ((s &gt;&gt; i) &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">if</span> ((i &gt; b - <span class="number">1</span> &amp;&amp; q == <span class="number">1</span>) || (i == b - <span class="number">1</span> &amp;&amp; q == <span class="number">0</span>)) <span class="keyword">continue</span>;</span><br><span class="line">          f[i][j + p + q][(k + p + q) / <span class="number">2</span>] += f[i - <span class="number">1</span>][j][k];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> f[limit][c][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> Ti, c;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Ti);</span><br><span class="line">  <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">    LL x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%lld%lld%d"</span>, &amp;d, &amp;x, &amp;y, &amp;c);</span><br><span class="line">    LL z = LCA(x, y), s = Dist(x) + Dist(y) - Dist(z) - Dist(z &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, s);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      LL ans = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; d; ++a)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; d; ++b) &#123;</span><br><span class="line">          LL v = (<span class="number">1L</span>L &lt;&lt; (a + <span class="number">1</span>)) + (<span class="number">1L</span>L &lt;&lt; (b + <span class="number">1</span>)) - <span class="number">3</span>;</span><br><span class="line">          <span class="keyword">if</span> (v == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">          z = s / v;</span><br><span class="line">          <span class="keyword">if</span> (z &lt;= <span class="number">0</span> || lg2(z) + max(a, b) &gt; d) <span class="keyword">continue</span>;</span><br><span class="line">          LL k = s - v * z;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= a + b; ++i)</span><br><span class="line">            <span class="keyword">if</span> ((k + i) % <span class="number">2</span> == <span class="number">0</span>) ans += solve((k + i) / <span class="number">2</span>, i, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;del&gt;我没有在刷水题 (确信&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;打 扰 了.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>SNOI 2019 简要题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/SNOI-2019-sol/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/SNOI-2019-sol/</id>
    <published>2020-05-15T11:00:58.000Z</published>
    <updated>2020-05-17T11:21:48.257Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>这套题我做过, 我记得不是很水的吗?</p><p>from 某神仙</p></blockquote><a id="more"></a><h3 id="「SNOI2019」字符串"><a href="#「SNOI2019」字符串" class="headerlink" title="「SNOI2019」字符串"></a>「SNOI2019」字符串</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3095" target="_blank" rel="noopener">https://loj.ac/problem/3095</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这是一道小清新字符串题.</p><p>可以观察到一个性质: 对于串 $s_i$, $s_j$ 之间的比较, 只需比较原串 $a_{i\ldots j}$ 的部分即可, 因为只有这部分两串不同.</p><p>先考虑任意两相邻字符不同的情况. 此时若有 $a_{i + 1} &lt; a_i$, 则一定有 $s_i &lt; s_j\ (i &lt; j)$. 也就是在比较 $s_i$ 和 $s_j$ 的过程中, $a_{i + 1}$ 一定是第一次两串不同的位置, $a_i$ 和 $a_{i + 1}$ 的大小决定了 $s_i$ 和 $s_j$ 的大小关系.</p><p>此时从后向前扫描串 $a$. 每加入一个位置 $i$ 时, 可以直接得出 $s_i$ 和已加入串的大小关系, 利用双端队列维护排序后的结果即可.</p><p>接着考虑相邻相同字符的影响. 如果 $i$, $j$ 都在相同字符的范围之内, 即 $a_{i \ldots j}$ 相同, 那么 $s_i$ 和 $s_j$ 的顺序只能通过 $i$, $j$ 大小决定. 对于此种情况, 直接将所有相邻相同字符合并为一个位置, 对合并后的结果利用上述方法排序, 在内部按照编号大小排序就好了.</p><p>时间复杂度 $O(n)$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3095</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ns;</span><br><span class="line"><span class="keyword">char</span> a[MAXN], s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Idx[MAXN];</span><br><span class="line"><span class="keyword">int</span> idx[MAXN], Ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"string/s3.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;n, a + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j, i = <span class="number">1</span>; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">    j = i;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n &amp;&amp; a[i] == a[j + <span class="number">1</span>]) ++j;</span><br><span class="line">    s[++ns] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; ++k)</span><br><span class="line">      Idx[ns].push_back(k);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Q.push_front(ns);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = ns - <span class="number">1</span>; i; --i)</span><br><span class="line">    <span class="keyword">if</span> (s[i + <span class="number">1</span>] &lt; s[i]) Q.push_front(i); <span class="keyword">else</span> Q.push_back(i);</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; v: Q) idx[++c] = v;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> rnk = <span class="number">0</span>, i = <span class="number">1</span>; i &lt;= c; ++i) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; u = idx[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; v: Idx[u]) Ans[++rnk] = v;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, Ans[i], <span class="string">" \n"</span>[i == n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SNOI2019」数论"><a href="#「SNOI2019」数论" class="headerlink" title="「SNOI2019」数论"></a>「SNOI2019」数论</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3096" target="_blank" rel="noopener">https://loj.ac/problem/3096</a></li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>考虑到 $P$, $Q$ 的顺序对答案没有影响, 不妨令 $P \le Q$.</p><p>如果不断枚举 $x$, 则 $x$ 在模 $P$, $Q$ 意义下的值一定会出现循环, 且循环节长度 $l$ 为</p><script type="math/tex; mode=display">l = \frac{\operatorname{lcm}(P, Q)}{P} = \frac{Q}{\gcd(P, Q)}</script><p>考虑到若 $x$ 满足 $\left( x \bmod P \in A \right) \land \left( x \bmod Q \in B \right)$, 那么 $x$ 一定能表示为 $x = A_i + k \cdot P$ 的形式, 注意到 $Q$ 的值并不是很大, 可以统计出模 $Q$ 意义下所有环的权值, 最后对于每个 $A_i$ 统计答案.</p><p>枚举 $x$ 在模 $Q$ 意义下的值, 并标记集合 $B$ 中的元素, 记其权值为 $1$. 找出所有环, 并记环的权值为环内元素权值的和.</p><p>形象地说, 每个环就是在图上, 由点 $x$ 向点 $(x + P) \bmod Q$ 连边, 找环的过程就是一遍 DFS.</p><p>最后考虑如何统计答案. 注意到 $x \in [0,\ T)$, 那么 $k \le \lfloor \frac{T - 1 - A_i}{P} \rfloor$. 此时 $x$ 会经过 $\lfloor \frac{k}{l} \rfloor$ 次完整的环, 同时剩余 $k \bmod l$ 的步数尚未行走.</p><p>对于完整的环, 直接记录环上权值总和即可; 对于剩余的部分, 可记录环上权值的前缀和统计. 为避免跨过最后一个节点的讨论, 直接将环上元素复制一遍接到原有环的后面再统计前缀和.</p><p>时间复杂度 $O(n)$.</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3096</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> !b? a: gcd(b, a % b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> P, Q, n, m; LL T;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Cyc[MAXN], s[MAXN];</span><br><span class="line"><span class="keyword">int</span> val[MAXN], w[MAXN], pos[MAXN], col[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; lgt)</span> </span>&#123; <span class="comment">// (pos_u, pos_u + lgt]</span></span><br><span class="line">  <span class="keyword">return</span> s[col[u]][pos[u] + lgt] - s[col[u]][pos[u]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"number/s2.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  read(P), read(Q), read(n), read(m), read(T);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) read(B[i]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (P &gt; Q) swap(P, Q), swap(n, m), swap(A, B);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> nC = <span class="number">0</span>, lgt = Q / gcd(P, Q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) val[B[i]] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; Q; ++x) <span class="keyword">if</span> (!col[x]) &#123;</span><br><span class="line">    ++nC;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = x; col[u] != nC; u = (u + P) % Q)</span><br><span class="line">      col[u] = nC, Cyc[nC].push_back(u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; v: Cyc[nC])</span><br><span class="line">      w[nC] += val[v];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= nC; ++c) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; Cyc[c].size(); ++i)</span><br><span class="line">      pos[Cyc[c][i]] = i;</span><br><span class="line">    <span class="keyword">size_t</span> limit = Cyc[c].size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; limit; ++i) Cyc[c].push_back(Cyc[c][i]);</span><br><span class="line">    s[c].resize(Cyc[c].size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; Cyc[c].size(); ++i)</span><br><span class="line">      s[c][i] = ((i &gt; <span class="number">0</span>)? s[c][i - <span class="number">1</span>]: <span class="number">0</span>) + val[Cyc[c][i]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LL ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; a = A[i];</span><br><span class="line">    LL k = (T - <span class="number">1</span> - a) / P;</span><br><span class="line">    ans += (k / lgt) * w[col[a]] + sum(a, k % lgt) + val[a];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SNOI2019」通信"><a href="#「SNOI2019」通信" class="headerlink" title="「SNOI2019」通信"></a>「SNOI2019」通信</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3097" target="_blank" rel="noopener">https://loj.ac/problem/3097</a></li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先有一个共计 $O(n ^ 2)$ 条边的网络流做法:</p><p>设源汇分别为 $S$, $T$, 同时将每个点 $i$ 拆为两点 $x_i$, $y_i$. 连边</p><ul><li>$S \rightarrow x_i$, 容量为 $1$, 费用为 $0$.</li><li>$S \rightarrow y_i$, 容量为 $1$, 费用为 $W$.</li><li>$y_i \rightarrow T$, 容量为 $1$, 费用为 $0$.</li><li>对于满足 $i &lt; j$ 的点, $x_i \rightarrow y_j$, 容量为 $1$, 费用为 $\lvert a_i - a_j \lvert$.</li></ul><p>考虑如何优化. 注意到建边的瓶颈处, 也就是最后一组连边, 和 $a_i$ 的值有关. 有一个思路为, 对于每一个 $a_i$, 都建一个新点, 按大小顺序在新点间建来回两条边, 容量为 $\infty$, 费用为 $\lvert a_{i + 1} - a_i \rvert$. 同时对于每个 $x_i$ 二分到其所在权值代表的位置 $p$, 连边 $p \rightarrow x_i$; 同理有 $p’ \rightarrow y_i$.</p><p>不过这样的方式有很大的缺陷, 即无法确定从 $x_i$ 到达 $a_i$ 位置的流量, 是否一定流向编号较大的 $y_j$.</p><p>考虑用分治解决这个问题. 设当前分治区间为 $[L,\ R]$, 记 $M$ 为区间中点. 那么只令 $[L,\ M]$ 范围内的点向新点连边, 新点向 $(M,\ R]$ 范围内的点连边. 此时边数为 $O(n \log n)$.</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>SPFA 的队列还是用 STL 好.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3097</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span> + <span class="number">5</span>, MAXV = MAXN &lt;&lt; <span class="number">6</span>, MAXE = MAXV * <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> LL INFLL = <span class="number">0x3f3f3f3f3f3f3f3f</span>LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, W, S, T;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN], nB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, cap, flow, cost; &#125; edges[MAXE &lt;&lt; <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> head[MAXV], eidx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edges[++eidx] = (Edge)&#123; head[from], to, c, <span class="number">0</span>, w &#125;, head[from] = eidx;</span><br><span class="line">    edges[++eidx] = (Edge)&#123; head[to], from, <span class="number">0</span>, <span class="number">0</span>, -w &#125;, head[to] = eidx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MCMF &#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">  LL d[MAXV];</span><br><span class="line">  <span class="keyword">int</span> cur[MAXV], vis[MAXV], Time;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    Q.push(S);</span><br><span class="line">    d[S] = <span class="number">0</span>, vis[S] = ++Time;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">      <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">      vis[u] = Time - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">const</span> Edge&amp; e = edges[i];</span><br><span class="line">        <span class="keyword">if</span> (d[e.to] &gt; d[u] + e.cost &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">          d[e.to] = d[u] + e.cost;</span><br><span class="line">          <span class="keyword">if</span> (vis[e.to] != Time) Q.push(e.to), vis[e.to] = Time;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[T] &lt; INFLL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> a, LL&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == T || !a) <span class="keyword">return</span> a;</span><br><span class="line">    vis[u] = Time;</span><br><span class="line">    <span class="keyword">int</span> f, flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">      Edge&amp; e = edges[i];</span><br><span class="line">      <span class="keyword">if</span> (vis[e.to] != Time &amp;&amp; d[e.to] == d[u] + e.cost &amp;&amp;</span><br><span class="line">          (f = DFS(e.to, min(a, e.cap - e.flow), cost)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cost += f * e.cost;</span><br><span class="line">        flow += f, a -= f, e.flow += f, edges[i ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">        <span class="keyword">if</span> (!a) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">LL <span class="title">MCMF</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (SPFA()) &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span> cur);</span><br><span class="line">        ++Time, DFS(S, INF, ret);</span><br><span class="line">      &#125; <span class="keyword">while</span> (vis[T] == Time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> uidx;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; type, <span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (type == <span class="number">2</span>)? uidx + u: type * n + u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L == R)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">  solve(L, Mid), solve(Mid + <span class="number">1</span>, R);</span><br><span class="line">  nB = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) B[++nB] = A[i];</span><br><span class="line">  sort(B + <span class="number">1</span>, B + <span class="number">1</span> + nB);</span><br><span class="line">  nB = unique(B + <span class="number">1</span>, B + <span class="number">1</span> + nB) - B - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nB; ++i) &#123;</span><br><span class="line">    Graph::AddEdge(idx(<span class="number">2</span>, i), idx(<span class="number">2</span>, i + <span class="number">1</span>), INF, B[i + <span class="number">1</span>] - B[i]);</span><br><span class="line">    Graph::AddEdge(idx(<span class="number">2</span>, i + <span class="number">1</span>), idx(<span class="number">2</span>, i), INF, B[i + <span class="number">1</span>] - B[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> p = lower_bound(B + <span class="number">1</span>, B + <span class="number">1</span> + nB, A[i]) - B;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= Mid) <span class="comment">// [L, Mid] --&gt; (Mid, R]</span></span><br><span class="line">      Graph::AddEdge(idx(<span class="number">0</span>, i), idx(<span class="number">2</span>, p), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      Graph::AddEdge(idx(<span class="number">2</span>, p), idx(<span class="number">1</span>, i), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  uidx += nB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  Graph::init();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;W);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, A + i);</span><br><span class="line"></span><br><span class="line">  uidx = <span class="number">2</span> * n, solve(<span class="number">1</span>, n);</span><br><span class="line">  S = <span class="number">0</span>, T = uidx + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    Graph::AddEdge(idx(<span class="number">1</span>, i), T, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    Graph::AddEdge(S, idx(<span class="number">0</span>, i), <span class="number">1</span>, <span class="number">0</span>), Graph::AddEdge(S, idx(<span class="number">1</span>, i), <span class="number">1</span>, W);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, MCMF::MCMF());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SNOI2019」纸牌"><a href="#「SNOI2019」纸牌" class="headerlink" title="「SNOI2019」纸牌"></a>「SNOI2019」纸牌</h3><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3098" target="_blank" rel="noopener">https://loj.ac/problem/3098</a></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>常规计数题.</p><p>注意到题目给定的两方案相同的定义, “两组牌相同当且仅当它们含有的每一种牌数量都相同”, 那么相同牌组成的顺子不超过 $2$ 组, 因为超过两组就将多余部分视为刻子.</p><p>于是 DP 时直接记录顺子个数即可. 具体的, 设 $f(i, j, k)$ 表示处理完前 $i$ 种牌, 其中有形如 $(i - 1, i, i + 1)$ 的顺子 $j$ 组, 形如 $(i, i + 1, i + 2)$ 的顺子 $k$ 组. 转移时需考虑 $a_i$ 的限制, 此时将 “初始有 $a_i$ 张 $k_i$ 号牌” 的限制看作 “$k_i$ 号牌至少选择 $a_i$ 张”, 同时对于未限制的牌有 $a_i = 0$.</p><p>具体地, 记 $s = i + j + k$, 表示 $i + 1$ 参与组成的顺子个数. 有转移</p><script type="math/tex; mode=display">f(i + 1, k, s) = \begin{cases} f(i, j, k) \cdot \left(\lfloor \dfrac{c - s}{3} \rfloor + 1\right) & s \ge a_{i + 1} \\ f(i, j, k) \cdot \left(\lfloor \dfrac{c - \left(s + 3 \cdot \lceil \frac{a_{i + 1} - s}{3} \rceil\right) }{3} \rfloor + 1\right) & s < a_{i + 1}\end{cases}</script><p>其中 $s \le C$.</p><p>笼统地解释一下, 就是在选择 $i + 1$ 号牌时, 如果不满足限制就选择刻子, 否则不选择刻子.</p><p>可以发现, 在 $a_i$ 一定时, 这个转移个第一维关系不大, 那么可以用一 $9 \times 9$ 的矩阵描述这个转移, 同时利用矩阵快速幂加速运算.</p><p>将 $a_i \neq 0$ 的位置称作关键点, 那么关键点个数为 $X$. 预先处理出 $a_i = 0$ 的情况, 转移两关键点之间的部分; 每次根据 $a_i$ 值重构转移矩阵, 转移关键点位置.</p><p>时间复杂度 $O(X \log n)$, 同时带有矩阵乘法的常数.</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p>注意 $k_i$ 的取值范围, 需要 <code>long long</code>.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3098</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">9</span>, P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> g[MAXM][MAXM];</span><br><span class="line">  Matrix() &#123; init(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXM; ++i) g[i][i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g); &#125;</span><br><span class="line">  Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    Matrix ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXM; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; MAXM; ++k) <span class="keyword">if</span> (g[i][k] != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; MAXM; ++j) <span class="keyword">if</span> (rhs.g[k][j] != <span class="number">0</span>)</span><br><span class="line">          ret.g[i][j] = (ret.g[i][j] + <span class="number">1L</span>L * g[i][k] * rhs.g[k][j] % P) % P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; f, g, h;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">fpow</span><span class="params">(Matrix base, LL b)</span> </span>&#123;</span><br><span class="line">  Matrix ret; ret.unit();</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * base;</span><br><span class="line">    base = base * base, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL n, K; <span class="keyword">int</span> X, C;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld%d%d"</span>, &amp;n, &amp;C, &amp;X);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = i + j + k;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= C) h.g[<span class="number">3</span> * i + j][<span class="number">3</span> * j + k] = (C - s) / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  LL lst = <span class="number">0</span>;</span><br><span class="line">  f.g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> a, i = <span class="number">1</span>; i &lt;= X; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%d"</span>, &amp;K, &amp;a);</span><br><span class="line">    g.init(), f = f * fpow(h, K - lst - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">3</span>; ++l) &#123;</span><br><span class="line">          <span class="keyword">int</span> s = j + k + l;</span><br><span class="line">          <span class="keyword">if</span> (s &lt; a) s = s + ((a - s + <span class="number">2</span>) / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">          <span class="keyword">if</span> (s &lt;= C) g.g[<span class="number">3</span> * j + k][<span class="number">3</span> * k + l] = (C - s) / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    f = f * g, lst = K;</span><br><span class="line">  &#125;</span><br><span class="line">  f = f * fpow(h, n - lst);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f.g[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SNOI2019」积木"><a href="#「SNOI2019」积木" class="headerlink" title="「SNOI2019」积木"></a>「SNOI2019」积木</h3><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3099" target="_blank" rel="noopener">https://loj.ac/problem/3099</a></li></ul><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>还是 <a href="https://yhx-12243.github.io/OI-transit/records/lg5372%3Bloj3099.html" target="_blank" rel="noopener">yhx-12243 的题解</a> 更为清晰明朗.</p><p>注意到题目中并未要求给出的操作数最少, 只需构造出长度限制可被接受的操作序列即可.</p><p>由上述题解的解释, 每次移动空白格的位置, 本质是找环和沿环行走的过程. 每次保证移动后, 有一个位置和最终状态匹配即可, 此时每个位置只会被搜索到一次.</p><p>时间复杂度 $O(nm)$, 构造的操作序列长度为 $2nm$.</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><p>一些实现的技巧参考了 <a href="https://www.cnblogs.com/PaperCloud/p/11289173.html" target="_blank" rel="noopener">PaperCloud</a>.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3099</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(args...) fprintf(stderr, ##args)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;, dy[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, nxt[][<span class="number">2</span>] = &#123;</span><br><span class="line">  &#123; <span class="number">0</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">2</span>, <span class="number">3</span> &#125;, &#123; <span class="number">3</span>, <span class="number">2</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e3</span> + <span class="number">5</span>, SIGMA = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x, y;</span><br><span class="line">  Point() = <span class="keyword">default</span>;</span><br><span class="line">  Point(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y): x(_x), y(_y) &#123; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> Point&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x != rhs.x || y != rhs.y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> S[MAXN], Ans[MAXN];</span><br><span class="line"></span><br><span class="line">Point os, ot;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> MS[MAXN][MAXN], MT[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">InitMap</span><span class="params">(<span class="keyword">int</span> (*A)[MAXN])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> Map[SIGMA];</span><br><span class="line">  Map[<span class="string">'o'</span>] = <span class="number">-1</span>, Map[<span class="string">'&lt;'</span>] = <span class="number">0</span>, Map[<span class="string">'&gt;'</span>] = <span class="number">1</span>, Map[<span class="string">'n'</span>] = <span class="number">2</span>, Map[<span class="string">'u'</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Point <span class="title">ret</span><span class="params">(<span class="number">-1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">      A[i][j] = Map[(<span class="keyword">int</span>) S[j]];</span><br><span class="line">      <span class="keyword">if</span> (S[j] == <span class="string">'o'</span>) ret = Point(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span> </span>&#123; <span class="comment">// os --&gt; n1 --&gt; n2</span></span><br><span class="line">  Point n1 = Point(os.x + dx[k], os.y + dy[k]),</span><br><span class="line">        n2 = Point(n1.x + dx[MS[n1.x][n1.y]], n1.y + dy[MS[n1.x][n1.y]]);</span><br><span class="line">  MS[os.x][os.y] = nxt[k][<span class="number">0</span>], os = n2;</span><br><span class="line">  MS[n1.x][n1.y] = nxt[k][<span class="number">1</span>], MS[n2.x][n2.y] = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">"RLDU"</span>[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">augment</span><span class="params">(<span class="keyword">const</span> Point&amp; p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (os != p) move(MT[os.x][os.y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> Point&amp; p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vis[p.x][p.y])</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  vis[p.x][p.y] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123; <span class="comment">// os --&gt; n1 --&gt; n2</span></span><br><span class="line">    Point n1 = Point(p.x + dx[k], p.y + dy[k]);</span><br><span class="line">    <span class="keyword">if</span> (n1.x &lt; <span class="number">1</span> || n1.x &gt; n || n1.y &lt; <span class="number">1</span> || n1.y &gt; m || vis[n1.x][n1.y])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    Point n2 = Point(n1.x + dx[MT[n1.x][n1.y]], n1.y + dy[MT[n1.x][n1.y]]);</span><br><span class="line">    <span class="keyword">if</span> (MS[n1.x][n1.y] != MT[n1.x][n1.y])</span><br><span class="line">      move(k), augment(n2), move(MT[n2.x][n2.y]);</span><br><span class="line">    move(k), vis[n1.x][n1.y] = <span class="literal">true</span>;</span><br><span class="line">    dfs(n2), move(MT[n2.x][n2.y]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">  os = InitMap(MS), ot = InitMap(MT);</span><br><span class="line">  augment(ot), dfs(os), <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SNOI2019」网络"><a href="#「SNOI2019」网络" class="headerlink" title="「SNOI2019」网络"></a>「SNOI2019」网络</h3><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3100" target="_blank" rel="noopener">https://loj.ac/problem/3100</a></li></ul><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a><del>解题思路</del></h4><p>这是能令人感到希望的一道题.</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;这套题我做过, 我记得不是很水的吗?&lt;/p&gt;
&lt;p&gt;from 某神仙&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>「UOJ 284」快乐游戏鸡 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/uoj-284/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/uoj-284/</id>
    <published>2020-05-11T01:46:02.000Z</published>
    <updated>2020-05-11T13:21:31.242Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接: <a href="https://uoj.ac/problem/284" target="_blank" rel="noopener">https://uoj.ac/problem/284</a></li></ul><p>大体是将询问离线, 利用长链剖分维护子树内的单调栈. <del>还有一火车的细节</del></p><a id="more"></a><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>先考虑在一条链上怎么做.</p><p>首先将所有点按 $1$ 到 $n$ 从左到右排布, 此时得到了一个序列. 对于一次询问 $(s,\ t)$, 从 $s$ 出发走向 $t$ (也只能这样走), 设在这条路径上依次经过节点 $i,\ j$. 如果有 $w_i \ge w_j$, 那么一定不会在 $j$ 上死亡.</p><p>如果我们直接删去这样的 $j$, 那么可以得出一个深度单调递增, 同时 $w$ 严格单调递增的单调栈.</p><p>在维护出单调栈后, 如何计算答案呢?</p><p>记 $f_u$ 为经过单调栈中上一个位置 $u$ 的花费, 如果完全经过单调栈下一位置 $v$, 那么 $s$ 经过 $v$ 的花费为 $f_u + \operatorname{depth}(v) \cdot (w_v - w_u)$.</p><p><em>(此处称之为 “花费” 并不完全准确, 因为此处的 <code>depth</code> 为到根节点的距离. 这样维护目的在于简化计算答案时分类讨论时的式子)</em></p><p>那么答案即可通过栈顶的 $f$ 算出, 并不要漏掉 $s$ 到 $t$ 的距离. 同时 $f$ 直接在加入一个节点时维护即可. 但是此时有多组询问. 直接离线处理, 从右向左, 对于每个节点依次维护单调栈即可.</p><p>再来推广到树的情况.</p><p>对于一轮从 $s$ 到 $t$ 的游戏, 每次都沿着 $s \rightarrow t$ 的路径前进, 直到能够到达 $t$ 的策略, 显然不是最优的: 我们可以在 $s$ 的子树内寻找一条深度较浅的点, 并通过在该点快速积累死亡次数, 从而减少在树上移动的时间.</p><p>而链上的情况并不存在其他儿子的子树, 因此可以不考虑这个问题. 在树的条件下, 维护单调栈的同时需要注意深度的影响.</p><p>栈中插入一个元素, 需满足栈中 $w_i$ 递增. 同时, 只在栈为空, 或是栈顶元素深度大于当前元素时插入. 这样就解决了上面的问题.</p><p>注意到单调栈的大小和子树中最深点的深度有关. 容易想到用长链剖分维护这个单调栈, 也就是直接继承长儿子的单调栈, 同时大力合并其他儿子的单调栈. 在合并时, 直接按照深度从小到大, 将一个栈中的元素插入另一个栈中即可.</p><p>计算答案则在栈内二分. 找到栈中某个点 $p$, 使其满足 $w_p \ge \max \{ {w_{s \rightarrow t} } \}$ (当然此处不包含 $s,t$). 注意不存在此位置的情况. 细节见代码实现.</p><p>而 <a href="https://www.cnblogs.com/penth/p/9801945.html" target="_blank" rel="noopener">hzy 的题解</a>, 有一个称作 “队列启发式合并” 的技巧: 在 DFS 维护处理询问时, 按照 DFS 序分配在队列中的空间. 而每次合并后的结果, 一定不会超过 DFS 序所限定的范围, 并且是连续的. 这样就避免了较为繁琐的实现.</p><p>时间复杂度 $O(n\log n + q \log n)$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UOJ #284</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e5</span> + <span class="number">5</span>, LOG = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> idx, t;</span><br><span class="line">  Ask() = <span class="keyword">default</span>;</span><br><span class="line">  Ask(<span class="keyword">int</span> _i, <span class="keyword">int</span> <span class="keyword">_t</span>): idx(_i), t(<span class="keyword">_t</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> pre[MAXN], W[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Mx[LOG][MAXN], anc[LOG][MAXN];</span><br><span class="line"><span class="keyword">int</span> depth[MAXN], son[MAXN], dfn[MAXN], clk;</span><br><span class="line"></span><br><span class="line">LL Ans[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;Ask&gt; Q[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN];</span><br><span class="line">  <span class="keyword">int</span> head[MAXN], d[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    depth[u] = depth[pre[u]] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; ++j) <span class="keyword">if</span> (anc[j - <span class="number">1</span>][u] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      anc[j][u] = anc[j - <span class="number">1</span>][anc[j - <span class="number">1</span>][u]];</span><br><span class="line">      Mx[j][u] = max(Mx[j - <span class="number">1</span>][u], Mx[j - <span class="number">1</span>][anc[j - <span class="number">1</span>][u]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">      dfs(v = edges[i].to);</span><br><span class="line">      <span class="keyword">if</span> (d[v] &gt; d[son[u]]) son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    d[u] = d[son[u]] + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">      Mx[<span class="number">0</span>][u] = W[u], anc[<span class="number">0</span>][u] = pre[u];</span><br><span class="line">    dfs(rt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">QryMax</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = LOG - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">    <span class="keyword">if</span> (depth[anc[j][u]] &gt;= depth[v])</span><br><span class="line">      ret = max(ret, Mx[j][u]), u = anc[j][u];</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Que &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> d, w;</span><br><span class="line">    Node(<span class="keyword">int</span> _d = <span class="number">0</span>, <span class="keyword">int</span> _w = <span class="number">0</span>): d(_d), w(_w) &#123; &#125;</span><br><span class="line">  &#125; Qu[MAXN], stk[MAXN];</span><br><span class="line"></span><br><span class="line">  LL s[MAXN];</span><br><span class="line">  <span class="keyword">int</span> Head[MAXN], Tail[MAXN];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">newnode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u, <span class="keyword">int</span> head, <span class="keyword">int</span> tail)</span> </span>&#123;</span><br><span class="line">    Head[u] = head, Tail[u] = tail;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">const</span> Node&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;head = Head[u], &amp;tail = Tail[u];</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail &amp;&amp; Qu[head].w &lt;= v.w) ++head;</span><br><span class="line">    <span class="keyword">if</span> (head &gt; tail || Qu[head].d &gt; v.d) &#123;</span><br><span class="line">      s[head - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (head &lt;= tail)</span><br><span class="line">        s[head - <span class="number">1</span>] = s[head] + <span class="number">1L</span>L * Qu[head].d * (Qu[head].w - v.w);</span><br><span class="line">      Qu[--head] = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Mrg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123; <span class="comment">// Qu[u] &lt;-- Qu[v]</span></span><br><span class="line">    <span class="keyword">int</span> &amp;hu = Head[u], &amp;tu = Tail[u], &amp;hv = Head[v], &amp;tv = Tail[v];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (hu &lt;= tu &amp;&amp; Qu[hu].d &lt; Qu[tv].d)</span><br><span class="line">      stk[++top] = Qu[hu++];</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; hv &lt;= tv) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Qu[tv].d &gt; stk[top].d) Ins(u, Qu[tv--]);</span><br><span class="line">      <span class="keyword">else</span> Ins(u, stk[top--]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">0</span>) Ins(u, stk[top--]);</span><br><span class="line">    <span class="keyword">while</span> (hv &lt;= tv) Ins(u, Qu[tv--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> Graph::edges;</span><br><span class="line">  dfn[u] = ++clk;</span><br><span class="line">  <span class="keyword">if</span> (son[u] &gt; <span class="number">0</span>)</span><br><span class="line">    dfs(son[u]), Que::newnode(u, Que::Head[son[u]], Que::Tail[son[u]]);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    Que::newnode(u, clk, clk - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v, i = Graph::head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">    <span class="keyword">if</span> ((v = edges[i].to) != son[u]) dfs(v), Que::Mrg(u, v);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> Ask&amp; a: Q[u]) &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Que;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;head = Head[u], &amp;tail = Tail[u];</span><br><span class="line">    <span class="keyword">int</span> L = head, R = tail, w = QryMax(pre[a.t], u);</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">      <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (Qu[Mid].w &lt; w) L = Mid + <span class="number">1</span>; <span class="keyword">else</span> R = Mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Qu[head].w &lt;= w) &#123;</span><br><span class="line">      Ans[a.idx] += s[head] - s[L] + <span class="number">1L</span>L * Qu[head].d * Qu[head].w;</span><br><span class="line">      Ans[a.idx] += <span class="number">1L</span>L * Qu[L].d * (w - Qu[L].w) - <span class="number">1L</span>L * w * depth[u];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Ans[a.idx] += <span class="number">1L</span>L * w * (Qu[L].d - depth[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    Ans[a.idx] += depth[a.t] - depth[u];</span><br><span class="line">  &#125;</span><br><span class="line">  Que::Ins(u, Que::Node(depth[u], W[u]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"data/ex_rewrite3.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  Graph::init();</span><br><span class="line"></span><br><span class="line">  read(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(W[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    read(pre[i]), Graph::AddEdge(pre[i], i);</span><br><span class="line">  read(q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> s, t, i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">    read(s), read(t), Q[s].push_back(Ask(i, t));</span><br><span class="line"></span><br><span class="line">  Graph::solve(<span class="number">1</span>), dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我再也不做数据结构了.cpp</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>UOJ, <a href="https://vfleaking.blog.uoj.ac/blog/2292" target="_blank" rel="noopener">Goodbye Bingshen 题解</a></li><li>hzy, <a href="https://www.cnblogs.com/penth/p/9801945.html" target="_blank" rel="noopener">题解-UOJ284 快乐游戏鸡</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://uoj.ac/problem/284&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://uoj.ac/problem/284&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大体是将询问离线, 利用长链剖分维护子树内的单调栈. &lt;del&gt;还有一火车的细节&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Data Structure" scheme="https://depletedprism.github.io/tags/Data-Structure/"/>
    
      <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>「ZJOI2018」历史 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/uoj-374/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/uoj-374/</id>
    <published>2020-05-10T08:52:45.000Z</published>
    <updated>2020-05-11T13:32:04.339Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接: <a href="https://uoj.ac/problem/374" target="_blank" rel="noopener">https://uoj.ac/problem/374</a></li></ul><p>一道非常有意思的 Link-Cut Tree 题.</p><a id="more"></a><p><del>ZJOI2018 唯一可做题</del></p><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>给定一棵有 $n$ 个节点的树, 根节点为 $1$. 在该树基础上建立 LCT, 同时给出第 $i$ 个点 <code>access</code> 的次数为 $a_i$. $m$ 次修改, 修改为将 $a_{x_i}$ 的值增加 $w_i$.</p><p>分别求出初始状态下, 和 $m$ 次修改后, <code>access</code> 操作中改变虚实链次数总和的最大值.</p><p>其中, $n,m \le 4 \times 10 ^ 5,\ a_i, w_i \le 10 ^ 7$.</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>先考虑不带修改怎么做.</p><p>首先每个点 <code>access</code> 操作时只会影响该点到根节点路径上的点, 因此影响一个点到其儿子边的虚实的操作只会发生在该点的子树内. 所以将每个子树分开考虑, 统计答案时直接求和即可.</p><p>注意到来自同一子树内的连续两次 <code>access</code> 操作, 并不会改变该子树根 $v$ 到 $v$ 的父亲 $u$ 这条边的虚实. 记 $u$ 的 <code>access</code> 次数为 $A_0$, 其儿子 $v$ 的子树内部 <code>access</code> 次数和分别为 $A_i$, 且节点 $u$ 共有 $m$ 个儿子. 那么问题可转化为</p><blockquote><p>给定若干个球, 总共有 $0$ 到 $m$ 共 $m + 1$ 种颜色, 第 $i$ 种颜色的球有 $A_i$ 个.</p><p>现在要构造一种球的排列, 使得相邻两个球颜色不同的间隔数尽量多.</p></blockquote><p>有一个贪心的思路: 选择小球个数最多的颜色, 将这些小球排成一列. 同时将其余小球插入这列小球之间. 用更加形式化的语言可描述为</p><p>记 $h = \max\limits_{i = 0} ^ m \{A_i \}$, $t = \sum\limits_{i = 0} ^ m A_i$, 分两种情况讨论.</p><ol><li><p>$2h \le t$, 此时答案为 $t - 1$.</p><p>即所有的小球中存在至多一半的球有相同颜色.</p></li><li><p>$2h \ge t + 1$, 此时答案为 $2 (t - h)$.</p><p>此种情况下按照上述策略贪心, 则不可避免存在多出一部分相同颜色的小球. 无论怎样改变已经放置的小球, 都无法使得不同颜色小球间隔数增加. 统计放置这些相同颜色小球前的间隔数, 即可计算答案.</p></li></ol><p>也就是 $\min \{ t - 1,\ 2(t - h) \}$.</p><p>因而可以得到一个做法: 直接 DFS 整棵树, 分别统计每棵子树对答案贡献. 可以在 $O(n)$ 的时间复杂度内计算.</p><p>观察上述结论中两种情况的性质. 设 $s_u$ 为 $u$ 子树内的 <code>access</code> 次数之和.</p><p>对于带修改的情况, 对于一条边 $(u, fa)$, 将满足 $2s_u \ge s_{fa} + 1$ 的边视作实链, 否则视为虚链. 类比于重链剖分, 虚链的个数有 $O(\log \sum a_i) = O(\log n)$ 个, 且连向 $fa$ 的实链唯一, 实儿子一定是 $u$.</p><p>对于一条实链, 每次单点修改 $u$ 的值时, $fa$ 处的答案不会改变: 此时 $h$ 的值不会发生变化, 且 $t - h$ 的差值不变.</p><p>可以直接用 LCT 来维护, 每次修改后暴力 <code>access</code> 沿当前点到根的路径依次修改即可. 注意实现时的细节, 以及虚实链的改变需要遵循上述条件.</p><p>时间复杂度 $O(n \log n)$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UOJ #374</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(args...) fprintf(stderr, ##args)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a &lt; b)? a = b, <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line">LL ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> LCT &#123;</span><br><span class="line">  <span class="keyword">int</span> ch[<span class="number">2</span>][MAXN], pre[MAXN];</span><br><span class="line">  LL s[MAXN], is[MAXN], val[MAXN];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; nd)</span> </span>&#123;</span><br><span class="line">    s[nd] = is[nd] + val[nd];</span><br><span class="line">    <span class="keyword">if</span> (ch[<span class="number">0</span>][nd]) s[nd] += s[ch[<span class="number">0</span>][nd]];</span><br><span class="line">    <span class="keyword">if</span> (ch[<span class="number">1</span>][nd]) s[nd] += s[ch[<span class="number">1</span>][nd]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">which</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123; <span class="keyword">return</span> pre[u]? ch[<span class="number">1</span>][pre[u]] == u: <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">nroot</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre[u]? ch[<span class="number">0</span>][pre[u]] == u || ch[<span class="number">1</span>][pre[u]] == u: <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = pre[u], w = which(u);</span><br><span class="line">    pre[u] = pre[fa];</span><br><span class="line">    <span class="keyword">if</span> (nroot(fa)) ch[which(fa)][pre[fa]] = u;</span><br><span class="line">    ch[w][fa] = ch[w ^ <span class="number">1</span>][u];</span><br><span class="line">    <span class="keyword">if</span> (ch[w ^ <span class="number">1</span>][u]) pre[ch[w ^ <span class="number">1</span>][u]] = fa;</span><br><span class="line">    ch[w ^ <span class="number">1</span>][u] = fa, pre[fa] = u;</span><br><span class="line">    maintain(fa);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (nroot(u)) &#123;</span><br><span class="line">      <span class="keyword">int</span> fa = pre[u];</span><br><span class="line">      <span class="keyword">if</span> (nroot(fa)) which(fa) == which(u)? rotate(fa): rotate(u);</span><br><span class="line">      rotate(u);</span><br><span class="line">    &#125;</span><br><span class="line">    maintain(u);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> LL <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, LL t, LL h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ch[<span class="number">1</span>][u]) <span class="keyword">return</span> <span class="number">2</span> * (t - h);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * val[u] &gt;= t + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">2</span> * (t - val[u]);</span><br><span class="line">    <span class="keyword">return</span> t - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v = u;</span><br><span class="line">    <span class="keyword">for</span> (u = pre[u]; u; v = u, u = pre[u]) &#123; <span class="comment">// start from pre[u]</span></span><br><span class="line">      splay(u);</span><br><span class="line">      LL t = s[u] - s[ch[<span class="number">0</span>][u]], h = s[ch[<span class="number">1</span>][u]];</span><br><span class="line">      ans -= calc(u, t, h);</span><br><span class="line">      s[u] += w, t += w, is[u] += w;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">2</span> * h &lt; t + <span class="number">1</span>)</span><br><span class="line">        ch[<span class="number">1</span>][u] = <span class="number">0</span>, is[u] += h;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">2</span> * s[v] &gt;= t + <span class="number">1</span>) <span class="comment">// update weight son</span></span><br><span class="line">        ch[<span class="number">1</span>][u] = v, h = s[v], is[u] -= h;</span><br><span class="line">      ans += calc(u, t, h);</span><br><span class="line">      maintain(u);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; w)</span> </span>&#123;</span><br><span class="line">    splay(u);</span><br><span class="line">    LL t = s[u] - s[ch[<span class="number">0</span>][u]], h = s[ch[<span class="number">1</span>][u]];</span><br><span class="line">    ans -= calc(u, t, h);</span><br><span class="line">    val[u] += w, t += w, s[u] += w;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * h &lt; t + <span class="number">1</span>)</span><br><span class="line">      ch[<span class="number">1</span>][u] = <span class="number">0</span>, is[u] += h;</span><br><span class="line">    ans += calc(u, t, h);</span><br><span class="line">    maintain(u), access(u, w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> LCT;</span><br><span class="line">    <span class="keyword">int</span> rson = <span class="number">-1</span>;</span><br><span class="line">    LL &amp;t = s[u], h = val[u]; t = val[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((v = edges[i].to) == pre[u]) <span class="keyword">continue</span>;</span><br><span class="line">      pre[v] = u, dfs(v), t += s[v];</span><br><span class="line">      <span class="keyword">if</span> (ckmax(h, s[v])) rson = v;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += min(t - <span class="number">1</span>, <span class="number">2</span> * (t - h));</span><br><span class="line">    <span class="keyword">if</span> (rson &gt; <span class="number">0</span> &amp;&amp; <span class="number">2</span> * h &gt;= t + <span class="number">1</span>)</span><br><span class="line">      ch[<span class="number">1</span>][u] = rson, is[u] = s[u] - s[rson] - val[u];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      is[u] = s[u] - val[u];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"data/ex_history2.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  Graph::init();</span><br><span class="line"></span><br><span class="line">  read(n), read(q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(LCT::val[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    read(u), read(v), Graph::AddEdge(u, v), Graph::AddEdge(v, u);</span><br><span class="line"></span><br><span class="line">  Graph::dfs(<span class="number">1</span>), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x, w; q; --q) &#123;</span><br><span class="line">    read(x), read(w), LCT::Mdy(x, w);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>ZJOI2018 day1 solution by ???</li><li>Kelin, <a href="https://blog.csdn.net/BeNoble_/article/details/79706461" target="_blank" rel="noopener">[ZJOI2018]历史</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://uoj.ac/problem/374&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://uoj.ac/problem/374&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一道非常有意思的 Link-Cut Tree 题.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Data Structure" scheme="https://depletedprism.github.io/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>「集训队作业 2018」喂鸽子 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/uoj-449/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/uoj-449/</id>
    <published>2020-05-06T13:09:31.000Z</published>
    <updated>2020-05-24T11:51:28.377Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接: <a href="https://uoj.ac/problem/449" target="_blank" rel="noopener">https://uoj.ac/problem/449</a></li></ul><p>个人现在感觉这是一道有启发意义的期望题.</p><p>大体是利用 Min-Max 容斥计算期望, 以及 NTT 优化时间复杂度.</p><a id="more"></a><p><del>我 喂 我 自 己</del></p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>显然可以使用 Min-Max 容斥.</p><p>记 $X_i$ 为第 $i$ 只鸽子喂饱的期望时间, 也可称作期望喂饱该鸽子的玉米粒个数. 同时记 $S$ 为鸽子的全集, 也就是全部的鸽子. 套用 Min-Max 容斥可得</p><script type="math/tex; mode=display">E(\max_{i \in S}\{X_i\}) = \sum_{T \subset S,\ T \neq \varnothing} (-1) ^ {\mid T \mid - 1} E(\min_{i \in T}\{ X_i \})</script><p>注意到每只鸽子之间并没有区别, 所以直接枚举集合大小即可. 设 $g(m)$ 表示喂 $m$ 只鸽子, 最早喂饱一只的期望时间. 则</p><script type="math/tex; mode=display">E(\max_{i \in S}\{X_i\}) = \sum_{m = 1} ^ n \binom{n}{m} g(m) \cdot \frac{n}{m}</script><p>此处等式右侧需乘上 $\frac{n}{m}$, 表示同时喂 $n$ 只鸽子, 喂到钦定的 $m$ 只鸽子的期望次数.</p><p>现在的问题转为如何快速求出 $g(m)$. 设 $f(m, i)$ 表示喂 $m$ 只鸽子, 喂 $i$ 粒玉米, 不存在任何一只鸽子被喂饱的概率. 那么至多只能喂 $m(k-1)$ 粒, 有</p><script type="math/tex; mode=display">g(m) = \sum_{i = 0} ^ {m(k - 1)} f(m, i) = 1 + \sum_{i = 1} ^ {m(k-1)} f(m, i)</script><p><em>此处将 $f(m, 0)$ 单独列出, 以避免讨论.</em></p><p>对于计算 $f(m, i)$, 有一个朴素的想法是, 用不喂饱任何一只鸽子的方案数除以总共的方案数. 设 $h(m, i)$ 表示喂 $m$ 只鸽子, 喂 $i$ 粒玉米, 不存在任何一只鸽子被喂饱的方案数, 则有</p><script type="math/tex; mode=display">f(m, i) = \frac{1}{m ^ i} h(m, i)</script><p>对于 $h(m, i)$, 可以枚举喂某一只鸽子的玉米粒数, 得出</p><script type="math/tex; mode=display">h(m, i) = \sum_{j = 0} ^ {\min\{ i,\ k - 1 \}} \binom{i}{j}\ h(m - 1, i - j) = i! \cdot \sum_{j = 0} ^ {\min\{ i,\ k - 1\}} \frac{h(m - 1, i - j)}{(i - j)!} \cdot \frac{1}{j!}</script><p>是一个卷积的形式, 用 NTT 计算即可. 和式中的 $\min$ 其实很好处理, 每次计算只取后者的前 $k - 1$ 次项即可.</p><p>时间复杂度 $O(n ^ 2 k \log nk)$.</p><p>另外存在时间复杂度为 $O(n ^ 2 k)$ 的优秀做法. <del>已经拿去喂鸽子了</del>, 不妨参看 <a href="https://yhx-12243.github.io/OI-transit/records/uoj449.html" target="_blank" rel="noopener">https://yhx-12243.github.io/OI-transit/records/uoj449.html</a>.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UOJ #449</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">1e3</span> + <span class="number">5</span>, MAXM = <span class="number">5e1</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LOG = <span class="number">17</span>, MAXN = <span class="number">1</span> &lt;&lt; LOG | <span class="number">1</span>, P = <span class="number">998244353</span>, G = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> W[LOG][MAXN];</span><br><span class="line"><span class="keyword">int</span> inv[MAXN], fac[MAXN], ifac[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (n &lt; m)? <span class="number">0</span>: <span class="number">1L</span>L * fac[n] * ifac[m] % P * ifac[n - m] % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % P;</span><br><span class="line">    base = <span class="number">1L</span>L * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">  <span class="keyword">int</span> r[MAXN];</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>, Mid = <span class="number">1</span>; Mid &lt; Lim; ++k, Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span>* w = W[k];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j) &#123;</span><br><span class="line">          <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1L</span>L * w[j] * f[i+j+Mid] % P;</span><br><span class="line">          f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> iv = fpow(Lim, P - <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * iv * f[i] % P;</span><br><span class="line">      reverse(f + <span class="number">1</span>, f + Lim);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n, <span class="keyword">int</span>* g, <span class="keyword">const</span> <span class="keyword">int</span>&amp; m, <span class="keyword">int</span>* h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">    <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Lim &lt; n + m - <span class="number">1</span>) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i)</span><br><span class="line">      A[i] = (i &lt; n)? f[i]: <span class="number">0</span>, B[i] = (i &lt; m)? g[i]: <span class="number">0</span>;</span><br><span class="line">    init(Lim, L), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) h[i] = <span class="number">1L</span>L * A[i] * B[i] % P;</span><br><span class="line">    NTT(h, Lim, <span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PolyPre</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">  inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">    inv[i] = <span class="number">1L</span>L * inv[P % i] * (P - P / i) % P;</span><br><span class="line">  fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    fac[i] = <span class="number">1L</span>L * i * fac[i - <span class="number">1</span>] % P;</span><br><span class="line">    ifac[i] = <span class="number">1L</span>L * inv[i] * ifac[i - <span class="number">1</span>] % P;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> w, i = <span class="number">0</span>, Mid = <span class="number">1</span>; i &lt; LOG; ++i, Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    W[i][<span class="number">0</span>] = <span class="number">1</span>, w = fpow(G, (P - <span class="number">1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; Mid; ++j)</span><br><span class="line">      W[i][j] = <span class="number">1L</span>L * w * W[i][j - <span class="number">1</span>] % P;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K;</span><br><span class="line"><span class="keyword">int</span> g[MAXM], f[MAXM][MAXN], h[MAXM][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;K);</span><br><span class="line">  PolyPre(n * K);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// h(m, i) = sum_&#123;j = 0&#125; ^ min(i, k - 1) C(i, j) * h(m - 1, i - j)</span></span><br><span class="line">  h[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt;= n; ++m) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (m - <span class="number">1</span>) * (K - <span class="number">1</span>); ++i)</span><br><span class="line">      A[i] = <span class="number">1L</span>L * h[m - <span class="number">1</span>][i] * ifac[i] % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= K - <span class="number">1</span>; ++i) <span class="comment">// i &lt;= K - 1</span></span><br><span class="line">      B[i] = ifac[i];</span><br><span class="line">    Poly::Mul(A, (m - <span class="number">1</span>) * (K - <span class="number">1</span>) + <span class="number">1</span>, B, K, A);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m * (K - <span class="number">1</span>); ++i)</span><br><span class="line">      h[m][i] = <span class="number">1L</span>L * fac[i] * A[i] % P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// f(m, i) = h(m, i) / (i ^ m)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt;= n; ++m)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m * (K - <span class="number">1</span>); ++i)</span><br><span class="line">      f[m][i] = <span class="number">1L</span>L * h[m][i] * fpow(inv[m], i) % P;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// g(m) = sum_&#123;i = 0&#125; ^ m (k-1) f(m, i)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt;= n; ++m) &#123;</span><br><span class="line">    g[m] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m * (K - <span class="number">1</span>); ++i)</span><br><span class="line">      g[m] = (g[m] + f[m][i]) % P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1L</span>L * C(n, k) * g[k] % P * n % P * inv[k] % P;</span><br><span class="line">    ans = (ans + ((k &amp; <span class="number">1</span>)? s: P - s)) % P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://uoj.ac/problem/449&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://uoj.ac/problem/449&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;个人现在感觉这是一道有启发意义的期望题.&lt;/p&gt;
&lt;p&gt;大体是利用 Min-Max 容斥计算期望, 以及 NTT 优化时间复杂度.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Polynomial" scheme="https://depletedprism.github.io/tags/Polynomial/"/>
    
      <category term="Probability &amp; Mean" scheme="https://depletedprism.github.io/tags/Probability-Mean/"/>
    
  </entry>
  
  <entry>
    <title>「清华集训 2017」生成树计数 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/uoj-335/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/uoj-335/</id>
    <published>2020-04-28T07:30:01.000Z</published>
    <updated>2020-04-29T03:27:17.648Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接: <a href="https://uoj.ac/problem/335" target="_blank" rel="noopener">https://uoj.ac/problem/335</a></li></ul><p>大概是利用树的 Prufer 序列解决某些计数问题, 第一次见感觉很新鲜.</p><a id="more"></a><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>先来考虑一个简化版的问题:</p><blockquote><p>在一个 $s$ 个点的图中, 存在 $s - n$ 条边, 使图中形成了 $n$ 个连通块, 第 $i$ 个连通块中有 $a_i$ 个点. 再连接 $n - 1$ 条边, 使得图连通.</p><p>求方案数.</p></blockquote><p>Prufer 序列有一个很基本的性质: 将一个有标号无根树用 $[1,\ n]$ 中的 $n - 2$ 个整数唯一表示.</p><p>将 $n$ 个连通块看作点, 那么这些点之间连 $n - 1$ 条边之后得出的连通图就是棵树, 对这棵树构造 Prufer 序列.</p><p>设 $n$ 个连通块的度数分别为 $d_i$, 则所有连通块度数之和为 $2n - 2$. 那么对于一组已经确定的 $d_i$, Prufer 序列的个数为</p><script type="math/tex; mode=display">\binom{n - 2}{d_1 - 1\; d_2 - 1\; \cdots\; d_n - 1}</script><p>可列出式子</p><script type="math/tex; mode=display">\binom{n - 2}{d_1 - 1\; d_2 - 1\; \cdots\; d_n - 1} \prod_{i = 1} ^ n a_i ^ {d_i}</script><p>式子最后的乘积就是考虑连通块内部对外连边的情况.</p><p>考虑用多项式定理去化简. 多项式定理即</p><script type="math/tex; mode=display">(x_1 + x_2 + \cdots + x_m) ^ n = \sum \binom{n}{n_1\ n_2\ \cdots\ n_m}\ x_1 ^ {n_1} x_2 ^ {n_2} \cdots x_m ^ {n_m}</script><p>其中 $\sum\limits_{i = 1} ^ m n_i = n$, $0 \le n_i \le n$.</p><p>记 $c_i = d_i -1$. (此时的 $c_i$ 也可理解为第 $i$ 个点在 Prufer 序列中的出现次数). 那么有</p><script type="math/tex; mode=display">\binom{n - 2}{c_1\ c_2\ \cdots\ c_n} \prod_{i = 1} ^ n a_i ^ {c_i} \cdot \left(\prod_{i = 1} ^ n a_i\right)</script><p><del>如果直接用 ci 的组合意义去考虑, 可以直接得到这个结果.</del></p><p>套多项式定理, 得</p><script type="math/tex; mode=display">(c_1 + c_2 + \cdots + c_n) ^ {n - 2} \prod_{i = 1} ^ n a_i</script><p>最终答案为</p><script type="math/tex; mode=display">s ^ {n - 2} \prod_{i = 1} ^ n a_i</script><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>沿用上面的思路, <del>其实只是套用多项式定理化简前的思路</del>. 那么答案可写作</p><script type="math/tex; mode=display">\sum_{T} \left( \prod_{i = 1} ^ n {d_i} ^ m \right) \left( \sum_{i = 1} ^ n {d_i} ^ m\right) = \binom{n - 2}{c_1\; c_2\; \cdots\; c_n} \sum_{i = 1} ^ n (c_i + 1) ^ m \cdot \prod_{i = 1} ^ n (c_i + 1) ^ m a_i ^ {c_i + 1}</script><p>将组合数拆开, 并从最后的乘积中提出来一项, 得到</p><script type="math/tex; mode=display">\frac{(n - 2)!}{\prod\limits_{i = 1} ^ n (c_i!)} \sum_{i = 1} ^ n (c_i+ 1) ^ {2m} a_i ^ {c_i + 1} \prod_{j \neq i} (c_j + 1) ^ m a_j ^ {c_j+1}</script><p>整理, 得</p><script type="math/tex; mode=display">(n - 2)! \prod_{i = 1} ^ n a_i \cdot \sum_{i = 1} ^ n \frac{1}{c_i!} (c_i + 1) ^ {2m} a_i ^ {c_i} \prod_{j \neq i} \frac{1}{c_j!} (c_j + 1) ^ m a_j ^ {c_j}</script><p>设后半部分 OGF 为 $F(x)$, 那么答案为</p><script type="math/tex; mode=display">(n - 2)! \prod_{i = 1} ^ n a_i \cdot [x ^ {n - 2}]F(x)</script><p>前半部分为常数, 直接计算即可. 现在的问题在于如何快速求 $F(x)$. 不妨设 $A(x)$, $B(x)$ 两个 EGF, 分别为</p><script type="math/tex; mode=display">A(x) = \sum_{k = 0} ^ \infty \frac{1}{k!} (k + 1) ^ {2m} x ^ k</script><script type="math/tex; mode=display">B(x) = \sum_{k = 0} ^ \infty \frac{1}{k!} (k + 1) ^ m x ^ k</script><p>此时的 $F(x)$ 可写作</p><script type="math/tex; mode=display">F(x) = \sum_{i = 1} ^ n \frac{A(a_i x)}{B(a_i x)} \prod_{j \neq i} B(a_j x)</script><p>利用对数解决这个乘积. 得</p><script type="math/tex; mode=display">F(x) = \sum_{i = 1} ^ n \frac{A(a_i x)}{B(a_i x)} \exp \left( \sum_{j \neq i} \ln B(a_j x) \right)</script><p>考虑到 $a_i$ 的影响, 这个好像不能直接做. 做一步转化, 在计算出 $\frac{A(x)}{B(x)}$ 及 $\ln B(x)$ 后, 对于第 $k$ 项系数乘 $\sum\limits_{i = 1} ^ n a_i ^ k$ 即可得出 $\sum\limits_{i = 1} ^ n \frac{A(a_i x)}{B(a_i x)}$ 和 $\sum\limits_{i = 1} ^ n \ln B(a_i x)$.</p><p>仅剩的问题是计算  $\sum\limits_{i = 1} ^ n a_i ^ k$. 设其 OGF 为 $G(x)$, 即</p><script type="math/tex; mode=display">G(x) = \sum_{k = 0} ^ \infty \left( \sum_{i = 1} ^ n a_i ^ k \right) x ^ k = \sum_{i = 1} ^ n \frac{1}{1 - a_i x}</script><p>此时的 $G(x)$ 不便于快速计算. 下面利用对数和导数对 $G(x)$ 进行转化, 使其成为乘积的形式.</p><p>注意到</p><script type="math/tex; mode=display">\ln (1 - a_i x)' = -\frac{a_i}{1 - a_i x}</script><p>而</p><script type="math/tex; mode=display">\frac{1}{1 - a_i x} = \frac{a_i x}{1 - a_i x} + 1</script><p>那么 $G(x)$ 可化作</p><script type="math/tex; mode=display">G(x) = n + \sum_{i = 1} ^ n \frac{a_i x}{1 - a_i x} = n - x \sum_{i = 1} ^ n \ln(1 - a_i x)'</script><p>考虑到求导的线性性, 以及对数的性质, 得到</p><script type="math/tex; mode=display">G(x) = n - x \left( \ln \prod_{i = 1} ^ n (1 - a_i x) \right)'</script><p>分治 FFT 计算即可. 时间复杂度 $O(n \log ^ 2 n)$.</p><p>另外存在基于第二类 Stirling 数的, 时间复杂度为 $O(nm\log ^ 2 n)$ 的做法, 在复杂度和推导过程上都不占优势.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>注意 $n = 1$ 的情况需要特判, UOJ 上有类似的 Hack 数据.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UOJ #335</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LOG = <span class="number">16</span>, MAXN = <span class="number">1</span> &lt;&lt; LOG | <span class="number">1</span>, P = <span class="number">998244353</span>, G = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> W[LOG][MAXN];</span><br><span class="line"><span class="keyword">int</span> inv[MAXN], fac[MAXN], ifac[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % P;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OutPoly</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%d%c"</span>, f[i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>, Mid = <span class="number">1</span>; Mid &lt; Lim; ++k, Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span>* w = W[k];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1L</span>L * w[j] * f[i+j+Mid] % P;</span><br><span class="line">                    f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> iv = fpow(Lim, P - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * iv % P;</span><br><span class="line">            reverse(f + <span class="number">1</span>, f + Lim);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">        g[<span class="number">0</span>] = fpow(f[<span class="number">0</span>], P - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">0</span>, Lim = <span class="number">1</span>, Mid = <span class="number">2</span>; Mid &lt; <span class="number">2</span>*n; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*Mid) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) A[i] = f[i], B[i] = g[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">            init(Lim, L), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i)</span><br><span class="line">                g[i] = ((B[i] + B[i]) % P - <span class="number">1L</span>L * A[i] * B[i] % P * B[i] % P + P) % P;</span><br><span class="line">            NTT(g, Lim, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = min(n, Mid); i &lt; Lim; ++i) g[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Der</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) g[i - <span class="number">1</span>] = <span class="number">1L</span>L * i * f[i] % P;</span><br><span class="line">        g[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Int</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i; --i) g[i] = <span class="number">1L</span>L * inv[i] * f[i - <span class="number">1</span>] % P;</span><br><span class="line">        g[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ln</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> ivf[MAXN], df[MAXN];</span><br><span class="line">        Der(f, df, n), Inv(f, ivf, n);</span><br><span class="line">        <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*n) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; Lim; ++i) ivf[i] = df[i] = <span class="number">0</span>;</span><br><span class="line">        init(Lim, L), NTT(df, Lim, <span class="number">1</span>), NTT(ivf, Lim, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) df[i] = <span class="number">1L</span>L * df[i] * ivf[i] % P;</span><br><span class="line">        NTT(df, Lim, <span class="number">-1</span>), Int(df, g, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Exp</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> lng[MAXN], A[MAXN], B[MAXN];</span><br><span class="line">        g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">0</span>, Lim = <span class="number">1</span>, Mid = <span class="number">2</span>; Mid &lt; <span class="number">2</span>*n; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            Ln(g, lng, Mid);</span><br><span class="line">            <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*Mid) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i)</span><br><span class="line">                A[i] = (f[i] - lng[i] + P) % P, B[i] = g[i];</span><br><span class="line">            A[<span class="number">0</span>] = (A[<span class="number">0</span>] + <span class="number">1</span>) % P;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">            init(Lim, L), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) g[i] = <span class="number">1L</span>L * A[i] * B[i] % P;</span><br><span class="line">            NTT(g, Lim, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = min(n, Mid); i &lt; Lim; ++i) g[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n, <span class="keyword">int</span>* g, <span class="keyword">const</span> <span class="keyword">int</span>&amp; m, <span class="keyword">int</span>* h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">        <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt; n + m - <span class="number">1</span>) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i)</span><br><span class="line">            A[i] = (i &lt; n)? f[i]: <span class="number">0</span>, B[i] = (i &lt; m)? g[i]: <span class="number">0</span>;</span><br><span class="line">        init(Lim, L), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) h[i] = <span class="number">1L</span>L * A[i] * B[i] % P;</span><br><span class="line">        NTT(h, Lim, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PolyPre</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">        inv[i] = <span class="number">1L</span>L * inv[P % i] * (P - P / i) % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        fac[i] = <span class="number">1L</span>L * i * fac[i - <span class="number">1</span>] % P;</span><br><span class="line">        ifac[i] = <span class="number">1L</span>L * inv[i] * ifac[i - <span class="number">1</span>] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> w, i = <span class="number">0</span>, Mid = <span class="number">1</span>; i &lt; LOG; ++i, Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        W[i][<span class="number">0</span>] = <span class="number">1</span>, w = fpow(G, (P - <span class="number">1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; Mid; ++j)</span><br><span class="line">            W[i][j] = <span class="number">1L</span>L * w * W[i][j - <span class="number">1</span>] % P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tmp[LOG &lt;&lt; <span class="number">1</span>][MAXN], ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123; <span class="comment">// [L, R)</span></span><br><span class="line">    <span class="keyword">if</span> (R - L &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>] = <span class="number">1</span>, f[<span class="number">1</span>] = (P - a[L]) % P, <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, *f0 = tmp[ptr++], *f1 = tmp[ptr++];</span><br><span class="line">    <span class="keyword">int</span> dl = solve(f0, L, Mid), dr = solve(f1, Mid, R);</span><br><span class="line">    Poly::Mul(f0, dl, f1, dr, f), ptr -= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> dl + dr - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN], ivB[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN], g[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(a[i]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">puts</span>((m == <span class="number">0</span>)? <span class="string">"1"</span>: <span class="string">"0"</span>), <span class="number">0</span>;</span><br><span class="line">    PolyPre(n);</span><br><span class="line">    <span class="comment">// A, B</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        A[i] = <span class="number">1L</span>L * ifac[i] * fpow(i + <span class="number">1</span>, <span class="number">2</span> * m) % P;</span><br><span class="line">        B[i] = <span class="number">1L</span>L * ifac[i] * fpow(i + <span class="number">1</span>, m) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    Poly::Inv(B, ivB, n + <span class="number">1</span>), Poly::Ln(B, B, n + <span class="number">1</span>);</span><br><span class="line">    Poly::Mul(A, n + <span class="number">1</span>, ivB, n + <span class="number">1</span>, A);</span><br><span class="line">    <span class="comment">// g</span></span><br><span class="line">    solve(g, <span class="number">1</span>, n + <span class="number">1</span>);</span><br><span class="line">    Poly::Ln(g, g, n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        g[i] = (P - <span class="number">1L</span>L * g[i] * i % P) % P;</span><br><span class="line">    g[<span class="number">0</span>] = n;</span><br><span class="line">    <span class="comment">// f</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        A[i] = <span class="number">1L</span>L * A[i] * g[i] % P, B[i] = <span class="number">1L</span>L * B[i] * g[i] % P;</span><br><span class="line">    Poly::Exp(B, f, n + <span class="number">1</span>);</span><br><span class="line">    Poly::Mul(f, n + <span class="number">1</span>, A, n + <span class="number">1</span>, f);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1L</span>L * fac[n - <span class="number">2</span>] * f[n - <span class="number">2</span>] % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ans = <span class="number">1L</span>L * ans * a[i] % P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>OI Wiki, <a href="https://oi-wiki.org/graph/prufer/#_3" target="_blank" rel="noopener">Prufer 序列</a></li><li>OwenOwl, <a href="https://www.luogu.com.cn/blog/mcfx0/p4002" target="_blank" rel="noopener">[清华集训2017]生成树计数 题解</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://uoj.ac/problem/335&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://uoj.ac/problem/335&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大概是利用树的 Prufer 序列解决某些计数问题, 第一次见感觉很新鲜.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Combinatorics" scheme="https://depletedprism.github.io/tags/Combinatorics/"/>
    
      <category term="Polynomial" scheme="https://depletedprism.github.io/tags/Polynomial/"/>
    
  </entry>
  
  <entry>
    <title>BJOI 2019 简要题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/BJOI-2019-sol/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/BJOI-2019-sol/</id>
    <published>2020-04-24T06:41:25.000Z</published>
    <updated>2020-05-14T13:22:22.003Z</updated>
    
    <content type="html"><![CDATA[<hr><p><del>听说大赏的意思好像和我之前认为的不太一样?</del></p><p>没文化啊.png</p><a id="more"></a><h3 id="「BJOI2019」奥术神杖"><a href="#「BJOI2019」奥术神杖" class="headerlink" title="「BJOI2019」奥术神杖"></a>「BJOI2019」奥术神杖</h3><p><del>为什么剧情里总是向过往寻求力量呢 (</del></p><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3089" target="_blank" rel="noopener">https://loj.ac/problem/3089</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>1 月份做过结果忘地一干二净</del></p><p>设选择后神杖上的宝石后, 得出的生效的咒语序列为 $a_i$. 如果答案比 $x$ 优, 那么有</p><script type="math/tex; mode=display">\left( \prod_{i = 1} ^ c V_{a_i} \right) ^ {1 / c} > x</script><p>运用一些运算的技巧, 有</p><script type="math/tex; mode=display">\ln \left( \sum_{i = 1} ^ c V_{a_i} \right) > c \ln x</script><script type="math/tex; mode=display">\ln \left( \sum_{i = 1} ^ c (V_{a_i} - c \ln x)\right) > 0</script><p>0-1 分数规划即可. 现在的重点在于计算中间和式的最大值.</p><p>考虑在 AC 自动机上 DP. 设 $f(i, u)$ 表示匹配到 $T$ 中第 $i$ 个位置, 以及 AC 自动机上第 $u$ 个节点在最大值.</p><p>那么根据 $T_i$ 处的字符转移即可, 输出方案可在 DP 时记录每次转移的选择就好了. 注意在处理权值时, 需要将 $u$ 的权值加到 $\operatorname{fail}(u)$ 上, 以及不要忽略多个串在同一节点上的情况.</p><p>记字符集大小为 $c$, 那么时间复杂度为 $O(nsc\log V)$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3089</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a &lt; b)? (a = b, <span class="literal">true</span>): <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">15e2</span> + <span class="number">5</span>, SIGMA = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-9</span>, INFD = <span class="number">1e9</span> * MAXN;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">fabs</span>(p) &lt; EPS)? <span class="number">0</span>: (p &lt; <span class="number">0</span>? <span class="number">-1</span>: <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> T[MAXN], S[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> f[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> g[MAXN][MAXN][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> AC &#123;</span><br><span class="line">  <span class="keyword">int</span> ch[MAXN][SIGMA], fail[MAXN], size[MAXN], nidx;</span><br><span class="line">  <span class="keyword">double</span> A[MAXN], val[MAXN];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; nidx = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">1</span>, lgt = <span class="built_in">strlen</span>(S + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lgt; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> c = S[i] - <span class="string">'0'</span>;</span><br><span class="line">      <span class="keyword">if</span> (!ch[u][c]) ch[u][c] = ++nidx;</span><br><span class="line">      u = ch[u][c];</span><br><span class="line">    &#125;</span><br><span class="line">    val[u] += w, ++size[u];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getfail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> Q[MAXN], head, tail;</span><br><span class="line">    Q[head = <span class="number">1</span>] = tail = <span class="number">0</span>, fail[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; SIGMA; ++c) &#123;</span><br><span class="line">      <span class="keyword">int</span>&amp; v = ch[<span class="number">1</span>][c];</span><br><span class="line">      <span class="keyword">if</span> (v) Q[++tail] = v, fail[v] = <span class="number">1</span>; <span class="keyword">else</span> v = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">      <span class="keyword">int</span> u = Q[head++];</span><br><span class="line">      size[u] += size[fail[u]], val[u] += val[fail[u]];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; SIGMA; ++c) &#123;</span><br><span class="line">        <span class="keyword">int</span>&amp; v = ch[u][c];</span><br><span class="line">        <span class="keyword">if</span> (v) Q[++tail] = v, fail[v] = ch[fail[u]][c];</span><br><span class="line">        <span class="keyword">else</span> v = ch[fail[u]][c];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; Mid, <span class="keyword">bool</span> flag = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= nidx; ++u)</span><br><span class="line">      A[u] = val[u] - Mid * size[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= nidx; ++u) f[i][u] = -INFD;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= nidx; ++u) <span class="keyword">if</span> (f[i - <span class="number">1</span>][u] &gt; -INFD) &#123;</span><br><span class="line">        <span class="keyword">if</span> (T[i] == <span class="string">'.'</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; SIGMA; ++c) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span>&amp; v = ch[u][c];</span><br><span class="line">            <span class="keyword">if</span> (ckmax(f[i][v], f[i - <span class="number">1</span>][u] + A[v]))</span><br><span class="line">              g[i][v][<span class="number">0</span>] = c, g[i][v][<span class="number">1</span>] = u;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">int</span> c = T[i] - <span class="string">'0'</span>, &amp;v = ch[u][c];</span><br><span class="line">          <span class="keyword">if</span> (ckmax(f[i][v], f[i - <span class="number">1</span>][u] + A[v]))</span><br><span class="line">            g[i][v][<span class="number">0</span>] = c, g[i][v][<span class="number">1</span>] = u;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">2</span>; u &lt;= nidx; ++u)</span><br><span class="line">      <span class="keyword">if</span> (f[n][u] &gt; f[n][v]) v = u;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> u = v, i = n; i; --i)</span><br><span class="line">        S[i] = g[i][u][<span class="number">0</span>] + <span class="string">'0'</span>, u = g[i][u][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dcmp(f[n][v]) &gt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  AC::init();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;n, &amp;m, T + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> w, i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, S + <span class="number">1</span>, &amp;w), AC::insert(<span class="built_in">log</span>(w));</span><br><span class="line"> </span><br><span class="line">  AC::getfail();</span><br><span class="line">  <span class="keyword">double</span> L = <span class="number">0.0</span>, R = <span class="built_in">log</span>(INFD);</span><br><span class="line">  <span class="keyword">while</span> (dcmp(R - L) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">double</span> Mid = (L + R) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (AC::check(Mid)) L = Mid; <span class="keyword">else</span> R = Mid;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  AC::check(L, <span class="literal">true</span>), <span class="built_in">puts</span>(S + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「BJOI2019」勘破神机"><a href="#「BJOI2019」勘破神机" class="headerlink" title="「BJOI2019」勘破神机"></a>「BJOI2019」勘破神机</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3090" target="_blank" rel="noopener">https://loj.ac/problem/3090</a></li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>先假设我们已经知道了第 $n$ 项的答案为 $h_n$. 那么所求即为 $\frac{1}{R - L + 1}$ 乘上</p><script type="math/tex; mode=display">\sum_{n = L} ^ R H(n, k) = \sum_{n = L} ^ R \binom{h_n}{k} = \frac{1}{k!} \sum_{n = L} ^ R {h_n} ^ {\underline k}</script><p>后者是下降幂的形式, 可以联想到</p><script type="math/tex; mode=display">x ^ {\underline{k}} = \sum_{i = 0} ^ k (-1) ^ {k - i} \begin{bmatrix} k \\ i \end{bmatrix} x ^ i</script><p>其中 $\begin{bmatrix} n \\ m \end{bmatrix}$ 表示第一类 Stirling 数. 此处可直接使用有符号第一类 Stirling 数来消去 $-1$.</p><p>那么原式可化作</p><script type="math/tex; mode=display">\frac{1}{k!} \sum_{n = L} ^ R \sum_{i = 0} ^ k (-1) ^ {k - i} \begin{bmatrix} k \\ i \end{bmatrix} {h_n} ^ i = \frac{1}{k!} \sum_{i = 0} ^ k (-1) ^ {k - i} \begin{bmatrix} k \\ i \end{bmatrix} \sum_{n = L} ^ R {h_n} ^ i</script><p>这就启发我们去求 $h_n$ 的通项公式.</p><p>先考虑 $m = 2$ 的情况, 此时是个经典问题. 记 Fibonacci 数列为 $f_n$, 且有 $f_0 = 0,\ f_1 = 1$, 那么 $f_{n + 1}$ 即为 $2 \times n$ 网格的填充方案, 此时直接将 $L, R + 1$.</p><p>根据 Fibonacci 数列的递推公式, 并利用特征方程可以解出 $f_n$ 的通项为</p><script type="math/tex; mode=display">f_n = \frac{1}{\sqrt 5} \left( \frac{1 + \sqrt 5}{2} \right) ^ n - \frac{1}{\sqrt 5} \left( \frac{1 - \sqrt 5}{2} \right) ^ n</script><p>设 $A = \frac{1}{\sqrt 5},\ B = -\frac{1}{\sqrt 5},\ x = \frac{1 + \sqrt 5}{2},\ y = \frac{1 - \sqrt 5}{2}$, 那么 $f_n = A x ^ n + B y ^ n$.</p><p>带入到原式继续化简, 可得</p><script type="math/tex; mode=display">\frac{1}{k!} \sum_{n = L} ^ R \sum_{i = 0} ^ k (-1) ^ {k - i} \begin{bmatrix} k \\ i \end{bmatrix} {h_n} ^ i = \frac{1}{k!} \sum_{i = 0} ^ k (-1) ^ {k - i} \begin{bmatrix} k \\ i \end{bmatrix} \sum_{n = L} ^ R (A x ^ n + B y ^ n) ^ i</script><script type="math/tex; mode=display">\frac{1}{k!} \sum_{i = 0} ^ k (-1) ^ {k - i} \begin{bmatrix} k \\ i \end{bmatrix} \sum_{n = L} ^ R \sum_{j = 0} ^ i \binom{i}{j} A^i B^{i - j} (x^j y^{i - j}) ^ n</script><script type="math/tex; mode=display">\frac{1}{k!} \sum_{i = 0} ^ k (-1) ^ {k - i} \begin{bmatrix} k \\ i \end{bmatrix} \sum_{j = 0} ^ i \binom{i}{j} A^i B^{i - j} \sum_{n = L} ^ R (x^j y^{i - j}) ^ n</script><p>后者为等比数列部分和, 直接计算 $O(\log R)$ 即可. 时间复杂度 $O(k ^ 2 \log R)$.</p><p>此时还有一个问题. 注意到 $5 ^ {(998244353 - 1) / 2} \equiv -1 \pmod {998244353}$, 即模意义下 $\sqrt{5}$ 不存在. 此时可运用称之为 “扩域” 的技巧, 也就是将数表示为 $x + \sqrt 5 y$ 的形式, 用类似于模意义下复数的方式进行运算. 同时, 最终结果一定为整数, 取 $x$ 值即可.</p><p>现在考虑 $m = 3$ 的情况. </p><p>手玩之后可以得出, 除去 $n = 2$ 的情况之外, 仅存在两种方式, 使得长度为偶数的网格被铺满, 且不是若干长度较小的偶数网格拼接而成. 同时, $n$ 为奇数时方案数为 $0$.</p><p>设 $g_n$ 为铺满 $3 \times 2n$ 网格的方案数. 则根据上述性质, 有</p><script type="math/tex; mode=display">g_n = \begin{cases} 0 & n = 0 \\ 3 & n = 1 \\ g_{n - 1} + 2 \sum\limits_{i = 1} ^ n g_{n - i} & n > 1\end{cases}</script><p>利用一些运算的技巧, 可得</p><script type="math/tex; mode=display">g_n = 4 g_{n - 1} - g_{n - 2}</script><p>利用之前的方法, 可以得出</p><script type="math/tex; mode=display">g_n = \left( \frac{3 + \sqrt{3}}{6} \right) (2 + \sqrt{3}) ^ n + \left( \frac{3 - \sqrt{3}}{6} \right) (2 - \sqrt{3}) ^ n</script><p>直接算就完事了.</p><p>时间复杂度 $O(k ^ 2 \log R)$. <del>然而存在时间复杂度更为优秀的神仙做法…</del></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>在利用快速幂计算 $x + \sqrt{5} y$ 的幂时, 不要天真地把指数模 $P - 1$…</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3090</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">5e2</span> + <span class="number">5</span>, P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Mod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span> </span>&#123; <span class="keyword">return</span> x + (x &gt;&gt; <span class="number">31</span> &amp; P); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mns</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123; <span class="keyword">return</span> Mod(a - b); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pls</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123; <span class="keyword">return</span> Mod(a + b - P); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1L</span>L * a * b % P; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stl[MAXK][MAXK];</span><br><span class="line"><span class="keyword">int</span> fac[MAXK], ifac[MAXK], inv[MAXK];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (n &lt; m)? <span class="number">0</span>: mul(mul(fac[n], ifac[m]), ifac[n - m]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = mul(ret, base);</span><br><span class="line">    base = mul(base, base), b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreDone</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">  inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">    inv[i] = mul(inv[P % i], P - P / i);</span><br><span class="line">  ifac[<span class="number">0</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    fac[i] = mul(i, fac[i - <span class="number">1</span>]), ifac[i] = mul(inv[i], ifac[i - <span class="number">1</span>]);</span><br><span class="line">  stl[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">      stl[i][j] = mns(stl[i - <span class="number">1</span>][j - <span class="number">1</span>], mul(i - <span class="number">1</span>, stl[i - <span class="number">1</span>][j]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL Sqrt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Int</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x, y; <span class="comment">// x + sqrt&#123;Sqrt&#125; y</span></span><br><span class="line">  Int (<span class="keyword">int</span> _x = <span class="number">0</span>, <span class="keyword">int</span> _y = <span class="number">0</span>): x(_x), y(_y) &#123; &#125;</span><br><span class="line">  Int <span class="keyword">operator</span> + (<span class="keyword">const</span> Int&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Int(pls(x, rhs.x), pls(y, rhs.y));</span><br><span class="line">  &#125;</span><br><span class="line">  Int <span class="keyword">operator</span> - (<span class="keyword">const</span> Int&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Int(mns(x, rhs.x), mns(y, rhs.y));</span><br><span class="line">  &#125;</span><br><span class="line">  Int <span class="keyword">operator</span> * (<span class="keyword">const</span> Int&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> ac = mul(x, rhs.x), ad = mul(x, rhs.y), bc = mul(y, rhs.x);</span><br><span class="line">    <span class="keyword">return</span> Int(pls(ac, Sqrt * y % P * rhs.y % P), pls(bc, ad));</span><br><span class="line">  &#125;</span><br><span class="line">  Int <span class="keyword">operator</span> / (<span class="keyword">const</span> Int&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> ac = mul(x, rhs.x), ad = mul(x, rhs.y), bc = mul(y, rhs.x);</span><br><span class="line">    <span class="keyword">int</span> iv = fpow(mns(mul(rhs.x, rhs.x), Sqrt * rhs.y % P * rhs.y % P), P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> Int(mns(ac, Sqrt * y % P * rhs.y % P), mns(bc, ad)) * iv;</span><br><span class="line">  &#125;</span><br><span class="line">  Int <span class="keyword">operator</span> += (<span class="keyword">const</span> Int&amp; rhs) &#123; <span class="keyword">return</span> x = pls(x, rhs.x), y = pls(y, rhs.y), *<span class="keyword">this</span>; &#125;</span><br><span class="line">  Int <span class="keyword">operator</span> -= (<span class="keyword">const</span> Int&amp; rhs) &#123; <span class="keyword">return</span> x = mns(x, rhs.x), y = pls(y, rhs.y), *<span class="keyword">this</span>; &#125;</span><br><span class="line">  Int <span class="keyword">operator</span> *= (<span class="keyword">const</span> Int&amp; rhs) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> * rhs; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Int <span class="title">conj</span><span class="params">(<span class="keyword">const</span> Int&amp; x)</span> </span>&#123; <span class="keyword">return</span> Int(x.x, mns(<span class="number">0</span>, x.y)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Int <span class="title">fpowInt</span><span class="params">(Int base, LL b)</span> </span>&#123;</span><br><span class="line">  Int ret = Int(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> ( ; b &gt; <span class="number">0</span>; base *= base, b &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret *= base;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Int <span class="title">Sum</span><span class="params">(<span class="keyword">const</span> LL&amp; L, <span class="keyword">const</span> LL&amp; R, <span class="keyword">const</span> Int&amp; q)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (q.x == <span class="number">1</span> &amp;&amp; q.y == <span class="number">0</span>) <span class="keyword">return</span> (R - L + <span class="number">1</span>) % P;</span><br><span class="line">  <span class="keyword">return</span> (fpowInt(q, R + <span class="number">1</span>) - fpowInt(q, L)) / (q - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(LL L, LL R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k, <span class="keyword">const</span> <span class="keyword">int</span>&amp; m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Int pa[MAXK], pb[MAXK], px[MAXK], py[MAXK], A, x;</span><br><span class="line">  <span class="keyword">int</span> lgt = (R - L + <span class="number">1</span>) % P;</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">2</span>)</span><br><span class="line">    Sqrt = <span class="number">5</span>, A = Int(<span class="number">0</span>, <span class="number">1</span>) / <span class="number">5</span>, x = Int(<span class="number">1</span>, <span class="number">1</span>) / <span class="number">2</span>, ++L, ++R;</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">3</span>)</span><br><span class="line">    Sqrt = <span class="number">3</span>, A = Int(<span class="number">3</span>, <span class="number">1</span>) / <span class="number">6</span>, x = Int(<span class="number">2</span>, <span class="number">1</span>), L = (L + <span class="number">1</span>) / <span class="number">2</span>, R /= <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  pa[<span class="number">0</span>] = pb[<span class="number">0</span>] = px[<span class="number">0</span>] = py[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">    pa[i] = pa[i - <span class="number">1</span>] * A, pb[i] = pb[i - <span class="number">1</span>] * conj(A);</span><br><span class="line">    px[i] = px[i - <span class="number">1</span>] * x, py[i] = py[i - <span class="number">1</span>] * conj(x);</span><br><span class="line">  &#125;</span><br><span class="line">  Int ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">    Int s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">      s += Sum(L, R, px[j] * py[i - j]) * pa[j] * pb[i - j] * C(i, j);</span><br><span class="line">    ret += s * stl[k][i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mul(fpow(lgt, P - <span class="number">2</span>), mul(ifac[k], ret.x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> Ti, m, k;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;Ti, &amp;m);</span><br><span class="line">  PreDone(MAXK - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (LL L, R; Ti; --Ti)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%d"</span>, &amp;L, &amp;R, &amp;k), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve(L, R, k, m));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「BJOI2019」送别"><a href="#「BJOI2019」送别" class="headerlink" title="「BJOI2019」送别"></a>「BJOI2019」送别</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3091" target="_blank" rel="noopener">https://loj.ac/problem/3091</a></li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a><del>解题思路</del></h4><p>送别 $\times$, 带走 $\checkmark$</p><h3 id="「BJOI2019」排兵布阵"><a href="#「BJOI2019」排兵布阵" class="headerlink" title="「BJOI2019」排兵布阵"></a>「BJOI2019」排兵布阵</h3><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3092" target="_blank" rel="noopener">https://loj.ac/problem/3092</a></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>这是一道定位在 NOIP Day 1 T2 的送分题 (</p><p>考虑 DP. 首先每个城堡和对手完全独立, 互不干扰. 设 $f(i, j)$ 表示已考虑完前 $i$ 个城堡, 小 C 剩余 $j$ 名士兵的得分最大值. 有</p><script type="math/tex; mode=display">f(i, j) = \max_{k} \{ f(i - 1, j - k) + w(i, k)\}</script><p>其中 $w(i, k)$ 表示对于城堡 $i$ 派遣 $k$ 名士兵, 所有对局的总得分. 显然有 $O(s)$ 的暴力计算方法, 将对手派遣士兵个数从小到大排序, 依次枚举, 可以 $O(1)$ 的时间内转移.</p><p>时间复杂度 $O(nms)$.</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3092</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a &lt; b)? a = b, <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e2</span> + <span class="number">5</span>, MAXM = <span class="number">2e4</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s, n, m;</span><br><span class="line"><span class="keyword">int</span> A[MAXN][MAXN], f[MAXN][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;s, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> w, i = <span class="number">1</span>; i &lt;= s; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w), A[j][i] = <span class="number">2</span> * w + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> *w, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    w = A[i], sort(w + <span class="number">1</span>, w + <span class="number">1</span> + s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= s &amp;&amp; j &gt;= w[k]; ++k)</span><br><span class="line">        ckmax(f[i][j], f[i - <span class="number">1</span>][j - w[k]] + k * i);</span><br><span class="line">      ckmax(ans, f[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「BJOI2019」光线"><a href="#「BJOI2019」光线" class="headerlink" title="「BJOI2019」光线"></a>「BJOI2019」光线</h3><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3093" target="_blank" rel="noopener">https://loj.ac/problem/3093</a></li></ul><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>这是一道物理题, 难点在于推式子.</p><p>设 $f_i$ 表示前 $i$ 层玻璃, 从第 $1$ 层玻璃射入光的透光率. 那么 $f_n$ 即为答案. 此时问题仍不好解决, 因为没有考虑到反射对答案的影响. 那么设 $g_n$ 表示从第 $n$ 层玻璃向上射入光的反射率. 因此有</p><script type="math/tex; mode=display">f_n = a_n \cdot f_{n - 1} \sum_{k = 0} ^ \infty (g_{n - 1} b_n) ^ k = a_n \cdot \frac{f_{n - 1}}{g_{n - 1} b_n}</script><p>表示透过第 $n$ 层的光来自上一层透过的光, 以及反射到上一层, 从而对本层做出贡献的部分.</p><script type="math/tex; mode=display">g_n = b_n + {a_n} ^ 2 g_{n - 1} \sum_{k = 0} ^ \infty (g_{n - 1} b_n) ^ k = b_n + \frac{ {a_n} ^ 2 g_{n - 1}}{g_{n - 1} b_n}</script><p>表示光在第 $n$ 层反射的贡献 ($b_n$), 另外有透过第 $n$ 层 (乘上 $a_n$), 并再次在第 $n - 1$ 层反射回来, 或是多次反射 ($g_{n - 1} \sum\limits_{k = 0} ^ \infty (g_{n - 1} b_n)$), 通过第 $n$ 层玻璃 (在原有基础上乘 $a_n$) 的部分.</p><p>递推计算即可. 时间复杂度 $O(n \log P)$.</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3093</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e5</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>, iv100 = <span class="number">570000004</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!b) x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> exgcd(b, a % b, y, x), y -= a / b * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> x, y;</span><br><span class="line">  <span class="keyword">return</span> exgcd(a, P, x, y), (x % P + P) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN], f[MAXN], g[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  read(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    read(A[i]), read(B[i]);</span><br><span class="line">    A[i] = <span class="number">1L</span>L * A[i] * iv100 % P, B[i] = <span class="number">1L</span>L * B[i] * iv100 % P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f[<span class="number">1</span>] = A[<span class="number">1</span>], g[<span class="number">1</span>] = B[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> iv = inv((<span class="number">1</span> - <span class="number">1L</span>L * B[i] * g[i - <span class="number">1</span>] % P + P) % P);</span><br><span class="line">    f[i] = <span class="number">1L</span>L * A[i] * f[i - <span class="number">1</span>] % P * iv % P;</span><br><span class="line">    g[i] = (B[i] + <span class="number">1L</span>L * A[i] * A[i] % P * g[i - <span class="number">1</span>] % P * iv % P) % P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「BJOI2019」删数"><a href="#「BJOI2019」删数" class="headerlink" title="「BJOI2019」删数"></a>「BJOI2019」删数</h3><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3094" target="_blank" rel="noopener">https://loj.ac/problem/3094</a></li></ul><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>可以发现每个数的位置在查询答案时是没有影响的. 如果将所有数丢到一个桶里, 即统计每个数的出现次数, 形成一个柱状的结构. 那么, 对于一次询问, 相当于将所有数向按值域所在位置向左填充, 或者形象地, 将柱子向左推倒. 此时 $[1,\ n]$ 中未覆盖位置即为答案.</p><p>同时要注意最大数 $&gt; n$, 此部分贡献单独统计 —- 因为一定会被修改, 而不能同前文一样计算向左覆盖的位置. 正确性证明大概是先证明此时得出的结果是所有答案的下界, 并将所有重复填充的位置选择一部分修改, 一定能达到这个下界.</p><p>现在的问题在于如何维护这个过程, 考虑用线段树去维护这个桶, 即维护每个位置被覆盖的次数.</p><p>对于计算答案, 记录区间最小值, 以及最小值出现的次数. 那么, 一个区间能做出贡献, 当且仅当该区间未被覆盖, 即区间最小值为 $0$, 用最小值出现次数更新答案即可. 向上合并时直接将子区间答案合并即可.</p><p>对于 $p &gt; 0$, 维护区间加的标记即可. 注意单独统计贡献的部分无需计算覆盖位置, 以及下传标记时需统计答案.</p><p>对于 $p = 0$, 也就是全局修改. 对应在桶中的影响, 也就是整体位移. 直接记录当前桶中 $0$ 的位置 $p_0$, 每次对应修改 $p_0$ 即可, 那么查询的区间为 $[p_0 + 1,\ p_0 + n]$.</p><p>值得留意的地方依旧是 $&gt; p_0 + n$ 的位置, 注意加上 / 减去边界的覆盖情况.</p><p>时间复杂度 $O(m \log n)$.</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3094</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1.5e5</span> + <span class="number">5</span>, MAXM = MAXN &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p0, N;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], bkt[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (nd &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (nd &lt;&lt; 1 | 1)</span></span><br><span class="line">  <span class="keyword">int</span> Mn[MAXM &lt;&lt; <span class="number">2</span>], Cnt[MAXM &lt;&lt; <span class="number">2</span>], dat[MAXM &lt;&lt; <span class="number">2</span>], tag[MAXM &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; nd)</span> </span>&#123;</span><br><span class="line">    dat[nd] = dat[lc] + dat[rc];</span><br><span class="line">    Mn[nd] = min(Mn[lc], Mn[rc]);</span><br><span class="line">    Cnt[nd] = (Mn[lc] == Mn[nd]) * Cnt[lc] + (Mn[rc] == Mn[nd]) * Cnt[rc];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; nd, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    tag[nd] += v, Mn[nd] += v, dat[nd] = (Mn[nd] == <span class="number">0</span>) * Cnt[nd];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; nd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag[nd] != <span class="number">0</span>)</span><br><span class="line">      push(lc, tag[nd]), push(rc, tag[nd]), tag[nd] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">void</span>( Cnt[nd] = dat[nd] = <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    build(lc, L, Mid), build(rc, Mid + <span class="number">1</span>, R);</span><br><span class="line">    maintain(nd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> push(nd, v);</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    pushdown(nd);</span><br><span class="line">    <span class="keyword">if</span> (opL &lt;= Mid) Mdy(lc, L, Mid, opL, opR, v);</span><br><span class="line">    <span class="keyword">if</span> (opR &gt; Mid) Mdy(rc, Mid + <span class="number">1</span>, R, opL, opR, v);</span><br><span class="line">    maintain(nd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> dat[nd];</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    pushdown(nd);</span><br><span class="line">    <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> Qry(lc, L, Mid, opL, opR);</span><br><span class="line">    <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> Qry(rc, Mid + <span class="number">1</span>, R, opL, opR);</span><br><span class="line">    <span class="keyword">return</span> Qry(lc, L, Mid, opL, opR) + Qry(rc, Mid + <span class="number">1</span>, R, opL, opR);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; v, <span class="keyword">const</span> <span class="keyword">int</span>&amp; d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = (d &gt; <span class="number">0</span>)? v - bkt[v]: v - bkt[v] + <span class="number">1</span>;</span><br><span class="line">  SGT::Mdy(<span class="number">1</span>, <span class="number">1</span>, N, p, p, d), bkt[v] += d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  read(n), read(m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]);</span><br><span class="line"></span><br><span class="line">  N = (m + n) * <span class="number">2</span> + <span class="number">1</span>, p0 = m + n;</span><br><span class="line">  SGT::build(<span class="number">1</span>, <span class="number">1</span>, N);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) A[i] += p0, Mdy(A[i], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> p, x; m; --m) &#123;</span><br><span class="line">    read(p), read(x);</span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (A[p] &lt;= p0 + n) Mdy(A[p], <span class="number">-1</span>); <span class="keyword">else</span> --bkt[A[p]];</span><br><span class="line">      A[p] = p0 + x;</span><br><span class="line">      <span class="keyword">if</span> (A[p] &lt;= p0 + n) Mdy(A[p], <span class="number">1</span>); <span class="keyword">else</span> ++bkt[A[p]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      p = (x &lt; <span class="number">0</span>)? (p0 + <span class="number">1</span>) + n: p0 + n;</span><br><span class="line">      <span class="keyword">if</span> (bkt[p] &gt; <span class="number">0</span>)</span><br><span class="line">        SGT::Mdy(<span class="number">1</span>, <span class="number">1</span>, N, p - bkt[p] + <span class="number">1</span>, p, -x);</span><br><span class="line">      p0 -= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, SGT::Qry(<span class="number">1</span>, <span class="number">1</span>, N, p0 + <span class="number">1</span>, p0 + n));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;del&gt;听说大赏的意思好像和我之前认为的不太一样?&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;没文化啊.png&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>ZJOI 2015 大赏</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/ZJOI-2015-sol/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/ZJOI-2015-sol/</id>
    <published>2020-04-21T08:57:39.000Z</published>
    <updated>2020-05-25T11:35:17.531Z</updated>
    
    <content type="html"><![CDATA[<hr><p>做这套题纯粹是为了好玩… 结果惨遭吊打 = =</p><a id="more"></a><h3 id="「ZJOI2015」幻想乡战略游戏"><a href="#「ZJOI2015」幻想乡战略游戏" class="headerlink" title="「ZJOI2015」幻想乡战略游戏"></a>「ZJOI2015」幻想乡战略游戏</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2135" target="_blank" rel="noopener">https://loj.ac/problem/2135</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>点分树是不可能的, 这辈子不可能写的. 数据结构又不会, 只能写写模板这样子.</del></p><p>考虑重链剖分.</p><p>不妨钦定 $1$ 为根. 记 $s_u$ 为 $u$ 子树内 $d$ 值之和. 对于一条边 $(u, v)$, 如果选择 $v$ 比 $u$ 更优, 也就是最终花费的变化量为负, 即</p><script type="math/tex; mode=display">w(u, v) \cdot (s_u - s_v) - w(u, v) \cdot s_v < 0 \\\ 2 s_v > s_u</script><p>因此有一个在线段树上二分 DFS 序, 找出最优点 $v$ 的做法.</p><p>同时记 $\text{dist}(u)$ 为点 $u$ 到根节点的距离, 那么最小花费可以表示为</p><script type="math/tex; mode=display">\sum_{v = 1} ^ n d_v \cdot \text{dist}(u, v) = \sum_{v = 1} ^ n d_v \cdot \big(\text{dist}(u) + \text{dist}(v) - 2 \text{dist}(\text{LCA}(u, v))\big)</script><script type="math/tex; mode=display">\text{dist}(u) \sum_{v = 1} ^ n d_v + \sum_{v = 1} ^ n d_v \cdot \text{dist}(v) - 2 \sum_{v = 1} ^ n d_v \cdot \text{dist}(\text{LCA}(u, v))</script><p>前两项很好维护, 记录 $d_v$ 和 $d_v \cdot \text{dist}(v)$ 的和即可.</p><p>注意到 $u$ 的子树内的点, 同 $u$ 的 LCA 一定是 $u$, 而其他点和 $u$ 的 LCA 一定在 $u$ 到根的路径上.</p><p>考虑使用重链剖分统计这些可能成为 LCA 的点对答案的贡献.</p><p>每次 $d_v$ 改变时, 从 $v$ 到根节点依次修改, 将变化量 $e$ 加入子树内包含 $v$ 的节点上. 设这些节点为 $u$, $u$ 的父亲节点为 $f$, 此时对答案贡献的变化即为 $e \cdot \big( \text{dist}(u) - \text{dist}(f) \big)$, 即 $u$ 到 $f$ 的边贡献的变化量. 用线段树维护就好了.</p><p>查询直接对统计的这些贡献求和即可.</p><p>时间复杂度 $O(n + q \log ^ 2 n)$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2135</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line">LL A[MAXN], dist[MAXN];</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN], rnk[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, w; &#125; edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, w &#125;, head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (nd&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (nd&lt;&lt;1|1)</span></span><br><span class="line">    LL s[MAXN &lt;&lt; <span class="number">2</span>], w[MAXN &lt;&lt; <span class="number">2</span>], datSum[MAXN &lt;&lt; <span class="number">2</span>], tagAdd[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">        s[nd] = max(s[lc], s[rc]);</span><br><span class="line">        datSum[nd] = datSum[lc] + datSum[rc];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushAdd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; nd, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">        s[nd] += v, tagAdd[nd] += v, datSum[nd] += w[nd] * v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tagAdd[nd] != <span class="number">0</span>)</span><br><span class="line">            pushAdd(lc, tagAdd[nd]), pushAdd(rc, tagAdd[nd]), tagAdd[nd] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> <span class="keyword">void</span>( w[nd] = A[L] );</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        build(lc, L, Mid), build(rc, Mid+<span class="number">1</span>, R);</span><br><span class="line">        w[nd] = w[lc] + w[rc];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR, <span class="keyword">const</span> <span class="keyword">int</span>&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> pushAdd(nd, d);</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        pushdown(nd);</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= Mid) Mdy(lc, L, Mid, opL, opR, d);</span><br><span class="line">        <span class="keyword">if</span> (opR &gt; Mid) Mdy(rc, Mid+<span class="number">1</span>, R, opL, opR, d);</span><br><span class="line">        maintain(nd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> datSum[nd];</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        pushdown(nd);</span><br><span class="line">        <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> Qry(lc, L, Mid, opL, opR);</span><br><span class="line">        <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> Qry(rc, Mid+<span class="number">1</span>, R, opL, opR);</span><br><span class="line">        <span class="keyword">return</span> Qry(lc, L, Mid, opL, opR) + Qry(rc, Mid+<span class="number">1</span>, R, opL, opR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Qry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Mid, nd = <span class="number">1</span>, L = <span class="number">1</span>, R = n;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">            Mid = (L + R) / <span class="number">2</span>, pushdown(nd);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * s[rc] &gt;= s[<span class="number">1</span>]) nd = rc, L = Mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> nd = lc, R = Mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rnk[L];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HLD &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">int</span> size[MAXN], son[MAXN], pre[MAXN], topfa[MAXN], clk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        pre[u] = fa, son[u] = <span class="number">-1</span>, size[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) == fa) <span class="keyword">continue</span>;</span><br><span class="line">            dist[v] = dist[u] + edges[i].w;</span><br><span class="line">            dfs1(v, u), size[u] += size[v];</span><br><span class="line">            <span class="keyword">if</span> (son[u] == <span class="number">-1</span> || size[v] &gt; size[son[u]]) son[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">        topfa[u] = top, rnk[dfn[u] = ++clk] = u;</span><br><span class="line">        A[clk] = dist[u] - dist[pre[u]];</span><br><span class="line">        <span class="keyword">if</span> (~son[u]) dfs2(son[u], top);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) != pre[u] &amp;&amp; v != son[u]) dfs2(v, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt = <span class="number">1</span>)</span> </span>&#123; dfs1(rt, <span class="number">0</span>), dfs2(rt, rt); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; p, <span class="keyword">const</span> <span class="keyword">int</span>&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = p; u &gt; <span class="number">0</span>; u = pre[topfa[u]])</span><br><span class="line">            SGT::Mdy(<span class="number">1</span>, <span class="number">1</span>, n, dfn[topfa[u]], dfn[u], d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; p)</span> </span>&#123;</span><br><span class="line">        LL ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = p; u &gt; <span class="number">0</span>; u = pre[topfa[u]])</span><br><span class="line">            ret += SGT::Qry(<span class="number">1</span>, <span class="number">1</span>, n, dfn[topfa[u]], dfn[u]);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, w, i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        read(u), read(v), read(w);</span><br><span class="line">        Graph::AddEdge(u, v, w), Graph::AddEdge(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    HLD::solve(<span class="number">1</span>), SGT::build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    LL sumd = <span class="number">0</span>, sumdd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> rt, u, e; q; --q) &#123;</span><br><span class="line">       read(u), read(e);</span><br><span class="line">       sumd += e, sumdd += e * dist[u];</span><br><span class="line">       HLD::Mdy(u, e), rt = SGT::Qry();</span><br><span class="line">       LL ret = sumdd + sumd * dist[rt] - <span class="number">2</span> * HLD::Qry(rt);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「ZJOI2015」地震后的幻想乡"><a href="#「ZJOI2015」地震后的幻想乡" class="headerlink" title="「ZJOI2015」地震后的幻想乡"></a>「ZJOI2015」地震后的幻想乡</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2136" target="_blank" rel="noopener">https://loj.ac/problem/2136</a></li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>套 Min/Max 容斥结果越想越偏是屑…</del></p><p>这里是一个平民做法.</p><p>考虑如何运用提示给出的公式. 模拟 Kruskal 的过程, 假定第 $k$ 次加入边后恰好得到一棵生成树, 那么对答案的贡献为 $\frac{k}{m + 1}$, 同时概率可以用合法方案数除以总方案数得出.</p><p>注意到一棵生成树的权值是对所有边取 $\max$. 那么对于一个连通图, 在该连通图恰好连通时内部边权的最大值, 和生成树的边权最大值是相同的, 因此可以从图的连通上考虑.</p><p>但是在恰好第 $k$ 次加入边得到连通图的情况不好统计, 做一步转化: 恰好加入第 $k$ 条边后图连通的方案数, 为: 加入这条边前不连通的方案数 - 加入这条边后不连通的方案数.</p><p>考虑用状压 DP 来求这个东西. 设 $f(S, i)$ 为当前选择的点集为 $S$, 已经使用了 $i$ 条边, 点集不连通的方案数.</p><p>记点集的全集为 $U$, $d(S)$ 为同点集 $S$ 相关的边的个数, 那么答案为</p><script type="math/tex; mode=display">\sum_{k = 1} ^ m \frac{k}{m + 1} \left(\frac{f(U, k - 1)}{\binom{d(U)}{k - 1}} - \frac{f(U, k)}{\binom{d(U)}{k}}\right)</script><p>化简, 得</p><script type="math/tex; mode=display">\frac{1}{m + 1} \sum_{k = 1} ^ {m - 1} \frac{f(U, k)}{\binom{d(U)}{k}}</script><p>同时, 点集连通的方案数为 $\binom{d(S)}{i} - f(S, i)$, 其中 $d(S)$ 可以通过枚举子集算出, 而点集连通时的方案数在转移 $f$ 时会用到.</p><p>点集不连通的情况可看作由一个连通非空子集上加边, 并保证新加入的点中存在不连通情况得出的. 因此有</p><script type="math/tex; mode=display">f(S, i) = \sum_{ T \subset S,\ T \neq \varnothing } \sum_{j = 0} ^ {d(T)} \binom{d(S \setminus T)}{i - j} \cdot \left(\binom{d(T)}{j} - f(T, j)\right)</script><p>枚举子集转移即可. 注意转移时, 需要钦定 $S$ 中某个点, 使得 $T$ 必须包含该点, 否则会重复计算一些情况. 实现时可使用 <code>lowbit</code>.</p><p>至于为什么钦点一个点是对的, 可参看 <a href="https://www.luogu.com.cn/blog/command-block/solution-p3343" target="_blank" rel="noopener">command_block 的题解</a></p><p>时间复杂度大概是 $O(m3 ^ n)$?</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>轻微压行.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2136</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10</span>, MAXM = MAXN * (MAXN - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">1</span> &lt;&lt; MAXN], d[<span class="number">1</span> &lt;&lt; MAXN];</span><br><span class="line">LL f[<span class="number">1</span> &lt;&lt; MAXN][MAXM], C[MAXM][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), ++c[<span class="number">1</span> &lt;&lt; (u<span class="number">-1</span>) | <span class="number">1</span> &lt;&lt; (v<span class="number">-1</span>)];</span><br><span class="line">    <span class="comment">// predone</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = C[i][<span class="number">0</span>] = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            C[i][j] = C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j];</span><br><span class="line">    <span class="keyword">int</span> U = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= U; ++s)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = s; t; t = (t<span class="number">-1</span>) &amp; s) d[s] += c[t];</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= U; ++s) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= d[s]; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = (s - <span class="number">1</span>) &amp; s; t; t = (t<span class="number">-1</span>) &amp; s) <span class="keyword">if</span> (t &amp; (s &amp; -s))</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i &amp;&amp; j &lt;= d[t]; ++j)</span><br><span class="line">                f[s][i] += (C[d[t]][j] - f[t][j]) * C[d[s ^ t]][i - j];</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k) ans += f[U][k] / <span class="keyword">double</span>(C[d[U]][k]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, ans / (m + <span class="number">1.0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「ZJOI2015」诸神眷顾的幻想乡"><a href="#「ZJOI2015」诸神眷顾的幻想乡" class="headerlink" title="「ZJOI2015」诸神眷顾的幻想乡"></a>「ZJOI2015」诸神眷顾的幻想乡</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2137" target="_blank" rel="noopener">https://loj.ac/problem/2137</a></li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>考虑广义 SAM, <del>以及不要读错题, 这题没了</del>.</p><p>显然本质不同子串个数可以通过 SAM 来求.</p><p>注意到一个重要的条件: “一个空地相邻的空地数量不超过 $20$ 个”, 即叶子个数不超过 $20$. 那么从每个叶子开始, 遍历整棵树, 同时建广义 SAM 即可. <del>本质上大概是在 Trie 上建 SAM?</del></p><p>设叶子个数为 $L$, 那么时间复杂度为 $O(nL)$.</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2137</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, C; LL ans;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], deg[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SAM &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = ::MAXN * <span class="number">40</span>, SIGMA = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][SIGMA], lnk[MAXN], len[MAXN], nidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; nidx = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> lst)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = lst;</span><br><span class="line">        <span class="keyword">if</span> (ch[p][val] &amp;&amp; len[ch[p][val]] == len[p] + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> ch[p][val];</span><br><span class="line">        <span class="keyword">int</span> nd = ++nidx, flag = <span class="literal">false</span>;</span><br><span class="line">        len[nd] = len[lst] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !ch[p][val]) ch[p][val] = nd, p = lnk[p];</span><br><span class="line">        <span class="keyword">if</span> (!p) lnk[nd] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> q = ch[p][val];</span><br><span class="line">            <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) lnk[nd] = q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> nxt = ++nidx;</span><br><span class="line">                <span class="keyword">if</span> (p == lst) flag = <span class="literal">true</span>;</span><br><span class="line">                len[nxt] = len[p] + <span class="number">1</span>, lnk[nxt] = lnk[q];</span><br><span class="line">                <span class="built_in">memcpy</span>(ch[nxt], ch[q], <span class="keyword">sizeof</span> ch[nxt]);</span><br><span class="line">                <span class="keyword">while</span> (p &amp;&amp; ch[p][val] == q) ch[p][val] = nxt, p = lnk[p];</span><br><span class="line">                lnk[nd] = lnk[q] = nxt;</span><br><span class="line">                <span class="keyword">if</span> (flag) <span class="keyword">return</span> nxt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += len[nd] - len[lnk[nd]];</span><br><span class="line">        <span class="keyword">return</span> nd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> lst)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nd = SAM::Ins(A[u], lst);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) != fa) dfs(v, u, nd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    SAM::init(), Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(C);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        read(u), read(v), ++deg[u], ++deg[v];</span><br><span class="line">        Graph::AddEdge(u, v), Graph::AddEdge(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">        <span class="keyword">if</span> (deg[u] == <span class="number">1</span>) Graph::dfs(u, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「ZJOI2015」黑客技术"><a href="#「ZJOI2015」黑客技术" class="headerlink" title="「ZJOI2015」黑客技术"></a>「ZJOI2015」黑客技术</h3><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://uoj.ac/problem/116" target="_blank" rel="noopener">https://uoj.ac/problem/116</a></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a><del>解题思路</del></h4><p><del>玩一个上午结果不如随缘乱敲分高是屑…</del></p><p>奥妙啊.</p><h3 id="「ZJOI2015」醉醺醺的幻想乡"><a href="#「ZJOI2015」醉醺醺的幻想乡" class="headerlink" title="「ZJOI2015」醉醺醺的幻想乡"></a>「ZJOI2015」醉醺醺的幻想乡</h3><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2138" target="_blank" rel="noopener">https://loj.ac/problem/2138</a></li></ul><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>很厉害的一道题, 以及一个很厉害的题解: <a href="http://c-sunshine.blog.uoj.ac/blog/563" target="_blank" rel="noopener">http://c-sunshine.blog.uoj.ac/blog/563</a>.</p><p>如果单位酿酒量 $x$ 只能是整数, 那么就很好解决了: 将费用差分, 根据差分后的结果将原有边拆为 $c_i$, 也就是容量条边.</p><p>但是这里的 $x$ 可以是非负实数, 且最后的结果要求没有精度误差. 因此要使用上述题解的做法. 大体是对费用求导, 然后再积分计算…</p><p>注意到每次跑网络流时得到的是一个一次函数, 容易在残量网络中得出斜率 $k$ 以及截距 $b$, 通过斜截式就比较容易理解代码中的式子.</p><p>以及上述题解代码将半平面上的点和线都写为 <code>pair&lt;frac, frac&gt;</code>, 我的代码将两者区分开了, 这样就会清晰许多.</p><p>记网络流建图时点数为 $V$, 边数为 $E$, 时间复杂度为 $O(n V ^ 2 E)$.</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2138</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e2</span> + <span class="number">5</span>, MAXV = <span class="number">2</span> * MAXN;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eeps = <span class="number">1e-9</span>, EPS = <span class="number">1e-6</span>, INFD = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123; <span class="keyword">return</span> !b? a: gcd(b, a % b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">fabs</span>(p) &lt; eeps)? <span class="number">0</span>: (p &lt; <span class="number">0</span>? <span class="number">-1</span>: <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Frac</span> &#123;</span></span><br><span class="line">    LL x, y;</span><br><span class="line">    Frac(LL _x = <span class="number">0</span>, LL _y = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_x == <span class="number">0</span>) x = <span class="number">0</span>, y = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> x = _x / gcd(_x, _y), y = _y / gcd(_x, _y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Frac <span class="keyword">operator</span> + (<span class="keyword">const</span> Frac&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Frac(x * rhs.y + y * rhs.x, y * rhs.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Frac <span class="keyword">operator</span> - (<span class="keyword">const</span> Frac&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Frac(x * rhs.y - y * rhs.x, y * rhs.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Frac <span class="keyword">operator</span> * (<span class="keyword">const</span> Frac&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Frac(x * rhs.x, y * rhs.y); &#125;</span><br><span class="line">    Frac <span class="keyword">operator</span> / (<span class="keyword">const</span> Frac&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Frac(x * rhs.y, y * rhs.x); &#125;</span><br><span class="line">    Frac <span class="keyword">operator</span> += (<span class="keyword">const</span> Frac&amp; rhs) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> + rhs; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">val</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">1.0</span> * x / y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">    Frac k, b; <span class="comment">// y = kx + b;</span></span><br><span class="line">    Line(Frac _k, Frac _b): k(_k), b(_b) &#123; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Line&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> k.x == rhs.k.x &amp;&amp; k.y == rhs.k.y &amp;&amp; b.x == rhs.b.x &amp;&amp; b.y == rhs.b.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    Frac x, y;</span><br><span class="line">    Point(Frac _x, Frac _y): x(_x), y(_y) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, S, T;</span><br><span class="line"><span class="keyword">int</span> M[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN], C[MAXN], D[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Point&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> to; <span class="keyword">double</span> cap, flow;</span><br><span class="line">        Edge(<span class="keyword">int</span> _v, <span class="keyword">double</span> _c, <span class="keyword">double</span> _f): to(_v), cap(_c), flow(_f) &#123; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXV];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _n)</span> </span>&#123;</span><br><span class="line">        edges.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _n; ++i) G[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> c)</span> </span>&#123;</span><br><span class="line">        edges.push_back(Edge(to, c, <span class="number">0.0</span>));</span><br><span class="line">        edges.push_back(Edge(from, <span class="number">0.0</span>, <span class="number">0.0</span>));</span><br><span class="line">        <span class="keyword">int</span> eidx = edges.size() - <span class="number">1</span>;</span><br><span class="line">        G[from].push_back(eidx - <span class="number">1</span>), G[to].push_back(eidx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Dinic &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">size_t</span> cur[MAXV];</span><br><span class="line">    <span class="keyword">int</span> depth[MAXV], vis[MAXV], Time;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        Q.push(S), vis[S] = ++Time, depth[S] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; G[u].size(); ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> Edge&amp; e = edges[G[u][i]];</span><br><span class="line">                <span class="keyword">if</span> (vis[e.to] != Time &amp;&amp; dcmp(e.cap - e.flow) &gt; <span class="number">0</span>)</span><br><span class="line">                    vis[e.to] = Time, depth[e.to] = depth[u] + <span class="number">1</span>, Q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[T] == Time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == T || !dcmp(a)) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">double</span> f, flow = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span>&amp; i = cur[u]; i &lt; G[u].size(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[u][i]];</span><br><span class="line">            <span class="keyword">if</span> (depth[e.to] == depth[u] + <span class="number">1</span> &amp;&amp;</span><br><span class="line">                    dcmp(f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                flow += f, a -= f, e.flow += f, edges[G[u][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">                <span class="keyword">if</span> (!dcmp(a)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Maxflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> flow = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS())</span><br><span class="line">            <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span> cur), flow += DFS(S, INFD);</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Line <span class="title">calc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; limit)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init(T + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// build graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (B[i] &lt;= limit) Graph::AddEdge(S, i, C[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (B[i] &lt;= limit) &#123;</span><br><span class="line">            <span class="keyword">double</span> c = (limit - B[i]) / (<span class="number">2.0</span> * A[i]);</span><br><span class="line">            Graph::AddEdge(S, i, min(<span class="number">1.0</span> * C[i], c));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        Graph::AddEdge(n + j, T, D[j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">if</span> (M[i][j]) Graph::AddEdge(i, n + j, INFD);</span><br><span class="line">    <span class="comment">// check</span></span><br><span class="line">    Dinic::Maxflow();</span><br><span class="line">    Frac k = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Dinic::vis[i] == Dinic::Time) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (B[i] &lt;= limit) b += C[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (B[i] &lt;= limit) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2.0</span> * A[i] * C[i] + B[i] &gt; limit)</span><br><span class="line">                k += Frac(<span class="number">1</span>, <span class="number">2</span> * A[i]), b += Frac(-B[i], <span class="number">2</span> * A[i]);</span><br><span class="line">            <span class="keyword">else</span> b += C[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        <span class="keyword">if</span> (Dinic::vis[n + j] == Dinic::Time) b += D[j];</span><br><span class="line">    <span class="keyword">return</span> Line(k, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Divide</span><span class="params">(<span class="keyword">const</span> Line&amp; L, <span class="keyword">const</span> Line&amp; R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">    Frac px = (L.b - R.b) / (R.k - L.k);</span><br><span class="line">    Line mL = calc(px.val() - EPS), mR = calc(px.val() + EPS);</span><br><span class="line">    <span class="keyword">if</span> (L == mL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>( P.push_back(Point(px, px * L.k + L.b)) );</span><br><span class="line">    Divide(L, mL), Divide(mR, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, A + i, B + i, C + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, D + j);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, M[i] + j);</span><br><span class="line">    <span class="comment">// solve 1</span></span><br><span class="line">    S = <span class="number">0</span>, T = n + m + <span class="number">1</span>;</span><br><span class="line">    Graph::init(T + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) Graph::AddEdge(S, i, C[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) Graph::AddEdge(n + j, T, D[j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">if</span> (M[i][j]) Graph::AddEdge(i, n + j, INFD);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%0.lf\n"</span>, Dinic::Maxflow());</span><br><span class="line">    <span class="comment">// solve 2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= <span class="number">4</span>; ++x) &#123;</span><br><span class="line">        <span class="keyword">double</span> L = x - <span class="number">1</span>, R = (x &lt;= <span class="number">3</span>)? x: INFD;</span><br><span class="line">        Line l1 = calc(L + EPS), l2 = calc(R - EPS);</span><br><span class="line">        P.push_back(Point(Frac(L), l1.k * Frac(L) + l1.b));</span><br><span class="line">        Divide(l1, l2);</span><br><span class="line">        P.push_back(Point(Frac(R), l2.k * Frac(R) + l2.b));</span><br><span class="line">    &#125;</span><br><span class="line">    P.pop_back();</span><br><span class="line">    Frac ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; P.size(); ++i)</span><br><span class="line">        ans += (P[i].y + P[i - <span class="number">1</span>].y) * (P[i].x - P[i - <span class="number">1</span>].x);</span><br><span class="line">    <span class="keyword">const</span> Point&amp; p = P.back();</span><br><span class="line">    ans = p.x * p.y - Frac(<span class="number">1</span>, <span class="number">2</span>) * ans;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld/%lld\n"</span>, ans.x, ans.y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「ZJOI2015」幻想乡-Wi-Fi-搭建计划"><a href="#「ZJOI2015」幻想乡-Wi-Fi-搭建计划" class="headerlink" title="「ZJOI2015」幻想乡 Wi-Fi 搭建计划"></a>「ZJOI2015」幻想乡 Wi-Fi 搭建计划</h3><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2139" target="_blank" rel="noopener">https://loj.ac/problem/2139</a></li></ul><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>对着费用流建半天图还调半天结果发现假了是屑…</del></p><p>首先第一问容易有在 $O(nm)$ 的时间复杂度内计算的方法, 下文不再考虑覆盖不到的景点.</p><p>先考虑架设点只在一边的情况. 有一个结论: 将架设点和景点分别按照 $x$ 坐标排序, 那么在最优的方案下, 选择的架设点覆盖到的景点一定是排序后连续的一段.</p><p>证明大概是利用长方形宽为 $R$, 同时覆盖半径为 $R$, 恰好不能构造出反例吧… 不大会证.png</p><p>有了这个条件, 直接记录选择到第几个架设点 DP 即可.</p><p>那么架设点在两侧的情况, 直接在 DP 时多记录一维, 即在另一侧选择到第几个架设点, 对于一个景点分别考虑在两侧架设的情况.</p><p>具体地, 设 $f(i, j, k)$ 表示已经覆盖到第 $i$ 个景点, 两侧架设点分别选择到 $j$, $k$. 转移比较显然, 看代码理解就好了.</p><p>时间复杂度 $O(nm^3)$, 但是跑不满.</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2139</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ckmin</span><span class="params">(T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123; <span class="keyword">if</span> (a &gt; b) a = b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e2</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Geo &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        Vector(<span class="keyword">int</span> _x = <span class="number">0</span>, <span class="keyword">int</span> _y = <span class="number">0</span>): x(_x), y(_y) &#123; &#125;</span><br><span class="line">        Vector <span class="keyword">operator</span> - (<span class="keyword">const</span> Vector&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Vector(x - rhs.x, y - rhs.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">typedef</span> Vector Point;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point&amp; A, <span class="keyword">const</span> Point&amp; B) &#123;</span><br><span class="line">        <span class="keyword">return</span> (A.x &lt; B.x) || (A.x == B.x &amp;&amp; A.y &lt; B.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">Dot</span><span class="params">(<span class="keyword">const</span> Vector&amp; A, <span class="keyword">const</span> Vector&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1L</span>L * A.x * B.x + <span class="number">1L</span>L * A.y * B.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">Length2</span><span class="params">(<span class="keyword">const</span> Vector&amp; A)</span> </span>&#123; <span class="keyword">return</span> Dot(A, A); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">Dist2</span><span class="params">(<span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2)</span> </span>&#123; <span class="keyword">return</span> Length2(p1 - p2); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Geo;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> &#123;</span></span><br><span class="line">    Point p; <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> p &lt; rhs.p; &#125;</span><br><span class="line">&#125; U[MAXN], D[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m; LL R;</span><br><span class="line">Point P[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;n, &amp;m, &amp;R), R *= R;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x, y, i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), P[i] = Point(x, y);</span><br><span class="line">    <span class="keyword">int</span> nU = <span class="number">0</span>, nD = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x, y, c, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;c);</span><br><span class="line">        <span class="keyword">if</span> (y &lt; <span class="number">0</span>) D[++nD] = (Item)&#123; Point(x, y), c &#125;;</span><br><span class="line">        <span class="keyword">else</span> U[++nU] = (Item)&#123; Point(x, y), c &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">int</span> nP = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; !flag &amp;&amp; j &lt;= nD; ++j)</span><br><span class="line">            <span class="keyword">if</span> (Dist2(P[i], D[j].p) &lt;= R) flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; !flag &amp;&amp; j &lt;= nU; ++j)</span><br><span class="line">            <span class="keyword">if</span> (Dist2(P[i], U[j].p) &lt;= R) flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag) P[++nP] = P[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(P + <span class="number">1</span>, P + nP + <span class="number">1</span>);</span><br><span class="line">    sort(D + <span class="number">1</span>, D + nD + <span class="number">1</span>), sort(U + <span class="number">1</span>, U + nU + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nP; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= nU; ++j) <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= nD; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; Dist2(P[i], U[j].p) &lt;= R) ckmin(f[i][j][k], f[i - <span class="number">1</span>][j][k]);</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; Dist2(P[i], D[k].p) &lt;= R) ckmin(f[i][j][k], f[i - <span class="number">1</span>][j][k]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = j + <span class="number">1</span>; l &lt;= nU; ++l)</span><br><span class="line">                <span class="keyword">if</span> (Dist2(P[i], U[l].p) &lt;= R) ckmin(f[i][l][k], f[i - <span class="number">1</span>][j][k] + U[l].w);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = k + <span class="number">1</span>; l &lt;= nD; ++l)</span><br><span class="line">                <span class="keyword">if</span> (Dist2(P[i], D[l].p) &lt;= R) ckmin(f[i][j][l], f[i - <span class="number">1</span>][j][k] + D[l].w);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> Mn = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= nU; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= nD; ++k) ckmin(Mn, f[nP][j][k]);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>, nP, Mn);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;做这套题纯粹是为了好玩… 结果惨遭吊打 = =&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>GXOI / GZOI 2019 大赏</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/GXOI-GZOI-2019-sol/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/GXOI-GZOI-2019-sol/</id>
    <published>2020-04-18T04:22:41.000Z</published>
    <updated>2020-04-28T16:14:48.312Z</updated>
    
    <content type="html"><![CDATA[<hr><p><del>从 LOJ 的通过人数可以看出, 这里没有毒瘤题.</del></p><p>假的, 都是毒瘤.</p><a id="more"></a><h3 id="「GXOI-GZOI2019」与或和"><a href="#「GXOI-GZOI2019」与或和" class="headerlink" title="「GXOI / GZOI2019」与或和"></a>「GXOI / GZOI2019」与或和</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3083" target="_blank" rel="noopener">https://loj.ac/problem/3083</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>在二进制下逐位考虑, 那么此时的矩阵就是 0-1 矩阵.</p><p>如果子矩阵 AND 值为 $1$, 则子矩阵内都为 $1$.</p><p>同理, 如果子矩阵 OR 值为 $1$, 则子矩阵任意存在一个 $1$ 即可.</p><p>先考虑 AND 的情况.</p><p>记 $f(i, j)$ 为位置 $(i,\ j)$ 上方 (包含 $(i,\ j)$) 最多 $1$ 的个数. 那么固定行的位置 $i$, 从左向右枚举列的位置 $j$, 每个位置 $(i, j)$ 对全 $1$ 子矩阵的贡献可看作 $f(i, j)$ 向左延伸的最大距离, 用单调栈维护这个过程即可.</p><p>OR 的情况类似. 任意存在一个 $1$ 的情况不好统计, 如果枚举矩阵中每一个位置 $(i,\ j)$, 那么以这个位置为右下角的子矩阵共有 $i \times j$ 个. 可以用所有情况减去子矩阵内都为 $0$ 的情况. 这样就 AND 一样了.</p><p>时间复杂度 $(n ^ 2 \log A)$, 其中 $A$ 为矩阵内最大值.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>随手打了个 $998244353$ 作为模数结果调半天的是屑…</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> A[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"><span class="keyword">int</span> stk[MAXN], top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) f[j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            f[j] = ((A[i][j] &gt;&gt; k) &amp; <span class="number">1</span>)? f[j] + <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s = stk[top = <span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            s += f[j];</span><br><span class="line">            <span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; f[stk[top]] &gt; f[j])</span><br><span class="line">                s -= (stk[top] - stk[top - <span class="number">1</span>]) * (f[stk[top]] - f[j]), --top;</span><br><span class="line">            stk[++top] = j;</span><br><span class="line">            ret = (ret + s) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1L</span>L &lt;&lt; k) * ret % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) f[j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            f[j] = ((A[i][j] &gt;&gt; k) &amp; <span class="number">1</span>)? <span class="number">0</span>: f[j] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> s = stk[top = <span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            s += f[j];</span><br><span class="line">            <span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; f[stk[top]] &gt; f[j])</span><br><span class="line">                s -= (stk[top] - stk[top - <span class="number">1</span>]) * (f[stk[top]] - f[j]), --top;</span><br><span class="line">            stk[++top] = j;</span><br><span class="line">            ret = (ret + (i * j - s)) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1L</span>L &lt;&lt; k) * ret % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">int</span> MxA = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            read(A[i][j]), MxA = max(MxA, A[i][j]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">int</span> a1 = <span class="number">0</span>, a2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; (<span class="number">1L</span>L &lt;&lt; k) &lt;= MxA; ++k)</span><br><span class="line">        a1 = (a1 + solve1(k)) % P, a2 = (a2 + solve2(k)) % P;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, a1, a2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「GXOI-GZOI2019」宝牌一大堆"><a href="#「GXOI-GZOI2019」宝牌一大堆" class="headerlink" title="「GXOI / GZOI2019」宝牌一大堆"></a>「GXOI / GZOI2019」宝牌一大堆</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3084" target="_blank" rel="noopener">https://loj.ac/problem/3084</a></li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>麻将题.</del></p><p>首先考虑 “国士无双” 和 “七对子”. 前者枚举 $14$ 张牌中选择哪一张牌出现两次, 统计分数即可. 后者选择分数最高的 $7$ 组雀头即可.</p><p>注意到 $\binom{4}{4} = 1 &lt; \binom{4}{3} = 4$, 在题目条件下, 即使是宝牌, 组合成杠子一定不优. 所以现在需要考虑的部分只有 “$3 \times 4 + 2$”.</p><p>如果之前有做过其他麻将 / 斗地主一类的题, 容易有高维 DP 的思路.</p><p>现在需要注意顺子, 刻子, 以及雀头的个数. 记 $f(i, j, k, l, s)$ 表示考虑完第 $i$ 张牌, 共组合成 $j$ 组面子, 准备以第 $i-1$ 张牌开始的顺子有 $k$ 组, 准备以第 $i$ 张牌开始的顺子有 $l$ 组, 且雀头的个数为 $s$.</p><p>以顺子为例, 记 $s$ 为第 $i + 1$ 张牌加入 $c$ 张时对分数的贡献, $\operatorname{Cnt}(i + 1)$ 为第 $i + 1$ 张牌剩余个数, 那么有</p><script type="math/tex; mode=display">f(i + 1,\ j + k,\ l,\ c - k - l,\ 0) = \max_{c = k + l} ^ {\operatorname{Cnt}(i + 1)} \{ s \cdot f(i,\ j,\ k,\ l,\ 0 ) \} \\f(i + 1,\ j + k,\ l,\ c - k - l,\ 1) = \max_{c = k + l} ^ {\operatorname{Cnt}(i + 1)} \{ s \cdot f(i,\ j,\ k,\ l,\ 1 ) \}</script><p>剩下的刻子和雀头的转移类似, 也就是在顺子的基础上多挑出一些牌组成刻子 / 雀头.</p><p>还有一些值得注意的地方:</p><ol><li>三组顺子和三组刻子的等价的, 每次枚举顺子组数不超过 $2$ 即可.</li><li>形同 <code>8m, 9m, ..., E, N, ..., Z, B, ...</code> 的牌型不能组成顺子, 在枚举 $k$, $l$ 的时候需要特判.</li><li>在遇到 $f$ 为 $0$ 的情况可以避免不必要的转移.</li></ol><p>记 $n = 34 \times 5 \times 3 \times 3 \times 2 \times 5 = 15300$, 那么时间复杂度为 $O(T n)$.</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p><del>预感到写起来会很毒瘤, 于是改用了之前写计算几何的码风</del>.</p><p>其实就是多打点空格, 少压一点行, 和一些以为然的注释…</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3084</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ckmax</span><span class="params">(T&amp; x, <span class="keyword">const</span> T&amp; y)</span> </span>&#123; <span class="keyword">if</span> (x &lt; y) x = y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">16</span>, MAXM = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> C[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> Cnt[MAXM], isDora[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; Mahj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// binom</span></span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = C[<span class="number">1</span>][<span class="number">0</span>] = C[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAXN; ++i) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            C[i][j] = C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// string --&gt; type</span></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i)</span><br><span class="line">        s = <span class="string">"m"</span>, Mahj[<span class="keyword">char</span>(<span class="string">'0'</span> + i) + s] = <span class="number">0</span> + i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i)</span><br><span class="line">        s = <span class="string">"p"</span>, Mahj[<span class="keyword">char</span>(<span class="string">'0'</span> + i) + s] = <span class="number">9</span> + i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i)</span><br><span class="line">        s = <span class="string">"s"</span>, Mahj[<span class="keyword">char</span>(<span class="string">'0'</span> + i) + s] = <span class="number">18</span> + i;</span><br><span class="line">    Mahj[<span class="string">"E"</span>] = <span class="number">28</span>, Mahj[<span class="string">"S"</span>] = <span class="number">29</span>, Mahj[<span class="string">"W"</span>] = <span class="number">30</span>, Mahj[<span class="string">"N"</span>] = <span class="number">31</span>;</span><br><span class="line">    Mahj[<span class="string">"Z"</span>] = <span class="number">32</span>, Mahj[<span class="string">"B"</span>] = <span class="number">33</span>, Mahj[<span class="string">"F"</span>] = <span class="number">34</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Normal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> LL f[MAXM][<span class="number">5</span>][<span class="number">3</span>][<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; MAXM; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">4</span>; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span> &amp;&amp; j + k &lt;= <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; (i == <span class="number">9</span> || i == <span class="number">18</span> || i &gt;= <span class="number">27</span>)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= <span class="number">2</span> &amp;&amp; j + k + l &lt;= <span class="number">4</span>; ++l) &#123;</span><br><span class="line">                <span class="keyword">if</span> (l &gt; <span class="number">0</span> &amp;&amp; (i == <span class="number">9</span> || i == <span class="number">18</span> || i &gt;= <span class="number">27</span>)) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (!f[i][j][k][l][<span class="number">0</span>] &amp;&amp; !f[i][j][k][l][<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> c = k + l; c &lt;= Cnt[i + <span class="number">1</span>]; ++c) &#123;</span><br><span class="line">                    LL s = C[Cnt[i + <span class="number">1</span>]][c] * (<span class="number">1L</span>L &lt;&lt; (c * isDora[i + <span class="number">1</span>]));</span><br><span class="line">                    LL f0 = s * f[i][j][k][l][<span class="number">0</span>], f1 = s * f[i][j][k][l][<span class="number">1</span>];</span><br><span class="line">                    <span class="comment">// Shuntsu</span></span><br><span class="line">                    <span class="keyword">if</span> (j + k &lt;= <span class="number">4</span> &amp;&amp; c - k - l &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">                        ckmax(f[i + <span class="number">1</span>][j + k][l][c - k - l][<span class="number">0</span>], f0);</span><br><span class="line">                        ckmax(f[i + <span class="number">1</span>][j + k][l][c - k - l][<span class="number">1</span>], f1);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Koutsu</span></span><br><span class="line">                    <span class="keyword">if</span> (j + k + <span class="number">1</span> &lt;= <span class="number">4</span> &amp;&amp; c - k - l - <span class="number">3</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        ckmax(f[i + <span class="number">1</span>][j + k + <span class="number">1</span>][l][c - k - l - <span class="number">3</span>][<span class="number">0</span>], f0);</span><br><span class="line">                        ckmax(f[i + <span class="number">1</span>][j + k + <span class="number">1</span>][l][c - k - l - <span class="number">3</span>][<span class="number">1</span>], f1);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Jantou</span></span><br><span class="line">                    <span class="keyword">if</span> (j + k &lt;= <span class="number">4</span> &amp;&amp; c - k - l - <span class="number">2</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                        ckmax(f[i + <span class="number">1</span>][j + k][l][c - k - l - <span class="number">2</span>][<span class="number">1</span>], f0);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> f[MAXM - <span class="number">1</span>][<span class="number">4</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">KokushiMusou</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> Need[] = &#123; <span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (Cnt[Need[i]] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>&amp; dmahj = Need[i];</span><br><span class="line">        LL now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">13</span>; ++j) <span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span>&amp; smahj = Need[j];</span><br><span class="line">            now *= C[Cnt[smahj]][<span class="number">1</span>] * (<span class="number">1L</span>L &lt;&lt; isDora[smahj]);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = max(now * C[Cnt[dmahj]][<span class="number">2</span>] * (<span class="number">1L</span>L &lt;&lt; (<span class="number">2</span> * isDora[dmahj])), ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span> * ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">SevenTiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> LL Points[MAXM];</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXM; ++i) <span class="keyword">if</span> (Cnt[i] &gt;= <span class="number">2</span>)</span><br><span class="line">        Points[tot++] = C[Cnt[i]][<span class="number">2</span>] * (<span class="number">1L</span>L &lt;&lt; (<span class="number">2</span> * isDora[i]));</span><br><span class="line">    <span class="keyword">if</span> (tot &lt; <span class="number">7</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    sort(Points, Points + tot, greater&lt;LL&gt;());</span><br><span class="line">    LL ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; ++i) ret *= Points[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">7</span> * ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> Ti;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Ti;</span><br><span class="line">    Prepare();</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">string</span> S;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        <span class="built_in">memset</span>(isDora, <span class="number">0</span>, <span class="keyword">sizeof</span> isDora);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXM; ++i) Cnt[i] = <span class="number">4</span>;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; S &amp;&amp; S[<span class="number">0</span>] != <span class="string">'0'</span>)</span><br><span class="line">            --Cnt[Mahj[S]];</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; S &amp;&amp; S[<span class="number">0</span>] != <span class="string">'0'</span>)</span><br><span class="line">            isDora[Mahj[S]] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// solve &amp; output</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; max(max(KokushiMusou(), SevenTiles()), Normal()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「GXOI-GZOI2019」特技飞行"><a href="#「GXOI-GZOI2019」特技飞行" class="headerlink" title="「GXOI / GZOI2019」特技飞行"></a>「GXOI / GZOI2019」特技飞行</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3085" target="_blank" rel="noopener">https://loj.ac/problem/3085</a></li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>很贴切实际地, 嘉宾团看到的动作和实际在哪个交点选择哪个操作并没有关系, 对答案的贡献只和观察范围内的交点个数有关.</p><p>所以题目可分作两个部分. 第一部分考虑交点的动作选择, 第二部分统计嘉宾团观察交点个数.</p><p>考虑如何处理第一部分.</p><p>注意到两直线相交的条件为 $y_0$ 和 $y_1$ 在 $x_{st}$ 处和 $x_{ed}$ 处的呈逆序, 并保证直线交点个数不大 ($\le 500,000$). 那么直接枚举直线, 暴力统计所有满足的直线计算交点即可. 具体可通过在 <code>set</code> 中二分实现.</p><p>设不计嘉宾团的影响下的答案为 $w$, 选择 $x$ 处交点交换, 共有 $m$ 个交点. 则有</p><script type="math/tex; mode=display">w = a x + b \cdot (m - x)</script><p>容易发现 $w$ 是关于 $x$ 的一次函数, 其极值显然在 $x$ 的上下界处取到.</p><p>一个显然的上界是交点个数. 注意到交换航线的操作并不影响纵坐标相对顺序, “能交换就交换” 一定能保持原有的相对位置.</p><p>如果将一个位置向在终点处对应位置的实际编号连边, 一定会构成多个环. <del>实际上是多个置换</del>. 而让大小为 $l$ 的环有序的交换次数为 $l - 1$.</p><p>记环个数为 $c$, 总次数为</p><script type="math/tex; mode=display">\sum_{i = 1} ^ c (l_i - 1) = \sum_{i = 1} ^ c l_i - c = n - c</script><p>此处 DFS 遍历一遍所有环统计个数即可.</p><p>考虑如何处理第二部分.</p><p>倾斜的正方形不好处理, 考虑旋转坐标轴, 使得正方形的边同坐标轴平行即可. 这里我将坐标轴逆时针旋转 $\frac{\pi}{4}$, 并将横纵坐标同时乘 $\sqrt 2$, 得出原坐标系下点 $(x,\ y)$ 在旋转后的坐标系中坐标为 $(x + y,\ y - x)$.</p><p>此时直接二维数点即可. 拆成扫描线后是经典问题, 同时只需要 BIT 即可实现.</p><p>记交点个数为 $m$, 那么时间复杂度为 $O\big( n \log n + (m + k) \log (m + k) \big)$.</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>想清楚细节之后写起来就十分快乐, 调试的时候就非常快乐了 (</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3085</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>, MAXM = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Geo &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">fabs</span>(p) &lt; EPS)? <span class="number">0</span>: (p &lt; <span class="number">0</span>? <span class="number">-1</span>: <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line">        <span class="keyword">double</span> x, y;</span><br><span class="line">        Vector(<span class="keyword">double</span> _x = <span class="number">0.0</span>, <span class="keyword">double</span> _y = <span class="number">0.0</span>): x(_x), y(_y) &#123; &#125;</span><br><span class="line">        Vector <span class="keyword">operator</span> + (<span class="keyword">const</span> Vector&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Vector(x + rhs.x, y + rhs.y); &#125;</span><br><span class="line">        Vector <span class="keyword">operator</span> - (<span class="keyword">const</span> Vector&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Vector(x - rhs.x, y - rhs.y); &#125;</span><br><span class="line">        Vector <span class="keyword">operator</span> * (<span class="keyword">const</span> <span class="keyword">double</span>&amp; p) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Vector(p * x, p * y); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">typedef</span> Vector Point;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Dot</span><span class="params">(<span class="keyword">const</span> Vector&amp; A, <span class="keyword">const</span> Vector&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.x * B.x + A.y * B.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Cross</span><span class="params">(<span class="keyword">const</span> Vector&amp; A, <span class="keyword">const</span> Vector&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.x * B.y - A.y * B.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Point <span class="title">LineIntersection</span><span class="params">(Point P, Vector v, Point Q, Vector w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> P + v * (Cross(w, P - Q) / Cross(v, w));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Geo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K, a, b, c, xst, xed;</span><br><span class="line"><span class="keyword">int</span> Y0[MAXN], Y1[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nP;</span><br><span class="line"><span class="keyword">int</span> pre[MAXN], vis[MAXN];</span><br><span class="line">Point P[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindLineIntersection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">set</span>&lt;Pii&gt; S;</span><br><span class="line">    nP = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        Point p1 = Point(xst, Y0[i]), p2 = Point(xed, Y1[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ite = S.lower_bound(Pii(Y1[i], i)); ite != S.end(); ++ite) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span>&amp; j = ite-&gt;second;</span><br><span class="line">            Point p3 = Point(xst, Y0[j]), p4 = Point(xed, Y1[j]);</span><br><span class="line">            P[++nP] = LineIntersection(p1, p2 - p1, p3, p4 - p3);</span><br><span class="line">        &#125;</span><br><span class="line">        S.insert(Pii(Y1[i], i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v: S) pre[++cur] = v.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123; <span class="keyword">if</span> (!vis[u]) vis[u] = <span class="literal">true</span>, dfs(pre[u]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">    <span class="keyword">int</span> n, C[MAXM + MAXN * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; p, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &lt;= n + <span class="number">1</span>; i += lowbit(i)) C[i] += v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">        Mdy(L, v), Mdy(R + <span class="number">1</span>, -v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i; i -= lowbit(i)) ret += C[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">Trans</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; x, <span class="keyword">const</span> <span class="keyword">double</span>&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Point(x + y, y - x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, L, R; <span class="keyword">int</span> type;</span><br><span class="line">    Ask() = <span class="keyword">default</span>;</span><br><span class="line">    Ask(<span class="keyword">double</span> _x, <span class="keyword">double</span> _L, <span class="keyword">double</span> _R, <span class="keyword">int</span> <span class="keyword">_t</span>): x(_x), L(_L), R(_R), type(<span class="keyword">_t</span>) &#123; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Ask&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (dcmp(x - rhs.x) != <span class="number">0</span>)? x &lt; rhs.x: type &lt; rhs.type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Q[MAXN * <span class="number">2</span> + MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UselessGuest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> B[MAXN * <span class="number">2</span> + MAXM];</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(K);</span><br><span class="line">    <span class="keyword">int</span> nq = <span class="number">0</span>, nB = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p, q, r, i = <span class="number">1</span>; i &lt;= K; ++i) &#123;</span><br><span class="line">        read(p), read(q), read(r);</span><br><span class="line">        <span class="keyword">double</span> r0 = p - r + q, r1 = p + q + r, c1 = q - p + r, c0 = q - p - r;</span><br><span class="line">        Q[++nq] = Ask(r0, c0, c1, <span class="number">1</span>), Q[++nq] = Ask(r1, c0, c1, <span class="number">-1</span>);</span><br><span class="line">        B[++nB] = c0, B[++nB] = c1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nP; ++i) &#123;</span><br><span class="line">        Point p = Trans(P[i].x, P[i].y);</span><br><span class="line">        Q[++nq] = Ask(p.x, p.y, p.y, <span class="number">0</span>), B[++nB] = p.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pre done</span></span><br><span class="line">    sort(B + <span class="number">1</span>, B + <span class="number">1</span> + nB);</span><br><span class="line">    nB = unique(B + <span class="number">1</span>, B + <span class="number">1</span> + nB) - B - <span class="number">1</span>;</span><br><span class="line">    sort(Q + <span class="number">1</span>, Q + <span class="number">1</span> + nq);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    BIT::n = nB;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nq; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Q[i].type == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = lower_bound(B + <span class="number">1</span>, B + nB + <span class="number">1</span>, Q[i].L) - B;</span><br><span class="line">            ret += (BIT::Qry(p) &gt; <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> L = lower_bound(B + <span class="number">1</span>, B + nB + <span class="number">1</span>, Q[i].L) - B,</span><br><span class="line">                R = lower_bound(B + <span class="number">1</span>, B + nB + <span class="number">1</span>, Q[i].R) - B;</span><br><span class="line">            BIT::Mdy(L, R, Q[i].type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(a), read(b), read(c), read(xst), read(xed);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(Y0[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(Y1[i]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    FindLineIntersection();</span><br><span class="line">    <span class="keyword">int</span> CircleCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) dfs(i), ++CircleCnt;</span><br><span class="line">    <span class="keyword">int</span> bonus = UselessGuest();</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    LL a1 = a * nP, a2 = (a - b) * (n - CircleCnt) + b * nP;</span><br><span class="line">    <span class="keyword">if</span> (a1 &gt; a2) swap(a1, a2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, a1 + <span class="number">1L</span>L * bonus * c, a2 + <span class="number">1L</span>L * bonus * c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「GXOI-GZOI2019」逼死强迫症"><a href="#「GXOI-GZOI2019」逼死强迫症" class="headerlink" title="「GXOI / GZOI2019」逼死强迫症"></a>「GXOI / GZOI2019」逼死强迫症</h3><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3086" target="_blank" rel="noopener">https://loj.ac/problem/3086</a></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>推了个 12 x 12 的矩阵当场弃疗, 翻题解结果只需要 4 x 4…</del></p><p>假定不考虑 $1 \times 1$ 方砖的影响, 那么剩下的就是经典问题了, 其方案数为 Fibonacci 数列, 并记 Fibonacci 数列第 $n$ 项为 $f_n$, 同时有 $f_0 = 1$.</p><p>如果将两个 $1\times 1$ 方砖填入 $2 \times n$ 的格子, 且要求两方砖分别处于第一列和最后一列, 那么只在 $n \ge 3$ 的情况下有合法方案, 可能的方案只有两种, 且具体排布方式和 $n$ 的奇偶性相关.</p><p>此时可以得到这样的思路: 枚举两方砖的间距, 将整体分成两部分, 统计方案数. 可以得出方案数为</p><script type="math/tex; mode=display">2 \sum_{i = 3} ^ {n} \sum_{j = 0} ^ {n - i} f_j \cdot f_{n - i - j}</script><p><del>卷积!</del> 卷个锤子. 交换求和顺序, 得</p><script type="math/tex; mode=display">2 \sum_{i = 0} ^ {n - 3} f_i \sum_{j = 0} ^ {n - i - 3} f_j</script><p>设 Fibonacci 数列的前缀和第 $n$ 项为 $s_n$, 有 $s_n = s_{n - 1} + s_{n - 2} + 1 = f_{n + 2} - 1$. 归纳可证.</p><p>带入原式, 得</p><script type="math/tex; mode=display">2 \sum_{i = 0} ^ {n - 3} f_i \cdot (f_{n - i - 1} - 1) =2 \sum_{i = 0} ^ {n - 3} f_i \cdot f_{n - i - 1} - 2 f_{n - 1} + 2</script><p>设 $g_n = \sum\limits_{ i = 0 } ^ n f_i \cdot f_{n - i}$, 那么可化为</p><script type="math/tex; mode=display">2\ (\sum_{i = 0} ^ {n - 1} f_i \cdot f_{n - i - 1} - f_{n - 1} \cdot f_0 - f_{n - 2} \cdot f_1) - 2 f_{n - 1} + 2</script><script type="math/tex; mode=display">2 g_{n - 1} - 2 f_{n - 2} - 4 f_{n - 1} + 2</script><p>现在的问题在于如何快速求出 $g_n$.</p><script type="math/tex; mode=display">g_n = \sum_{i = 0} ^ {n - 1} f_i \cdot f_{n - i} = \sum_{i = 0} ^ {n - 2} f_i \cdot (f_{n - i - 1} + f_{n - i - 2}) + f_{n} + f_{n - 1}</script><p><del>想必大家都知道接下来要做什么</del></p><script type="math/tex; mode=display">g_n = (f_{n - 1} + \sum_{i = 0} ^ {n - 2} f_i \cdot f_{n - i - 1} ) + \sum_{i = 0} ^ {n - 2} f_i \cdot f_{n - i - 2} + f_n = g_{n - 1} + g_{n - 2} + f_n</script><p>设 $\mathbf{A_{n}} = \begin{bmatrix} f_{n - 1} \\ f_n \\ g_{n - 1} \\ g_{n} \end{bmatrix}$, 有</p><script type="math/tex; mode=display">\mathbf{A_i} = \begin{bmatrix} 0 & 1 & 0 & 0 \\ 1 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 1 & 1 & 1 & 1 \end{bmatrix} \times \mathbf{A_{i - 1}}</script><p>矩阵快速幂即可.</p><p>时间复杂度为 $O(T \cdot 4 ^ 3 \log n)$.</p><p><del>那个 12 x 12 的矩阵是大力设状态, xjb 转移的产物.</del></p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3086</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">4</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> A[MAXM][MAXM] = &#123;</span><br><span class="line">    &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B[MAXM][MAXM] = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, &#123; <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> g[MAXM][MAXM];</span><br><span class="line">    Matrix() &#123; <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g); &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        Matrix ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXM; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; MAXM; ++k)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; MAXM; ++j)</span><br><span class="line">                    ret.g[i][j] = (ret.g[i][j] + <span class="number">1L</span>L * g[i][k] * rhs.g[k][j] % P) % P;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXM; ++i) g[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">fpow</span><span class="params">(Matrix base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    Matrix ret; ret.init();</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * base;</span><br><span class="line">        base = base * base, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> Ti, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Ti);</span><br><span class="line">    Matrix res, base;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXM; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; MAXM; ++j) base.g[i][j] = A[i][j];</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123; <span class="built_in">puts</span>(<span class="string">"0"</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXM; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; MAXM; ++j) res.g[i][j] = B[i][j];</span><br><span class="line">        res = fpow(base, n - <span class="number">2</span>) * res;</span><br><span class="line">        <span class="keyword">int</span> g1 = res.g[<span class="number">3</span>][<span class="number">0</span>], f1 = res.g[<span class="number">1</span>][<span class="number">0</span>], f2 = res.g[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ((<span class="number">2L</span>L * g1 - <span class="number">2L</span>L * f2 - <span class="number">4L</span>L * f1 + <span class="number">2</span>) % P + P) % P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「GXOI-GZOI2019」旅行者"><a href="#「GXOI-GZOI2019」旅行者" class="headerlink" title="「GXOI / GZOI2019」旅行者"></a>「GXOI / GZOI2019」旅行者</h3><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3087" target="_blank" rel="noopener">https://loj.ac/problem/3087</a></li></ul><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>并不优美的题.</del></p><p>我们称 $k$ 座感兴趣的城市为关键点.</p><p>官方题解有一个时间复杂度为 $O(T \cdot m \log m \log k)$ 的做法:</p><p>每次枚举关键点在二进制下的每一位, 按二进制下该位在值将关键点分作两个部分. 建立源点 $s$ 向某一部分连边, 边权为 $0$. 建立汇点 $t$, 令另一部分向 $t$ 连边, 边权为 $0$. 此时 $s$ 到 $t$ 的最短路即为第一部分关键点到另一部分关键点距离的最小值. 重复 $\log k$ 次即可.</p><p>但是还存在时间复杂度为 $O(T \cdot m \log m)$ 的做法.</p><p>同样建立源点 $s$, 向所有关键点连边, 边权为 $0$, 求 $s$ 出发的最短路. 在反图上建立源点 $s$, 向所有关键点连边, 边权为 $0$, 在反图上再次求以 $s$ 为起点的最短路.</p><p>两次求最短路的同时, 分别记录到达点 $u$ 的最短路长度 $d_1(u),\ d_2(u)$, 以及 $p_1(u),\ p_2(u)$, 表示到达 $u$ 的最短路是从关键点 $p(u)$ 出发的.</p><p>对于关键点间最短距离, 其路径上一定不存在另一个关键点. 那么, 枚举每条边 $(u,\ v,\ w)$, 在保证 $p_1(u) \neq p_2(v)$ 的情况下用 $d_1(u) + w + d_2(v)$ 更新答案即可.</p><p>具体实现时不需要显式地建出 $s$. 因为 $s$ 到关键点一定是最短路, 直接将最短路长度初始化后丢进堆里就好了.</p><p>由于只跑两次最短路, 使用 <code>priority_queue</code> 实现的 Dijkstra, 时间复杂度为 $O(T \cdot m \log m)$.</p><p><del>我实在看不懂那些长篇大论的题解在证个什么</del>.</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3087</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">19</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, <span class="keyword">int</span>&gt; Pli;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>, MAXM = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, K;</span><br><span class="line"><span class="keyword">int</span> A[MAXN];</span><br><span class="line"><span class="keyword">int</span> U[MAXM], V[MAXM], W[MAXM];</span><br><span class="line"></span><br><span class="line">LL d1[MAXN], d2[MAXN];</span><br><span class="line"><span class="keyword">int</span> p1[MAXN], p2[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, w; &#125; edges[MAXM];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, w &#125;, head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span>* pre, LL* d)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;Pli, <span class="built_in">vector</span>&lt;Pli&gt;, greater&lt;Pli&gt; &gt; PQ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u, i = <span class="number">1</span>; i &lt;= K; ++i)</span><br><span class="line">            u = A[i], PQ.push(Pli(d[u] = <span class="number">0</span>, u)), pre[u] = u;</span><br><span class="line">        <span class="keyword">while</span> (!PQ.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = PQ.top().second; LL w = PQ.top().first; PQ.pop();</span><br><span class="line">            <span class="keyword">if</span> (w != d[u]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">                <span class="keyword">if</span> ((d[v = edges[i].to] &gt; d[u] + edges[i].w))</span><br><span class="line">                    pre[v] = pre[u], PQ.push(Pli(d[v] = d[u] + edges[i].w, v));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> Ti;</span><br><span class="line">    read(Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        <span class="built_in">memset</span>(d1, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d1);</span><br><span class="line">        <span class="built_in">memset</span>(d2, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d2);</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        read(n), read(m), read(K);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            read(U[i]), read(V[i]), read(W[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i) read(A[i]);</span><br><span class="line">        <span class="comment">// predone 1</span></span><br><span class="line">        Graph::init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) Graph::AddEdge(U[i], V[i], W[i]);</span><br><span class="line">        Graph::Dijkstra(p1, d1);</span><br><span class="line">        <span class="comment">// predone 2</span></span><br><span class="line">        Graph::init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) Graph::AddEdge(V[i], U[i], W[i]);</span><br><span class="line">        Graph::Dijkstra(p2, d2);</span><br><span class="line">        <span class="comment">// solve</span></span><br><span class="line">        LL ans = LLONG_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> &amp;u = U[i], &amp;v = V[i], &amp;w = W[i];</span><br><span class="line">            <span class="keyword">if</span> (p1[u] != p2[v]) ans = min(ans, d1[u] + d2[v] + w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// output</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「GXOI-GZOI2019」旧词"><a href="#「GXOI-GZOI2019」旧词" class="headerlink" title="「GXOI / GZOI2019」旧词"></a>「GXOI / GZOI2019」旧词</h3><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3088" target="_blank" rel="noopener">https://loj.ac/problem/3088</a></li></ul><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>早已跌下神坛的树链剖分.</del></p><p>如果直接做, $x$ 的限制不好处理. 考虑离线, 动态加入 $x$ 的权值, 在一定的时机处理询问.</p><p>现在来讨论一个询问 $(x, y)$ 的答案, 同时称点 $u$ 的权值为 $A_u = \text{depth}(u) ^ k$. 经过上面的处理后, $y$ 的权值对答案的贡献次数为 $y$ 子树内已加入的节点数量.</p><p>形式化地, 记 $y$ 子树内已加入节点数量为 $s_y$, 那么其对答案的贡献为 $s_y \cdot A_y$. 以此类推, $y$ 的某个祖先对答案的贡献则需要抠去重复计算的部分, 即对于 $y$ 的祖先 $u$, 记 $y$ 和 $u$ 之间最靠近 $u$ 的节点为 $v$, 那么 $u$ 的答案的贡献为 $(s_u - s_v) \cdot A_u$.</p><p><del>然后… 然后我就不知道怎么维护了, 参考 <a href="https://www.luogu.com.cn/blog/Mrsrz/solution-p5305" target="_blank" rel="noopener">mrsrz 的题解</a> 之后可以发现</del></p><p>对给定树重链剖分, 直接维护每一条重链对答案的贡献, 接着考虑轻链对答案的影响.</p><p>借助重链剖分后轻重链的结构关系, 轻链两端点一定满足上述 $u$ 和 $v$ 之间的关系. 即计算答案时, 加上轻链顶和轻链底两节点 $s_u$ 的差值乘上轻链顶节点的权值之后的结果.</p><p>修改时维护上述信息即可, 可以用 BIT 简单实现.</p><p>时间复杂度 $O(n \log k + q \log ^ 2 n)$.</p><p>还有一种做法为类似树上差分的思路, 将 LCA 处的值 “平摊” 到根节点到 LCA 的路径上. 利用线段树打上计算次数的标记, 维护权值的增量, 询问时求标记和增量乘积的和就好了.</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3088</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e4</span> + <span class="number">5</span>, MAXQ = <span class="number">5e4</span> + <span class="number">5</span>, P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % P;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> idx, x, y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Ask&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; rhs.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Q[MAXQ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, K;</span><br><span class="line"><span class="keyword">int</span> pre[MAXN], dfn[MAXN];</span><br><span class="line"><span class="keyword">int</span> A[MAXN], f[MAXN], Ans[MAXN], depth[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT1 &#123;</span><br><span class="line">    <span class="keyword">int</span> C[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; p, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &lt;= n + <span class="number">1</span>; i += lowbit(i)) C[i] += v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">        Mdy(L, v), Mdy(R + <span class="number">1</span>, -v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i; i -= lowbit(i)) ret += C[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Dff</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Qry(dfn[u]) - ((v &gt; <span class="number">0</span>)? Qry(dfn[v]): <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT2 &#123;</span><br><span class="line">    <span class="keyword">int</span> C[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; p, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &lt;= n; i += lowbit(i)) C[i] = (C[i] + v) % P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i; i -= lowbit(i)) ret = (ret + C[i]) % P;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((Qry(R) - Qry(L - <span class="number">1</span>)) % P + P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HLD &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">int</span> size[MAXN], son[MAXN], topfa[MAXN], clk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        son[u] = <span class="number">-1</span>, size[u] = <span class="number">1</span>;</span><br><span class="line">        depth[u] = depth[pre[u]] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            dfs(v = edges[i].to), size[v] += size[u];</span><br><span class="line">            <span class="keyword">if</span> (son[u] == <span class="number">-1</span> || size[v] &gt; size[son[u]]) son[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">        topfa[u] = top, dfn[u] = ++clk;</span><br><span class="line">        <span class="keyword">if</span> (~son[u]) dfs(son[u], top);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) != son[u]) dfs(v, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt = <span class="number">1</span>)</span> </span>&#123; dfs(rt), dfs(rt, rt); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = p; u &gt; <span class="number">0</span>; u = pre[topfa[u]]) &#123;</span><br><span class="line">            BIT1::Mdy(dfn[topfa[u]], dfn[u], <span class="number">1</span>);</span><br><span class="line">            BIT2::Mdy(dfn[u], -f[u]);</span><br><span class="line">            BIT2::Mdy(dfn[u], f[u] = <span class="number">1L</span>L * A[u] * BIT1::Dff(u, son[u]) % P);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = p, lst = <span class="number">0</span>; u &gt; <span class="number">0</span>; u = pre[topfa[u]]) &#123;</span><br><span class="line">            ret = (ret + <span class="number">1L</span>L * A[u] * BIT1::Dff(u, lst) % P) % P;</span><br><span class="line">            <span class="keyword">if</span> (u != topfa[u])</span><br><span class="line">                ret = (ret + BIT2::Qry(dfn[topfa[u]], dfn[pre[u]])) % P;</span><br><span class="line">            lst = topfa[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(q), read(K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        read(pre[i]), Graph::AddEdge(pre[i], i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x, y, i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">        read(x), read(y), Q[i] = (Ask)&#123; i, x, y &#125;;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    HLD::solve(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u) A[u] = fpow(depth[u], K);</span><br><span class="line">    sort(Q + <span class="number">1</span>, Q + q + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>, i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> Ask&amp; p = Q[i];</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= n &amp;&amp; x &lt;= p.x) HLD::Mdy(x++);</span><br><span class="line">        Ans[p.idx] = HLD::Qry(p.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;del&gt;从 LOJ 的通过人数可以看出, 这里没有毒瘤题.&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;假的, 都是毒瘤.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>SDOI 2019 大赏</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/SDOI-2019-sol/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/SDOI-2019-sol/</id>
    <published>2020-04-15T13:29:06.000Z</published>
    <updated>2020-04-28T15:52:25.813Z</updated>
    
    <content type="html"><![CDATA[<hr><p>从四月开始摸了两周鱼… 感觉不太行, 又滚过来做省选套题了.</p><a id="more"></a><h3 id="「SDOI2019」快速查询"><a href="#「SDOI2019」快速查询" class="headerlink" title="「SDOI2019」快速查询"></a>「SDOI2019」快速查询</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3110" target="_blank" rel="noopener">https://loj.ac/problem/3110</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>这道题有意思的地方在于 T2.</del></p><p>显然正解是线性做法. 维护标记 $a$, $b$, $c$, 以及真实值全局和 $s$. 那么, 对于记录的值 $x$, 如果这个位置曾被单点赋值, 其真实值为 $ax + b$. 否则 $x$ 为 $c$.</p><p>可以利用离散化处理数列位置标号的问题. 但是离散化做法在实现时有些繁琐的细节, 于是偷懒用了 <code>unordered_map</code>, 每次全局赋值暴力清空 <code>unordered_map</code> = =</p><p>具体地, 对于操作</p><ol><li><p>更新 $s$, 改变记录的 $A_i$, 使其满足 $a A_i + b = \mathrm{val}$, 即 $A_i \equiv  a ^ {-1} \cdot (\mathrm{val} - b) \pmod P$.</p></li><li><p>更新 $b,\ s$.</p></li><li><p>更新 $a,\ b,\ s$.</p></li><li><p>清空 <code>unordered_map</code>, 初始化 $a,\ b,\ s,\ c$. 清空的时间复杂度和 <code>unordered_map</code> 中元素个数有关, 因此复杂度是对的.</p></li><li><p>在 <code>unordered_map</code> 中查询, 不存在该位置即为 $c$.</p></li><li><p>返回 $s$ 即可.</p></li></ol><p>1 操作需要用到逆元. 注意到模数不大且是质数, 线性预处理逆元即可.</p><p>时间复杂度 $O(tq)$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3110</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXQ = <span class="number">1e5</span> + <span class="number">5</span>, P = <span class="number">1e7</span> + <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Opt</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> opt, idx, val;</span><br><span class="line">&#125; Q[MAXQ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, t, ans;</span><br><span class="line"><span class="keyword">int</span> inv[P];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; A;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">const</span> Opt&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>, c = <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p.opt == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A.count(p.idx) &gt; <span class="number">0</span>)</span><br><span class="line">            s = (s - (<span class="number">1L</span>L * a * A[p.idx] % P + b) % P + P) % P;</span><br><span class="line">        <span class="keyword">else</span> s = (s - (<span class="number">1L</span>L * a * c % P + b) % P + P) % P;</span><br><span class="line">        A[p.idx] = <span class="number">1L</span>L * (p.val - b + P) % P * inv[a] % P;</span><br><span class="line">        s = (s + p.val) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.opt == <span class="number">2</span>)</span><br><span class="line">        b = (b + p.val) % P, s = (s + <span class="number">1L</span>L * n * p.val) % P;</span><br><span class="line">    <span class="keyword">if</span> (p.opt == <span class="number">3</span>) &#123;</span><br><span class="line">        a = <span class="number">1L</span>L * a * p.val % P, b = <span class="number">1L</span>L * b * p.val % P;</span><br><span class="line">        s = <span class="number">1L</span>L * s * p.val % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.opt == <span class="number">4</span>) &#123;</span><br><span class="line">        a = <span class="number">1</span>, b = <span class="number">0</span>, c = p.val, s = <span class="number">1L</span>L * n * p.val % P;</span><br><span class="line">        A.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.opt == <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A.count(p.idx) &gt; <span class="number">0</span>)</span><br><span class="line">            ans = (ans + (<span class="number">1L</span>L * a * A[p.idx] % P + b) % P) % P;</span><br><span class="line">        <span class="keyword">else</span> ans = (ans + (<span class="number">1L</span>L * a * c % P + b) % P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.opt == <span class="number">6</span>)</span><br><span class="line">        ans = (ans + s) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> opt, idx, val;</span><br><span class="line">        read(opt), idx = val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span> || opt == <span class="number">5</span>) read(idx);</span><br><span class="line">        <span class="keyword">if</span> (opt != <span class="number">5</span> &amp;&amp; opt != <span class="number">6</span>) read(val);</span><br><span class="line">        Q[i] = (Opt)&#123; opt, idx, (val % P + P) % P &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; P; ++i)</span><br><span class="line">        inv[i] = <span class="number">1L</span>L * inv[P % i] * (P - P / i) % P;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    read(t);</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> a, b;</span><br><span class="line">        read(a), read(b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= q; ++j)</span><br><span class="line">            solve(Q[(a + <span class="number">1L</span>L * j * b % q) % q + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SDOI2019」染色"><a href="#「SDOI2019」染色" class="headerlink" title="「SDOI2019」染色"></a>「SDOI2019」染色</h3><p><del>暴论: 题目名称叫 “染色” 的都是毒瘤题</del>.</p><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3111" target="_blank" rel="noopener">https://loj.ac/problem/3111</a></li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>毒瘤题, 琢磨了好久也写了好久.</p><p>参考了 <a href="https://yhx-12243.github.io/OI-transit/records/lydsy5530%3Blg5359%3Bloj3111.html" target="_blank" rel="noopener">yhx-12243 的题解</a>, 感觉 yhx-12243 讲地非常好.</p><p>容易得出一个朴素 DP: 设 $f(i, c_1, c_2)$ 表示处理前 $i$ 列, 第 $i$ 列颜色分别为 $c_1,\ c_2$ 的方案数, 每次转移时枚举颜色.</p><p>考虑到 “相邻节点颜色不同” 的限制只约束了颜色不同, 每次枚举所有颜色看起来没有必要. 同时行数很小, 本质不同的情况很少.</p><p>从这个角度出发, 只考虑被染色的列. 我们称上下两行任意一格已经被染色的列为关键列. 对于两个 “相邻” 的关键列, 也就是两列间不包含其他的关键列, 其对方案数的贡献只和两列的染色的相对情况, 以及相隔未染色列个数有关.</p><p>具体地, 关键列的排布只有以下几种情况. (其中 $x$, $y$ 表示已经确定过的颜色, $w$ 为不同于 $x$, $y$ 的颜色)</p><script type="math/tex; mode=display">\begin{bmatrix} x & \ldots & x \\ y & \ldots & y \end{bmatrix} \tag{0}</script><script type="math/tex; mode=display">\begin{bmatrix} x & \ldots & y \\ y & \ldots & x \end{bmatrix} \tag{1}</script><script type="math/tex; mode=display">\begin{bmatrix} x & \ldots & x \\ y & \ldots & w \end{bmatrix},  \begin{bmatrix} x & \ldots & w \\ y & \ldots & y \end{bmatrix} \tag{2}</script><script type="math/tex; mode=display">\begin{bmatrix} x & \ldots & y \\ y & \ldots & w \end{bmatrix},  \begin{bmatrix} x & \ldots & w \\ y & \ldots & x \end{bmatrix} \tag{3}</script><script type="math/tex; mode=display">\begin{bmatrix} x & \ldots & w_1 \\ y & \ldots & w_2 \end{bmatrix} \tag{4}</script><p>那么预处理出两关键列之间的转移. 设 $g(i, s)$ 表示两关键列相隔长度为 $i$, 后一关键列状态为 $s$ 的方案数.</p><p>设 $\mathbf{g_i} =\begin{bmatrix} g(i, 0) \\ g(i, 1) \\ g(i, 2) \\ g(i, 3) \\ g(i, 4) \end{bmatrix}$, 大力分类讨论后可以得到转移</p><script type="math/tex; mode=display">\mathbf{g_{i + 1}} = \begin{bmatrix} 0 & 1 & 0 & 2(c-2) & (c-2)(c-3) \\ 1 & 0 & 2(c-2) & 0 & (c-2)(c-3) \\ 0 & 1 & c-2 & (c-2) + (c-3) & (c-3)^2 \\ 1 & 0 & (c - 2) + (c - 3) & c-2 & (c-3) ^ 2 \\ 1 & 1 & 2(c-3) & 2(c-3) & c^2 - 7c + 13  \end{bmatrix} \times \mathbf{g_i}</script><p>(其中 $c ^ 2 - 7c + 13$ 由 $(c-2)(c-3) - (c-2) - (c-3)$ 得到)</p><p>通过预处理 $g$, 只需枚举关键列, 通过关键列的颜色分布以及关键列相隔距离转移即可得出答案.</p><p>具体地, 和 yhx-12243 的题解一样, 将转移分为 brute, open, close, move 四个部分, 具体定义参见上述题解 (</p><p>为了表述方便, 记两关键列的颜色的分布情况为 $\begin{bmatrix} l_1 &amp; \ldots &amp; r_1 \\ l_2 &amp; \ldots &amp; r_2 \end{bmatrix}$.</p><ol><li><p>brute</p><p>此时两关键列的情况都唯一, 根据颜色相对情况填上对应情况的数值即可.</p></li><li><p>open</p><p>不妨假设 $r_1$ 为已确定的颜色, 另一种情况同这个情况类似.</p><p>通过比较 $r_1$ 和 $l_1,\ l_2$ 的相等关系, 判定其是否属于情况 2 / 3, 以及枚举 $r_2$ 取值, 并额外处理 $r_2$ 和 $l_1,\ l_2$ 相等的情况.</p></li><li><p>close</p><p>不妨假设 $l_1$ 为已确定的颜色, 另一种情况同这个情况类似.</p><p>同 open 的情况类似, 不过在处理 $l_2$ 和 $r_1,\ r_2$ 相等情况时, 需减去 $l_1$ 时已经计算的部分避免算重.</p></li><li><p>move</p><p>最为繁琐的情况. <del>同时也是前两档部分分的组成</del></p><p>首先需要判定组成的局面构成情况 2 或是情况 3. 接着用类似 open / close 的方法讨论颜色, 注意减去算重的部分.</p></li></ol><p>此外还需要处理首尾关键列的部分, 以及不存在关键列, 或是无解的一些特殊情况, 详细式子相对容易理解, 自行参考代码 (</p><p>综上, 得出了时间复杂度为 $O(nc)$ 的做法.</p><p>可以发现, 转移时的操作恰好是 T1 中的操作, 利用 T1 的做法优化转移即可, 时间复杂度 $O(n + c)$.</p><p><strong>注意, 全局乘 $a$ 时, 如果 $a = 0$, 那么等价于全局赋值 $0$</strong>. 如果 T1 实现不精细, 在这里就会出现问题.</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3111</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % P;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> exgcd(b, a % b, y, x), y -= a / b * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">return</span> exgcd(a, P, x, y), (x % P + P) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SDOI &#123;</span><br><span class="line">    <span class="keyword">int</span> n, a, b, c, s;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; A;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _n)</span> </span>&#123; n = _n, a = <span class="number">1</span>, b = c = s = <span class="number">0</span>, A.clear(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">Qry</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1L</span>L * a * ((A.count(p) &gt; <span class="number">0</span>)? A[p]: c) % P + b) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Sgn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>, b = <span class="number">0</span>, c = v, s = <span class="number">1L</span>L * n * v % P, A.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Sgn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; p, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">        s = (s - (<span class="number">1L</span>L * a * ((A.count(p) &gt; <span class="number">0</span>)? A[p]: c) % P + b) % P + P) % P;</span><br><span class="line">        A[p] = <span class="number">1L</span>L * (v - b + P) % P * inv(a) % P, s = (s + v) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123; b = (b + v) % P, s = (s + <span class="number">1L</span>L * n * v % P) % P; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!v) <span class="keyword">return</span> Sgn(v);</span><br><span class="line">        a = <span class="number">1L</span>L * a * v % P, b = <span class="number">1L</span>L * b * v % P, s = <span class="number">1L</span>L * s * v % P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> SDOI::Sgn; <span class="keyword">using</span> SDOI::Add; <span class="keyword">using</span> SDOI::Mul; <span class="keyword">using</span> SDOI::Qry;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatrixMul</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">const</span> <span class="keyword">int</span> (*W)[<span class="number">5</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++j) g[i] = (g[i] + <span class="number">1L</span>L * f[j] * W[i][j] % P) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, C;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line"><span class="keyword">int</span> pos[MAXN], g[MAXN][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreMatrix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = C - <span class="number">2</span>, y = C - <span class="number">3</span>, yy = <span class="number">1L</span>L * y * y % P, xy = <span class="number">1L</span>L * x * y % P;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> W[<span class="number">5</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">1</span>,   <span class="number">0</span>, <span class="number">2</span>*x, xy &#125;,</span><br><span class="line">        &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>*x,   <span class="number">0</span>, xy &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">1</span>,   x, x+y, yy &#125;,</span><br><span class="line">        &#123; <span class="number">1</span>, <span class="number">0</span>, x+y,   x, yy &#125;,</span><br><span class="line">        &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>*y, <span class="number">2</span>*y, <span class="keyword">int</span>((C * (C - <span class="number">7L</span>L) + <span class="number">13</span>) % P) &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) MatrixMul(g[i - <span class="number">1</span>], g[i], W);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">brute</span><span class="params">(<span class="keyword">int</span> l1, <span class="keyword">int</span> l2, <span class="keyword">int</span> r1, <span class="keyword">int</span> r2, <span class="keyword">int</span>* f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> tmp[] = &#123; <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> f[tmp[(l1 == r1) | (l1 == r2) &lt;&lt; <span class="number">1</span> | (l2 == r1) &lt;&lt; <span class="number">2</span> | (l2 == r2) &lt;&lt; <span class="number">3</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">int</span> l1, <span class="keyword">int</span> l2, <span class="keyword">int</span> r1, <span class="keyword">int</span> r2, <span class="keyword">int</span>* f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = r1 | r2;</span><br><span class="line">    <span class="keyword">if</span> (!r1 &amp;&amp; r2 &gt; <span class="number">0</span>) swap(l1, l2);</span><br><span class="line">    <span class="keyword">if</span> (l1 == r) Sgn(f[<span class="number">2</span>]), Sgn(l2, f[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l2 == r) Sgn(f[<span class="number">3</span>]), Sgn(l1, f[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span> Sgn(f[<span class="number">4</span>]), Sgn(l1, f[<span class="number">3</span>]), Sgn(l2, f[<span class="number">2</span>]);</span><br><span class="line">    Sgn(r, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> l1, <span class="keyword">int</span> l2, <span class="keyword">int</span> r1, <span class="keyword">int</span> r2, <span class="keyword">int</span>* f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = l1 | l2;</span><br><span class="line">    <span class="keyword">if</span> (!l1 &amp;&amp; l2 &gt; <span class="number">0</span>) swap(r1, r2);</span><br><span class="line">    <span class="keyword">if</span> (l == r1) <span class="keyword">return</span> (Qry() * f[<span class="number">2</span>] + Qry(r2) * (f[<span class="number">0</span>] - f[<span class="number">2</span>] + P)) % P;</span><br><span class="line">    <span class="keyword">if</span> (l == r2) <span class="keyword">return</span> (Qry() * f[<span class="number">3</span>] + Qry(r1) * (f[<span class="number">1</span>] - f[<span class="number">3</span>] + P)) % P;</span><br><span class="line">    <span class="keyword">return</span> (Qry() * f[<span class="number">4</span>] + Qry(r1) * (f[<span class="number">3</span>] - f[<span class="number">4</span>] + P) + Qry(r2) * (f[<span class="number">2</span>] - f[<span class="number">4</span>] + P)) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> l1, <span class="keyword">int</span> l2, <span class="keyword">int</span> r1, <span class="keyword">int</span> r2, <span class="keyword">int</span>* f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = l1 | l2, r = r1 | r2;</span><br><span class="line">    LL v, s = Qry();</span><br><span class="line">    <span class="keyword">if</span> (!l1 ^ !r1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) Mul((f[<span class="number">1</span>] - f[<span class="number">3</span>] + P) % P), Add(s * f[<span class="number">3</span>] % P);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            v = Qry(r), s = (s - v + P) % P;</span><br><span class="line">            Mul((f[<span class="number">3</span>] - f[<span class="number">4</span>] + P) % P), Add((s * f[<span class="number">4</span>] + v * f[<span class="number">2</span>]) % P);</span><br><span class="line">            Sgn(l, (s * f[<span class="number">2</span>] + v * f[<span class="number">0</span>]) % P);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) Mul((f[<span class="number">0</span>] - f[<span class="number">2</span>] + P) % P), Add(s * f[<span class="number">2</span>] % P);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            v = Qry(r), s = (s - v + P) % P;</span><br><span class="line">            Mul((f[<span class="number">2</span>] - f[<span class="number">4</span>] + P) % P), Add((s * f[<span class="number">4</span>] + v * f[<span class="number">3</span>]) % P);</span><br><span class="line">            Sgn(l, (s * f[<span class="number">3</span>] + v * f[<span class="number">1</span>]) % P);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Sgn(r, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(C);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(B[i]);</span><br><span class="line">    <span class="comment">// check</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (A[i] || B[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == B[i]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &amp;&amp; A[i] == A[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (B[i] &amp;&amp; B[i] == B[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pos[++m] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!m) &#123;</span><br><span class="line">        ans = <span class="number">1L</span>L * C * (C - <span class="number">1</span>) % P * fpow((C * (C - <span class="number">3L</span>L) + <span class="number">3</span>) % P, n - <span class="number">1</span>) % P;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans), <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    SDOI::init(C), PreMatrix();</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">int</span> u = A[pos[<span class="number">1</span>]], d = B[pos[<span class="number">1</span>]], t = fpow((C * (C - <span class="number">3L</span>L) + <span class="number">3</span>) % P, pos[<span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (u &amp;&amp; d) ans = t; <span class="keyword">else</span> Add(t), Sgn(u | d, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> lu = u, ld = d, *f = g[pos[i] - pos[i - <span class="number">1</span>]];</span><br><span class="line">        u = A[pos[i]], d = B[pos[i]];</span><br><span class="line">        <span class="keyword">if</span> (u &amp;&amp; d) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lu &amp;&amp; ld) ans = <span class="number">1L</span>L * ans * brute(lu, ld, u, d, f) % P;</span><br><span class="line">            <span class="keyword">else</span> ans = <span class="number">1L</span>L * ans * close(lu, ld, u, d, f) % P;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lu &amp;&amp; ld) open(lu, ld, u, d, f); <span class="keyword">else</span> move(lu, ld, u, d, f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(u &amp;&amp; d)) ans = ans * Qry() % P;</span><br><span class="line">    ans = <span class="number">1L</span>L * ans * fpow((C * (C - <span class="number">3L</span>L) + <span class="number">3</span>) % P, n - pos[m]) % P;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SDOI2019」世界地图"><a href="#「SDOI2019」世界地图" class="headerlink" title="「SDOI2019」世界地图"></a>「SDOI2019」世界地图</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3112" target="_blank" rel="noopener">https://loj.ac/problem/3112</a></li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先有一个朴素的想法. 观察到 $1 &lt; L \le R &lt; m$, 预处理前缀 / 后缀的 MST, 每次查询区间 $[L,\ R]$ 时, 合并 $L$ 前以及 $R$ 后的 MST, 同时加入第一列和最后一列的边.</p><p>时间复杂度为 $O(m ^ 2 n \log nm + q n m\log nm)$, 快乐.</p><p>观察到题目中给定的是网格图, 对于前缀或后缀 MST, 除去边界两列, 其 “内部” 列不会再存在边同其相连. 换句话说, 每次合并 MST 时, 用到的部分只有 $2n$ 个边界两列节点, 其内部节点部分并不受影响.</p><p>那么, 每次只记录和这 $2n$ 个点相关的边, 并记录其余边的边权和, 称之为 “虚树”. 每次合并 MST 时, 取出相关的边跑 Kruksal, 之后对得到的生成树建虚树即可.</p><p>对于建虚树的部分, 为了保持 MST 的性质, 涉及到保留哪些节点以及对应边的边权问题. 我们称保留在虚树中的点为 “关键点”, 那么关键点需满足以下任一条件:</p><ol><li><p>设待合并的两棵虚树分别为 $L$, $R$, 那么 $L$ 中最靠前的部分, 以及 $R$ 中最靠后的部分一定是关键点.</p><p>这一部分并不受新增加的边影响, 显然要保留.</p></li><li><p>至少有两个儿子, 满足在儿子的子树内存在关键点.</p></li></ol><p>同时, 只需记录关键点之间最大边权作为合并后虚树边权即可. 根据 MST 的回路性质, 可以发现这是对的.</p><p>时间复杂度 $O(mn \log n + q n\log n)$.</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>“为什么你们的代码都是一个叫 <code>MST</code> 的结构体, 然后都用一个叫 <code>merge</code> 的函数合并 ?”</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3112</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(args...) fprintf(stderr, ##args)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e2</span> + <span class="number">5</span>, MAXM = <span class="number">1e4</span> + <span class="number">5</span>, MAXV = MAXN &lt;&lt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    Edge(<span class="keyword">int</span> _u, <span class="keyword">int</span> _v, <span class="keyword">int</span> _w): u(_u), v(_v), w(_w) &#123; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> w &lt; rhs.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, lim;</span><br><span class="line"><span class="keyword">unsigned</span> SA, SB, SC;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; E;</span><br><span class="line"><span class="keyword">int</span> Idx[MAXV], W1[MAXM][MAXN], W2[MAXM][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, w; &#125; edges[MAXV &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXV], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, (_n + <span class="number">1</span>) * <span class="keyword">sizeof</span> (<span class="keyword">int</span>)), eidx = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, w &#125;, head[from] = eidx;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[to], from, w &#125;, head[to] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfsPre</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">const</span> <span class="keyword">int</span>&amp; tot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) != fa) s += dfsPre(v, u, tot);</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= <span class="number">2</span>) Idx[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> s + Idx[u] &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> lst, <span class="keyword">int</span> w, LL&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Idx[u] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lst &gt; <span class="number">0</span>) E.push_back(::Edge(Idx[lst], Idx[u], w));</span><br><span class="line">            lst = u, s -= w, w = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) != fa) dfs(v, u, lst, max(w, edges[i].w), s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DSU &#123;</span><br><span class="line">    <span class="keyword">int</span> fa[MAXV];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; _n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= _n; ++i) fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findfa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123; <span class="keyword">return</span> fa[u] == u? u: fa[u] = findfa(fa[u]); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> fu, <span class="keyword">int</span> fv)</span> </span>&#123;</span><br><span class="line">        fu = findfa(fu), fv = findfa(fv);</span><br><span class="line">        <span class="keyword">return</span> (fu == fv)? <span class="literal">false</span>: (fa[fv] = fu, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MST</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v; LL s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; E;</span><br><span class="line"></span><br><span class="line">    MST() &#123; &#125;</span><br><span class="line">    MST(<span class="keyword">int</span>* W) &#123;</span><br><span class="line">        v = n, s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) E.push_back(Edge(i, i + <span class="number">1</span>, W[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    MST(<span class="keyword">int</span> _v, LL _s, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;Edge&gt;&amp; _E): v(_v), s(_s), E(_E) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LL ret = s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e: E) ret += e.w;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; pre[MAXM], suf[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function">MST <span class="title">Mrg</span><span class="params">(<span class="keyword">const</span> MST&amp; L, <span class="keyword">const</span> MST&amp; R, <span class="keyword">const</span> <span class="keyword">int</span> *W)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = L.v + R.v;</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    E.clear(), DSU::init(tot), Graph::init(tot);</span><br><span class="line">    <span class="comment">// Kruskal</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> Edge&amp; e: L.E) E.push_back(e);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> Edge&amp; e: R.E)</span><br><span class="line">        E.push_back(Edge(L.v + e.u, L.v + e.v, e.w));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        E.push_back(Edge(L.v - n + i, L.v + i, W[i]));</span><br><span class="line">    sort(E.begin(), E.end());</span><br><span class="line">    LL s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> Edge&amp; e: E)</span><br><span class="line">        <span class="keyword">if</span> (DSU::join(e.u, e.v)) Graph::AddEdge(e.u, e.v, e.w), s += e.w;</span><br><span class="line">    <span class="comment">// build virtual tree</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= tot; ++u)</span><br><span class="line">        Idx[u] = (u &lt;= n || u &gt; tot - n);</span><br><span class="line">    Graph::dfsPre(<span class="number">1</span>, <span class="number">0</span>, tot);</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">        <span class="keyword">if</span> (Idx[i] &gt; <span class="number">0</span>) Idx[i] = ++idx;</span><br><span class="line">    E.clear(), Graph::dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, s);</span><br><span class="line">    <span class="keyword">return</span> MST(idx, L.s + R.s + s, E);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Rnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SA ^= SA &lt;&lt; <span class="number">16</span>, SA ^= SA &gt;&gt; <span class="number">5</span>, SA ^= SA &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> t = SA;</span><br><span class="line">    SA = SB, SB = SC, SC ^= t ^ SA;</span><br><span class="line">    <span class="keyword">return</span> SC % lim + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    read(SA), read(SB), read(SC), read(lim);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) W1[j][i] = Rnd();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) W2[j][i] = Rnd();</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    pre[<span class="number">1</span>] = MST(W2[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; m; ++i)</span><br><span class="line">        pre[i] = Mrg(pre[i - <span class="number">1</span>], MST(W2[i]), W1[i - <span class="number">1</span>]);</span><br><span class="line">    suf[m] = MST(W2[m]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt; <span class="number">1</span>; --i)</span><br><span class="line">        suf[i] = Mrg(MST(W2[i]), suf[i + <span class="number">1</span>], W1[i]);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    read(q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> L, R; q; --q) &#123;</span><br><span class="line">        read(L), read(R);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Mrg(suf[R + <span class="number">1</span>], pre[L - <span class="number">1</span>], W1[m]).calc());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SDOI2019」热闹的聚会与尴尬的聚会"><a href="#「SDOI2019」热闹的聚会与尴尬的聚会" class="headerlink" title="「SDOI2019」热闹的聚会与尴尬的聚会"></a>「SDOI2019」热闹的聚会与尴尬的聚会</h3><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3113" target="_blank" rel="noopener">https://loj.ac/problem/3113</a></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>清新题.</p><p>首先有 $\frac{n}{p + 1} &lt; \lfloor \frac{n}{p + 1} \rfloor + 1 \le q + 1$, 也就是 $n &lt; (p + 1) (q + 1)$.</p><p>再进一步转换, 也就是求尽量大的 $p$, $q$. 那么问题可拆分成两部分:</p><ul><li><p>求 $G$ 点集的某个子集 $V’$, 以 $V’$ 和 $G$ 中对应边构成 $G$ 的一张子图 $G’$, 使得 $G’$ 中度数最小点的度数为 $p$.</p></li><li><p>求 $G$ 的最大独立集, 使其大小 $q$ 满足 $n &lt; (p + 1) (q + 1)$.</p></li></ul><p>对于 $p$, 一个显然的思路是依次删除度数尽量小的点, 并在删点的过程中维护当前得到的最大 $p$ 值.</p><p>对于 $q$, 直接做显然是 NPC. 考虑一个贪心, 每次选择度数最小的点, 然后将这个点周围的点删去, 更新其余点的度数.</p><p>考虑如何证明这个做法的正确性.</p><p>求一个可行的 $q$ 时, 删去的节点不超过 $p$ 个. 即 $q \ge \lceil \frac{n}{p + 1} \rceil$. 进行一些转化, 有</p><script type="math/tex; mode=display">\frac{n}{p + 1} <\lceil \frac{n}{p + 1} \rceil +1 \le q + 1</script><script type="math/tex; mode=display">n < (p + 1) (q + 1)</script><p>这就是要证的.</p><p>时间复杂度大概是 $O((n + m) \log m)$? 感觉很假…</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3113</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e4</span> + <span class="number">5</span>, MAXM = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> d, u;</span><br><span class="line">    Item(<span class="keyword">int</span> _d, <span class="keyword">int</span> _u): d(_d), u(_u) &#123; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> d &gt; rhs.d; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> deg[MAXN];</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Item&gt; PQ;</span><br><span class="line"><span class="keyword">int</span> vis[MAXN], Time;</span><br><span class="line"><span class="keyword">int</span> f[MAXN], A[MAXN], B[MAXN], nA, nB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Lively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> Rmv[MAXN], nR, p, limit;</span><br><span class="line">    ++Time, limit = nR = <span class="number">0</span>, p = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">        p = min(p, f[u]), PQ.push(Item(f[u] = deg[u], u));</span><br><span class="line">    <span class="keyword">while</span> (!PQ.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = PQ.top().u, d = PQ.top().d; PQ.pop();</span><br><span class="line">        <span class="keyword">if</span> (d != f[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; d) p = d, limit = nR;</span><br><span class="line">        Rmv[++nR] = u, vis[u] = Time;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = Graph::head[u]; ~i; i = Graph::edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[v = Graph::edges[i].to] == Time) <span class="keyword">continue</span>;</span><br><span class="line">            PQ.push(Item(--f[v], v));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nA = <span class="number">0</span>, ++Time;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= limit; ++i) vis[Rmv[i]] = Time;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">        <span class="keyword">if</span> (vis[u] != Time) A[++nA] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awkward</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    nB = <span class="number">0</span>, ++Time;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">        PQ.push(Item(f[u] = deg[u], u));</span><br><span class="line">    <span class="keyword">while</span> (!PQ.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = PQ.top().u, d = PQ.top().d; PQ.pop();</span><br><span class="line">        <span class="keyword">if</span> (d != f[u] || vis[u] == Time) <span class="keyword">continue</span>;</span><br><span class="line">        B[++nB] = u, vis[u] = Time;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = Graph::head[u]; ~i; i = Graph::edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[v = Graph::edges[i].to] == Time) <span class="keyword">continue</span>;</span><br><span class="line">            vis[v] = Time;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x, j = Graph::head[v]; ~j; j = Graph::edges[j].nxt)</span><br><span class="line">                <span class="keyword">if</span> (vis[x = Graph::edges[j].to] != Time) PQ.push(Item(--f[x], x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> Ti; read(Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        Graph::init();</span><br><span class="line">        <span class="built_in">memset</span>(deg, <span class="number">0</span>, <span class="keyword">sizeof</span> deg);</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        read(n), read(m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            read(u), read(v);</span><br><span class="line">            Graph::AddEdge(u, v), Graph::AddEdge(v, u);</span><br><span class="line">            ++deg[u], ++deg[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// solve</span></span><br><span class="line">        Lively(), Awkward();</span><br><span class="line">        <span class="comment">// output</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, nA);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nA; ++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, A[i], <span class="string">" \n"</span>[i == nA]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, nB);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nB; ++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, B[i], <span class="string">" \n"</span>[i == nB]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SDOI2019」移动金币"><a href="#「SDOI2019」移动金币" class="headerlink" title="「SDOI2019」移动金币"></a>「SDOI2019」移动金币</h3><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3114" target="_blank" rel="noopener">https://loj.ac/problem/3114</a></li></ul><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>似乎是单纯的 Staircase Nim 计数?</del></p><p>对题意做一步转化. 将移动金币的过程看作一定量的格子移动到了金币后. 那么, 将金币看作阶梯的分界, 移动金币看作将阶梯上的石子移动到下一层, 显然就是 “阶梯博弈” 的模型了.</p><p>阶梯博弈中, 先手必胜的条件是所有编号为奇 (注意这里的编号从 $0$ 开始) 的阶梯上石子个数异或和不为 $0$. 此时根据后手的决策讨论一番即可得出证明.</p><p>那么, 现在有 $n - m$ 颗石子, 要将这些石子放在在 $m + 1$ 个阶梯上, 求满足限制的方案数.</p><p>注意到 “异或和不为 $0$” 的条件不好处理, 于是改为处理编号为奇数的阶梯上异或和为 $0$ 的方案数. 考虑二进制下按位 DP, 则需要满足的条件为每一位出现 $1$ 的次数为偶数次.</p><p>设 $f(i, j)$ 表示处理完前 $i$ 位, 剩余 $j$ 个石子的方案数. 为满足异或和为 $0$ 的条件, 需要选择偶数个阶梯, 在这些阶梯上放置 $2 ^ i$ 个石子. </p><p>记编号为奇数的阶梯个数为 $q = \lfloor \frac{m + 1}{2} \rfloor$, 有</p><script type="math/tex; mode=display">f(i, j) = \sum_{k \bmod 2 = 0} ^ q f(i + 1, j + k \cdot 2 ^ {i})</script><p>记编号为偶数的阶梯个数为 $p = \lceil \frac{m + 1}{2} \rceil$, 最终答案为</p><script type="math/tex; mode=display">\binom{n}{m} - \sum_{i = 0} ^ {n - m} \binom{i + p - 1}{i} \cdot f\big(0,\ i\big)</script><p>时间复杂度 $O(nm\log n)$.</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3114</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">15e4</span> + <span class="number">5</span>, MAXM = <span class="number">55</span>, LOG = <span class="number">19</span>, P = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fac[MAXN], ifac[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % P;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PolyPre</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) fac[i] = <span class="number">1L</span>L * i * fac[i - <span class="number">1</span>] % P;</span><br><span class="line">    ifac[N] = fpow(fac[N], P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i; --i) ifac[i - <span class="number">1</span>] = <span class="number">1L</span>L * ifac[i] * i % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt; m? <span class="number">0</span>: <span class="number">1L</span>L * fac[n] * ifac[n - m] % P * ifac[m] % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> f[LOG][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="comment">// sovle</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span>;</span><br><span class="line">    PolyPre(n + m);</span><br><span class="line">    <span class="keyword">int</span> q = (m + <span class="number">1</span>) / <span class="number">2</span>, lg2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; lg2) &lt;= n - m) ++lg2;</span><br><span class="line">    f[lg2][n - m] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lg2 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n - m; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= q &amp;&amp; j + k * (<span class="number">1L</span>L &lt;&lt; i) &lt;= n - m; k += <span class="number">2</span>)</span><br><span class="line">                f[i][j] = (f[i][j] + <span class="number">1L</span>L * C(q, k) * f[i + <span class="number">1</span>][j + k * (<span class="number">1</span> &lt;&lt; i)] % P) % P;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - m; ++i)</span><br><span class="line">        ans = (ans + <span class="number">1L</span>L * C(i + (m + <span class="number">2</span>) / <span class="number">2</span> - <span class="number">1</span>, i) * f[<span class="number">0</span>][i] % P) % P;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (C(n, m) - ans + P) % P);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SDOI2019」连续子序列"><a href="#「SDOI2019」连续子序列" class="headerlink" title="「SDOI2019」连续子序列"></a>「SDOI2019」连续子序列</h3><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3115" target="_blank" rel="noopener">https://loj.ac/problem/3115</a></li></ul><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>根据 <del>T.M. 序列</del> $\text{Thue−Morse}$ 序列的定义, 手玩之后可以发现:</p><ol><li><p>序列从 <code>&#39;0&#39;</code> 出发, 定义 “扩充” 为长度为 $n$ 的序列的每一个字符 <code>&#39;0&#39; --&gt; &#39;01&#39;</code>, <code>&#39;1&#39; --&gt; &#39;10&#39;</code>, 从而得到另一个长度 $2n$ 序列. 不断扩充后得到的序列, 恰好是 Thus-Morse 序列.</p></li><li><p>任何子串包含 <code>111</code> 或 <code>000</code> 的串一定不是 Thus-Morse 序列的子串.</p><p>考虑到性质 1 给出的构造 Thus-Morse 序列的方法, 至多有两个相同字符相邻.</p></li><li><p>长度 $&gt; 3$ 的 Thus-Morse 序列子串 $S$ 一定是由唯一的某个 Thus-Morse 序列子串生成的.</p><p>证明参见: <a href="https://okazakiyumemi.github.io/blog/%E3%80%8CSDOI2019%E3%80%8D%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/" target="_blank" rel="noopener">https://okazakiyumemi.github.io/blog/「SDOI2019」连续子序列/</a>.</p></li></ol><p>此时得到了一个分治做法: 每次由 $S$ 得到扩充操作之前的串 $T$, 然后分治计算 $T$ 的答案再加以合并.</p><p>注意在得出扩充操作前的串 $T$ 时, 需讨论从 $S$ 开头匹配, 以及在 $S$ 前增加一个字符后两种情况. 后者可看作 “$T$ 是 T.M. 的连续子序列” 条件下多考虑的情况.</p><p>此外, $|S| \le 3$ 时的问题仍然没有解决.</p><p>除去 $|S| = 2$ 或 $|S| = 3$ 的一些特殊情况, 剩余的问题在于 $|S| = 1$.</p><p>设 $f(k)$ 表示一个字符后添加恰好 $k$ 个字符, 得出合法序列的方案数. 不难发现, 这个字符为 <code>0</code> / <code>1</code> 并不影响 $f(k)$ 的值, 并有</p><script type="math/tex; mode=display">f(k) = f(\lfloor \frac{k}{2} \rfloor) + f(\lfloor \frac{k + 1}{2} \rfloor)</script><p>记忆化即可. 并存在初值 $f(0) = 1,\ f(1) = 2,\ f(2) = 3$.</p><p>时间复杂度大概是 $O(T \cdot (|S| + \log k))$?</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3115</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> LL&amp; k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">unordered_map</span>&lt;LL, <span class="keyword">int</span>&gt; mf;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">3</span>) <span class="keyword">return</span> k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (mf.count(k) &gt; <span class="number">0</span>)? mf[k]: mf[k] = (f(k / <span class="number">2</span>) + f((k + <span class="number">1</span>) / <span class="number">2</span>)) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">compress</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; S, <span class="built_in">string</span>&amp; T)</span> </span>&#123;</span><br><span class="line">    T.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; S.size(); i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> != S.size() &amp;&amp; S[i] == S[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        T += S[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; S, <span class="keyword">const</span> LL&amp; K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lgt = (<span class="keyword">int</span>) S.size();</span><br><span class="line">    <span class="keyword">if</span> (lgt == <span class="number">1</span>) <span class="keyword">return</span> f(K);</span><br><span class="line">    <span class="keyword">if</span> (lgt == <span class="number">2</span> &amp;&amp; K == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 10 / 01, 11 / 00</span></span><br><span class="line">    <span class="keyword">if</span> (lgt == <span class="number">2</span> &amp;&amp; K == <span class="number">1</span>) <span class="keyword">return</span> (S[<span class="number">0</span>] == S[<span class="number">1</span>])? <span class="number">1</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (lgt == <span class="number">3</span> &amp;&amp; K == <span class="number">0</span>) <span class="keyword">return</span> S[<span class="number">0</span>] != S[<span class="number">1</span>] || S[<span class="number">1</span>] != S[<span class="number">2</span>]; <span class="comment">// 111, 000</span></span><br><span class="line">    <span class="built_in">string</span> T;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (compress(S, T))</span><br><span class="line">        ret = (ret + solve(T, (K + !(lgt &amp; <span class="number">1</span>)) / <span class="number">2</span>)) % P;</span><br><span class="line">    <span class="keyword">if</span> (compress((S[<span class="number">0</span>] == <span class="string">'0'</span>? <span class="string">'1'</span>: <span class="string">'0'</span>) + S, T))</span><br><span class="line">        ret = (ret + solve(T, (K + (lgt &amp; <span class="number">1</span>)) / <span class="number">2</span>)) % P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> Ti;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Ti;</span><br><span class="line">    <span class="keyword">for</span> (LL K; Ti; --Ti) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">string</span> str;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str &gt;&gt; K;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solve(str, K) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;从四月开始摸了两周鱼… 感觉不太行, 又滚过来做省选套题了.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>「CTSC 2010」性能优化 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/luogu-P4191/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/luogu-P4191/</id>
    <published>2020-04-11T08:45:40.000Z</published>
    <updated>2020-04-28T16:07:02.789Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P4191" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P4191</a></li></ul><p>这道题真是奥妙重重, 直接暴露了我 FFT 那一套单位根的东西没搞懂 = =</p><a id="more"></a><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>给定两个序列 $a_0,\ a_1,\ \ldots, a_{n - 1}$, 以及 $b_0,\ b_1,\ \ldots, b_{n - 1}$, 定义一种运算</p><script type="math/tex; mode=display">c_{r} = \sum_{(p + q) \bmod n = r} a_p \cdot b_q</script><p>也就是循环卷积. 求 $a \cdot b ^ c$ 各项模 $n + 1$ 后的值.</p><p>其中 $n$ 在质因数分解后每个质因数不超过 $10$, $n + 1$ 为质数, 且 $n \le 5 \times 10 ^ 5$, $a_i, b_i, C \le 10 ^ 9$.</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>先观察循环卷积是个什么东西.</p><p>根据 <del>等比数列求和</del> 单位根反演, 有</p><script type="math/tex; mode=display">\frac{1}{n} \sum_{0 \le k < n} \omega_{n}^{vk} = [v \bmod n = 0]</script><p>那么有</p><script type="math/tex; mode=display">c_r = \sum_{(p + q) \bmod n = r} a_p \cdot b_q = \sum_{p,\ q} \frac{1}{n} \sum_{0 \le k < n} \omega_{n}^{(p + q - r) k} \cdot a_p b_q</script><p>稍微整理一下, 得</p><script type="math/tex; mode=display">c_r = \frac{1}{n} \sum_{0 \le k < n} \omega_{n} ^ {-rk} \left( \sum_{0 \le p < n} a_p \omega_{n}^{pk} \right) \left( \sum_{0 \le q < n} b_q \omega_{n}^{qk}\right)</script><p>那么对 $a$, $b$ 做 DFT, 乘起来再做一次 IDFT 即可得出 $c$.</p><p>问题在于, $n$ 不满足 FFT 的要求, 即 $n$ 不是 $2$ 的幂次. 现在要处理的事情就是混合基 FFT 的计算.</p><p>将 $n$ 质因数分解, 得到</p><script type="math/tex; mode=display">n = 2 ^ {c_1} \times 3 ^ {c_2} \times 5 ^ {c_3} \times 7 ^ {c_4}</script><p>在做朴素 FFT 时有 $n = 2 ^ c$, 每次将序列分作两部分合并. 现在, 将序列分作 $p$ 部分 ($p \in \{2 ,\ 3,\ 5,\ 7 \}$) 部分, 然后合并.</p><p>重新推导 DFT 的式子. 将多项式的系数按照次项模 $p$ 意义下不同取值分为 $p$ 组, 记作 $F_r(x)$, 即</p><script type="math/tex; mode=display">F_r(x) = \sum_{0 \le k < n} f_{kp + r} x^ k</script><p>取 $F_r(x)$ 在 $x = \omega_{n} ^ i\ (0 \le i &lt; n)$ 处的点值. 同时需要将 $p$ 组点值合并为 $pn$ 组点值. 合并后的多项式为</p><script type="math/tex; mode=display">F(x) = \sum_{0 \le k < pn} f_k x ^ k</script><p>利用单位根的性质, 可以得到</p><script type="math/tex; mode=display">\omega_{pn}^{kp + r} = \left( \omega_{n} ^ k \right) ^ {\frac{kp + r}{kp}} = \omega_{n}^k \cdot \omega_{pn} ^ r</script><p>那么有</p><script type="math/tex; mode=display">F(\omega_{pn} ^ i) = \sum_{0 \le k < pn} f_k \cdot (\omega_{pn}^i) ^ k = \sum_{0\le r < p} (\omega_{pn} ^ i) ^ r F_r(\omega_{n}^i)</script><p>其中 $0 \le i &lt; pn$, 不妨将 $i$ 表示为 $an + b$. 则</p><script type="math/tex; mode=display">F(\omega_{pn} ^ {an + b}) = \sum_{0 \le r < p} \left( \omega_{pn} ^ {an+b} \right) ^ r F_r (\omega_n ^ b)</script><p>此时得出了在 $O(p)$ 的时间复杂度内合并一处点值的方法.</p><p>IDFT 时类似, 根据下式可在 DFT 的基础上简单计算.</p><script type="math/tex; mode=display">c_r = \frac{1}{n} \sum_{0 \le k < n} a_k \omega_{n}^{-rk} = \frac{1}{n} \sum_{0 \le k < n} a_k \omega_{n} ^ {r(n-k)}</script><p>如果追求迭代实现, 那么在预处理每个元素分治时的位置需要精巧实现.</p><p>注意到 $n + 1$ 保证为质数, 且根据 $n$ 的性质可以快速计算原根. 利用原根作为单位根就好了.</p><p>再来分析时间复杂度. 分治计算的过程中, 层数 $\sum\limits_{i = 1} ^ 4 c_i = O(\log n)$, 每层合并的复杂度为 $O(pn)$ 且 $p$ 为常数, 因此总时间复杂度为 $O(n \log n)$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>参考了 <a href="https://www.luogu.com.cn/blog/wengweijie/solution-p4191" target="_blank" rel="noopener">Weng_Weijie</a> 的迭代实现. <del>问就是奥妙重重</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P4191</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(args...) fprintf(stderr, ##args)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e5</span> + <span class="number">5</span>, MAXM = <span class="number">114514</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> P, W[MAXN];</span><br><span class="line"><span class="keyword">int</span> fact[MAXM], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> m = P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % m;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="comment">// f(w ^ &#123;an+b&#125;_&#123;pn&#125;) = sum (w ^ &#123;an+b&#125;_&#123;pn&#125;) ^ r f_r (w ^ &#123;b&#125;_&#123;n&#125;)</span></span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Rev</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = tot, Mid = n; k; Mid /= fact[k--]) &#123;</span><br><span class="line">            <span class="comment">// i, l = an, j = b</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; n; i += Mid)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; fact[k]; ++j)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; Mid; l += fact[k]) r[idx++] = f[i + j + l];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) f[i] = r[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n, <span class="keyword">const</span> <span class="keyword">int</span>&amp; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> tmp[MAXN];</span><br><span class="line">        Rev(f, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, Mid = <span class="number">1</span>; k &lt;= tot; Mid *= fact[k++]) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span>&amp; unit = W[n / (Mid * fact[k])];</span><br><span class="line">            <span class="built_in">memset</span>(tmp, <span class="number">0</span>, n * <span class="keyword">sizeof</span> (<span class="keyword">int</span>));</span><br><span class="line">            <span class="comment">// i = an, j = b, l = b'</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += Mid * fact[k]) &#123;</span><br><span class="line">                <span class="keyword">int</span> wk = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid * fact[k]; ++j) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>, l = j % Mid; l &lt; Mid * fact[k]; l += Mid) &#123;</span><br><span class="line">                        tmp[i + j] = (tmp[i + j] + <span class="number">1L</span>L * w * f[i + l] % P) % P;</span><br><span class="line">                        w = <span class="number">1L</span>L * w * wk % P;</span><br><span class="line">                    &#125;</span><br><span class="line">                    wk = <span class="number">1L</span>L * wk * unit % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(f, tmp, n * <span class="keyword">sizeof</span> (<span class="keyword">int</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// n * n = 1 (mod n + 1)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) f[i] = <span class="number">1L</span>L * f[i] * n % P;</span><br><span class="line">            reverse(f + <span class="number">1</span>, f + n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">proot</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> phi = p - <span class="number">1</span>; tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">2</span>; d*d &lt;= phi; ++d)</span><br><span class="line">        <span class="keyword">while</span> (phi % d == <span class="number">0</span>) phi /= d, fact[++tot] = d;</span><br><span class="line">    <span class="keyword">if</span> (phi &gt; <span class="number">1</span>) fact[++tot] = phi;</span><br><span class="line">    phi = p - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> g = <span class="number">2</span>; g &lt; p; ++g) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot &amp;&amp; flag; ++i)</span><br><span class="line">            <span class="keyword">if</span> (fpow(g, phi / fact[i], p) == <span class="number">1</span>) flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, C;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">PolyPre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    W[<span class="number">0</span>] = <span class="number">1</span>, W[<span class="number">1</span>] = proot(P);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) W[i] = <span class="number">1L</span>L * W[<span class="number">1</span>] * W[i<span class="number">-1</span>] % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(C);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) read(A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) read(B[i]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    P = n + <span class="number">1</span>, PolyPre();</span><br><span class="line">    Poly::NTT(A, n, <span class="number">1</span>), Poly::NTT(B, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        A[i] = <span class="number">1L</span>L * A[i] * fpow(B[i], C) % P;</span><br><span class="line">    Poly::NTT(A, n, <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, A[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>skywalkert, <a href="https://blog.csdn.net/skywalkert/article/details/51737272" target="_blank" rel="noopener">BZOJ 1919 [Ctsc2010]性能优化</a>.</li><li>lvzelong2014, <a href="https://blog.csdn.net/lvzelong2014/article/details/85939531" target="_blank" rel="noopener">bzoj1919: [Ctsc2010]性能优化</a>.</li><li>Weng_Weijie, <a href="https://www.luogu.com.cn/blog/wengweijie/solution-p4191" target="_blank" rel="noopener">题解 P4191 【[CTSC2010]性能优化】</a>.</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://www.luogu.com.cn/problem/P4191&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.com.cn/problem/P4191&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这道题真是奥妙重重, 直接暴露了我 FFT 那一套单位根的东西没搞懂 = =&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Polynomial" scheme="https://depletedprism.github.io/tags/Polynomial/"/>
    
  </entry>
  
  <entry>
    <title>一些简单的图计数问题</title>
    <link href="https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/graph-count/"/>
    <id>https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/graph-count/</id>
    <published>2020-04-07T13:31:16.000Z</published>
    <updated>2020-05-25T00:47:53.538Z</updated>
    
    <content type="html"><![CDATA[<hr><p><del>老年健忘选手终于下定决心去学数数了.</del></p><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>大概是利用生成函数推出一些式子, 然后拿多项式去算吧 = =</p><a id="more"></a><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ol><li><p>多项式的相关运算</p><p>最好有跑地比谁都快的板子, 以免在做题的时候被卡常.</p></li><li><p>生成函数</p><p>对于一个数列 $\{ a_n \}$, 有</p><p>$\{ a_n \}$ 的普通生成函数 (<strong>O</strong>rdinary <strong>G</strong>enerating <strong>F</strong>unction, OGF), 为</p><script type="math/tex; mode=display">g(x) = \sum\limits_{k = 0}^\infty a_k x^k</script><p>常用于处理无标号问题.</p><p>$\{ a_n \}$ 的指数生成函数, (<strong>E</strong>xponential <strong>G</strong>enerating <strong>F</strong>unction, EGF), 为</p><script type="math/tex; mode=display">g(x) = \sum\limits_{k = 0}^\infty a_k \frac{x^k}{k!}</script><p>常用于处理有标号问题.</p><p>$\{ a_n \}$ 的组合生成函数, 为</p><script type="math/tex; mode=display">g(x) = \sum\limits_{k = 0}^\infty a_k \frac{x^k}{2 ^ \binom{k}{2} k!}</script><p>其中 “组合生成函数” 是从 JOHNKRAM 课件里看来的新东西, 似乎只在有标号有向图计数中用到过…</p></li><li><p>拉格朗日反演</p><p>在遇到多项式复合逆的时候快速计算出某一位的值.</p><p>设多项式 $F(x),\ G(x)$ 满足 $F(G(x)) = G(F(x)) = x$, 并记 $[x^n]F(x)$ 表示 $F(x)$ 的第 $n$ 次项系数, 那么</p><script type="math/tex; mode=display">[x^n] G(x) = \frac{1}{n} [x^{n-1}] \left(\frac{x}{F(x)}\right)^n</script><p>还有一个拓展形式. 设 $H(x)$ 是另一个多项式, 那么</p><script type="math/tex; mode=display">[x^n] H\left(G(x)\right) = \frac{1}{n} [x^{n-1}] H'(x) \left(\frac{x}{F(x)}\right)^n</script></li></ol><h2 id="连通-不连通"><a href="#连通-不连通" class="headerlink" title="连通 / 不连通?"></a>连通 / 不连通?</h2><p>对于有标号元素 $A$ 组成的集合 $B$, 不妨设 $A$ 的 EGF 为 $A(x)$, 考虑到集合内的元素没有顺序关系. 可以得到 $B$ 的 EGF 为</p><script type="math/tex; mode=display">B(x) = \sum_{k = 0} ^ \infty \frac{A(x) ^ k}{k!} = \exp A(x)</script><p>应用在图计数中, 可以将非连通图看作多个连通图构成的集合.</p><p>也就是在确定连通图个数的 EGF 后, 可以通过多项式 $\exp$ 得出非连通图个数的 EGF.</p><h2 id="有标号无向图计数"><a href="#有标号无向图计数" class="headerlink" title="有标号无向图计数"></a>有标号无向图计数</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>考虑到 Prufer 序列将一个带标号且有 $n$ 个节点的树用 $[1,\ n]$ 中 $n-2$ 个整数表示, 且 Prufer 序列同树一一对应. 那么, 直接统计 Prufer 序列的个数即可.</p><p>记树的 EGF 为 $T(x)$, 那么</p><script type="math/tex; mode=display">T(x) = \sum_{k = 2} ^ \infty \frac{k ^ {k - 2}}{k!} x^k</script><p>此时得到是无根树的结果, 而对于有根树, 枚举根的位置计算即可, 也就是无根树的个数乘以点数.</p><h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3><p>对于含有 $n$ 个点的无向图, 先考虑不连通的情况, 直接利用 $\binom{n}{2}$ 条边的存在情况计算即可.</p><p>记无向图的 EGF 为 $G(x)$, 那么</p><script type="math/tex; mode=display">G(x) = \sum_{k = 0} ^ \infty \frac{2 ^ \binom{n}{2}}{k!} x ^ k</script><p>根据之前的讨论, 无向连通图的 EGF 即为 $\exp G(x)$.</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><ul><li><a href="https://www.luogu.com.cn/problem/P4841" target="_blank" rel="noopener">Luogu P4841 城市规划</a></li></ul><h3 id="基环树"><a href="#基环树" class="headerlink" title="基环树"></a>基环树</h3><p>基环树即为包含 $n$ 个节点, $n$ 条边的简单图. 在形态上仅有一个简单环, 且环上每一个节点都是一棵有根树的根节点.</p><p>回忆有标号环的计数, 以及圆排列公式. 对于组合对象 $A$, 由 $A$ 构成的环 $B$ 的 EGF 为</p><script type="math/tex; mode=display">B(x) = \sum_{k = 1} ^ \infty \frac{(k - 1)!}{k!} A(x) ^ k = \sum_{k = 1} ^ \infty \frac{1}{k} A(x) ^ k = - \ln \left(1 - A(x)\right)</script><p>注意到基环树上一定存在一个长度 $\ge 3$ 的环, 记有根树的 EGF 为 $T(x)$, 基环树的 EGF 为 $C(x)$, 那么</p><script type="math/tex; mode=display">T(x) = \sum_{k = 1} ^ \infty \frac{k ^ {k - 1}}{k!} x^k</script><p>考虑到基环树中的环没有方向, 可以翻转, 直接套用上面的公式会算重.</p><script type="math/tex; mode=display">C(x) = \frac{1}{2} \sum_{k = 3} ^ \infty \frac{T(x) ^ k}{k}</script><p>化简之后可得</p><script type="math/tex; mode=display">C(x) = \frac{1}{2} \ln \big(1 - T(x)\big) - \frac{1}{2} T(x) - \frac{1}{4} T(x) ^ 2</script><p>利用多项式 $\ln$ 和多项式乘法即可在 $O(n\log n)$ 的时间复杂度内计算.</p><h3 id="仙人掌"><a href="#仙人掌" class="headerlink" title="仙人掌"></a>仙人掌</h3><p>如果一个无向连通图任意一条边最多属于一个简单环, 那么称这个无向连通图为仙人掌.</p><p>先钦定仙人掌上某一点为根, 设 “有根仙人掌” 个数的 EGF 为 $C(x)$, 最后在结果的系数上除 $n$ 即可.</p><p>从 “任意一条边最多属于一个简单环” 这一条件入手. 考虑根节点连出的边, 可以分为简单环上和不属于任何简单环的独立边两种.</p><p>对于环上的边, 设环中点数为 $k + 1$, 考虑环上每一个节点都可以作为有根仙人掌的根, 那么环的生成函数为 $\frac{1}{2} C(x) ^ k$. 对于独立边, 另一端点为有根仙人掌的根, 其生成函数为 $C(x)$.</p><p>而根节点连出的边可看作上述两种情况构成的集合, 同时考虑根节点的影响, 可以得出</p><script type="math/tex; mode=display">C(x) = x \exp\left( C(x) + \frac{1}{2} \sum_{k = 2} ^ \infty C(x) ^ k\right) = x \exp \frac{2C(x) - C(x) ^ 2}{2 - 2 C(x)}</script><p><em>此处也可以从圆方树的角度考虑, 可以得到同样的结果.</em></p><p><em>详见: <a href="https://blog.csdn.net/qq_39972971/article/details/89214832" target="_blank" rel="noopener">https://blog.csdn.net/qq_39972971/article/details/89214832</a></em></p><p>然后套牛顿迭代的式子, 记 $C_0(x)$ 为模 $x ^ {\lceil \frac{n}{2} \rceil}$ 意义下的结果, $C(x)$ 为模 $x ^ n$ 意义下的结果, 同时记录 $T(x)$ 来便于表述, 有</p><script type="math/tex; mode=display">T(x) = x \exp \frac{ 2C_0(x) - C_0 (x) ^ 2 }{ 2 - 2 C_0(x) ^ 2 }</script><script type="math/tex; mode=display">C(x) = C_0(x) - \frac{ 2T(x) - 2 C_0 }{ \Big( 1 + 1\ /\ \big(C_0(x) ^ 2 - 2C_0(x) + 1\big) \Big) T(x) - 2 }</script><p><em>详细的过程可以在 <a href="https://memset0.cn/loj6569" target="_blank" rel="noopener">memset0 的博客</a> 内找到.</em></p><p>至此我们得出了在 $O(n\log n)$ 的时间复杂度内计算 $n$ 项的做法. 实现时可以合并一部分式子来避免重复计算, 以及便于实现.</p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><ul><li><a href="https://loj.ac/problem/6569" target="_blank" rel="noopener">LOJ #6569 仙人掌计数</a></li><li><a href="https://www.luogu.com.cn/problem/P5434" target="_blank" rel="noopener">Luogu P5434 有标号荒漠计数</a></li></ul><h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><p>二分图为节点可分作两个集合, 且保证集合内部不存在边的图.</p><p>先考虑将二分图的两个部分黑白染色, 枚举黑色节点的个数 $k$, 容易得到黑白染色的二分图个数 $f_n$ 为</p><script type="math/tex; mode=display">f_n = \sum_{k = 0} ^ n \binom{n}{k} 2 ^ {k (n - k)}</script><p>我们有 $k (n - k) = \binom{n}{2} - \binom{k}{2} - \binom{n - k}{2}$, 所以原式可化作</p><script type="math/tex; mode=display">f_n = \sum_{k = 0} ^ n \frac{n!}{k! (n - k)!} 2 ^ \binom{n}{2} 2 ^ {-\binom{k}{2}} 2 ^ {-\binom{n - k}{2}}</script><script type="math/tex; mode=display">\frac{f_n}{n!\ 2 ^ {\binom{n}{2}}} = \sum_{k = 0} ^ n \frac{1}{(n - k)!\ 2 ^ \binom{n - k}{2}} \cdot \frac{1}{k!\ 2 ^ \binom{k}{2}}</script><p>显然是卷积的形式, 利用 FFT 即可在 $O(n \log n)$ 的时间内计算.</p><p>接下来考虑去掉染色怎么做.</p><p>设黑白染色后的二分图 EGF 为 $F(x)$, 不染色二分图 EGF 为 $B(x)$, 连通的不染色二分图为 $C(x)$. 那么有</p><script type="math/tex; mode=display">F(x) = \sum_{k = 0} ^ \infty \frac{2 ^ k C(x) ^ k}{k!} = \exp \big(2C(x)\big)</script><script type="math/tex; mode=display">B(x) = \sum_{k = 0} ^ \infty \frac{C(x) ^ k}{k!} = \exp \big( C(x) \big)</script><p>容易发现 $B(x) = \sqrt {F(x)}$, 利用多项式开方即可在 $O(n \log n)$ 的时间内计算.</p><h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><ul><li><a href="https://zyzoj.com/problem/1191" target="_blank" rel="noopener">ZYZOJ #1191 有标号二分图计数</a></li><li><a href="http://cogs.pro:8081/cogs/problem/problem.php?pid=vzQSJVjPj" target="_blank" rel="noopener">COGS 2393 [HZOI 2015] 有标号的二分图计数 II</a></li><li><a href="http://cogs.pro:8081/cogs/problem/problem.php?pid=vNymQVjPg" target="_blank" rel="noopener">COGS 2395 [HZOI 2015] 有标号的二分图计数 III</a></li></ul><h3 id="边双连通图"><a href="#边双连通图" class="headerlink" title="边双连通图"></a>边双连通图</h3><p>边双连通图为任意删去一条边, 使得原图不连通的无向图.</p><p>按照以往的思路, 先统计有根的情况. 设 $b_n$ 为有 $n$ 个节点的有根边双连通图个数, $f_n$ 为有 $n$ 个节点的有根连通图个数. 设根所在的边双连通分量大小为 $k$, 那么该边双连通分量中每个点…</p><h4 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h4><ul><li><a href="https://www.luogu.com.cn/problem/P5828" target="_blank" rel="noopener">Luogu P5828 边双连通图计数</a></li></ul><h3 id="点双连通图"><a href="#点双连通图" class="headerlink" title="点双连通图"></a>点双连通图</h3><p>点双连通图为任意删去一个点, 使得原图不连通的无向图.</p><p>咕咕咕.</p><h4 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h4><ul><li><a href="https://www.luogu.com.cn/problem/P5827" target="_blank" rel="noopener">Luogu P5827 点双连通图计数</a></li></ul><h2 id="有标号有向图计数"><a href="#有标号有向图计数" class="headerlink" title="有标号有向图计数"></a>有标号有向图计数</h2><h3 id="有向无环图"><a href="#有向无环图" class="headerlink" title="有向无环图"></a>有向无环图</h3><p>考虑容斥.</p><p>设 $d_n$ 表示有 $n$ 个节点的 DAG 个数, 且不要求弱连通. 记 $A_{n, i}$ 表示有 $n$ 个节点, 其中有 $i$ 个节点入度为 $0$. 有</p><script type="math/tex; mode=display">d_n = \mid \bigcap_{i = 0} ^ n A_{n, i} \mid</script><p>根据容斥原理展开, 得</p><script type="math/tex; mode=display">d_n = \sum_{k = 1} ^ n (-1) ^ {k - 1} \sum_{1 \le i_1, \cdots, i_k \le n} ^ {} \mid \bigcup_{j = 1} ^ k A_{n, i_j} \mid</script><p>注意到后者的并集大小和 $i_j$ 具体取值无关, 也就是在 $n$ 个点中取出 $k$ 个点, 而将这 $k$ 个点删去后剩余 $n - k$ 个点仍然组成 DAG, 且这 $k$ 个点同其余点连边不破坏两边的性质. 因此可得出</p><script type="math/tex; mode=display">d_n = \sum_{k = 1} ^ n (-1) ^ {k - 1} \binom{n}{k} d_{n - k} 2 ^ {k (n - k)}</script><p>我们有 $k (n - k) = \binom{n}{2} - \binom{k}{2} - \binom{n - k}{2}$, 所以原式可化作</p><script type="math/tex; mode=display">d_n = \sum_{k = 1} ^ n (-1) ^ {k - 1} \frac{n!}{k! (n - k)!} d_{n - k} 2 ^ \binom{n}{2} 2 ^ {-\binom{k}{2}} 2 ^ {-\binom{n - k}{2}}</script><script type="math/tex; mode=display">\frac{d_n}{n!\ 2 ^ {\binom{n}{2}}} = \sum_{k = 1} ^ n \frac{d_{n - k}}{(n - k)!\ 2 ^ {\binom{n - k}{2}}} \cdot \frac{(-1) ^ {k - 1}}{k!\ 2 ^ \binom{k}{2}}</script><p>设 $d_n$ 的组合生成函数为 $D(x)$, 同时设</p><script type="math/tex; mode=display">F(x) = \sum\limits_{k = 1} ^ \infty \frac{(-1) ^ {k - 1}}{k!\ 2 ^ \binom{k}{2}}</script><p>那么有</p><script type="math/tex; mode=display">D(x) = D(x)  F(x) + 1 \\\ D(x) = \frac{1}{1 - F(x)}</script><p>一次求乘法逆即可. 时间复杂度 $O(n\log n)$.</p><p>简洁的形式背后一定有我不能理解的高妙组合意义…</p><h4 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h4><ul><li><a href="https://www.luogu.com.cn/problem/P6295" target="_blank" rel="noopener">Luogu P6295 有标号 DAG 计数</a></li></ul><h3 id="强连通图"><a href="#强连通图" class="headerlink" title="强连通图"></a>强连通图</h3><p>强连通图即为任意两点连通的有向图.</p><p>设 $n$ 个点有标号强连通图个数为 $d_n$. 考虑强连通图和 DAG 的关系: 强连通图缩点后为一个 DAG. 但是缩点后 DAG 上每个节点所包含的缩点前的点数并不一定为 $1$, 从而无法利用原来的方法计算.</p><p>此处有一个思路为, 对 DAG 的式子中容斥系数改写, 也就是将系数和方案数 “放在一起” 计算.</p><p>记一个集合 $|S|$ 的权值为 $(-1) ^ {|S|}$, 设 $e_n$ 为任一元素都为强连通图, 且所有强连通图点数和为 $n$ 的集合的权值和. 那么有</p><script type="math/tex; mode=display">e_n = - \sum_{k = 1} ^ n \binom{n}{k} e_{n - k} 2 ^ {k (k-1)} \cdot 2 ^ {k (n-k)}</script><p>其组合意义和 DAG 计数类似, 不再赘述.</p><p>此时可以根据 $e_n$ 计算 $d_n$. 考虑到在一强连通图中删去节点 $1$ 及节点 $1$ 所在连通块, 仍可得到一个由强连通图组成的集合. 同时, 在所有强连通图集合中减去不包含节点 $1$ 的情况即为最终答案. 即</p><script type="math/tex; mode=display">d_n = -e_n - \sum_{k = 1} ^ {n - 1} \binom{n - 1}{k - 1}\ d_k \cdot e_{n - k}</script><p>具体实现时可能需要一些技巧, 例如计算 $d_n$ 时可将 $k$ 枚举的上限改为 $n$ 同时做一些处理, 并不会影响答案且便于计算等.</p><p>利用多项式求逆, 则时间复杂度为 $O(n \log n)$.</p><h4 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h4><ul><li><a href="https://zyzoj.com/problem/1164" target="_blank" rel="noopener">ZYZOJ #1164 有标号强连通图计数</a></li><li><a href="http://cogs.pro:8081/cogs/problem/problem.php?pid=vQmxzVjPW" target="_blank" rel="noopener">COGS 2397 [HZOI 2015]有标号的强连通图计数 II</a></li></ul><h2 id="有标号-无标号"><a href="#有标号-无标号" class="headerlink" title="有标号 / 无标号?"></a>有标号 / 无标号?</h2><p>首先定义形式幂级数的 Euler 变换. 即</p><script type="math/tex; mode=display">\mathcal E\big(F(x)\big) = \prod_{k = 0} ^ \infty (1 + x ^ k + x ^ {2k} + \cdots) ^ {f_k} = \prod_{k = 0} ^ \infty (\frac{1}{1 - x ^ k}) ^ {f_k}</script><p>类比于 exp, Euler 变换的组合意义即为选取若干无标号元素组成集合的方案数. 注意无标号元素的影响, 某些在有标号情况下不同的方案在无标号情况下相同.</p><p>利用一些运算的技巧, 可以得到</p><script type="math/tex; mode=display">\mathcal E\big(F(x)\big) = \exp \left( \sum_{i = 0} ^ \infty f_i \sum_{j = 0} ^ \infty \frac{1}{j} x ^ {ij} \right) = \exp \left( \sum_{k = 0} ^ \infty \frac{1}{k} F(x ^ k) \right)</script><p>这个结果也可以通过 Polya 定理得到.</p><h2 id="无标号图计数"><a href="#无标号图计数" class="headerlink" title="无标号图计数"></a>无标号图计数</h2><h3 id="有根树"><a href="#有根树" class="headerlink" title="有根树"></a>有根树</h3><p>借助 Euler 变换, 有根树可看作根节点接上若干子树. 设无标号有根树 OGF 为 $F(x)$, 那么有</p><script type="math/tex; mode=display">F(x) = x \cdot \mathcal E \big(F(x)\big) = x \cdot \prod_{k = 0} ^ \infty (\frac{1}{1 - x ^ k}) ^ {f_k}</script><p>两边同时取 $\ln$, 得</p><script type="math/tex; mode=display">\ln F(x) = \ln x - \sum_{k = 0} ^ \infty f_k \ln (1 - x ^ k)</script><p>求导, 得</p><script type="math/tex; mode=display">\frac{F(x)'}{F(x)} = \frac{1}{x} + \sum_{k = 1} ^ \infty f_k \cdot \frac{k x ^ {k - 1}}{1 - x ^ k}</script><p>两侧同时乘 $F(x) \cdot x$, 得</p><script type="math/tex; mode=display">x \cdot F(x)' = F(x) + F(x) \left( \sum_{k = 1} ^ \infty k f_k \cdot \frac{x ^ k}{1 - x ^ k}\right)</script><p>取第 $n$ 项系数, 同时设 $g_n = \sum_{k \mid n} k f_k$. 则有</p><script type="math/tex; mode=display">n \cdot f_n = f_n + \sum_{k = 1} ^ n f_k g_{n - k}</script><script type="math/tex; mode=display">f_n = \frac{1}{n - 1} \sum_{k = 1} ^ n f_k g_{n - k}</script><p>分治 FFT 计算即可, 时间复杂度为 $O(n \log ^ 2 n)$.</p><p>实现时, 在计算 $f_n$ 后枚举 $n$ 的倍数更新 $g$. 注意到如果分治的左端点为 $1$, $g$ 位数不够. 在计算左区间对右区间的贡献时, 需要额外注意.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123; <span class="comment">// [L, R)</span></span><br><span class="line">  <span class="keyword">if</span> (R-L &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    f[L] = (L == <span class="number">1</span>)? <span class="number">1</span>: <span class="number">1L</span>L * f[L] * inv[L - <span class="number">1</span>] % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1L</span>L * L * f[L] % P, i = L; i &lt;= n; i += L)</span><br><span class="line">      g[i] = (g[i] + v) % P;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">  solve(L, Mid);</span><br><span class="line">  <span class="keyword">if</span> (L == <span class="number">1</span>) &#123;</span><br><span class="line">    Mul(f, Mid, g + L, Mid - L, h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid; i &lt; R; ++i) f[i] = (f[i] + h[i - L]) % P;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Mul(f + L, Mid - L, g, R - L, h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid; i &lt; R; ++i) f[i] = (f[i] + h[i - L]) % P;</span><br><span class="line">    Mul(f, R - L, g + L, Mid - L, h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid; i &lt; R; ++i) f[i] = (f[i] + h[i - L]) % P;</span><br><span class="line">  &#125;</span><br><span class="line">  solve(Mid, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>另外存在时间复杂度为 $O(n \log n)$ 的牛顿迭代实现. 在常数和推导过程上都没有什么优势…</p><h3 id="无根树"><a href="#无根树" class="headerlink" title="无根树"></a>无根树</h3><p>一个经典的套路是只讨论根为重心的情况, 那么用有根树个数 $f_n$ 减去根不是重心的个数即为无根树个数. 此时根据 $n$ 的奇偶性不同存在 $1$ 或 $2$ 个重心, 讨论的情况相对较少.</p><p>对于 $n$ 为奇数的情况, 重心唯一. 考虑根节点和任意一条和儿子相连的边, 如果根节点不是重心, 那么该儿子的子树大小 $&gt; \lfloor \frac{n}{2} \rfloor$. 可以得出无根树个数为</p><script type="math/tex; mode=display">f_n - \sum_{k = \lfloor \frac{n}{2} \rfloor + 1} ^ {n - 1} f_k \cdot f_{n - k}</script><p>对于 $n$ 为偶数的情况, 重心不唯一. 如果按照奇数的方法计算, 则另外要注意到根和该儿子都为重心的情况. 此时如果断开这条边, 得到的两棵树不同, 则会在之前的过程中重复统计. 也就是说, 需要在奇数的基础上额外减去</p><script type="math/tex; mode=display">\binom{f_{n / 2}}{2}</script><p>利用有根树的计算方法即可.</p><h4 id="例题-7"><a href="#例题-7" class="headerlink" title="例题"></a>例题</h4><ul><li><a href="https://www.luogu.com.cn/problem/P5900" target="_blank" rel="noopener">Luogu P5900 无标号无根树计数</a></li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>似乎这些问题本质上都能归类于 <a href="https://oeis.org/transforms2.html" target="_blank" rel="noopener">https://oeis.org/transforms2.html</a>?</p><p>另外还有其他更为复杂的图计数问题, 以及 “二元生成函数” 之类的科技… 等我学明白了再说吧 (</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>部分整理自 JOHNKRAM 的课件, 也有一些自己的发现.</p><ol><li><a href="http://codeforces.com/problemset/problem/438/E" target="_blank" rel="noopener">CF438E The Child and Binary Tree</a></li><li><a href="http://lydsy.com/JudgeOnline/problem.php?id=3684" target="_blank" rel="noopener">BZOJ 3684 大朋友和多叉树</a></li><li><a href="https://www.luogu.com.cn/problem/P4233" target="_blank" rel="noopener">Luogu P4233 射命丸文的笔记</a></li><li><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5279" target="_blank" rel="noopener">HDU 5279 YJC plays Minecraft</a></li><li><a href="https://www.luogu.com.cn/problem/P5448" target="_blank" rel="noopener">Luogu P5448 [THUPC2018] 好图计数</a></li><li><a href="https://loj.ac/problem/6570" target="_blank" rel="noopener">LOJ #6570 毛毛虫计数</a></li><li><a href="https://loj.ac/problem/6684" target="_blank" rel="noopener">LOJ #6684 有根无标号「奇树」计数</a></li><li><a href="https://loj.ac/problem/6538" target="_blank" rel="noopener">LOJ #6538 烷基计数 加强版 加强版</a></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>汪乐平, &lt;生成函数, 多项式算法与图的计数&gt;. 2019.1.28.</li><li>金策, &lt;生成函数的运算与组合计数问题&gt;. 国家集训队 2015 论文集.</li><li>AntiLeaf, <a href="https://www.cnblogs.com/hzoier/p/6597833.html" target="_blank" rel="noopener">COGS 有标号的二分图计数系列</a>.</li><li>Weng_Weijie, <a href="https://www.luogu.com.cn/blog/wengweijie/solution-p5900" target="_blank" rel="noopener">题解 P5900【无标号无根树计数】</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;del&gt;老年健忘选手终于下定决心去学数数了.&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;大概是利用生成函数推出一些式子, 然后拿多项式去算吧 = =&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://depletedprism.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Combinatorics" scheme="https://depletedprism.github.io/tags/Combinatorics/"/>
    
      <category term="Polynomial" scheme="https://depletedprism.github.io/tags/Polynomial/"/>
    
  </entry>
  
  <entry>
    <title>HNOI 2019 大赏</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/HNOI-2019-sol/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/HNOI-2019-sol/</id>
    <published>2020-03-18T14:08:54.000Z</published>
    <updated>2020-04-28T16:16:31.017Z</updated>
    
    <content type="html"><![CDATA[<hr><p>AH 跑去十二省联考了 (</p><p>HNOI 独自毒瘤.</p><a id="more"></a><h3 id="「HNOI2019」鱼"><a href="#「HNOI2019」鱼" class="headerlink" title="「HNOI2019」鱼"></a>「HNOI2019」鱼</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3054" target="_blank" rel="noopener">https://loj.ac/problem/3054</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>考虑枚举点 $D$, 将其他点按照极角排序, 在排序后得到的结果中枚举点 $A$.</p><p>先处理鱼头部分. 显然有 $AD$ 垂直平分 $BC$, 可以通过二分找到中点在 $AD$ 上, 且垂直于 $AD$ 的线段的范围. 将所有点两两连线, 记录得到的向量及中点, 并排序, 可以保证排序后, 满足以上条件的线段是连续的.</p><p>再考虑鱼尾部分. 现在已经确定了 $AD$ 位置, 因为有 $DE = DF$, 以及 $\angle ADE,\ \angle ADF$ 的限制, 用 <code>map</code> 记录到点 $D$ 为某一长度的线段出现次数, 并用 Two-Points 的技巧维护合法鱼尾的方案数即可.</p><p>此时将鱼头鱼尾的方案数相乘即可. 因为翻转后视为不同的鱼, 最后统计答案需 $\times 4$.</p><p>实际代码中并没有用到 <code>double</code> 之类的东西… 判断两向量位置关系用叉积和点积就好了 (</p><p>时间复杂度 $O(n^2 \log n)$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>在极角序和平面序的浑水里折腾.cpp</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3054</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123; <span class="keyword">return</span> !b? a: gcd(b, a % b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Geo &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line">        LL x, y;</span><br><span class="line">        Vector(LL _x = <span class="number">0</span>, LL _y = <span class="number">0</span>): x(_x), y(_y) &#123; &#125;</span><br><span class="line">        Vector <span class="keyword">operator</span> + (<span class="keyword">const</span> Vector&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Vector(x + rhs.x, y + rhs.y); &#125;</span><br><span class="line">        Vector <span class="keyword">operator</span> - (<span class="keyword">const</span> Vector&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Vector(x - rhs.x, y - rhs.y); &#125;</span><br><span class="line">        Vector <span class="keyword">operator</span> * (<span class="keyword">const</span> LL&amp; p) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Vector(p * x, p * y); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">typedef</span> Vector Point;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point&amp; A, <span class="keyword">const</span> Point&amp; B) &#123;</span><br><span class="line">        <span class="keyword">return</span> A.x &lt; B.x || (A.x == B.x &amp;&amp; A.y &lt; B.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">Dot</span><span class="params">(<span class="keyword">const</span> Vector&amp; A, <span class="keyword">const</span> Vector&amp; B)</span> </span>&#123; <span class="keyword">return</span> A.x * B.x + A.y * B.y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">Cross</span><span class="params">(<span class="keyword">const</span> Vector&amp; A, <span class="keyword">const</span> Vector&amp; B)</span> </span>&#123; <span class="keyword">return</span> A.x * B.y - A.y * B.x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">Length2</span><span class="params">(<span class="keyword">const</span> Vector&amp; A)</span> </span>&#123; <span class="keyword">return</span> Dot(A, A); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Vector <span class="title">Normal</span><span class="params">(Vector A)</span> </span>&#123;</span><br><span class="line">        LL g = gcd(A.x, A.y);</span><br><span class="line">        A.x /= g, A.y /= g;</span><br><span class="line">        <span class="keyword">if</span> (A.x &lt; <span class="number">0</span> || (A.x == <span class="number">0</span> &amp;&amp; A.y &lt; <span class="number">0</span>)) A.x = -A.x, A.y = -A.y;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">        Point p; Vector v;</span><br><span class="line">        Line() &#123; p = v = Point(); &#125;</span><br><span class="line">        Line(Point _p, Vector _v): p(_p), v(_v) &#123; &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Line&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (v &lt; rhs.v || rhs.v &lt; v) <span class="keyword">return</span> v &lt; rhs.v;</span><br><span class="line">            <span class="keyword">if</span> (Dot(v, p) != Dot(rhs.v, rhs.p)) <span class="keyword">return</span> Dot(v, p) &lt; Dot(rhs.v, rhs.p);</span><br><span class="line">            <span class="keyword">return</span> p &lt; rhs.p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Geo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">where</span><span class="params">(<span class="keyword">const</span> Vector&amp; A)</span> </span>&#123; <span class="keyword">return</span> A.y &gt; <span class="number">0</span> || (A.y == <span class="number">0</span> &amp;&amp; A.x &lt; <span class="number">0</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Vector&amp; A, <span class="keyword">const</span> Vector&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> where(A) &lt; where(B) || (where(A) == where(B) &amp;&amp; Cross(A, B) &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, nL, nA;</span><br><span class="line">Point P[MAXN], A[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">Line Li[MAXN * MAXN / <span class="number">2</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;LL, <span class="keyword">int</span>&gt; M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(P[i].x), read(P[i].y);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            Li[++nL] = Line(P[i] + P[j], Normal(P[i] - P[j]));</span><br><span class="line">    sort(Li+<span class="number">1</span>, Li+<span class="number">1</span>+nL);</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        nA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="keyword">if</span> (i != j) A[++nA] = P[j] - P[i];</span><br><span class="line">        sort(A+<span class="number">1</span>, A+<span class="number">1</span>+nA, cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nA; ++j) A[nA + j] = A[j];</span><br><span class="line">        M.clear();</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, L = <span class="number">1</span>, R = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nA; ++j) &#123;</span><br><span class="line">            <span class="comment">// [L, R)</span></span><br><span class="line">            <span class="keyword">while</span> (Cross(A[j], A[R]) &gt; <span class="number">0</span> || (R &lt;= nA &amp;&amp; Cross(A[j], A[R]) == <span class="number">0</span>) || Dot(A[j], A[R]) &lt; <span class="number">0</span>)</span><br><span class="line">                s += M[Length2(A[R++])]++;</span><br><span class="line">            <span class="keyword">while</span> (L &lt; R &amp;&amp; Dot(A[j], A[L]) &gt;= <span class="number">0</span>) s -= --M[Length2(A[L++])];</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            Point v = Normal(Point(A[j].y, -A[j].x)), lp = P[i] * <span class="number">2</span>, rp = (P[i] + A[j]) * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (rp &lt; lp) swap(lp, rp);</span><br><span class="line">            <span class="keyword">int</span> d = lower_bound(Li+<span class="number">1</span>, Li+<span class="number">1</span>+nL, Line(rp, v)) - upper_bound(Li+<span class="number">1</span>, Li+<span class="number">1</span>+nL, Line(lp, v));</span><br><span class="line">            ans += <span class="number">4L</span>L * d * s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「HNOI2019」JOJO"><a href="#「HNOI2019」JOJO" class="headerlink" title="「HNOI2019」JOJO"></a>「HNOI2019」JOJO</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3055" target="_blank" rel="noopener">https://loj.ac/problem/3055</a></li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>还是 <a href="https://www.luogu.com.cn/blog/dsidsi/solution-p5287" target="_blank" rel="noopener">dsidsi 的题解</a> 好啊.</del></p><p>时间复杂度 $O(n\log n)$.</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3055</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read; <span class="keyword">using</span> IO::Gc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>, M = <span class="number">1e4</span> + <span class="number">5</span>, SIGMA = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">s1</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1L</span>L * p * (p + <span class="number">1</span>) / <span class="number">2</span> % P; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, uidx, top;</span><br><span class="line"><span class="keyword">int</span> Ans[MAXN], pos[MAXN], val[MAXN];</span><br><span class="line"><span class="keyword">int</span> rt[MAXN][SIGMA], mx[MAXN][SIGMA];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PSGT &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> <span class="keyword">int</span> lc, rc, s, t, f; &#125; dat[MAXN &lt;&lt; <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">int</span> nidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nidx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(rt[<span class="number">1</span>], <span class="number">0</span>, <span class="keyword">sizeof</span> rt[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">memset</span>(mx[<span class="number">1</span>], <span class="number">0</span>, <span class="keyword">sizeof</span> mx[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span>&amp; nd)</span> </span>&#123; dat[++nidx] = dat[nd], nd = nidx; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">        dat[nd].s = (dat[dat[nd].lc].s + dat[dat[nd].rc].s) % P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushset</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        dat[nd].s = <span class="number">1L</span>L * v * (R - L + <span class="number">1</span>) % P, dat[nd].t = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!dat[nd].t) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> &amp;lc = dat[nd].lc, &amp;rc = dat[nd].rc, Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        newnode(lc), pushset(lc, L, Mid, dat[nd].t);</span><br><span class="line">        newnode(rc), pushset(rc, Mid+<span class="number">1</span>, R, dat[nd].t);</span><br><span class="line">        dat[nd].t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [1, p]: 前缀赋值, 前缀求和</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span>&amp; nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; p, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v, <span class="keyword">const</span> <span class="keyword">int</span>&amp; f)</span> </span>&#123;</span><br><span class="line">        newnode(nd);</span><br><span class="line">        <span class="keyword">if</span> (R &lt; p) <span class="keyword">return</span> pushset(nd, L, R, v);</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> dat[nd].f = f, pushset(nd, L, R, v);</span><br><span class="line">        pushdown(nd, L, R);</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        Mdy(dat[nd].lc, L, Mid, p, v, f);</span><br><span class="line">        <span class="keyword">if</span> (p &gt; Mid) Mdy(dat[nd].rc, Mid+<span class="number">1</span>, R, p, v, f);</span><br><span class="line">        maintain(nd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; p, <span class="keyword">int</span>&amp; s, <span class="keyword">int</span>&amp; fail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (R &lt; p) <span class="keyword">return</span> <span class="keyword">void</span>( s = (s + dat[nd].s) % P );</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> s = (s + dat[nd].s) % P, <span class="keyword">void</span>( fail = dat[nd].f );</span><br><span class="line">        pushdown(nd, L, R);</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        Qry(dat[nd].lc, L, Mid, p, s, fail);</span><br><span class="line">        <span class="keyword">if</span> (p &gt; Mid) Qry(dat[nd].rc, Mid+<span class="number">1</span>, R, p, s, fail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">    <span class="comment">// 维护根节点到 u 的一条链, A[i] 记录链上颜色, B[i] 记录链长度</span></span><br><span class="line">    ++top;</span><br><span class="line">    <span class="keyword">int</span> x = val[u] % M, c = val[u] / M, fail = <span class="number">0</span>;</span><br><span class="line">    A[top] = c, B[top] = B[top - <span class="number">1</span>] + x;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">1</span>) Ans[u] = s1(x - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Ans[u] = (Ans[u] + s1(min(mx[top][c], x))) % P;</span><br><span class="line">        PSGT::Qry(rt[top][c], <span class="number">1</span>, M, x, Ans[u], fail);</span><br><span class="line">        <span class="comment">// 特判前缀第一段字符同末尾相同的情况</span></span><br><span class="line">        <span class="keyword">if</span> (!fail &amp;&amp; A[<span class="number">1</span>] == c &amp;&amp; B[<span class="number">1</span>] &lt; x)</span><br><span class="line">            fail = <span class="number">1</span>, Ans[u] = (Ans[u] + <span class="number">1L</span>L * B[<span class="number">1</span>] * max(<span class="number">0</span>, x - mx[top][c]) % P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    mx[top][c] = max(mx[top][c], x);</span><br><span class="line">    PSGT::Mdy(rt[top][c], <span class="number">1</span>, M, x, B[top - <span class="number">1</span>], top);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v: G[u]) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(rt[top + <span class="number">1</span>], rt[fail + <span class="number">1</span>], <span class="keyword">sizeof</span> rt[top + <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">memcpy</span>(mx[top + <span class="number">1</span>], mx[fail + <span class="number">1</span>], <span class="keyword">sizeof</span> mx[top + <span class="number">1</span>]);</span><br><span class="line">        Ans[v] = Ans[u], dfs(v);</span><br><span class="line">    &#125;</span><br><span class="line">    --top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> opt, x, c;</span><br><span class="line">        read(opt), read(x);</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                c = Gc();</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">isspace</span>(c)) c = Gc();</span><br><span class="line">                val[++uidx] = (c - <span class="string">'a'</span>) * M + x;</span><br><span class="line">                G[pos[i - <span class="number">1</span>]].push_back(pos[i] = uidx);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: pos[i] = pos[x]; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERR\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v: G[<span class="number">0</span>]) PSGT::init(), dfs(v);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans[pos[i]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「HNOI2019」多边形"><a href="#「HNOI2019」多边形" class="headerlink" title="「HNOI2019」多边形"></a>「HNOI2019」多边形</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3056" target="_blank" rel="noopener">https://loj.ac/problem/3056</a></li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>通过手玩可以发现, 最终状态一定是多边形内所有的边都连向顶点 $n$. 如果要保证旋转次数最小, 那么每次操作都要使不连向顶点 $n$ 的边, 连向顶点 $n$.</p><p>记 $s$ 为 $S_0$ 中同 $n$ 直接相连的边数, 最小旋转次数即为 $n - 3 - s$. 接下来的问题就是求解方案数了.</p><p>按照顶点 $n$ 出发的边将多边形分成多个部分, 那么各部分之间互不影响.</p><p>单独考虑每个部分. 设当前操作的部分, 边界处顶点为 $[L,\ R]$, 如果要保证旋转次数最小, 那么第一次旋转操作一定选择顶点 $R$ 出边中最靠近 $L$ 的可行边旋转. 设当前选择边为 $(R,\ k)$, 此后该部分被分成两块: $[L,\ k]$, $[k,\ R]$.</p><p>此时就可以建立出二叉树的模型. 方案数可以通过子树大小和树上结构计算.</p><p>考虑子树间的转移, 也就是取出根节点后, 其余节点按照子树内部顺序考虑. 记左儿子为 $lc$, 右儿子为 $rc$, 根据乘法原理, 方案数乘上</p><script type="math/tex; mode=display">\binom{\mathrm{size}(lc) + \mathrm{size}(rc)}{\mathrm{size}(lc)} \cdot \binom{\mathrm{size}(lc) + \mathrm{size}(rc)}{\mathrm{size}(rc)} = \dfrac{(\mathrm{size}(lc) + \mathrm{size}(rc))!}{\mathrm{size}(lc)! \cdot \mathrm{size}(rc)!}</script><p>即可. 根节点之间的情况则类似.</p><p>此时的转移, 化简之后可以得到相当简洁的结果. 参见: <a href="https://blog.csdn.net/zhouyuheng2003/article/details/89177440" target="_blank" rel="noopener">zhouyuheng2003 的博客</a>.</p><p>但是原来的式子就很够用了, 只有代码长度与常数的区别.</p><p>接下来考虑做一次旋转对答案的影响.</p><p>在二叉树上考虑. 如果强制旋转一条边, 那么二叉树结构的改变类似于平衡树的旋转操作.</p><p><del>此处有张图会非常好理解, 但是这位退役选手却非常鸽子 (</del></p><p>图例就参考 <a href="https://www.cnblogs.com/xzz_233/p/10672208.html" target="_blank" rel="noopener">https://www.cnblogs.com/xzz_233/p/10672208.html</a> 好了 (</p><p>去掉原有贡献, 并计算新增贡献即可.</p><p>时间复杂度 $O(n\log n)$.</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>采用了代码较为冗长的写法…</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3056</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % P;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fac[MAXN &lt;&lt; <span class="number">1</span>], ifac[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1L</span>L * fac[n + m] * ifac[n] % P * ifac[m] % P; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">invc</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1L</span>L * ifac[n + m] * fac[n] % P * fac[m] % P; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, W;</span><br><span class="line"><span class="built_in">map</span>&lt;Pii, <span class="keyword">int</span>&gt; M;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="keyword">int</span> rt[MAXN], ch[<span class="number">2</span>][MAXN], pre[MAXN], size[MAXN], nidx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>&amp; u, <span class="keyword">int</span> fa, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span>&amp; p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L + <span class="number">1</span> &gt;= R) <span class="keyword">return</span>;</span><br><span class="line">    M[Pii(L, R)] = u = ++nidx;</span><br><span class="line">    size[u] = <span class="number">1</span>, pre[u] = fa;</span><br><span class="line">    <span class="keyword">int</span> k = *lower_bound(G[R].begin(), G[R].end(), L + <span class="number">1</span>);</span><br><span class="line">    dfs(ch[<span class="number">0</span>][u], u, L, k, p2), dfs(ch[<span class="number">1</span>][u], u, k, R, p2);</span><br><span class="line">    size[u] += size[ch[<span class="number">0</span>][u]] + size[ch[<span class="number">1</span>][u]];</span><br><span class="line">    p2 = <span class="number">1L</span>L * p2 * calc(size[ch[<span class="number">0</span>][u]], size[ch[<span class="number">1</span>][u]]) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(W), read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= n<span class="number">-3</span>; ++i)</span><br><span class="line">        read(u), read(v), G[u].push_back(v), G[v].push_back(u);</span><br><span class="line">    <span class="comment">// init factorial</span></span><br><span class="line">    <span class="keyword">int</span> N = n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    ifac[<span class="number">0</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) fac[i] = <span class="number">1L</span>L * i * fac[i<span class="number">-1</span>] % P;</span><br><span class="line">    ifac[N] = fpow(fac[N], P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i; --i) ifac[i<span class="number">-1</span>] = <span class="number">1L</span>L * i * ifac[i] % P;</span><br><span class="line">    <span class="comment">// build polygon</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) G[i].push_back(i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>) G[i].push_back(i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    G[<span class="number">1</span>].push_back(n), G[n].push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) sort(G[i].begin(), G[i].end());</span><br><span class="line">    <span class="comment">// calculate</span></span><br><span class="line">    <span class="keyword">int</span> p1 = (n<span class="number">-3</span>) - (G[n].size() - <span class="number">2</span>), p2 = <span class="number">1</span>, s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; G[n].size(); ++i) &#123;</span><br><span class="line">        dfs(rt[i], <span class="number">0</span>, G[n][i], G[n][i + <span class="number">1</span>], p2);</span><br><span class="line">        p2 = <span class="number">1L</span>L * p2 * calc(s, size[rt[i]]) % P, s += size[rt[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (W) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, p1, p2); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p1);</span><br><span class="line">    <span class="comment">// solve &amp; output</span></span><br><span class="line">    read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> L, R, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        read(L), read(R);</span><br><span class="line">        <span class="keyword">int</span> n1 = p1, n2 = p2, u = M[Pii(L, R)];</span><br><span class="line">        <span class="keyword">if</span> (pre[u]) &#123;</span><br><span class="line">            <span class="keyword">int</span> fa = pre[u], w = ch[<span class="number">1</span>][fa] == u;</span><br><span class="line">            n2 = <span class="number">1L</span>L * n2 * invc(size[ch[<span class="number">0</span>][u]], size[ch[<span class="number">1</span>][u]]) % P;</span><br><span class="line">            n2 = <span class="number">1L</span>L * n2 * invc(size[ch[<span class="number">0</span>][fa]], size[ch[<span class="number">1</span>][fa]]) % P;</span><br><span class="line">            n2 = <span class="number">1L</span>L * n2 * calc(size[ch[w^<span class="number">1</span>][fa]], size[ch[w^<span class="number">1</span>][u]]) % P;</span><br><span class="line">            n2 = <span class="number">1L</span>L * n2 * calc(size[fa] - size[u] + size[ch[w^<span class="number">1</span>][u]], size[ch[w][u]]) % P;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --n1;</span><br><span class="line">            n2 = <span class="number">1L</span>L * n2 * invc(size[ch[<span class="number">0</span>][u]], size[ch[<span class="number">1</span>][u]]) % P;</span><br><span class="line">            n2 = <span class="number">1L</span>L * n2 * invc(s - size[u], size[u]) % P;</span><br><span class="line">            n2 = <span class="number">1L</span>L * n2 * calc(s - size[u], size[ch[<span class="number">0</span>][u]]) % P;</span><br><span class="line">            n2 = <span class="number">1L</span>L * n2 * calc(s - size[u] + size[ch[<span class="number">0</span>][u]], size[ch[<span class="number">1</span>][u]]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (W) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, n1, n2); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「HNOI2019」校园旅行"><a href="#「HNOI2019」校园旅行" class="headerlink" title="「HNOI2019」校园旅行"></a>「HNOI2019」校园旅行</h3><p>myy 的题感觉很有意思… 就是做不出来 (</p><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3057" target="_blank" rel="noopener">https://loj.ac/problem/3057</a></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>先祭上官方题解: <a href="https://matthew99.blog.uoj.ac/blog/4968" target="_blank" rel="noopener">https://matthew99.blog.uoj.ac/blog/4968</a></p><p>首先有一个朴素的 DP.</p><p>设 $f(i, j)$ 表示节点 $i$ 到 $j$ 是否存在一条路径, 使得标记形成回文串.</p><p>将所有在给定条件下能形成回文串的点对丢到队列中, 枚举边更新 $f$ 即可. 注意到单独一个点也是合法的情况. 此时的时间复杂度为 $O(m^2)$.</p><p>考虑到边数较多, 而点数较少. 可以将连通块内连边情况进行一些改造, 以降低时间复杂度.</p><p>先只考虑连接两相同标记的边, 对于此时的一个连通块, 如果</p><ul><li><p>为二分图, 那么保留连通块的任意一个生成树即可.</p><p>因为不限制为简单路径, 因此可以在连通块内一条边上反复横跳, 此时得到的标记串长度可以改变, 而奇偶性并不改变. 因此保留生成树即可.</p></li><li><p>不为二分图, 此时保留任意一个生成树, 并选择任意一个节点增加一个自环.</p><p>此时存在奇环, 标记串长度和奇偶性都可以任意改变, 增加一个自环就好了.</p></li></ul><p>对于连接两不同标记的边, 直接按标记分类即可得到一个二分图, 因此保留任意一个生成树.</p><p>转化后边数不超过 $2n - 2$, 且不会影响到原来 DP 的转移, 用原来的 DP 就好了.</p><p>时间复杂度 $O(n^2)$.</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3057</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e3</span> + <span class="number">5</span>, MAXM = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Abs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span> </span>&#123; <span class="keyword">return</span> x &lt; <span class="number">0</span>? -x: x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">char</span> S[MAXN];</span><br><span class="line"><span class="keyword">int</span> C[MAXN], U[MAXM], V[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;Pii&gt; Q;</span><br><span class="line"><span class="keyword">bool</span> f[MAXN][MAXN], Odd[MAXN], vis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DSU &#123;</span><br><span class="line">    <span class="keyword">int</span> fa[<span class="number">2</span>][MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[<span class="number">0</span>][i] = fa[<span class="number">1</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findfa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; idx, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fa[idx][u] == u? u: fa[idx][u] = findfa(idx, fa[idx][u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front().first, v = Q.front().second; Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> iu = head[u]; ~iu; iu = edges[iu].nxt) &#123;</span><br><span class="line">                <span class="keyword">int</span> vu = edges[iu].to;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> vv, iv = head[v]; ~iv; iv = edges[iv].nxt)</span><br><span class="line">                    <span class="keyword">if</span> (S[vu] == S[vv = edges[iv].to] &amp;&amp; !f[vu][vv])</span><br><span class="line">                        f[vu][vv] = f[vv][vu] = <span class="literal">true</span>, Q.push(Pii(vu, vv));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        C[u] = c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!C[v = edges[i].to]) dfs(v, -c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (C[v] == c) Odd[Abs(c)] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="comment">// freopen("input.in", "r", stdin);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%s"</span>, &amp;n, &amp;m, &amp;q, S+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        read(u), read(v), U[i] = u, V[i] = v;</span><br><span class="line">        <span class="keyword">if</span> (S[u] == S[v]) Graph::AddEdge(u, v), Graph::AddEdge(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!C[i]) Graph::dfs(i, i);</span><br><span class="line">    Graph::init(), DSU::init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> &amp;u = U[i], &amp;v = V[i];</span><br><span class="line">        <span class="keyword">if</span> (S[u] != S[v]) &#123;</span><br><span class="line">            <span class="keyword">int</span> fu = DSU::findfa(<span class="number">1</span>, u), fv = DSU::findfa(<span class="number">1</span>, v);</span><br><span class="line">            <span class="keyword">if</span> (fu == fv) <span class="keyword">continue</span>;</span><br><span class="line">            DSU::fa[<span class="number">1</span>][fv] = fu;</span><br><span class="line">            Graph::AddEdge(u, v), Graph::AddEdge(v, u);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> fu = DSU::findfa(<span class="number">0</span>, u), fv = DSU::findfa(<span class="number">0</span>, v);</span><br><span class="line">            <span class="keyword">if</span> (fu == fv) <span class="keyword">continue</span>;</span><br><span class="line">            DSU::fa[<span class="number">0</span>][fv] = fu;</span><br><span class="line">            Graph::AddEdge(u, v), Graph::AddEdge(v, u);</span><br><span class="line">            Q.push(Pii(u, v)), f[u][v] = f[v][u] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = Abs(C[i]);</span><br><span class="line">        Q.push(Pii(i, i)), f[i][i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (Odd[c] &amp;&amp; !vis[c]) Graph::AddEdge(i, i), vis[c] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Graph::BFS();</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x, y;</span><br><span class="line">        read(x), read(y), <span class="built_in">puts</span>(f[x][y]? <span class="string">"YES"</span>: <span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「HNOI2019」白兔之舞"><a href="#「HNOI2019」白兔之舞" class="headerlink" title="「HNOI2019」白兔之舞"></a>「HNOI2019」白兔之舞</h3><blockquote><p>强制类型转换而 “溢出” 不会被 <code>-fsanitize=undefined</code> 警告, <code>-Wconversion</code> 报平安.</p></blockquote><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3058" target="_blank" rel="noopener">https://loj.ac/problem/3058</a></li></ul><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><ul><li><p>单位根反演</p><p><del>之前看 <a href="http://vfleaking.blog.uoj.ac/blog/87" target="_blank" rel="noopener">VFleaKing</a> 课件还以为这个东西没考过 (</del></p><p>给定两个长度为 $n$ 的序列 $a_0,\ a_1,\ \ldots,\ a_{n-1}$, $b_0,\ b_1,\ \ldots,\ b_{n-1}$, 求序列 $c$ 满足</p><script type="math/tex; mode=display">c_r = \sum_{p,\ q} [(p + q) \bmod n = r] a_p b_q</script><p>由单位根反演, 可得</p><script type="math/tex; mode=display">c_r = \sum_{p,\ q} (\frac{1}{n} \sum_{k = 0} ^ {n-1} \omega_{n}^{-rk} \omega_{n}^{pk} \omega_{n}^{qk} )\ a_p b_q = \frac{1}{n} \sum_{k = 0}^{n-1} \omega_{n}^{-rk} \sum_{p} \omega_{n}^{pk} a_p \sum_{q} \omega_{n}^{qk} b_q</script><p>具体证明参见课件好了…</p></li></ul><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>将题目中 “有向图” 看作二维平面, 并称第一维为行, 第二维为列. 那么共有 $L+1$ 行, 以及 $n$ 列.</p><p>考虑朴素 DP. 设 $f(i, j)$ 表示共走 $i$ 步, 到达第 $j$ 行任意位置的方案数. $g(i, j)$ 表示共走 $i$ 步, 达到第 $j$ 行的方案数. 那么有</p><script type="math/tex; mode=display">f(i, j) = \binom{L}{i} g(i, j)</script><script type="math/tex; mode=display">g(i, j) = \sum_{k = 1} ^ n g(i-1, k) \cdot w(k, j)</script><p>显然 $g$ 的转移可以用矩阵快速幂优化. 记初始矩阵为 $G_0$, 转移矩阵为 $S$. 设所求答案为 $A_t$, 那么</p><script type="math/tex; mode=display">A_t = \sum_{i = 1} ^ L [i \bmod k = t]\ f(i, y)</script><p>由单位根反演, 得</p><script type="math/tex; mode=display">A_t = \sum_{i = 1} ^ L \frac{1}{k} \sum_{j = 0} ^ {k-1} \omega_{k}^{-tj} \omega_{k}^{ij}\ f(i, y)</script><p>简单整理, 得</p><script type="math/tex; mode=display">A_t = \frac{1}{k} \sum_{j = 0}^{k-1} \omega_{k}^{-tj} \sum_{i = 1} ^ L \omega_{k}^{ij} \binom{L}{i} g(i, j) \\\\A_t = \frac{1}{k} \sum_{j = 0}^{k-1} \omega_{k}^{-tj} \sum_{i = 1} ^ L \binom{L}{i} \omega_{k}^{ij} G_0 S^i</script><p>根据二项式定理, 并设矩阵 $B_t$ 的第 $y$ 项为 $A_t$, 可知</p><script type="math/tex; mode=display">B_t = \frac{1}{k} \sum_{i = 0}^{k-1} \omega_{k}^{-ti} G_0 (\omega_{k}^{i} S + I)^L</script><p>设 $h_i$ 为 $G_0 (\omega_{k}^{i} + I) ^ L$ 的第 $y$ 项. 那么</p><script type="math/tex; mode=display">A_t = \frac{1}{k} \sum_{i = 0} ^ {k-1} \omega_{k}^{-ti} h_i</script><p>考虑 $\omega_{k}^{ti}$ 如何处理. 此处可以构造</p><script type="math/tex; mode=display">ti = \binom{t + i}{2} - \binom{t}{2} - \binom{i}{2}</script><p>容易发现这是对的. 此外还有</p><script type="math/tex; mode=display">ti = \frac{1}{2} (t + i) ^ 2 - \frac{1}{2}\ t ^ 2 - \frac{1}{2}\ i ^ 2</script><p>不过在此题中并不适用. <del>想一想, 为什么.</del></p><p>那么答案可写作</p><script type="math/tex; mode=display">A_t = \frac{1}{k} \omega_{k}^{\binom{t}{2}} \sum_{i = 0} ^ {k-1} \omega_{k}^{\binom{i}{2}} h_i \cdot \omega_{k}^{-\binom{t+i}{2}}</script><p>模意义下单位根用原根就好了, 翻转即可凑出来卷积…</p><p>使用 MTT, 时间复杂度 $O(n \log n)$.</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3058</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>, MAXM = <span class="number">4</span>, MAXL = <span class="number">64</span>, MAXK = <span class="number">7e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Complex(<span class="keyword">double</span> _x = <span class="number">0.0</span>, <span class="keyword">double</span> _y = <span class="number">0.0</span>): x(_x), y(_y) &#123; &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> + (<span class="keyword">const</span> Complex&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Complex(x + rhs.x, y + rhs.y); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> - (<span class="keyword">const</span> Complex&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Complex(x - rhs.x, y - rhs.y); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> * (<span class="keyword">const</span> Complex&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Complex <span class="title">conj</span><span class="params">(<span class="keyword">const</span> Complex&amp; p)</span> </span>&#123; <span class="keyword">return</span> Complex(p.x, -p.y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> P;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> m = P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % m;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    Complex W[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) W[i] = Complex(<span class="built_in">cos</span>(PI / Lim * i), <span class="built_in">sin</span>(PI / Lim * i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j) &#123;</span><br><span class="line">                    Complex f0 = f[i+j], f1 = W[<span class="number">1L</span>L * j * Lim / Mid] * f[i+j+Mid];</span><br><span class="line">                    f[i+j] = f0 + f1, f[i+j+Mid] = f0 - f1;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> Lim, <span class="keyword">int</span>* h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Complex A[MAXN], B[MAXN];</span><br><span class="line">        <span class="keyword">static</span> Complex dfta[MAXN], dftb[MAXN], dftc[MAXN], dftd[MAXN];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = Complex(f[i] &amp; <span class="number">32767</span>, f[i] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) B[i] = Complex(g[i] &amp; <span class="number">32767</span>, g[i] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">        FFT(A, Lim), FFT(B, Lim);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) &#123;</span><br><span class="line">            <span class="keyword">static</span> Complex da, db, dc, dd;</span><br><span class="line">            <span class="keyword">int</span> j = (Lim - i) &amp; (Lim - <span class="number">1</span>);</span><br><span class="line">            da = (A[i] + conj(A[j])) * Complex(<span class="number">0.5</span>, <span class="number">0.0</span>);</span><br><span class="line">            db = (A[i] - conj(A[j])) * Complex(<span class="number">0.0</span>, <span class="number">-0.5</span>);</span><br><span class="line">            dc = (B[i] + conj(B[j])) * Complex(<span class="number">0.5</span>, <span class="number">0.0</span>);</span><br><span class="line">            dd = (B[i] - conj(B[j])) * Complex(<span class="number">0.0</span>, <span class="number">-0.5</span>);</span><br><span class="line">            dfta[j] = da * dc, dftb[j] = da * dd;</span><br><span class="line">            dftc[j] = db * dc, dftd[j] = db * dd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = dfta[i] + dftb[i] * Complex(<span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) B[i] = dftc[i] + dftd[i] * Complex(<span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        FFT(A, Lim), FFT(B, Lim);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> da = LL(A[i].x / Lim + <span class="number">0.5</span>) % P, db = LL(A[i].y / Lim + <span class="number">0.5</span>) % P;</span><br><span class="line">            <span class="keyword">int</span> dc = LL(B[i].x / Lim + <span class="number">0.5</span>) % P, dd = LL(B[i].y / Lim + <span class="number">0.5</span>) % P;</span><br><span class="line">            h[i] = (da + (LL(db + dc) &lt;&lt; <span class="number">15</span>) + (LL(dd) &lt;&lt; <span class="number">30</span>)) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> n, <span class="keyword">int</span>* g, <span class="keyword">int</span> m, <span class="keyword">int</span>* h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt;= n + m) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">        init(Lim, L), MTT(f, g, Lim, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">proot</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> fact[MAXL];</span><br><span class="line">    <span class="keyword">int</span> phi = p - <span class="number">1</span>, tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">2</span>; d*d &lt;= phi; ++d) <span class="keyword">if</span> (phi % d == <span class="number">0</span>) &#123;</span><br><span class="line">        fact[++tot] = d;</span><br><span class="line">        <span class="keyword">while</span> (phi % d == <span class="number">0</span>) phi /= d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (phi &gt; <span class="number">1</span>) fact[++tot] = phi;</span><br><span class="line">    phi = p - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= phi; ++i) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; flag; ++j)</span><br><span class="line">            <span class="keyword">if</span> (fpow(i, phi / fact[j], p) == <span class="number">1</span>) flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 long long --- 引用部分就是在说这个 (</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1L</span>L * n * (n<span class="number">-1</span>) / <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K, L, x, y;</span><br><span class="line"><span class="keyword">int</span> W[MAXM][MAXM], powG[MAXK];</span><br><span class="line"><span class="keyword">int</span> f[MAXN], g[MAXN], h[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m[MAXM][MAXM];</span><br><span class="line">    Matrix() &#123; <span class="built_in">memset</span>(m, <span class="number">0</span>, <span class="keyword">sizeof</span> m); &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        Matrix ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                    ret.m[i][j] = (ret.m[i][j] + <span class="number">1L</span>L * m[i][k] * rhs.m[k][j] % P) % P;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">fpow</span><span class="params">(Matrix base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    Matrix ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ret.m[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * base;</span><br><span class="line">        base = base * base, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>, &amp;n, &amp;K, &amp;L, &amp;x, &amp;y, &amp;P);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, W[i] + j);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">int</span> G = fpow(proot(P), (P - <span class="number">1</span>) / K);</span><br><span class="line">    powG[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; K; ++i) powG[i] = <span class="number">1L</span>L * powG[i<span class="number">-1</span>] * G % P;</span><br><span class="line">    Matrix base, G0;</span><br><span class="line">    G0.m[<span class="number">1</span>][x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">1</span>; a &lt;= n; ++a) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">1</span>; b &lt;= n; ++b) base.m[a][b] = <span class="number">1L</span>L * W[a][b] * powG[i] % P;</span><br><span class="line">            base.m[a][a] = (base.m[a][a] + <span class="number">1</span>) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        base = G0 * fpow(base, L);</span><br><span class="line">        f[i] = <span class="number">1L</span>L * base.m[<span class="number">1</span>][y] * powG[C2(i) % K] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>*K; ++i) g[i] = powG[(K - C2(i) % K) % K];</span><br><span class="line">    reverse(g, g + <span class="number">2</span>*K + <span class="number">1</span>);</span><br><span class="line">    Poly::Mul(f, K, g, <span class="number">2</span>*K + <span class="number">1</span>, h);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">int</span> invK = fpow(K, P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; K; ++t) &#123;</span><br><span class="line">        LL s1 = <span class="number">1L</span>L * invK * powG[C2(t) % K] % P;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, s1 * h[<span class="number">2</span>*K - t] % P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「HNOI2019」序列"><a href="#「HNOI2019」序列" class="headerlink" title="「HNOI2019」序列"></a>「HNOI2019」序列</h3><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3059" target="_blank" rel="noopener">https://loj.ac/problem/3059</a></li></ul><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>类似于 <a href="https://m1.oi-archive.org:9000/#/problem/bzoj/1367" target="_blank" rel="noopener">BZOJ 1367</a>, 可得到这样的思路:</p><p>将 $A$ 分段, 对每一段 $[L,\ R]$ 构造相同的序列 $B_i$, 并令 $B_i$ 为该段 $A_i$ 的平均值. 在满足 $B$ 单调不降的条件下使每次分出区间长度尽量小, 此时可以得到最优结果.</p><p><del>个人感觉证明方法应该类似于 黄源河 &lt;左偏树的特点及其应用&gt; 例题部分对 BZOJ 1367 的证明</del>.</p><p>证明参见 <a href="https://www.cnblogs.com/Paul-Guderian/p/10801584.html" target="_blank" rel="noopener">https://www.cnblogs.com/Paul-Guderian/p/10801584.html</a> 好了.</p><p>$A$ 的分段情况可以利用单调栈维护.</p><p>具体地说, 每个单调栈中元素对应 $A$ 中一段区间. 假设单调栈内某一元素对应 $A_i$ 中区间 $[L,\ R]$, 记该段平均值为 $\bar x$, 那么区间内的答案为</p><script type="math/tex; mode=display">\sum_{i = L}^ R (A_i - \bar x) ^ 2 = \sum_{i = L}^R A_i^2 - \frac{1}{R - L + 1} (\sum_{i = L}^R A_i) ^ 2</script><p>此时记录区间和, 区间平方和, 区间大小就可以快速合并两个区间的信息, 也就是单调栈内两元素的值.</p><p>从前往后扫描 $A$, 假设当前扫描到位置 $i$, 那么在单调栈中加入 $i$. 此时不断检查栈中元素. 如果不满足 $B$ 单调不降, 则不断向栈内元素合并. 同时记录在每个位置得到的答案.</p><p>此时得到了 $m = 0$ 情况下的做法.</p><p>注意到每次都是单点修改, 考虑单点修改对单调栈中元素的影响. 设当前修改位置为 $x$, 那么在修改后重新计算得到单调栈中一定存在一个区间满足 $L \le x \le R$.</p><p>重构单调栈的复杂度过高, 如果确定了 $L$, $R$ 的位置, 那么除去这一部分, 其他部分并不会改变. 因此仿照从前到后维护单调栈的过程, 从后往前扫描 $A$, 这样配合可持久化就能快速得到 $[1,\ L)$ 以及 $(R, n]$ 的信息.</p><p>现在的问题就是如何确定 $L,\ R$ 的位置. 根据单调性, $L,\ R$ 的位置可以通过二分来确定.</p><p>具体地说, 在维护单调栈的过程中, 利用可持久化线段树维护单调栈中每个元素在序列上的实际范围. 线段树向上合并时维护该节点对应实际范围 $[L,\ R]$, 以及最靠左元素对应的右端点位置 $k$.</p><p>不断二分 $x$ 修改后影响到的单调栈编号 $p$, 每次在线段树上查询到该编号对应的右端点位置 $R$. 可以证明, 改变 $x$ 位置的值后, 确定的 $L$, $R$ 位置仍是原有单调栈中某个元素的左右端点之一, 否则答案一定不优.</p><p>另外需保证选择的区间长度尽量小, 因此 $R$ 的位置很好确定, 直接找到编号 $p$ 对应的右端点位置. 根据 $R$ 的位置, 并利用 $B$ 单调不降的限制, 可以确定出左端点 $L$ 的位置, 并在查询 $L$ 位置的同时维护 $[L,\ R]$ 这一段合并后得到的元素. 如果该元素小于后一位置单调栈中元素, 那么编号 $p$ 合法, 减小区间长度继续二分.</p><p><del>似乎也可以通过二分套二分实现这个过程 ?</del></p><p>时间复杂度 $O(n \log n + m \log ^ 2 n)$.</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3059</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>, P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> inv[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> s0; LL s1; <span class="keyword">int</span> s2;</span><br><span class="line">    Data() &#123; s1 = s0 = s2 = <span class="number">0</span>; &#125;</span><br><span class="line">    Data(<span class="keyword">int</span> _s0, LL _s1, <span class="keyword">int</span> _s2): s0(_s0), s1(_s1), s2(_s2) &#123; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Data&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s1 * rhs.s0 &lt; rhs.s1 * s0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> Data&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(rhs &lt; *<span class="keyword">this</span>); &#125;</span><br><span class="line">    Data <span class="keyword">operator</span> + (<span class="keyword">const</span> Data&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Data(s0 + rhs.s0, s1 + rhs.s1, (s2 + rhs.s2) % P);</span><br><span class="line">    &#125;</span><br><span class="line">    Data <span class="keyword">operator</span> - (<span class="keyword">const</span> Data&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Data(s0 - rhs.s0, s1 - rhs.s1, (s2 - rhs.s2 + P) % P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> s = s1 % P; <span class="keyword">return</span> (s2 - <span class="number">1L</span>L * s % P * s % P * inv[s0] % P + P) % P; &#125;</span><br><span class="line">&#125; Sum[MAXN], stk[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, top;</span><br><span class="line"><span class="keyword">int</span> A[MAXN];</span><br><span class="line"><span class="keyword">int</span> pre[MAXN], suf[MAXN];</span><br><span class="line"><span class="keyword">int</span> Ansp[MAXN], Anss[MAXN], Posp[MAXN], Poss[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Data <span class="title">Part</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="number">0</span> || R == <span class="number">0</span>) <span class="keyword">return</span> Data();</span><br><span class="line">    <span class="keyword">return</span> Sum[R] - Sum[L - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PSGT &#123;</span><br><span class="line">    <span class="comment">// [L, k], (k, ..., R]</span></span><br><span class="line">    <span class="comment">// [L, k] 为一段, 其余部分不一定是一段 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> <span class="keyword">int</span> lc, rc, L, R, k; &#125; dat[MAXN &lt;&lt; <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">int</span> nidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> &amp;rc = dat[nd].rc, &amp;lc = dat[nd].lc;</span><br><span class="line">        dat[nd].L = dat[nd].R = dat[lc].L;</span><br><span class="line">        <span class="keyword">if</span> (rc) dat[nd].R = dat[rc].R;</span><br><span class="line">        dat[nd].k = dat[lc].k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; pos, <span class="keyword">const</span> <span class="keyword">int</span>&amp; vL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; vR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nxt = ++nidx;</span><br><span class="line">        dat[nxt] = dat[nd];</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> dat[nxt].L = vL, dat[nxt].R = dat[nxt].k = vR, nxt;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= Mid) dat[nxt].lc = Mdy(dat[nxt].lc, L, Mid, pos, vL, vR);</span><br><span class="line">        <span class="keyword">else</span> dat[nxt].rc = Mdy(dat[nxt].rc, Mid+<span class="number">1</span>, R, pos, vL, vR);</span><br><span class="line">        <span class="keyword">return</span> maintain(nxt), nxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">QryR</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> dat[nd].R;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= Mid) <span class="keyword">return</span> QryR(dat[nd].lc, L, Mid, pos);</span><br><span class="line">        <span class="keyword">return</span> QryR(dat[nd].rc, Mid+<span class="number">1</span>, R, pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">QryL</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; pos, Data&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (R &lt;= pos) &#123;</span><br><span class="line">            Data vL = Part(dat[nd].L, dat[nd].k), vR = Part(dat[nd].k + <span class="number">1</span>, dat[nd].R);</span><br><span class="line">            <span class="keyword">if</span> (vR + d &lt;= vL)</span><br><span class="line">                <span class="keyword">return</span> d = d + Part(dat[nd].L, dat[nd].R), <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (L == R) <span class="keyword">return</span> dat[nd].R;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 尽可能找到最大的可行 L</span></span><br><span class="line">        <span class="keyword">if</span> (pos &gt; Mid) &#123;</span><br><span class="line">            <span class="keyword">int</span> ret = QryL(dat[nd].rc, Mid+<span class="number">1</span>, R, pos, d); </span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> QryL(dat[nd].lc, L, Mid, pos, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]);</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) inv[i] = <span class="number">1L</span>L * (P - P / i) * inv[P % i] % P;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        Sum[i] = Sum[i<span class="number">-1</span>] + Data(<span class="number">1</span>, A[i], <span class="number">1L</span>L * A[i] * A[i] % P);</span><br><span class="line">    <span class="comment">// pre done</span></span><br><span class="line">    stk[top = <span class="number">0</span>] = Data();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        stk[++top] = Data(<span class="number">1</span>, A[i], <span class="number">1L</span>L * A[i] * A[i] % P);</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; stk[top] &lt;= stk[top<span class="number">-1</span>])</span><br><span class="line">            stk[top<span class="number">-1</span>] = stk[top<span class="number">-1</span>] + stk[top], --top;</span><br><span class="line">        Posp[i] = top;</span><br><span class="line">        Ansp[i] = (Ansp[i - stk[top].s0] + stk[top].calc()) % P;</span><br><span class="line">        pre[i] = PSGT::Mdy(pre[i<span class="number">-1</span>], <span class="number">1</span>, n, top, i - stk[top].s0 + <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// suf done</span></span><br><span class="line">    stk[top = <span class="number">0</span>] = Data();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) &#123;</span><br><span class="line">        stk[++top] = Data(<span class="number">1</span>, A[i], <span class="number">1L</span>L * A[i] * A[i] % P);</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; stk[top<span class="number">-1</span>] &lt;= stk[top])</span><br><span class="line">            stk[top<span class="number">-1</span>] = stk[top<span class="number">-1</span>] + stk[top], --top;</span><br><span class="line">        Poss[i] = top;</span><br><span class="line">        Anss[i] = (Anss[i + stk[top].s0] + stk[top].calc()) % P;</span><br><span class="line">        suf[i] = PSGT::Mdy(suf[i+<span class="number">1</span>], <span class="number">1</span>, n, top, i, i + stk[top].s0 - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ansp[n]);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x, val;</span><br><span class="line">        read(x), read(val);</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = Poss[x + <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> Rp = Mid? PSGT::QryR(suf[x+<span class="number">1</span>], <span class="number">1</span>, n, Poss[x+<span class="number">1</span>] - Mid + <span class="number">1</span>): x;</span><br><span class="line">            Data d = Data(<span class="number">1</span>, val, <span class="number">1L</span>L * val * val % P) + Part(x+<span class="number">1</span>, Rp);</span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">1</span>) PSGT::QryL(pre[x<span class="number">-1</span>], <span class="number">1</span>, n, Posp[x<span class="number">-1</span>], d);</span><br><span class="line">            <span class="keyword">if</span> (d &lt; Part(Rp + <span class="number">1</span>, PSGT::QryR(suf[x+<span class="number">1</span>], <span class="number">1</span>, n, Poss[x+<span class="number">1</span>] - Mid))) R = Mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> L = Mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Rp = (R + <span class="number">1</span> &gt; <span class="number">0</span>)? PSGT::QryR(suf[x+<span class="number">1</span>], <span class="number">1</span>, n, Poss[x+<span class="number">1</span>] - R): x;</span><br><span class="line">        Data d = Data(<span class="number">1</span>, val, <span class="number">1L</span>L * val * val % P) + Part(x+<span class="number">1</span>, Rp);</span><br><span class="line">        <span class="keyword">int</span> Lp = x &gt; <span class="number">1</span>? PSGT::QryL(pre[x<span class="number">-1</span>], <span class="number">1</span>, n, Posp[x<span class="number">-1</span>], d): x;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ((Ansp[Lp] + d.calc()) % P + Anss[Rp+<span class="number">1</span>]) % P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;AH 跑去十二省联考了 (&lt;/p&gt;
&lt;p&gt;HNOI 独自毒瘤.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>十二省联考 2019 大赏</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/union-2019-sol/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/union-2019-sol/</id>
    <published>2020-03-16T06:43:17.000Z</published>
    <updated>2020-04-28T16:07:02.790Z</updated>
    
    <content type="html"><![CDATA[<hr><p>其实之前都已经写地差不多了…</p><a id="more"></a><h3 id="「十二省联考-2019」异或粽子"><a href="#「十二省联考-2019」异或粽子" class="headerlink" title="「十二省联考 2019」异或粽子"></a>「十二省联考 2019」异或粽子</h3><p><del>听说是原题? 原题没写过怎么办啊.</del></p><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3048" target="_blank" rel="noopener">https://loj.ac/problem/3048</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>考虑到区间异或值, 可以看作前缀异或值的两点异或值. 那么在处理出前缀异或值后, 所求即为前 $k$ 大有序对, 对应位置异或值的和.</p><p>考虑到 $a\ \mathrm {xor}\ b$ = $b\ \mathrm{xor}\ a$, 以及 $a\ \mathrm{xor}\ a = 0$, 求出前 $2k$ 大两两异或最大值, 并将最终答案 / 2 即可.</p><p>整个过程可以用 0-1 Trie 和优先队列实现.</p><p>具体地说, 对每个位置在 Trie 上查出最大异或值, 丢进优先队列. 此后在优先队列中取出 $2k$ 个元素, 若取出元素为该位置第 $x$ 大异或值, 那么重新放入第 $x+1$ 大异或值.</p><p>类似的优先队列技巧也在<a href="https://www.luogu.com.cn/problem/P2048" target="_blank" rel="noopener">「NOI2010」超级钢琴</a> 中使用过.</p><p>时间复杂度 $O(\ (n + k)\ (\log n + \log v)\ )$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3048</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e5</span> + <span class="number">5</span>, LOG = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, k; LL s;</span><br><span class="line">    Item(<span class="keyword">int</span> _u, <span class="keyword">int</span> _k, LL _s): u(_u), k(_k), s(_s) &#123; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s &lt; rhs.s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K;</span><br><span class="line">LL A[MAXN];</span><br><span class="line">priority_queue&lt;Item&gt; PQ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Trie &#123;</span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>][MAXN &lt;&lt; <span class="number">5</span>], size[MAXN &lt;&lt; <span class="number">5</span>], nidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; nidx = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(LL S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = LOG - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = (S &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            ++size[u];</span><br><span class="line">            <span class="keyword">if</span> (!ch[c][u]) ch[c][u] = ++nidx;</span><br><span class="line">            u = ch[c][u];</span><br><span class="line">        &#125;</span><br><span class="line">        ++size[u];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">Qry</span><span class="params">(LL S, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        LL ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>, i = LOG - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = (S &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ch[!c][u]) u = ch[c][u];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (k &lt;= size[ch[!c][u]]) u = ch[!c][u], ret |= <span class="number">1L</span>L &lt;&lt; i;</span><br><span class="line">            <span class="keyword">else</span> k -= size[ch[!c][u]], u = ch[c][u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Trie::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(K), K &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">static</span> LL x;</span><br><span class="line">        read(x), A[i] = A[i<span class="number">-1</span>] ^ x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="comment">// 注意到要往 Trie 里塞个 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) Trie::insert(A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) PQ.push(Item(i, <span class="number">1</span>, Trie::Qry(A[i], <span class="number">1</span>)));</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (K--) &#123;</span><br><span class="line">        Item u = PQ.top(); PQ.pop();</span><br><span class="line">        ans += u.s;</span><br><span class="line">        <span class="keyword">if</span> (u.k + <span class="number">1</span> &lt;= n) PQ.push(Item(u.u, u.k + <span class="number">1</span>, Trie::Qry(A[u.u], u.k + <span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「十二省联考-2019」字符串问题"><a href="#「十二省联考-2019」字符串问题" class="headerlink" title="「十二省联考 2019」字符串问题"></a>「十二省联考 2019」字符串问题</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3049" target="_blank" rel="noopener">https://loj.ac/problem/3049</a></li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>我之前有写过的说… 参见<a href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/luogu-P5284/">「十二省联考 2019」字符串问题 题解</a>.</p><p>时间复杂度 $O(n \log n)$.</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p><del>假装自己又写了一遍</del></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3049</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span> + <span class="number">5</span>, MAXM = MAXN &lt;&lt; <span class="number">1</span>, LOG = <span class="number">19</span>, SIGMA = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = MAXM &lt;&lt; <span class="number">1</span>, MAXE = MAXV &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, uidx;</span><br><span class="line"><span class="keyword">char</span> S[MAXN];</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN], nA, nB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> isA[MAXV];</span><br><span class="line"><span class="keyword">int</span> pre[LOG][MAXM], pos[MAXN], len[MAXV], lst[MAXM];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXE];</span><br><span class="line">    <span class="keyword">int</span> head[MAXV], in[MAXV], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span> in), <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx, ++in[to];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">Toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> LL f[MAXV];</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, (uidx + <span class="number">1</span>) * <span class="keyword">sizeof</span> (LL));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= uidx; ++i) <span class="keyword">if</span> (!in[i]) Q.push(i);</span><br><span class="line">        LL ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            ret = max(ret, f[u] + len[u]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = edges[i].to;</span><br><span class="line">                f[v] = max(f[v], f[u] + len[u]);</span><br><span class="line">                <span class="keyword">if</span> (!(--in[v])) Q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= uidx; ++i) <span class="keyword">if</span> (in[i]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SAM &#123;</span><br><span class="line">    <span class="keyword">int</span> ch[MAXM][SIGMA], lnk[MAXM], nidx, last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nidx = last = <span class="number">1</span>, <span class="built_in">memset</span>(ch[<span class="number">1</span>], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        len[++nidx] = l, lnk[nidx] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">memset</span>(ch[nidx], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[nidx]), nidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nd = newnode(len[last] + <span class="number">1</span>), p = last;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !ch[p][val]) ch[p][val] = nd, p = lnk[p];</span><br><span class="line">        <span class="keyword">if</span> (!p) lnk[nd] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> q = ch[p][val];</span><br><span class="line">            <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) lnk[nd] = q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> nxt = newnode(len[p] + <span class="number">1</span>);</span><br><span class="line">                lnk[nxt] = lnk[q], <span class="built_in">memcpy</span>(ch[nxt], ch[q], <span class="keyword">sizeof</span> ch[nxt]);</span><br><span class="line">                <span class="keyword">while</span> (p &amp;&amp; ch[p][val] == q) ch[p][val] = nxt, p = lnk[p];</span><br><span class="line">                lnk[q] = lnk[nd] = nxt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last = nd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nidx; ++i) pre[<span class="number">0</span>][i] = lnk[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; LOG; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nidx; ++i) pre[j][i] = pre[j<span class="number">-1</span>][pre[j<span class="number">-1</span>][i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Jump</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; lgt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = LOG - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">            <span class="keyword">if</span> (pre[j][u] &amp;&amp; len[pre[j][u]] &gt;= lgt) u = pre[j][u];</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> len[a] &lt; len[b] || (len[a] == len[b] &amp;&amp; isA[a] &lt; isA[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="comment">// freopen("input.in", "r", stdin);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> Ti; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        SAM::init(), Graph::init();</span><br><span class="line">        <span class="built_in">memset</span>(isA, <span class="literal">false</span>, <span class="keyword">sizeof</span> isA);</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// solve</span></span><br><span class="line">        n = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(S + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) SAM::insert(S[i] - <span class="string">'a'</span>), pos[i] = SAM::last;</span><br><span class="line">        SAM::build();</span><br><span class="line">        <span class="comment">// build graph</span></span><br><span class="line">        uidx = SAM::nidx;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;nA);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L, R, i = <span class="number">1</span>; i &lt;= nA; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">            <span class="keyword">int</span> lgt = R - L + <span class="number">1</span>, u = SAM::Jump(pos[L], lgt);</span><br><span class="line">            len[++uidx] = lgt, A[i] = uidx, isA[uidx] = <span class="literal">true</span>;</span><br><span class="line">            G[u].push_back(uidx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;nB);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L, R, i = <span class="number">1</span>; i &lt;= nB; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">            <span class="keyword">int</span> lgt = R - L + <span class="number">1</span>, u = SAM::Jump(pos[L], lgt);</span><br><span class="line">            len[++uidx] = lgt, B[i] = uidx;</span><br><span class="line">            G[u].push_back(uidx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, u = <span class="number">1</span>; u &lt;= SAM::nidx; ++u) &#123;</span><br><span class="line">            <span class="keyword">int</span> last = u;</span><br><span class="line">            sort(G[u].begin(), G[u].end(), cmp);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; G[u].size(); ++i) &#123;</span><br><span class="line">                Graph::AddEdge(last, v = G[u][i]);</span><br><span class="line">                <span class="keyword">if</span> (!isA[v]) last = v;</span><br><span class="line">            &#125;</span><br><span class="line">            lst[u] = last, G[u].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">2</span>; u &lt;= SAM::nidx; ++u) Graph::AddEdge(lst[SAM::lnk[u]], u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= uidx; ++i) <span class="keyword">if</span> (!isA[i]) len[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), Graph::AddEdge(A[u], B[v]);</span><br><span class="line">        <span class="comment">// output</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Graph::Toposort());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「十二省联考-2019」骗分过样例"><a href="#「十二省联考-2019」骗分过样例" class="headerlink" title="「十二省联考 2019」骗分过样例"></a>「十二省联考 2019」骗分过样例</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3050" target="_blank" rel="noopener">https://loj.ac/problem/3050</a></li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li><p>$\texttt{1_998244353}$</p><p>观察到结果是 $19$ 的幂次, 直接快速幂即可. 对于较大的数, 读入的同时模 $\varphi(998244353) = 998244352$ 即可.</p></li><li><p>$\texttt{1?}$</p><p><del>可以开始吐槽出题人了 (</del></p><p>观察到结果的最大值为 $1145099$, 从此处枚举模数 $p$, 并用一个大数验证即可.</p><p>为防止出题人毒瘤, 可以用 <a href="https://oi-wiki.org/math/fermat/#_6" target="_blank" rel="noopener">拓展欧拉定理</a> 处理这个较大数. 实际上得到的模数是 $1145141$, 恰好是一个 <del>恶臭的</del> 素数.</p></li><li><p>$\texttt{1?+}$</p><p>此时需要猜一个 $10^{18}$ 级别的大模数…</p><p>观察到数据中有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">264708066 1996649514996338529</span><br><span class="line">264708068 1589589654696467295</span><br></pre></td></tr></table></figure><p>那么有</p><script type="math/tex; mode=display">1996649514996338529 \times 19^2 \equiv 1589589654696467295\pmod m</script><p>即</p><script type="math/tex; mode=display">m \mid (1996649514996338529 \times 19^2 -1589589654696467295 ) \\\  m \mid 719200885258981741674</script><p>先考虑 $m$ 是素数的情况, 用 Linux 下命令 <code>factor</code> 分解, 得</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">719200885258981741674: 2 3 23 5211600617818708273</span><br></pre></td></tr></table></figure><p>选择 $5211600617818708273$ 检验, 发现这就是要找的模数.</p></li><li><p>$\texttt{1wa_998244353}$</p><p><del>那么出题人是怎么写挂的呢</del></p><p>猜测这个写法是 <code>int</code> 溢出得到的… 而测试点 #6 也印证了这一点.</p><p>此时答案会出现循环, 找到起始位置和循环节长度即可. 似乎可以手算, 但是我选择写程序暴力.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    M[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; ; ++i) &#123;</span><br><span class="line">        x = <span class="number">19</span> * x % P;</span><br><span class="line">        <span class="keyword">if</span> (M.count(x) != <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, M[x], i); <span class="keyword">break</span>; &#125;</span><br><span class="line">        M[x] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到 <code>55245 100944</code>, 那么循环节长度为 <code>45699</code>, 起始位置为 <code>55245</code>, 预处理出前 <code>100944</code> 位答案即可.</p><p>尽管出题人提醒自然溢出是 ub, 但是强制类型转换我没能调出来, 于是只能 “自然溢出啥事没有” 了, <del>感谢编译器没有把我的电脑关掉</del>.</p></li><li><p>$\texttt{2p}$</p><p>题意: 判断区间内每一个数是否为素数, 若为素数输出 <code>&#39;p&#39;</code>, 否则输出 <code>&#39;.&#39;</code>.</p><p>观察到区间长度是 $10^6$ 级别的, 那么用 Miller-Rabin 判素即可.</p><p>单次 Miller-Rabin 判素的时间复杂度为 $O(k \log^3 n)$. 来源: <a href="https://zh.wikipedia.org/wiki/%E7%B1%B3%E5%8B%92-%E6%8B%89%E5%AE%BE%E6%A3%80%E9%AA%8C" target="_blank" rel="noopener">米勒-拉宾素性检验</a>.</p><p>此处只选择 $2$, $3$ 两个素数即可. 虽然正确性堪忧, 但是可以通过给定的数据.</p></li><li><p>$\texttt{2u}$</p><p>题意: 计算区间内每一个数的 $\mu(n)$, 根据 $\mu(n)$ 的值输出 <code>&#39;0&#39;</code> / <code>&#39;+&#39;</code> / <code>&#39;-&#39;</code>.</p><p>观察到区间长度为 $10^6$, 最大值为 $10^{18}$. 在筛出 $10^6$ 以内的素数后, 枚举素数的该区间内的倍数.</p><p>由 $\mu$ 的定义可知, </p><ul><li>如果此时某个数 $n$ 被 $p^2$ 整除, 那么 $\mu(n) = 0$.</li><li>如果此时某个数 $n$ 被 $p$ 整除, 则令 $\mu(n) := -\mu(n)$.</li></ul><p>此后剩下的数 $n$, 若 $n \neq 1$, 那么 $n$ 可表示为最多两个 $&gt; 10^6$ 的素数的乘积.</p><ul><li>如果 $n$ 为素数, 那么 $\mu(n)$ 取反.</li><li>如果 $n$ 为完全平方数, 那么 $\mu(n) = 0$.</li><li>对于其余情况, $n$ 为两不同素数乘积, 对 $\mu(n)$ 取值没有影响.</li></ul></li><li><p>$\texttt{2g}$</p><p>题意: 判断区间内每一个数是否为给定数的原根, 若为原根输出 <code>&#39;g&#39;</code>, 否则输出 <code>&#39;.&#39;</code>.</p><p>神仙曾经教育过, “求原根大多数情况直接按定义暴力”. 此时可解决求 $998244353$ 原根的情况.</p><p>具体地说, 若 $g$ 为 $m$ 原根, 将 $\varphi(m)$ 质因数分解, 对于每个质因数 $p_i$ 都满足 $g ^ {\frac{\varphi(m)}{p_i}} \not\equiv 1 \pmod m$. from <a href="https://oi-wiki.org/math/primitive-root/#_5" target="_blank" rel="noopener">OI-Wiki 原根</a>.</p><p>显然这个方法在 $\varphi(m)$ 质因数个数较多, 判断区间长度较大时有效率问题. 考虑此种情况下的数 $13123111$ 较小, 可以预处理出答案后 $O(1)$ 回答.</p><p>假定已经找到了 $m$ 的一个原根 $g$, 设 $x = g ^ k\mod m$, 那么 $x$ 为 $m$ 的原根当且仅当 $k$ 同 $\varphi(m)$ 互质.</p><p>此时枚举指标 $k$, 并标记 $\varphi(m)$ 质因数的倍数即可.</p></li><li><p>$\texttt{2g?}$</p><p>此时又需要猜数…</p><blockquote><p>// Hint: ? is a prime number larger than 1000000000 but smaller than 2000000000</p></blockquote><p>考虑到存在原根的数必然形如 $2,\ 4,\ p^a,\ 2p^a$, 其中 $p$ 为奇素数. $a$ 为正整数. from <a href="https://oi-wiki.org/math/primitive-root/#_3" target="_blank" rel="noopener">OI-Wiki 原根</a>.</p><p>直接在这个范围内大力寻找就好了.</p><p>还是优先考虑素数, 可以得到结果 <code>1515343657</code>.</p></li></ol><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>写得很垃圾…</p><p>Miller-Rabin 的快速幂部分用 <code>__int128</code> / <code>__float128</code> 才能勉强保证精度, 为了拯救代码的大常数只用了 2 个素数, 没救了.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3050</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> uLL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x, LL m)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = (x * <span class="number">10L</span>L + ch - <span class="string">'0'</span>) % m, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solve1 &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % P;</span><br><span class="line">            base = <span class="number">1L</span>L * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n; read(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x, i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            read(x, P<span class="number">-1</span>), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, fpow(<span class="number">19</span>, x));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solve2 &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1145141</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % P;</span><br><span class="line">            base = <span class="number">1L</span>L * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n; read(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x, i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            read(x, P<span class="number">-1</span>), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, fpow(<span class="number">19</span>, x));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solve3 &#123;</span><br><span class="line">    <span class="keyword">const</span> LL P = <span class="number">5211600617818708273</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">plus</span><span class="params">(uLL a, uLL b)</span> </span>&#123; <span class="keyword">return</span> a + b &gt;= P? a + b - P: a + b; &#125;</span><br><span class="line">    <span class="function">LL <span class="title">smul</span><span class="params">(LL base, LL b)</span> </span>&#123;</span><br><span class="line">        LL ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = plus(ret, base);</span><br><span class="line">            base = plus(base, base), b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LL <span class="title">fpow</span><span class="params">(LL base, LL b)</span> </span>&#123;</span><br><span class="line">        LL ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = smul(ret, base);</span><br><span class="line">            base = smul(base, base), b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n; read(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x, i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            read(x), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, fpow(<span class="number">19</span>, x));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solve4 &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>, BEG = <span class="number">55244</span>, LOOP = <span class="number">45699</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, A[BEG + LOOP + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= BEG + LOOP; ++i) A[i] = <span class="number">19</span> * A[i<span class="number">-1</span>] % P;</span><br><span class="line">        read(n); LL x;</span><br><span class="line">        <span class="keyword">while</span> (n--) read(x), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, A[x &lt; BEG? x: (x - BEG) % LOOP + BEG]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MillerRabin &#123;</span><br><span class="line">    <span class="function">LL <span class="title">fpow</span><span class="params">(LL base, LL b, LL m)</span> </span>&#123;</span><br><span class="line">        LL ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = __int128(ret) * base % m;</span><br><span class="line">            base = __int128(base) * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret % m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(LL p, <span class="keyword">int</span> L = <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">2</span> || p == <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">2</span> || p % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">2</span>; a &lt;= L; ++a) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fpow(a, p<span class="number">-1</span>, p) != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            LL t, k = p - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (!(k &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                k &gt;&gt;= <span class="number">1</span>, t = fpow(a, k, p);</span><br><span class="line">                <span class="keyword">if</span> (t != p<span class="number">-1</span> &amp;&amp; t != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (t == p<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> MillerRabin::isPrime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solve5 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n; read(n);</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            <span class="keyword">static</span> LL L, R; </span><br><span class="line">            read(L), read(R);</span><br><span class="line">            <span class="keyword">for</span> (LL i = L; i &lt;= R; ++i) <span class="built_in">putchar</span>(isPrime(i, <span class="number">3</span>)? <span class="string">'p'</span>: <span class="string">'.'</span>);</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solve6 &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    LL L, R, A[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> notPrime[MAXN];</span><br><span class="line">    <span class="keyword">int</span> mu[MAXN], Prime[MAXN], tot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EulerSieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notPrime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAXN; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!notPrime[i]) Prime[++tot] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i*Prime[j] &lt; MAXN; ++j) &#123;</span><br><span class="line">                notPrime[i*Prime[j]] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % Prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">val</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (x == <span class="number">0</span>)? <span class="string">'0'</span>: (x &lt; <span class="number">0</span>? <span class="string">'-'</span>: <span class="string">'+'</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EulerSieve(), read(n);</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            read(L), read(R);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R - L + <span class="number">1</span>; ++i) mu[i] = <span class="number">1</span>, A[i] = i + L - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; ++j) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span>&amp; p = Prime[j];</span><br><span class="line">                <span class="comment">// 枚举倍数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1L</span>L * p * ((L<span class="number">-1</span>) / p + <span class="number">1</span>) - L + <span class="number">1</span>; i &lt;= R-L+<span class="number">1</span>; i += p) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (A[i] % (<span class="number">1L</span>L * p * p) == <span class="number">0</span>) mu[i] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> mu[i] = -mu[i], A[i] /= p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R - L + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mu[i] != <span class="number">0</span> &amp;&amp; A[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    LL m = <span class="built_in">sqrt</span>(A[i]);</span><br><span class="line">                    <span class="keyword">if</span> (m * m == A[i]) mu[i] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (A[i] &lt;= <span class="number">1e12</span> || isPrime(A[i])) mu[i] = -mu[i];</span><br><span class="line">                    <span class="comment">// A[i] &lt;= 1e12 时, 一定是素数</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">putchar</span>(val(mu[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solve7 &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e7</span>+<span class="number">5</span>, MAXM = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, p, L, R;</span><br><span class="line">    <span class="keyword">int</span> fact[MAXM], tot;</span><br><span class="line">    <span class="keyword">int</span> vis[MAXN], lg[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt; x; ++i) <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            fact[++tot] = i;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">1</span>) fact[++tot] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % m;</span><br><span class="line">            base = <span class="number">1L</span>L * base * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret % m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">            <span class="keyword">if</span> (fpow(g, (p - <span class="number">1</span>) / fact[i], p) == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        read(n);</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            read(L), read(R);</span><br><span class="line">            <span class="keyword">if</span> (R != <span class="number">234133333</span>) read(p); <span class="keyword">else</span> p = <span class="number">1515343657</span>;</span><br><span class="line">            prime(p - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="number">13123111</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; ++j)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (p<span class="number">-1</span>) / fact[j]; ++i) vis[i * fact[j]] = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 6 为 13123111 原根</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">6</span>, i = <span class="number">1</span>; i &lt; p; ++i, x = <span class="number">6L</span>L * x % p) lg[x] = i;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) <span class="built_in">putchar</span>(vis[lg[i]]? <span class="string">'.'</span>: <span class="string">'g'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) <span class="built_in">putchar</span>(isroot(i)? <span class="string">'g'</span>: <span class="string">'.'</span>);</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">char</span> cmd[MAXL];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"output.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</span><br><span class="line">    <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmd[<span class="number">1</span>] == <span class="string">'_'</span>) <span class="keyword">return</span> Solve1::main();</span><br><span class="line">        <span class="keyword">if</span> (cmd[<span class="number">1</span>] == <span class="string">'?'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cmd[<span class="number">2</span>] == <span class="string">'+'</span>) <span class="keyword">return</span> Solve3::main();</span><br><span class="line">            <span class="keyword">return</span> Solve2::main();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cmd[<span class="number">1</span>] == <span class="string">'w'</span>) <span class="keyword">return</span> Solve4::main();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'2'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmd[<span class="number">1</span>] == <span class="string">'p'</span>) <span class="keyword">return</span> Solve5::main();</span><br><span class="line">        <span class="keyword">if</span> (cmd[<span class="number">1</span>] == <span class="string">'u'</span>) <span class="keyword">return</span> Solve6::main();</span><br><span class="line">        <span class="keyword">if</span> (cmd[<span class="number">1</span>] == <span class="string">'g'</span>) <span class="keyword">return</span> Solve7::main();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「十二省联考-2019」皮配"><a href="#「十二省联考-2019」皮配" class="headerlink" title="「十二省联考 2019」皮配"></a>「十二省联考 2019」皮配</h3><p>不 是 网 络 流.</p><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3051" target="_blank" rel="noopener">https://loj.ac/problem/3051</a></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>考虑背包.</p><p>如果 $k = 0$, 此时为城市选定阵营, 为学校选定导师两种决策互不影响, 直接朴素背包计算方案数, 利用乘法原理相乘即可.</p><p>具体地说, 用 $f(i)$ 表示选择蓝阵营总人数为 $i$ 的方案数, $g(i)$ 表示选择鸭派系总人数为 $i$ 的方案数, 记 $S$ 为总人数和, 那么答案为</p><script type="math/tex; mode=display">\sum_{i = S - C1} ^ {C0} f(i) \sum_{j = S - D1} ^ {D0} g(j)</script><p>此时时间复杂度为 $O((n + c) M)$.</p><p>如果 $k &gt; 0$, 没有偏好的城市 / 学校不会受到影响, 直接用以上方法处理即可.</p><p>考虑有偏好的城市 / 学校如何处理. 观察到 $k$ 很小, 此时使用高维 DP. 设 $F(i, j)$ 表示在有偏好的城市及学校中, 城市选择蓝阵营人数为 $i$, 学校选择鸭派系人数为 $j$ 的方案数.</p><p>转移有些复杂… 大力讨论学校偏好即可. 此时动态维护阵营和派系的人数上限可减小常数.</p><p>最后分别枚举蓝阵营和鸭派系人数, 利用 $f,\ g$ 的前缀和 $O(1)$ 合并答案即可.</p><p>综上, 时间复杂度为 $O((n + c) M + kM \min \{M,\ k \cdot \max \{ s_i \}\})$.</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3051</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span> + <span class="number">5</span>, MAXM = <span class="number">2.5e3</span> + <span class="number">5</span>, MAXK = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, c, K;</span><br><span class="line"><span class="keyword">int</span> C0, C1, D0, D1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> b[MAXN], s[MAXN], cs[MAXN], p[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXM], g[MAXM], pf[MAXM], pg[MAXM];</span><br><span class="line"><span class="keyword">int</span> F[MAXM][MAXM], G[MAXM][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    read(n), read(c);</span><br><span class="line">    read(C0), read(C1), read(D0), read(D1);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">-1</span>, (n+<span class="number">1</span>) * <span class="keyword">sizeof</span> (<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i)</span><br><span class="line">        vis[i] = <span class="literal">false</span>, cs[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="keyword">int</span> S = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        read(b[i]), read(s[i]), cs[b[i]] += s[i], S += s[i];</span><br><span class="line">    read(K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idx, i = <span class="number">1</span>; i &lt;= K; ++i)</span><br><span class="line">        read(idx), read(p[idx]), vis[b[idx]] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, (C0 + <span class="number">1</span>) * <span class="keyword">sizeof</span> (<span class="keyword">int</span>));</span><br><span class="line">    pf[<span class="number">0</span>] = f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i) <span class="keyword">if</span> (!vis[i] &amp;&amp; cs[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>&amp; w = cs[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = C0; j &gt;= w; --j)</span><br><span class="line">            f[j] = (f[j] + f[j - w]) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C0; ++i) pf[i] = (pf[i<span class="number">-1</span>] + f[i]) % P;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, (D0 + <span class="number">1</span>) * <span class="keyword">sizeof</span> (<span class="keyword">int</span>));</span><br><span class="line">    pg[<span class="number">0</span>] = g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (p[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>&amp; w = s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = D0; j &gt;= w; --j)</span><br><span class="line">            g[j] = (g[j] + g[j - w]) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= D0; ++i) pg[i] = (pg[i<span class="number">-1</span>] + g[i]) % P;</span><br><span class="line">    <span class="built_in">memset</span>(F, <span class="number">0</span>, <span class="keyword">sizeof</span> F);</span><br><span class="line">    <span class="built_in">memset</span>(G, <span class="number">0</span>, <span class="keyword">sizeof</span> G);</span><br><span class="line">    F[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> Cs = <span class="number">0</span>, Ss = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ci = <span class="number">1</span>; ci &lt;= c; ++ci) <span class="keyword">if</span> (vis[ci]) &#123;</span><br><span class="line">        Cs = min(C0, Cs + cs[ci]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Cs; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= Ss; ++j) G[i][j] = F[i][j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> si = <span class="number">1</span>; si &lt;= n; ++si) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> &amp;w = s[si], &amp;h = p[si];</span><br><span class="line">            <span class="keyword">if</span> (b[si] != ci || h == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            Ss = min(D0, Ss + w);</span><br><span class="line">            <span class="keyword">if</span> (h == <span class="number">1</span> || h == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="comment">// 二维指针不会开.c</span></span><br><span class="line">                <span class="comment">// auto 真香.cpp</span></span><br><span class="line">                <span class="keyword">auto</span> A = (h == <span class="number">1</span>)? F: G;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Cs; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = Ss; j &gt;= w; --j) A[i][j] = A[i][j - w];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w; ++j) A[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> A = (h &gt;= <span class="number">2</span>)? F: G;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Cs; ++i)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = Ss; j &gt;= w; --j)</span><br><span class="line">                    A[i][j] = (A[i][j] + A[i][j - w]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>&amp; w = cs[ci];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= Ss; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Cs; i &gt;= w; --i) F[i][j] = F[i - w][j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w; ++i) F[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Cs; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= Ss; ++j) F[i][j] = (F[i][j] + G[i][j]) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Cs; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= Ss; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> L1 = max(<span class="number">0</span>, S - C1 - i), R1 = C0 - i,</span><br><span class="line">                L2 = max(<span class="number">0</span>, S - D1 - j), R2 = D0 - j;</span><br><span class="line">            <span class="keyword">if</span> (L1 &gt; R1 || L2 &gt; R2) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> s1 = (pf[R1] + (L1 &gt; <span class="number">0</span>? P - pf[L1<span class="number">-1</span>]: <span class="number">0</span>)) % P,</span><br><span class="line">                s2 = (pg[R2] + (L2 &gt; <span class="number">0</span>? P - pg[L2<span class="number">-1</span>]: <span class="number">0</span>)) % P;</span><br><span class="line">            ret = (ret + <span class="number">1L</span>L * s1 * s2 % P * F[i][j] % P) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> Ti; read(Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「十二省联考-2019」春节十二响"><a href="#「十二省联考-2019」春节十二响" class="headerlink" title="「十二省联考 2019」春节十二响"></a>「十二省联考 2019」春节十二响</h3><p><del>清 明 十 二 响</del></p><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3052" target="_blank" rel="noopener">https://loj.ac/problem/3052</a></li></ul><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>这是一道清新题.</p><p>部分分的提示很明显了, 先考虑一条链的情况怎么做.</p><p>假设当前链被根分成了两段, 且这两段之间没有祖先-后代关系. 记这两段序列为 $a_1,\ a_2,\ \ldots,\ a_n$, $b_1,\ b_2,\ \ldots,\ b_m$.</p><p>令 $n \ge m$, 那么将 $a$ 前 $m$ 大元素取出, 并从大到小依次对应 $b$ 中每一个元素, 取最大值作为当前段的权值, 也就是 “这个段的子程序所需内存大小的最大值”. 此时同 $b$ 合并后得到权值, $a$ 中剩余元素, 根的权值的和即为答案.</p><p>对于树的情况, 直接把每个儿子的答案序列, 按链的方式依次合并即可.</p><p>具体证明参见官方题解好了 (</p><p>用优先队列实现这个过程就好了. 由于每个节点出队后不会再进队, 换句话说, 总的合并次数为 $O(n)$.</p><p>时间复杂度 $O(n \log n)$.</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3052</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; PQ[MAXN];</span><br><span class="line"><span class="keyword">int</span> pre[MAXN], M[MAXN], Idx[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], nA;</span><br><span class="line">        Idx[u] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            dfs(v = edges[i].to);</span><br><span class="line">            <span class="keyword">int</span> &amp;iu = Idx[u], &amp;iv = Idx[v];</span><br><span class="line">            <span class="keyword">if</span> (PQ[iv].size() &gt; PQ[iu].size()) swap(iu, iv);</span><br><span class="line">            nA = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!PQ[iv].empty())</span><br><span class="line">                A[++nA] = max(PQ[iv].top(), PQ[iu].top()), PQ[iv].pop(), PQ[iu].pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nA; ++j) PQ[iu].push(A[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        PQ[Idx[u]].push(M[u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="comment">// freopen("input.in", "r", stdin);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(M[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) read(pre[i]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) Graph::AddEdge(pre[i], i);</span><br><span class="line">    Graph::dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; u = Idx[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (!PQ[u].empty()) ans += PQ[u].top(), PQ[u].pop();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「十二省联考-2019」希望"><a href="#「十二省联考-2019」希望" class="headerlink" title="「十二省联考 2019」希望"></a>「十二省联考 2019」希望</h3><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/3053" target="_blank" rel="noopener">https://loj.ac/problem/3053</a></li></ul><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>没希望, 走了.</del></p><p>可以发现, 对于一个联通块 $S$, 设满足在 $S$ 中且到 $S$ 中任意点距离都 $\le L$ 的点集为 $T$, 则 $T$ 也是一个联通块.</p><p>推广到 $k$ 个连通块的情况, 也就是满足题目要求的点集 $T$ 为一个连通块.</p><p>设连通块边集为 $E$, 点集为 $V$, 考虑到树上连通块的性质, 有 $|E| - |V| = 1$.</p><p>那么可以通过容斥计算答案. 设 $f(u)$ 表示以点 $u$ 为中心点的联通块数, $g(e)$ 表示以边 $e$ 的两个端点为中心点联通块数, 那么答案可表示为</p><script type="math/tex; mode=display">\sum_{u \in V} f(u)^k - \sum_{e \in E} g(e)^k</script><p>于是就可以 DP 了. 以下过程中钦定根节点为 $1$.</p><p>设 $f(i, j)$ 表示以 $i$ 为根的子树, 包含节点 $i$ 且同 $i$ 距离不超过 $j$ 的连通块个数. 那么转移为</p><script type="math/tex; mode=display">f(u, i) = \prod_{v \in son(u)} \left(f(v, i-1) + 1\right)</script><p>设 $g(i, j)$ 表示包含节点 $i$, 不包含以 $i$ 为根的子树, 且同 $i$ 距离不超过 $j$ 的连通块个数. 记 $fa$ 为 $u$ 父亲节点, 那么转移为</p><script type="math/tex; mode=display">g(u, i) = g(fa, i-1) \prod_{v \in son(fa),\ v \neq u} \left(f(v, i-2) + 1\right) + 1</script><p>记边 $(u, v)$ 中 $v$ 为较深节点, 那么答案为</p><script type="math/tex; mode=display">\sum_{u = 1} ^ n \big(f(u, L)\cdot g(u, L)\big) ^ k - \sum_{(u, v) \in E} \big(f(v, L-1) \cdot (g(v, L) - 1)\big) ^ k</script><p>此时直接树形 DP, 两次 DFS 分别处理 $f,\ g$ 即可.</p><p>时间复杂度 $O(nL)$. 36 pts 滚出.</p><p><del>使用长链剖分, 可回退数据结构, 离线求逆元优化即可 AC</del>.</p><p>注意到 $f,\ g$ 的转移可以通过长链剖分优化, 转移时可以用数据结构维护.</p><p>另外 $f,\ g$ 的状态在设计时, 给出的限制是 “距离不超过”. 记 $d(u)$ 为节点 $u$ 到子树内叶子的最长距离, 那么不管 $L$ 的限制, 第二维 $\geq d(u)$ 的状态和第二维等于 $d(u)$ 的状态值相等.</p><p>直接记录 $d(u)$ 的值, 对于超过 $d(u)$ 的部分直接取 $d(u)$ 的值即可.</p><p>转移对 $f,\ g$ 的修改只是后缀乘, 全局加, 以及单点修改. 利用可回退数据结构 —- 也就是用类似栈的结构记录操作, 每次记录修改的位置和值, 回退时恢复 —- 即可. 此步骤的时间复杂度和空间复杂度都是 $O(n)$.</p><p>回退时还有一个细节. 在更新 $g$ 的值时, 为了使将来会用到的值不会被提前弹出, 所以转移 $g$ 时需要将 DFS 序翻转.</p><p>后缀乘时可能出现模数 $P$ 的倍数, 也就是要考虑后缀乘 $0$ 的问题. 另外维护一个标记, 表示这个标记后的值全部为 $0$ 即可. 注意此时的 “为 $0$” 指经过 $ax + b$ 的标记运算后为 $0$, 也就是后缀赋值 $-\frac{b}{a}$.</p><p>但是转移 $g$ 时需要用到乘法逆元. 所幸需要用到的值的逆元可以不考虑 $L$ 的限制, 通过一次 DFS 求出. 那么用 “线性求逆元” 的 Trick $O(n)$ 计算就好了.</p><p>综上, 得出了时间复杂度为 $O(n)$ 的做法.</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><p><em>36 pts 代码.</em></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #3053</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">5</span>, MAXL = <span class="number">1e3</span> + <span class="number">5</span>, P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * base * ret % P;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, L, K, ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f[MAXN], g[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123; G[from].push_back(to); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v: G[u]) <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">            dfs1(v, u);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= L; ++i)</span><br><span class="line">                f[u][i] = <span class="number">1L</span>L * f[u][i] * (f[v][i<span class="number">-1</span>] + <span class="number">1</span>) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> p[MAXN], s[MAXN], A[MAXN], nA;</span><br><span class="line">        nA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v: G[u]) <span class="keyword">if</span> (v != fa) A[++nA] = v;</span><br><span class="line">        p[<span class="number">0</span>] = s[nA + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= L; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nA; ++j)</span><br><span class="line">                    p[j] = <span class="number">1L</span>L * p[j<span class="number">-1</span>] * (f[A[j]][i<span class="number">-2</span>] + <span class="number">1</span>) % P;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = nA; j &gt;= <span class="number">1</span>; --j)</span><br><span class="line">                    s[j] = <span class="number">1L</span>L * s[j+<span class="number">1</span>] * (f[A[j]][i<span class="number">-2</span>] + <span class="number">1</span>) % P;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nA; ++j) p[j] = s[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nA; ++j)</span><br><span class="line">                g[A[j]][i] = (<span class="number">1L</span>L * g[u][i<span class="number">-1</span>] * p[j<span class="number">-1</span>] % P * s[j+<span class="number">1</span>] % P + <span class="number">1</span>) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v: G[u]) <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">            ans = (ans + fpow(<span class="number">1L</span>L * f[v][L<span class="number">-1</span>] * (g[v][L] - <span class="number">1</span>) % P, K)) % P;</span><br><span class="line">            dfs2(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        ans = P - ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">            ans = (ans + fpow(<span class="number">1L</span>L * f[u][L] * g[u][L] % P, K)) % P;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(L), read(K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        read(u), read(v), Graph::AddEdge(u, v), Graph::AddEdge(v, u);</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        f[i].resize(L + <span class="number">1</span>, <span class="number">1</span>), g[i].resize(L + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    Graph::solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p><em>100 pts 代码.</em></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 码力尚弱, 码力尚弱.</span></span><br></pre></td></tr></table></figure></div></div><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;其实之前都已经写地差不多了…&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>AHOI / HNOI 2018 大赏</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/AHOI-HNOI-2018-sol/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/AHOI-HNOI-2018-sol/</id>
    <published>2020-03-14T06:11:32.000Z</published>
    <updated>2020-04-28T16:07:02.789Z</updated>
    
    <content type="html"><![CDATA[<hr><p>其实不想再写 18 年的题了… 再写就没时间写 19 年的了 (</p><p>果然立 flag 就是用来倒的.</p><p><del>话说这套题单看正解, 还挺考验思维的?</del></p><a id="more"></a><p>其实写不写都不重要了.</p><h3 id="「AHOI-HNOI2018」寻宝游戏"><a href="#「AHOI-HNOI2018」寻宝游戏" class="headerlink" title="「AHOI / HNOI2018」寻宝游戏"></a>「AHOI / HNOI2018」寻宝游戏</h3><p>挺有意思的一道题.</p><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2494" target="_blank" rel="noopener">https://loj.ac/problem/2494</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>先祭上官方题解: <a href="http://matthew99.blog.uoj.ac/blog/3488" target="_blank" rel="noopener">http://matthew99.blog.uoj.ac/blog/3488</a>.</p><p>着重解释一下什么是 “容易证明, 第 $i$ 位的结果为 $1$, 当且仅当 $x&lt;b_i$.”</p><p>首先根据 myy 的题解, 构造出长度为 $n$ 的串 $x$, 以及 $m$ 个长度为 $n$ 的串 $b_i$.</p><p>对于二进制下某一位的值, 此时对这一位 <code>| 0</code> 或者 <code>&amp; 1</code>, 并不会对原来的该位上的值造成影响. 那么, 如果第 $i$ 位为 <code>1</code>, 那么在一次形如 <code>&amp; 0</code> 的操作后, 一定存在操作 <code>&amp; 1</code>.</p><p>也就是说, 如果把左边看作低位, 那么 $x$ 形如 <code>...1...0...</code>, $b_i$ 形如 <code>...0...1...</code>. 换句话说, $x &lt; b_i$.</p><p>大体思路就是这样了, 也不知道考场 AC 的 “逆推” 做法是什么样的. 还有一些值得注意的细节, 也在代码里了.</p><p>由于使用了基数排序, 时间复杂度 $O(nm + mq)$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2494</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span> + <span class="number">5</span>, MAXM = <span class="number">5e5</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">char</span> S[MAXM];</span><br><span class="line"><span class="keyword">int</span> idx[MAXM], pos[MAXM], A[MAXM];</span><br><span class="line"><span class="keyword">int</span> pow2[MAXN], val[MAXM], Ans[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) pow2[i] = <span class="number">2L</span>L * pow2[i<span class="number">-1</span>] % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) A[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> c[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 字符集为 2 的基数排序相当清爽啊</span></span><br><span class="line">        c[<span class="number">0</span>] = <span class="number">0</span>, c[<span class="number">1</span>] = m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">if</span> (S[j] == <span class="string">'1'</span>) val[j] = (val[j] + pow2[i - <span class="number">1</span>]) % P; <span class="keyword">else</span> ++c[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j; --j) idx[c[S[A[j]] - <span class="string">'0'</span>]--] = A[j];</span><br><span class="line">        <span class="built_in">memcpy</span>(A, idx, (m + <span class="number">1</span>) * <span class="keyword">sizeof</span> (<span class="keyword">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) Ans[i] = val[A[i]];</span><br><span class="line">    Ans[m + <span class="number">1</span>] = pow2[n];</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">1</span>; --i) <span class="keyword">if</span> (S[A[i]] == <span class="string">'0'</span>) &#123; L = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="keyword">if</span> (S[A[i]] == <span class="string">'1'</span>) &#123; R = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, L &lt; R? (Ans[R] - Ans[L] + P) % P: <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「AHOI-HNOI2018」转盘"><a href="#「AHOI-HNOI2018」转盘" class="headerlink" title="「AHOI / HNOI2018」转盘"></a>「AHOI / HNOI2018」转盘</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2495" target="_blank" rel="noopener">https://loj.ac/problem/2495</a></li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>将选择物品这个过程的顺序倒过来, 也就是在某个时刻 $t$, 从位置 $i$ 开始先前移动, 每个物品在时刻 $T_j$ 消失, 需要在每个物品消失前到达该物品的位置.</p><p>此时容易看出, 选择好位置和时刻之后, 一刻不停地走才能得到当前状态下的最优解. 本题做法就此展开.</p><p>首先将出现时刻序列 $T_i$ 倍长, 记当前出发位置为 $i$ ($i \in [n,\ 2n)$), 当前时刻为 $t$, 则标记所有物品的限制可以表示为</p><script type="math/tex; mode=display">\forall\ j \in (i-n,\ i],\ t - (i - j) \ge T_j</script><p>即</p><script type="math/tex; mode=display">t \ge (T_j - j) + i</script><p>记 $a_j = T_j - j$, 那么答案为</p><script type="math/tex; mode=display">\min_{i = n} ^ {2n - 1} \{ \max_{j = i - n + 1} ^ {i} \{ a_j \} + i \}</script><p>对 $i$ 进行一些变换, 得</p><script type="math/tex; mode=display">\min_{i = 1} ^ n \{ \max_{j = i} ^ {i + n -1} \{ a_j \} + i \} + (n-1)</script><p>考虑到 $i \le j &lt; i + n$ 这个限制又臭又长, 因为 $a_i = T_i - i &gt; a_{i + n} = T_{i + n} - (i + n) = T_i - i - n$, 所以此时的 $a_j$ 就是个后缀最大值, 即</p><script type="math/tex; mode=display">\min_{i = 1} ^ n \{ \max_{j = i} ^ {2 n} \{ a_j \} + i \} + (n-1)</script><p>考虑某一个位置 $j$, 令 $j$ 满足 $a_j$ 为后缀最大值, 那么从 $j-1$ 往前找到第一个满足 $a_i &gt; a_j$ 的位置 $i$, 此时答案为 $a_j + i + 1$.</p><p>如果此时 $a_j$ 不是后缀最大值, 那么答案和后缀最大值的情况相同.</p><p>就此我们得到了一个单调栈做法, 即维护一个 $a_j$ 值从右到左单调上升的栈, 并设栈中元素为 $p_i$, 令 $p_0 = 0$, 答案即为</p><script type="math/tex; mode=display">\min_{i = 1} ^ j \{ a_{p_i} + p_{i-1} + 1\} + n - 1 = \min_{i = 1} ^ j \{ a_{p_i} + p_{i-1}\} + n</script><p>利用线段树维护这个单调栈即可. 还是由于 $a_i = T_i - i,\ a_{i + n} = T_{i + n} - i - n$, 此时只需要维护 $[1,\ n]$ 即可.</p><p>类似的技巧也在 <a href="https://www.luogu.com.cn/problem/P4198" target="_blank" rel="noopener">Luogu P4198 楼房重建</a> 中使用过.</p><p>时间复杂度 $O(n \log ^2 n)$.</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2495</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p;</span><br><span class="line"><span class="keyword">int</span> A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (nd&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (nd&lt;&lt;1|1)</span></span><br><span class="line">    <span class="keyword">int</span> datMax[MAXN &lt;&lt; <span class="number">2</span>], dat[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> datMax[nd] &gt; k? k + L: INF;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; datMax[rc]) <span class="keyword">return</span> min(dat[nd], Qry(rc, Mid+<span class="number">1</span>, R, k));</span><br><span class="line">        <span class="keyword">return</span> Qry(lc, L, Mid, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        datMax[nd] = max(datMax[lc], datMax[rc]);</span><br><span class="line">        dat[nd] = Qry(lc, L, Mid, datMax[rc]);</span><br><span class="line">        <span class="comment">// 用右子树的最大值在左子树中查询, 以更新答案</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> <span class="keyword">void</span>( datMax[nd] = A[L] - L );</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        build(lc, L, Mid), build(rc, Mid+<span class="number">1</span>, R);</span><br><span class="line">        maintain(nd, L, R);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; pos, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> <span class="keyword">void</span>( datMax[nd] = val - L );</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= Mid) Mdy(lc, L, Mid, pos, val);</span><br><span class="line">        <span class="keyword">else</span> Mdy(rc, Mid+<span class="number">1</span>, R, pos, val);</span><br><span class="line">        maintain(nd, L, R);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m), read(p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    SGT::build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">int</span> x, y, lstans = SGT::Qry(<span class="number">1</span>, <span class="number">1</span>, n, SGT::datMax[<span class="number">1</span>] - n) + n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lstans);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        read(x), read(y);</span><br><span class="line">        x ^= p * lstans, y ^= p * lstans;</span><br><span class="line">        SGT::Mdy(<span class="number">1</span>, <span class="number">1</span>, n, x, y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lstans = SGT::Qry(<span class="number">1</span>, <span class="number">1</span>, n, SGT::datMax[<span class="number">1</span>] - n) + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「AHOI-HNOI2018」毒瘤"><a href="#「AHOI-HNOI2018」毒瘤" class="headerlink" title="「AHOI / HNOI2018」毒瘤"></a>「AHOI / HNOI2018」毒瘤</h3><p>毒瘤.</p><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2496" target="_blank" rel="noopener">https://loj.ac/problem/2496</a></li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先考虑树的情况下怎么做.</p><p>设 $f(i, j)$ 表示以节点 $i$ 为根的子树内, 第 $i$ 个点选 ($j = 1$) / 不选 ($j = 0$) 时的方案数, 容易得到转移</p><script type="math/tex; mode=display">f(u, 1) \prod_{v \in son(u)} f(v, 0) \\ f(u, 0) = \prod_{v \in son(u)} (\ f(v, 0) + f(v, 1)\ )</script><p>观察到 $n - 1 \le m \le n + 10$ 的限制, 可以得到一个 $O(n 2 ^ {m - n + 1})$, 即依次枚举非树边的选择情况, 以此为限制修改 DP 初始值, 每次都做一次整棵树的 DP.</p><p>此时仍有优化的余地, 考虑到非树边很少, 影响到的点很少, 可以对这些点建出虚树, 并在虚树上 DP.</p><p>具体地说, 考虑虚树上一条边 $(u, v)$, 其在树边上路径为 $k_1,\ k_2,\ \ldots,\ k_n$ (其中 $k_1 = u$, $k_n = v$), 此时 $v$ 对 $u$ 的答案有贡献. 即</p><script type="math/tex; mode=display">f(k_i, 1) := f(k_i, 1) \cdot f(k_{i+1}, 0) \\ f(k_i, 0) := f(k_i, 0) \cdot (\ f(k_{i+1}, 0) + f(k_{i+1}, 1)\ )</script><p>手动展开之后式子有些复杂… 冷静一下可以发现, 其中的系数都是一样的, 直接按照定义预处理出来就好了.</p><p>记 $k(u, i, j)$ 表示节点 $u$, 由状态 $i$ 到达状态 $j$, DP 转移时的系数. 则虚树边上的转移可写作</p><script type="math/tex; mode=display">f(u, 0) = \prod_{v \in son(u)} (\ k(v, 1, 0) \cdot f(v, 1) + k(v, 0, 0) \cdot f(v, 0)\ ) \\ f(u, 1) = \prod_{v \in son(u)} (\ k(v, 1, 1) \cdot f(v, 1) + k(v, 0, 1) \cdot f(v, 0)\ )</script><p>还应注意到, 虚树上 DP 的初始值并不是 $1$ —- 而是原树上, 子树内不包含虚树上结点的 DP 值.</p><p>考虑为什么是这样. 如果原树某个节点, 其子树包含有虚数上节点, 那么此时原树上的答案已经在计算系数的过程中贡献到最终答案了. 因而只考虑子树内不包含虚树上节点的部分即可.</p><p>时间复杂度 $O(n + (m-n+1)\ 2 ^ {m - n + 1})$.</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>实际为了缓存友好, DP 状态的顺序稍有改变.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2496</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">114</span>, P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> U[MAXN], V[MAXN], nE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> pre[MAXN], dfn[MAXN], A[MAXN], nA;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][MAXN], g[<span class="number">2</span>][MAXN], K[<span class="number">2</span>][<span class="number">2</span>][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line">    Edge edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    Graph() &#123; init(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G, T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HLD &#123;</span><br><span class="line">    <span class="keyword">int</span> son[MAXN], depth[MAXN], size[MAXN], topfa[MAXN], dfs_clock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        pre[u] = fa, size[u] = <span class="number">1</span>, son[u] = <span class="number">-1</span>;</span><br><span class="line">        dfn[u] = ++dfs_clock, depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = G.head[u]; ~i; i = G.edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = G.edges[i].to) == fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">                dfs1(v, u), size[u] += size[v];</span><br><span class="line">                <span class="keyword">if</span> (son[u] == <span class="number">-1</span> || size[son[u]] &lt; size[v]) son[u] = v;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dfn[v] &lt; dfn[u])</span><br><span class="line">                U[++nE] = v, V[nE] = u, vis[u] = vis[v] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">        topfa[u] = top;</span><br><span class="line">        <span class="keyword">if</span> (~son[u]) dfs2(son[u], top), vis[u] |= vis[son[u]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = G.head[u]; ~i; i = G.edges[i].nxt)</span><br><span class="line">            <span class="keyword">if</span> ((v = G.edges[i].to) != pre[u] &amp;&amp; v != son[u])</span><br><span class="line">                dfs2(v, v), vis[u] |= vis[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (topfa[u] != topfa[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth[topfa[u]] &lt; depth[topfa[v]]) swap(u, v);</span><br><span class="line">            u = pre[topfa[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth[u] &gt; depth[v]? v: u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dfs1(<span class="number">1</span>, <span class="number">0</span>), G.init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (pre[i]) G.AddEdge(pre[i], i);</span><br><span class="line">        dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> VT &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123; <span class="keyword">return</span> dfn[a] &lt; dfn[b]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> stk[MAXN], top;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nE; ++i) A[++nA] = U[i], A[++nA] = V[i];</span><br><span class="line">        sort(A+<span class="number">1</span>, A+<span class="number">1</span>+nA, cmp);</span><br><span class="line">        stk[top = <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nA; ++i) <span class="keyword">if</span> (A[i] != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == stk[top]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> lca = HLD::LCA(A[i], stk[top]);</span><br><span class="line">            <span class="keyword">if</span> (lca != stk[top]) &#123;</span><br><span class="line">                <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; dfn[lca] &lt; dfn[stk[top<span class="number">-1</span>]])</span><br><span class="line">                    T.AddEdge(stk[top<span class="number">-1</span>], stk[top]), --top;</span><br><span class="line">                <span class="keyword">if</span> (top &gt; <span class="number">1</span> &amp;&amp; dfn[lca] &gt; dfn[stk[top<span class="number">-1</span>]])</span><br><span class="line">                    T.AddEdge(lca, stk[top]), stk[top] = lca;</span><br><span class="line">                <span class="keyword">else</span> T.AddEdge(lca, stk[top--]);</span><br><span class="line">            &#125;</span><br><span class="line">            stk[++top] = A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; ++i) T.AddEdge(stk[i], stk[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在原树上 DP, 辅助计算系数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; ban)</span> </span>&#123;</span><br><span class="line">        f[<span class="number">0</span>][u] = f[<span class="number">1</span>][u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = G.head[u]; ~i; i = G.edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = G.edges[i].to) == ban || v == pre[u]) <span class="keyword">continue</span>;</span><br><span class="line">            DP(v, u);</span><br><span class="line">            f[<span class="number">1</span>][u] = <span class="number">1L</span>L * f[<span class="number">1</span>][u] * f[<span class="number">0</span>][v] % P;</span><br><span class="line">            f[<span class="number">0</span>][u] = <span class="number">1L</span>L * f[<span class="number">0</span>][u] * (f[<span class="number">0</span>][v] + f[<span class="number">1</span>][v]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 DP 初始值 g</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DPinit</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        g[<span class="number">0</span>][u] = g[<span class="number">1</span>][u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = G.head[u]; ~i; i = G.edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = G.edges[i].to) == fa || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            DPinit(v, u);</span><br><span class="line">            g[<span class="number">1</span>][u] = <span class="number">1L</span>L * g[<span class="number">1</span>][u] * g[<span class="number">0</span>][v] % P;</span><br><span class="line">            g[<span class="number">0</span>][u] = <span class="number">1L</span>L * g[<span class="number">0</span>][u] * (g[<span class="number">0</span>][v] + g[<span class="number">1</span>][v]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算系数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Jump</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; fa)</span> </span>&#123;</span><br><span class="line">        K[<span class="number">0</span>][<span class="number">0</span>][u] = K[<span class="number">0</span>][<span class="number">1</span>][u] = K[<span class="number">1</span>][<span class="number">0</span>][u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = u; pre[i] != fa; i = pre[i]) &#123;</span><br><span class="line">            DP(pre[i], i);</span><br><span class="line">            <span class="keyword">int</span> ft = pre[i], k0 = K[<span class="number">0</span>][<span class="number">0</span>][u], k1 = K[<span class="number">0</span>][<span class="number">1</span>][u];</span><br><span class="line">            K[<span class="number">0</span>][<span class="number">0</span>][u] = (<span class="number">1L</span>L * f[<span class="number">0</span>][ft] * k0 % P + <span class="number">1L</span>L * f[<span class="number">1</span>][ft] * K[<span class="number">1</span>][<span class="number">0</span>][u] % P) % P;</span><br><span class="line">            K[<span class="number">0</span>][<span class="number">1</span>][u] = (<span class="number">1L</span>L * f[<span class="number">0</span>][ft] * k1 % P + <span class="number">1L</span>L * f[<span class="number">1</span>][ft] * K[<span class="number">1</span>][<span class="number">1</span>][u] % P) % P;</span><br><span class="line">            K[<span class="number">1</span>][<span class="number">1</span>][u] = <span class="number">1L</span>L * f[<span class="number">0</span>][ft] * k1 % P;</span><br><span class="line">            K[<span class="number">1</span>][<span class="number">0</span>][u] = <span class="number">1L</span>L * f[<span class="number">0</span>][ft] * k0 % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在虚树上 DFS 以初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        A[++nA] = u, DPinit(u, fa);</span><br><span class="line">        <span class="keyword">if</span> (fa &amp;&amp; u != fa) Jump(u, fa);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = T.head[u]; ~i; i = T.edges[i].nxt)</span><br><span class="line">            <span class="keyword">if</span> ((v = T.edges[i].to) != fa) init(v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123; build(), nA = <span class="number">0</span>, init(<span class="number">1</span>, <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚树上 DP</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = T.head[u]; ~i; i = T.edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = T.edges[i].to) == fa) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(v, u);</span><br><span class="line">            f[<span class="number">0</span>][u] = <span class="number">1L</span>L * f[<span class="number">0</span>][u] *</span><br><span class="line">                (<span class="number">1L</span>L * K[<span class="number">0</span>][<span class="number">0</span>][v] * f[<span class="number">0</span>][v] % P + <span class="number">1L</span>L * K[<span class="number">0</span>][<span class="number">1</span>][v] * f[<span class="number">1</span>][v] % P) % P;</span><br><span class="line">            f[<span class="number">1</span>][u] = <span class="number">1L</span>L * f[<span class="number">1</span>][u] *</span><br><span class="line">                (<span class="number">1L</span>L * K[<span class="number">1</span>][<span class="number">0</span>][v] * f[<span class="number">0</span>][v] % P + <span class="number">1L</span>L * K[<span class="number">1</span>][<span class="number">1</span>][v] * f[<span class="number">1</span>][v] % P) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        read(u), read(v), G.AddEdge(u, v), G.AddEdge(v, u);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    HLD::solve(), VT::solve();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; nE); ++s) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nA; ++i)</span><br><span class="line">            f[<span class="number">0</span>][A[i]] = g[<span class="number">0</span>][A[i]], f[<span class="number">1</span>][A[i]] = g[<span class="number">1</span>][A[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nE; ++i)</span><br><span class="line">            <span class="keyword">if</span> ((s &gt;&gt; (i<span class="number">-1</span>)) &amp; <span class="number">1</span>) f[<span class="number">0</span>][U[i]] = f[<span class="number">1</span>][V[i]] = <span class="number">0</span>; <span class="keyword">else</span> f[<span class="number">1</span>][U[i]] = <span class="number">0</span>;</span><br><span class="line">        VT::dfs(<span class="number">1</span>, <span class="number">0</span>), ans = (ans + (f[<span class="number">0</span>][<span class="number">1</span>] + f[<span class="number">1</span>][<span class="number">1</span>]) % P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「AHOI-HNOI2018」游戏"><a href="#「AHOI-HNOI2018」游戏" class="headerlink" title="「AHOI / HNOI2018」游戏"></a>「AHOI / HNOI2018」游戏</h3><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2508" target="_blank" rel="noopener">https://loj.ac/problem/2508</a></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先将房间按上锁的门分割, 处理出房间 $i$ 能到达的房间位置 $[L_i,\ R_i]$. 这样判断 $s$ 是否能到达 $t$, 只需要判断 $t$ 是否在区间 $[L_i,\ R_i]$ 就好了.</p><p>有一个显然的暴力, 对于每个位置向左右两个方向扩展, 并逐步更新 $L_i$ / $R_i$.</p><p>思考如何优化这个暴力. 考虑到对每个位置扩展时, 很多状态被计算了多次. 而题目中钥匙放置位置, 又存在这样的性质:</p><ol><li><p>如果房间 $i$ 和房间 $i+1$ 存在锁, 且钥匙在房间 $i$ 左侧 (包含 $i$), 那么房间 $i+1$ 之后的位置一定不能越过这扇门.</p></li><li><p>如果房间 $i$ 和房间 $i+1$ 存在锁, 且钥匙在房间 $i+1$ 右侧 (包含 $i+1$), 那么房间 $i$ 之前的位置一定不能越过这扇门.</p></li></ol><p>每次遇到一个锁时, 将一个位置向该位置不能到达的地方连边, 建完边后可以得到一个 DAG, 在拓扑排序时更新可到达位置区间即可.</p><p>实际实现时, 直接使用按锁分割后的编号, 也就是所谓 “缩点” 了.</p><p>虽然拓扑排序更新到达位置区间 $[L_i, R_i]$ 时的复杂度看起来很不对劲, 但其实均摊是线性的… 这也是建图方法所保证的.</p><p>时间复杂度 $O(n + m)$.</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2508</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">int</span> L[MAXN], R[MAXN];</span><br><span class="line"><span class="keyword">int</span> Key[MAXN], Idx[MAXN], idx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], in[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">        ++in[to];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= idx; ++i) <span class="keyword">if</span> (!in[i]) Q.push(i);</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">int</span> p1 = Key[L[u] - <span class="number">1</span>], p2 = Key[R[u]];</span><br><span class="line">                <span class="keyword">while</span> (L[u] &lt;= p1 &amp;&amp; p1 &lt;= R[u])</span><br><span class="line">                    flag = <span class="literal">true</span>, L[u] = L[Idx[L[u] - <span class="number">1</span>]], p1 = Key[L[u] - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">while</span> (L[u] &lt;= p2 &amp;&amp; p2 &lt;= R[u])</span><br><span class="line">                    flag = <span class="literal">true</span>, R[u] = R[Idx[R[u] + <span class="number">1</span>]], p2 = Key[R[u]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">                <span class="keyword">if</span> (!(--in[v = edges[i].to])) Q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m), read(q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x, i = <span class="number">1</span>; i &lt;= m; ++i) read(x), read(Key[x]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    L[<span class="number">1</span>] = R[<span class="number">1</span>] = idx = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Key[i - <span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            L[++idx] = i;</span><br><span class="line">            <span class="keyword">if</span> (Key[i - <span class="number">1</span>] &lt;= i - <span class="number">1</span>) Graph::AddEdge(idx, idx - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> Graph::AddEdge(idx - <span class="number">1</span>, idx);</span><br><span class="line">        &#125;</span><br><span class="line">        R[idx] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记 Idx[i] 为实际房间标号 i, 对应按锁分割后块的编号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= idx; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = L[i]; j &lt;= R[i]; ++j) Idx[j] = i;</span><br><span class="line">    Graph::Toposort();</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> s, t;</span><br><span class="line">        read(s), read(t);</span><br><span class="line">        <span class="built_in">puts</span>((L[Idx[s]] &lt;= t &amp;&amp; t &lt;= R[Idx[s]])? <span class="string">"YES"</span>: <span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「AHOI-HNOI2018」排列"><a href="#「AHOI-HNOI2018」排列" class="headerlink" title="「AHOI / HNOI2018」排列"></a>「AHOI / HNOI2018」排列</h3><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2509" target="_blank" rel="noopener">https://loj.ac/problem/2509</a></li></ul><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>考虑题目中这个很奇怪的限制在说什么.</p><p>既然满足 “如果 $a_{p_j} = p_k$, 那么 $k &lt; j$”, 换句话说, 如果增量构造出这个排列, 在选择 $j$ 时, 一定要先选 $a_j$.</p><p>此时将 $a_j$ 向 $j$ 连边, 如果形成环则一定无解, 否则就是一颗以 $0$ 为根的树.</p><p>考虑如何构造出最优解, 可以发现, 权值都是固定的, 要做的事就是在合法的范围内, 将尽量大的 $w_i$ 放在后面.</p><p>于是可以得到一个贪心策略. 首先找到当前权值最小的位置 $p$, 如果 $p$ 在树上没有父亲, 也就是 $a_p = 0$, 此时一定选择 $p$; 否则在选择 $a_p$ 后立刻选择 $p$.</p><p>因此可以将 $p$ 和 $a_p$ 合并, 具体而言, 每次取出最小值, 更新信息并利用并查集合并即可.</p><p>剩余的问题就是如何找到这个最小值了. 考虑到合并一些节点之后, 得到的就是一个序列. 假有两个序列 $a$, $b$, 记两个序列的权值分别为 $W_a$, $W_b$, 那么</p><script type="math/tex; mode=display">W_a = \sum_{i = p}^{s_a} (p + i)\ w_{a_i} \\\ W_b = \sum_{i = p} ^ {s_b} (p + i)\ w_{b_i}</script><p>考虑两序列拼接的两种方式, 即</p><script type="math/tex; mode=display">W_{ab} = \sum_{i = 1} ^ {s_a} (p + i)\ w_{a_i} + \sum_{i = 1} ^ {s_b} (p + i + s_a)\ w_{b_i} \\\ W_{ba} = \sum_{i = 1} ^ {s_b} (p + i)\ w_{b_i} + \sum_{i = 1} ^ {s_a} (p + i + s_b)\ w_{a_i}</script><p>若选择 $ab$ 的形式使得答案更大, 那么有 $W_{ab} &gt; W_{ba}$, 即</p><script type="math/tex; mode=display">s_b \sum_{i = 1} ^ {s_a} w_{a_i} < s_a \sum_{i = 1} ^ {s_b} w_{b_i}</script><p>于是万事大吉.</p><p>时间复杂度 $O(n \log n)$.</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><p>如果考虑节点 $0$ 在计算答案时的影响, 则需要把 <code>W[0]</code> 设为 INF, 但是这个 INF 太大爆 <code>long long</code> (虽然不影响结果), 太小会 WA = =</p><p>那就直接不考虑吧 (</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2509</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, s; LL w;</span><br><span class="line">    Item(<span class="keyword">int</span> _u, <span class="keyword">int</span> _s, LL _w): u(_u), s(_s), w(_w) &#123; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w * rhs.s &gt; rhs.w * s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], size[MAXN];</span><br><span class="line">LL W[MAXN];</span><br><span class="line">priority_queue&lt;Item&gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DSU &#123;</span><br><span class="line">    <span class="keyword">int</span> fa[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) fa[i] = i, size[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">findfa</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123; <span class="keyword">return</span> u == fa[u]? u: fa[u] = findfa(fa[u]); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NoAns</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> vis[MAXN];</span><br><span class="line">        <span class="keyword">int</span> s = vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) == fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (vis[v]) NoAns();</span><br><span class="line">            s += dfs(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(W[i]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) Graph::AddEdge(A[i], i);</span><br><span class="line">    <span class="keyword">if</span> (Graph::dfs(<span class="number">0</span>, <span class="number">-1</span>) != n + <span class="number">1</span>) NoAns();</span><br><span class="line">    DSU::init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) Q.push(Item(i, size[i], W[i]));</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        Item x = Q.top(); Q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = DSU::findfa(x.u), fa = DSU::findfa(A[u]);</span><br><span class="line">        <span class="keyword">if</span> (size[u] != x.s) <span class="keyword">continue</span>;</span><br><span class="line">        ans += W[u] * size[fa];</span><br><span class="line">        DSU::fa[u] = fa, W[fa] += W[u], size[fa] += size[u];</span><br><span class="line">        <span class="keyword">if</span> (fa) Q.push(Item(fa, size[fa], W[fa]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「AHOI-HNOI2018」道路"><a href="#「AHOI-HNOI2018」道路" class="headerlink" title="「AHOI / HNOI2018」道路"></a>「AHOI / HNOI2018」道路</h3><p>这是一道 NOIP 题…</p><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2510" target="_blank" rel="noopener">https://loj.ac/problem/2510</a></li></ul><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>观察式子</p><script type="math/tex; mode=display">c_i \cdot (a_i + x) \cdot (b_i + y)</script><p>可以发现, 这个式子没有用.</p><p>题目给定的其实是一颗以 $1$ 为根, 共 $2n - 1$ 个节点的二叉树, 叶节点都是乡村. 并钦定连向左儿子的边为公路, 连向右儿子的边为铁路.</p><p>设 $f(u, i, j)$ 表示节点 $u$, 其到根节点共经过 $i$ 条公路, $j$ 条铁路. 则</p><p>对于叶子 $u$, 有</p><script type="math/tex; mode=display">f(u, i, j) = c_u \cdot (a_u + i) \cdot (b_u + j)</script><p>对于其他节点 $u$, 记 $u$ 左儿子为 $lc$, 右儿子为 $rc$, 有转移</p><script type="math/tex; mode=display">f(u, i, j) = \min \{ f(lc, i + 1, j) + f(rc, i, j),\ f(lc, i, j) + f(rc, i,  j + 1) \}</script><p>答案即为 $f(1, 0, 0)$.</p><p>以及一个卡空间的方法. 考虑到每次计算 $f(u, i, j)$ 时, 只是利用了一条链, 不相交的链之间不会互相影响, 若记二叉树最大深度为 $h$, 第一维只需记录 $2h$ 位即可.</p><p>时间复杂度 $O(h ^ 2 n)$.</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2510</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">            (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">4e4</span> + <span class="number">5</span>, MAXH = <span class="number">41</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN], C[MAXN];</span><br><span class="line"><span class="keyword">int</span> ch[<span class="number">2</span>][(MAXN &gt;&gt; <span class="number">1</span>) | <span class="number">1</span>], dfn[MAXN];</span><br><span class="line">LL f[MAXH][MAXH][(MAXH &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> clk, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> du = dfn[u] = clk;</span><br><span class="line">    <span class="keyword">if</span> (u &gt;= n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= x; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= y; ++j)</span><br><span class="line">                f[i][j][du] = <span class="number">1L</span>L * C[u] * (A[u] + i) * (B[u] + j);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 假装自己在下传 DFS 序.png</span></span><br><span class="line">    dfs(ch[<span class="number">0</span>][u], clk + <span class="number">1</span>, x + <span class="number">1</span>, y), dfs(ch[<span class="number">1</span>][u], clk + <span class="number">2</span>, x, y + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> d1 = dfn[ch[<span class="number">0</span>][u]], d2 = dfn[ch[<span class="number">1</span>][u]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= x; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= y; ++j)</span><br><span class="line">            f[i][j][du] = min(f[i + <span class="number">1</span>][j][d1] + f[i][j][d2], f[i][j][d1] + f[i][j + <span class="number">1</span>][d2]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        read(u), read(v);</span><br><span class="line">        ch[<span class="number">0</span>][i] = u &lt; <span class="number">0</span>? -u + n - <span class="number">1</span>: u, ch[<span class="number">1</span>][i] = v &lt; <span class="number">0</span>? -v + n - <span class="number">1</span>: v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt;= n + n<span class="number">-1</span>; ++i) read(A[i]), read(B[i]), read(C[i]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[<span class="number">0</span>][<span class="number">0</span>][dfn[<span class="number">1</span>]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这周比上周少写了一整套 SDOI = =, 退役稳了.</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;其实不想再写 18 年的题了… 再写就没时间写 19 年的了 (&lt;/p&gt;
&lt;p&gt;果然立 flag 就是用来倒的.&lt;/p&gt;
&lt;p&gt;&lt;del&gt;话说这套题单看正解, 还挺考验思维的?&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
</feed>
