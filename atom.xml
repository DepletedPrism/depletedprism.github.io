<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DepletedPrism&#39;s Blog</title>
  
  <subtitle>知其然而不知其所以然是可悲的.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://depletedprism.github.io/"/>
  <updated>2020-02-08T08:16:18.437Z</updated>
  <id>https://depletedprism.github.io/</id>
  
  <author>
    <name>DepletedPrism</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「置顶」算法教程合辑</title>
    <link href="https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/compilation/"/>
    <id>https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/compilation/</id>
    <published>9102-11-14T00:11:23.000Z</published>
    <updated>2020-02-08T08:16:18.437Z</updated>
    
    <content type="html"><![CDATA[<hr><p>这个 idea 来源于 <a href="https://www.cnblogs.com/mlystdcall/p/8078467.html" target="_blank" rel="noopener">__stdcall 的教程合辑</a>, 觉得这个很好, 所以学习了.</p><a id="more"></a><p><del>Hexo 博客的强制置顶</del></p><h4 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h4><ul><li>树状数组进阶<ul><li><a href="https://www.cnblogs.com/RabbitHu/p/BIT.html" target="_blank" rel="noopener">https://www.cnblogs.com/RabbitHu/p/BIT.html</a></li></ul></li></ul><h4 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h4><ul><li>网络流入门<ul><li><a href="https://www.xht37.com/二分图与网络流-学习笔记/" target="_blank" rel="noopener">https://www.xht37.com/二分图与网络流-学习笔记/</a></li></ul></li><li>上下界网络流<ul><li><a href="https://www.cnblogs.com/mlystdcall/p/6734852.html" target="_blank" rel="noopener">https://www.cnblogs.com/mlystdcall/p/6734852.html</a></li></ul></li></ul><h4 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h4><ul><li>基础构造<ul><li><a href="https://oi.men.ci/linear-basis-notes/" target="_blank" rel="noopener">https://oi.men.ci/linear-basis-notes/</a></li></ul></li><li>可重集 Kth 异或和<ul><li><a href="https://blog.csdn.net/qaq__qaq/article/details/53812883" target="_blank" rel="noopener">https://blog.csdn.net/qaq__qaq/article/details/53812883</a></li></ul></li></ul><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul><li>四边形不等式优化<ul><li><a href="https://oi-wiki.org/dp/opt/quadrangle/" target="_blank" rel="noopener">https://oi-wiki.org/dp/opt/quadrangle/</a></li></ul></li></ul><h4 id="Link-Cut-Tree"><a href="#Link-Cut-Tree" class="headerlink" title="Link Cut Tree"></a>Link Cut Tree</h4><ul><li>应用 &amp; 题单<ul><li><a href="https://www.cnblogs.com/flashhu/p/9498517.html" target="_blank" rel="noopener">https://www.cnblogs.com/flashhu/p/9498517.html</a></li></ul></li></ul><h4 id="左偏树"><a href="#左偏树" class="headerlink" title="左偏树"></a>左偏树</h4><ul><li>特点及应用<ul><li><a href="https://files-cdn.cnblogs.com/files/shenben/算法合集之《左偏树的特点及其应用》.pdf" target="_blank" rel="noopener">https://files-cdn.cnblogs.com/files/shenben/算法合集之《左偏树的特点及其应用》.pdf</a></li></ul></li></ul><h4 id="Min-Max-容斥"><a href="#Min-Max-容斥" class="headerlink" title="Min-Max 容斥"></a>Min-Max 容斥</h4><ul><li>证明及应用<ul><li><a href="https://www.cnblogs.com/GXZlegend/p/11563330.html" target="_blank" rel="noopener">https://www.cnblogs.com/GXZlegend/p/11563330.html</a></li></ul></li></ul><h4 id="Stirling-数及-Stirling-反演"><a href="#Stirling-数及-Stirling-反演" class="headerlink" title="Stirling 数及 Stirling 反演"></a>Stirling 数及 Stirling 反演</h4><ul><li>性质及应用<ul><li><a href="https://www.cnblogs.com/y2823774827y/p/10700231.html" target="_blank" rel="noopener">https://www.cnblogs.com/y2823774827y/p/10700231.html</a></li></ul></li></ul><h4 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h4><ul><li>证明及应用<ul><li><a href="https://www.cnblogs.com/GXZlegend/p/11407185.html" target="_blank" rel="noopener">https://www.cnblogs.com/GXZlegend/p/11407185.html</a></li></ul></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;这个 idea 来源于 &lt;a href=&quot;https://www.cnblogs.com/mlystdcall/p/8078467.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;__stdcall 的教程合辑&lt;/a&gt;, 觉得这个很好, 所以学习了.&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://depletedprism.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>「UVA-10572」Black &amp; White 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/UVA-10572/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/UVA-10572/</id>
    <published>2020-02-24T12:27:59.000Z</published>
    <updated>2020-02-24T13:54:49.011Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>最后一步判断最为关键, 也最容易想错… 请读者思考如何区分这两种情况.</p></blockquote><ul><li>题目链接: <a href="https://vjudge.net/problem/UVA-10572" target="_blank" rel="noopener">https://vjudge.net/problem/UVA-10572</a></li></ul><p><em>由于某些原因, 链接指向的其实是 vjudge</em></p><p><del>毒瘤啊!</del></p><p>其实是常规的插头 DP 维护棋盘格联通性的问题, 第一次见感觉很新鲜, 然后… 就自闭了. = =</p><a id="more"></a><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给定一个部分黑白染色的 $n \times m$ 棋盘, 现在给出两种限制</p><ol><li>任意 $2 \times 2$ 的网格不会全黑或者全白.</li><li><strong>所有黑格四联通, 所有白格四联通</strong>.</li></ol><p>现在要把所有的棋盘染色, 求满足以上限制的方案数.</p><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>容易发现这是一道插头 DP / 轮廓线 DP, 我们依次考虑两种限制.</p><p>对于题目给定的颜色, 容易发现这个限制很好处理, 只不过是在已染色位置按照给定颜色转移.</p><p>对于第一种限制, 容易发现只用记录 “当前转移位置” 的左上棋盘的颜色即可. 这样转移的时候, 抛弃掉引起冲突的颜色就好了.</p><p>对于第二种限制, 则需要考虑每个点的联通情况. 考虑在轮廓线步步推进的过程中, 刚开始不连通的区域可能在某处得到联通, 所以在转移当前状态时, 显然不能在要求当前轮廓线一直保持两种颜色四联通的状态.</p><p><del>一开始没看到第二种限制, 整个人傻掉了</del></p><p>那怎么办呢? 考虑加一些状态, 记录当前轮廓线上每个位置所属的连通分量编号. 暂且不考虑如何记录这个编号, 先来考虑记录之后如何转移, 以及正确性.</p><p>沿用普通的插头 DP 思路, 对于当前状态, 枚举当前位置要放置的颜色, 排除掉已有颜色, 以及 $2 \times 2$ 方格的限制. 新加入棋盘格的连通分量编号呢? 有两种情况:</p><ol><li><p>当前棋盘格颜色和左侧 / 上方棋盘格颜色相同</p><p>此种情况可以通过对连通分量编号进行简单合并解决.</p></li><li><p>当前棋盘格颜色和<strong>上方</strong>棋盘格颜色<strong>不同</strong></p><p>重点考虑这个情况. 为什么要重点分析? 因为当前棋盘格位置上方的棋盘格即将离开轮廓线, 以后就考虑不到了, 但是题目要求颜色各自是四联通的. 如果直接把她抛弃, 那么就… 人没了. = =</p><p>经过思考可以得出, 在轮廓线上还存在上方棋盘格所对应的连通分量就不需要额外考虑这一点了, 即, 可以直接把这个状态扔掉.</p><p>此时我们在状态中记录黑白两色连通分量个数, 并引入 “钦定选择颜色”. 这样, 转移如下:</p><ul><li><p>如果上方棋盘格颜色所属的连通分量个数 $&gt; 1$, 说明以后没有机会再把这些连通分量连接起来了, 放弃吧</p></li><li><p>如果上方棋盘格颜色所属的连通分量满足题目限制, 那么把剩下的所有格子涂满, 涂成当前棋盘格颜色就好了.</p><p>注意到这样做的条件为, 剩下未填满的行数小于 $2$, 否则直接填满无法满足限制 1.</p></li></ul></li></ol><p>现在再来考虑如何记录联通分量的编号. 常用的方法有: 最小表示法, 以及广义括号法. 这里只考虑最小表示法, 虽然另一种方法更快一点…</p><p>所谓 “最小表示法”, 就是用字典序最小的方法把所有连通分量重标号, 然后没了. 注意每次都要把状态这样整理一下.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>参考了刘汝佳先生的实现…</p><p>毕竟很少有那样清晰的代码和完整的注释了. = =</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UVA-10572</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ch[] = &#123; <span class="string">'o'</span>, <span class="string">'#'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, exist;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">unsigned</span>, <span class="keyword">int</span>&gt; f[MAXN][MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> G[MAXN][MAXN+<span class="number">1</span>], Ans[MAXN][MAXN], Now[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> c[MAXN], g[MAXN], cnt[<span class="number">2</span>], UL, tot;</span><br><span class="line"></span><br><span class="line">    State() &#123; <span class="built_in">memset</span>(<span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">sizeof</span> *<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最小表示法</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Normalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> rep[MAXN + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(rep, <span class="number">-1</span>, <span class="keyword">sizeof</span> rep);</span><br><span class="line">        tot = cnt[<span class="number">0</span>] = cnt[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rep[g[i]] &lt; <span class="number">0</span>) rep[g[i]] = tot++, ++cnt[c[i]];</span><br><span class="line">            g[i] = rep[g[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并: 把 from 对应的连通分量编号改为 to</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> to, <span class="keyword">int</span> from)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (from == to) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) <span class="keyword">if</span> (g[i] == from) g[i] = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码: 最大值 + 1 = 16 ^ m = 2 ^ (4 * 8) = 2 ^ 32, 正好 unsigned int</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="title">encode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) ret = ret * <span class="number">16</span> + c[i] * <span class="number">8</span> + g[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, State&amp; S, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (col == m) ++row, col = <span class="number">0</span>;</span><br><span class="line">    S.Normalize();</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.cnt[<span class="number">0</span>] &gt; <span class="number">1</span> || S.cnt[<span class="number">1</span>] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录方案</span></span><br><span class="line">        <span class="keyword">if</span> (!exist) &#123;</span><br><span class="line">            exist = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) Ans[i][j] = Now[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一个剪枝: 如果左边颜色和上方颜色不同, 那么左上角的颜色就不重要了</span></span><br><span class="line">    <span class="keyword">if</span> (row &gt; <span class="number">0</span> &amp;&amp; col &gt; <span class="number">0</span> &amp;&amp; S.c[col] != S.c[col<span class="number">-1</span>]) S.UL = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> key;</span><br><span class="line">    <span class="comment">// 只在不钦定颜色的情况下记忆化</span></span><br><span class="line">    <span class="keyword">if</span> (limit &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        key = S.encode();</span><br><span class="line">        <span class="keyword">if</span> (f[row][col][S.UL].count(key) &gt; <span class="number">0</span>) <span class="keyword">return</span> f[row][col][S.UL][key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">2</span>; ++t) &#123;</span><br><span class="line">        <span class="comment">// 钦定颜色 / 限制 0</span></span><br><span class="line">        <span class="keyword">if</span> (limit == (t ^ <span class="number">1</span>) || G[row][col] == ch[t ^ <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 限制 1</span></span><br><span class="line">        <span class="keyword">if</span> (row &gt; <span class="number">0</span> &amp;&amp; col &gt; <span class="number">0</span> &amp;&amp; S.UL == t &amp;&amp; S.c[col] == t &amp;&amp; S.c[col<span class="number">-1</span>] == t) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 新的状态 !</span></span><br><span class="line">        State T = S;</span><br><span class="line">        T.c[col] = t, T.UL = S.c[col];</span><br><span class="line">        <span class="comment">// 通过考虑左侧和上方状态, 来合并一些连通分量</span></span><br><span class="line">        T.g[col] = (row &gt; <span class="number">0</span> &amp;&amp; S.c[col] == t)? S.g[col]: S.tot;</span><br><span class="line">        <span class="keyword">if</span> (col &gt; <span class="number">0</span> &amp;&amp; T.c[col<span class="number">-1</span>] == t) T.merge(T.g[col<span class="number">-1</span>], T.g[col]);</span><br><span class="line">        Now[row][col] = ch[t];</span><br><span class="line">        <span class="keyword">if</span> (row &gt; <span class="number">0</span> &amp;&amp; S.c[col] == (t ^ <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">bool</span> none = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; none; ++i)</span><br><span class="line">                <span class="keyword">if</span> (T.g[i] == S.g[col]) none = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (none) &#123;</span><br><span class="line">                <span class="comment">// 注意跳转逻辑: 这些条件满足 / 不满足, 直接向下一颜色进行</span></span><br><span class="line">                <span class="keyword">if</span> (S.cnt[t ^ <span class="number">1</span>] &gt; <span class="number">1</span> || n - row &gt; <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                ret += dfs(row, col + <span class="number">1</span>, T, t);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ret += dfs(row, col + <span class="number">1</span>, T, limit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (limit &lt; <span class="number">0</span>) f[row][col][S.UL][key] = ret;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> Ti;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        exist = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; ++k) f[i][j][k].clear();</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, G[i]);</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        State none; none.Normalize();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dfs(<span class="number">0</span>, <span class="number">0</span>, none, <span class="number">-1</span>));</span><br><span class="line">        <span class="comment">// output</span></span><br><span class="line">        <span class="keyword">if</span> (exist) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i, <span class="built_in">putchar</span>(<span class="string">'\n'</span>))</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) <span class="built_in">putchar</span>(Ans[i][j]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>在 陈丹琦 &lt;基于连通性状态压缩的动态规划问题&gt; 对这一类问题有相当详尽的讲解, 头疼看不懂, 以后再说了 <del>咕咕咕</del></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;最后一步判断最为关键, 也最容易想错… 请读者思考如何区分这两种情况.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://vjudge.net/problem/UVA-10572&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://vjudge.net/problem/UVA-10572&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;由于某些原因, 链接指向的其实是 vjudge&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;毒瘤啊!&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;其实是常规的插头 DP 维护棋盘格联通性的问题, 第一次见感觉很新鲜, 然后… 就自闭了. = =&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Dynamic Programing" scheme="https://depletedprism.github.io/tags/Dynamic-Programing/"/>
    
  </entry>
  
  <entry>
    <title>「JSOI2018」战争 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P4557/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P4557/</id>
    <published>2020-02-20T04:51:21.000Z</published>
    <updated>2020-02-20T06:00:09.784Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P4557" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P4557</a></li></ul><p>这是一道 <del>九条可怜</del> 计算几何题, 在思路上不算困难但是有一些细节值得留念.</p><a id="more"></a><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><ol><li>二维凸包</li><li>闵可夫斯基和</li></ol><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给定两个大小分别为 $n,\ m$ 的点集, $q$ 次询问, 每次给出一个偏移向量 $\vec{v}$, 问将第二个点集的所有点按这个向量偏移后, 是否存在一个点, 在另一点集的凸包内.</p><p>其中 $3 \le n, m \le 10^5,\ q \le 10^5$</p><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>考虑最简单的思路, 每次直接将第二个点集暴力平移, 求凸包, 判断是否存在一个点在另一个凸包内.</p><p>时间复杂度 $O(n \log n + q (m \log m + n m)\,)$, 期望得分 40 pts.</p><p>如果再加一些技巧, 大概是 $O(n \log n + m\log m + q(n\log m + m\log n))\,)$, 期望得分 40 pts, 并没有本质区别…</p><p>换一种思路, 考虑造成冲突的向量范围, 容易得到这样的式子</p><p>$$\exists \ \vec{v},\ \text{s.t.}\ b + \vec{v} = a\ (a \in A, b \in B)$$</p><p>那么就可以得到 $\vec{v}$ 的范围</p><p>$$\vec{v} = a - b\ (a \in A, b \in B)$$</p><p>把 $B$ 中点的横纵坐标取反, 就得到了闵可夫斯基和的形式.</p><p>考虑到两个凸包的闵可夫斯基和中的边都由两个凸包中的边构成, 而凸包上的边具有单调性, 直接以类似于合并两个有序表的方式进行合并就好了, 这样合并出来的闵可夫斯基和也是个凸包.</p><p>如何统计答案呢? 直接判断偏移向量是否在闵可夫斯基和中的时间复杂度是 $O(n)$ 的, 可以拿到 70 pts 的好成绩.<br>考虑把一个凸包转化为一点到其他点的向量的形式, 这样判断一个向量是否在凸包内可以根据凸包的单调性, 通过二分查找解决.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>如果细节明确了, 其实代码不难写…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P4557</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Geo &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line">        LL x, y;</span><br><span class="line">        Vector(LL _x = <span class="number">0</span>, LL _y = <span class="number">0</span>): x(_x), y(_y) &#123; &#125;</span><br><span class="line"></span><br><span class="line">        Vector <span class="keyword">operator</span> + (<span class="keyword">const</span> Vector&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Vector(x + rhs.x, y + rhs.y); &#125;</span><br><span class="line">        Vector <span class="keyword">operator</span> - (<span class="keyword">const</span> Vector&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Vector(x - rhs.x, y - rhs.y); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">typedef</span> Vector Point;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point&amp; A, <span class="keyword">const</span> Point&amp; B) &#123;</span><br><span class="line">        <span class="keyword">return</span> A.x &lt; B.x || (A.x == B.x &amp;&amp; A.y &lt; B.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>== (<span class="keyword">const</span> Point&amp; A, <span class="keyword">const</span> Point&amp; B) &#123; <span class="keyword">return</span> !(A &lt; B) &amp;&amp; !(B &lt; A); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">Dot</span><span class="params">(<span class="keyword">const</span> Vector&amp; A, <span class="keyword">const</span> Vector&amp; B)</span> </span>&#123; <span class="keyword">return</span> A.x * B.x + A.y * B.y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">Cross</span><span class="params">(<span class="keyword">const</span> Vector&amp; A, <span class="keyword">const</span> Vector&amp; B)</span> </span>&#123; <span class="keyword">return</span> A.x * B.y - A.y * B.x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ConvexHull</span><span class="params">(Point* P, <span class="keyword">int</span> n, Point* ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        sort(P, P+n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (m &gt; <span class="number">1</span> &amp;&amp; Cross(ch[m<span class="number">-1</span>] - ch[m<span class="number">-2</span>], P[i] - ch[m<span class="number">-2</span>]) &lt;= <span class="number">0</span>) --m;</span><br><span class="line">            ch[m++] = P[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (m &gt; k &amp;&amp; Cross(ch[m<span class="number">-1</span>] - ch[m<span class="number">-2</span>], P[i] - ch[m<span class="number">-2</span>]) &lt;= <span class="number">0</span>) --m;</span><br><span class="line">            ch[m++] = P[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m - (n &gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Geo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, pidx, K;</span><br><span class="line">Point poly[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">Vector v1[MAXN], v2[MAXN];</span><br><span class="line">Point P1[MAXN], P2[MAXN], ch1[MAXN], ch2[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通俗地说, 凸包上的边, 在右侧的边总是在左侧的边的 "左侧"</span></span><br><span class="line"><span class="comment">// 还要考虑向量的模长, 可能太长就冲出去了...</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Point&amp; A, <span class="keyword">const</span> Point&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Cross(A, B) &gt; <span class="number">0</span> || (Cross(A, B) == <span class="number">0</span> &amp;&amp; Dot(A, A) &lt; Dot(B, B));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">inPoly</span><span class="params">(<span class="keyword">const</span> Vector&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Cross(v, poly[<span class="number">0</span>]) &gt; <span class="number">0</span> || Cross(v, poly[pidx<span class="number">-1</span>]) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = lower_bound(poly, poly+pidx, v, cmp) - poly - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Cross(v - poly[pos], poly[(pos+<span class="number">1</span>)%pidx] - poly[pos]) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="comment">// freopen("input.in", "r", stdin);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m), read(K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x, y, i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        read(x), read(y), P1[i] = Point(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x, y, i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        read(x), read(y), P2[i] = Point(-x, -y);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    n = ConvexHull(P1, n, ch1);</span><br><span class="line">    m = ConvexHull(P2, m, ch2);</span><br><span class="line">    <span class="comment">// 将凸包的点集转化为边集, 以向量的形式体现</span></span><br><span class="line">    ch1[n] = ch1[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) v1[i] = ch1[i+<span class="number">1</span>] - ch1[i];</span><br><span class="line">    ch2[m] = ch2[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) v2[i] = ch2[i+<span class="number">1</span>] - ch2[i];</span><br><span class="line">    <span class="comment">// Minkowski Sum</span></span><br><span class="line">    <span class="comment">// 合并两个凸包, 由于凸包单调性, 类似于合并两个有序表</span></span><br><span class="line">    poly[pidx++] = ch1[<span class="number">0</span>] + ch2[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; n &amp;&amp; q &lt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Cross(v1[p], v2[q]) &gt;= <span class="number">0</span>)</span><br><span class="line">            poly[pidx] = poly[pidx<span class="number">-1</span>] + v1[p++], ++pidx;</span><br><span class="line">        <span class="keyword">else</span> poly[pidx] = poly[pidx<span class="number">-1</span>] + v2[q++], ++pidx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; n) poly[pidx] = poly[pidx<span class="number">-1</span>] + v1[p++], ++pidx;</span><br><span class="line">    <span class="keyword">while</span> (q &lt; m) poly[pidx] = poly[pidx<span class="number">-1</span>] + v2[q++], ++pidx;</span><br><span class="line">    <span class="keyword">while</span> (pidx &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">        Cross(poly[pidx<span class="number">-1</span>] - poly[pidx<span class="number">-2</span>], poly[<span class="number">0</span>] - poly[pidx<span class="number">-2</span>]) &lt;= <span class="number">0</span>) --pidx;</span><br><span class="line">    <span class="comment">// 将闵可夫斯基和的点集转化为由一点指向其他点的向量</span></span><br><span class="line">    Point o = poly[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pidx; ++i) poly[i] = poly[i] - o;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (K--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x, y;</span><br><span class="line">        read(x), read(y), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, inPoly(Vector(x, y) - o));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://www.luogu.com.cn/problem/P4557&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.com.cn/problem/P4557&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是一道 &lt;del&gt;九条可怜&lt;/del&gt; 计算几何题, 在思路上不算困难但是有一些细节值得留念.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Geometry" scheme="https://depletedprism.github.io/tags/Geometry/"/>
    
  </entry>
  
  <entry>
    <title>一些简单的偏序维护问题</title>
    <link href="https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/simple-partial-order/"/>
    <id>https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/simple-partial-order/</id>
    <published>2020-02-14T15:15:28.000Z</published>
    <updated>2020-02-21T16:47:08.721Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>拜读了毒瘤的数据结构课件, 深受启发, <del>甚是谔谔, 当即感觉自己之前一直在玩泥巴</del>.</p><p>初学数据结构, 恳请指正.</p><a id="more"></a><h3 id="什么是偏序"><a href="#什么是偏序" class="headerlink" title="什么是偏序"></a>什么是偏序</h3><p><em>其实这一点也不重要</em></p><p>对于一个非空集上的二元关系, 如果其满足<strong>自反性</strong>, <strong>反对称性</strong>, <strong>传递性</strong>, 那么称这个二元关系就是这个集合上的偏序.</p><p>一个简单的例子: 实数集上的小于等于关系是一个偏序关系.</p><h3 id="偏序维护"><a href="#偏序维护" class="headerlink" title="偏序维护"></a>偏序维护</h3><p>现在我们有一个具有很多属性的元素, 比如有 $a_i, b_i, c_i, \ldots$</p><p>接下来对每个属性给出一些限制, 对满足这些限制的元素进行一些操作, 像 $L_1 \leq a_i \leq R_1, L_2 \leq b_i \leq R_2, L_3 \leq c_i \leq R_3, \ldots$</p><p>这就是在维护偏序了, 有时候也把 “属性” 称作 “维度”.</p><h2 id="一些维护方法-amp-例题"><a href="#一些维护方法-amp-例题" class="headerlink" title="一些维护方法 &amp; 例题"></a>一些维护方法 &amp; 例题</h2><blockquote><p>反正我之前是先推出一个 poly log 的数据结构做法</p><p>然后想办法去 log，到一个可以接受的复杂度</p><p>from lxl 某次洛谷网课</p></blockquote><h3 id="CDQ-分治"><a href="#CDQ-分治" class="headerlink" title="CDQ 分治"></a>CDQ 分治</h3><p>强烈推荐 <a href="https://www.cnblogs.com/mlystdcall/p/6219421.html" target="_blank" rel="noopener">__stdcall 的 CDQ 分治教程</a>.</p><p>简单来说, CDQ 分治做了这样一件事情: 把操作离线下来, 分成两部分, 递归解决; 考虑把这两部分合并, 就要考虑左半部分操作对右半部分的影响, 然后合并.</p><h4 id="Luogu-P3810【模板】三维偏序"><a href="#Luogu-P3810【模板】三维偏序" class="headerlink" title="Luogu P3810【模板】三维偏序"></a>Luogu P3810【模板】三维偏序</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P3810" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3810</a></li></ul><p>是一道经典题, 考虑 CDQ 分治, 先将第一维排序, CDQ 分治过程中按第二维排序, 使用树状数组统计第三维答案.</p><p>有一个细节: 可能存在相同元素, 按题意来讲这些完全相同的元素互相有贡献, 但是在 CDQ 分治的过程中只能统计左半部分对右半部分的贡献, 所以需要去重, 对重复不同次数的元素给定一个不同的权值.</p><p>时间复杂度: $O (n\log n \log k)$</p><p><strong>代码实现</strong></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3810</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">5</span>, MAXM = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> idx, a, b, c, w;</span><br><span class="line">    Item(<span class="keyword">int</span> _i = <span class="number">0</span>, <span class="keyword">int</span> _a = <span class="number">0</span>, <span class="keyword">int</span> _b = <span class="number">0</span>, <span class="keyword">int</span> _c = <span class="number">0</span>, <span class="keyword">int</span> _w = <span class="number">0</span>):</span><br><span class="line">        idx(_i), a(_a), b(_b), c(_c), w(_w) &#123; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (a == rhs.a)? ((b == rhs.b)? c &lt; rhs.c: b &lt; rhs.b): a &lt; rhs.a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>== (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; rhs) &amp;&amp; !(rhs &lt; *<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; A[MAXN], tmp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, nA, K;</span><br><span class="line"><span class="keyword">int</span> Ans[MAXN], f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">    <span class="keyword">int</span> C[MAXM];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; pos, <span class="keyword">const</span> <span class="keyword">int</span>&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= K; i += lowbit(i)) C[i] += d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i; i -= lowbit(i)) ret += C[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, p = L, q = Mid+<span class="number">1</span>;</span><br><span class="line">    CDQ(L, Mid), CDQ(Mid+<span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">        <span class="comment">// 在右半部分排满时移动左半部分</span></span><br><span class="line">        <span class="keyword">if</span> ((p &lt;= Mid &amp;&amp; A[p].b &lt;= A[q].b) || q &gt; R)</span><br><span class="line">            BIT::Mdy(A[p].c, A[p].w), tmp[i] = A[p++];</span><br><span class="line">        <span class="keyword">else</span> Ans[A[q].idx] += BIT::Qry(A[q].c), tmp[i] = A[q++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空树状数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= Mid; ++i) BIT::Mdy(A[i].c, -A[i].w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) A[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a, b, c, i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        read(a), read(b), read(c), A[i] = Item(i, a, b, c, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    sort(A+<span class="number">1</span>, A+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; A[i] == A[j+<span class="number">1</span>]) ++j;</span><br><span class="line">        A[++nA] = A[i], A[nA].w = j - i + <span class="number">1</span>;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    CDQ(<span class="number">1</span>, nA);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nA; ++i) f[Ans[A[i].idx] + A[i].w] += A[i].w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h4 id="Luogu-P3374【模板】树状数组-1"><a href="#Luogu-P3374【模板】树状数组-1" class="headerlink" title="Luogu P3374【模板】树状数组 1"></a>Luogu P3374【模板】树状数组 1</h4><blockquote><p>CDQ 分治可以顶替复杂的高级数据结构.</p></blockquote><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P3374" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3374</a></li></ul><p>我们可以把初始值看作在 $0$ 的基础上单点修改, 把查询看作两次询问前缀和, 这样每个操作有时间, 对应操作位置, 权值三个属性.</p><p>时间这一维按给定顺序有序, CDQ 分治过程中按操作位置维护权值和即可, 注意在操作位置相同时, 按照先修改后查询的顺序统计.</p><p><strong>代码实现</strong></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3374</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc(); </span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> opt, pos; LL val;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Ask&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pos &lt; rhs.pos || (pos == rhs.pos &amp;&amp; opt &lt; rhs.opt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Q[MAXN * <span class="number">3</span>], tmp[MAXN * <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, qidx, aidx;</span><br><span class="line">LL A[MAXN], Ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    CDQ(L, Mid), CDQ(Mid+<span class="number">1</span>, R);</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p = L, q = Mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((p &lt;= Mid &amp;&amp; Q[p] &lt; Q[q]) || q &gt; R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Q[p].opt == <span class="number">1</span>) sum += Q[p].val;</span><br><span class="line">        tmp[i] = Q[p++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Q[q].opt == <span class="number">2</span>) Ans[Q[q].val] -= sum;</span><br><span class="line">        <span class="keyword">if</span> (Q[q].opt == <span class="number">3</span>) Ans[Q[q].val] += sum;</span><br><span class="line">        tmp[i] = Q[q++];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) Q[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        read(A[i]);</span><br><span class="line">        Q[++qidx] = (Ask)&#123; <span class="number">1</span>, i, A[i] &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt, L, R; LL val;</span><br><span class="line">        read(opt); read(L);</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                read(val);</span><br><span class="line">                Q[++qidx] = (Ask)&#123; opt, L, val &#125;;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                read(R);</span><br><span class="line">                Q[++qidx] = (Ask)&#123; opt, L<span class="number">-1</span>, ++aidx &#125;;</span><br><span class="line">                Q[++qidx] = (Ask)&#123; opt+<span class="number">1</span>, R, aidx &#125;;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="built_in">puts</span>(<span class="string">"ERROR"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CDQ(<span class="number">1</span>, qidx);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= aidx; ++i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h4 id="HDU-5126-stars"><a href="#HDU-5126-stars" class="headerlink" title="HDU 5126 stars"></a>HDU 5126 stars</h4><ul><li>题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5126" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=5126</a></li></ul><p>对于四维的情况, CDQ 分治可以嵌套使用. <del>但是 CDQ 套 CDQ 套 CDQ… 就和树套树套树… 一样没用, 不如直接写 bitset</del></p><p>这是一个三维数点问题, 因为要考虑操作时间的影响就是四维偏序了, 在此我使用 CDQ 套 CDQ 解决.</p><p>还是参考 <a href="https://www.cnblogs.com/mlystdcall/p/6232324.html" target="_blank" rel="noopener">__stdcall 的 CDQ 套 CDQ 教程</a>, 把第二维按左右两部分重标号, 依此为根据统计答案.</p><p>空间内数点可仿照平面内数点的思路, 统计前缀和按坐标点容斥计算就好了.</p><p>时间复杂度大概是 $O(n \log ^3 n)$</p><p><strong>代码实现</strong></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HDU 5126</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> opt, idx, x, y, z, part;</span><br><span class="line">&#125; Q[MAXN], tmp2d[MAXN], tmp3d[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, qidx, aidx;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN &lt;&lt; <span class="number">1</span>], nB;</span><br><span class="line"><span class="keyword">int</span> Ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">    <span class="keyword">int</span> C[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; pos, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= nB; i += lowbit(i)) C[i] += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i; i -= lowbit(i)) ret += C[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ3d</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, p = L, q = Mid+<span class="number">1</span>;</span><br><span class="line">    CDQ3d(L, Mid), CDQ3d(Mid+<span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p &lt;= Mid &amp;&amp; tmp2d[p].y &lt;= tmp2d[q].y) || q &gt; R) &#123;</span><br><span class="line">            <span class="comment">// 只考虑两次归并都排布在左半部分的元素的贡献</span></span><br><span class="line">            <span class="keyword">if</span> (tmp2d[p].opt == <span class="number">0</span> &amp;&amp; tmp2d[p].part == <span class="number">0</span>)</span><br><span class="line">                BIT::Mdy(tmp2d[p].z, <span class="number">1</span>);</span><br><span class="line">            tmp3d[i] = tmp2d[p++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 只统计两次归并都排布在右半部分的元素的答案</span></span><br><span class="line">            <span class="keyword">if</span> (tmp2d[q].opt != <span class="number">0</span> &amp;&amp; tmp2d[q].part == <span class="number">1</span>)</span><br><span class="line">                Ans[tmp2d[q].idx] += tmp2d[q].opt * BIT::Qry(tmp2d[q].z);</span><br><span class="line">            tmp3d[i] = tmp2d[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= Mid; ++i)</span><br><span class="line">        <span class="keyword">if</span> (tmp2d[i].opt == <span class="number">0</span> &amp;&amp; tmp2d[i].part == <span class="number">0</span>)</span><br><span class="line">            BIT::Mdy(tmp2d[i].z, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) tmp2d[i] = tmp3d[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ2d</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, p = L, q = Mid+<span class="number">1</span>;</span><br><span class="line">    CDQ2d(L, Mid), CDQ2d(Mid+<span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">        <span class="comment">// 重标号: 左半部分标为 0, 右半部分标为 1</span></span><br><span class="line">        <span class="keyword">if</span> ((p &lt;= Mid &amp;&amp; Q[p].x &lt;= Q[q].x) || q &gt; R) &#123;</span><br><span class="line">            Q[p].part = <span class="number">0</span>;</span><br><span class="line">            tmp2d[i] = Q[p++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Q[q].part = <span class="number">1</span>;</span><br><span class="line">            tmp2d[i] = Q[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) Q[i] = tmp2d[i];</span><br><span class="line">    CDQ3d(L, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> Ti; read(Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        qidx = nB = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        read(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> opt, x1, y1, z1, x2, y2, z2;</span><br><span class="line">            read(opt), read(x1), read(y1), read(z1);</span><br><span class="line">            <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    Q[++qidx] = (Ask)&#123; <span class="number">0</span>, i, x1, y1, z1, <span class="number">0</span> &#125;;</span><br><span class="line">                    Ans[i] = <span class="number">-1</span>, B[++nB] = z1;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    read(x2), read(y2), read(z2);</span><br><span class="line">                    --x1, --y1, --z1;</span><br><span class="line">                    <span class="comment">// 容斥</span></span><br><span class="line">                    Q[++qidx] = (Ask)&#123; <span class="number">1</span>, i, x2, y2, z2, <span class="number">0</span> &#125;;</span><br><span class="line">                    Q[++qidx] = (Ask)&#123;<span class="number">-1</span>, i, x1, y1, z1, <span class="number">0</span> &#125;;</span><br><span class="line">                    Q[++qidx] = (Ask)&#123;<span class="number">-1</span>, i, x1, y2, z2, <span class="number">0</span> &#125;;</span><br><span class="line">                    Q[++qidx] = (Ask)&#123;<span class="number">-1</span>, i, x2, y1, z2, <span class="number">0</span> &#125;;</span><br><span class="line">                    Q[++qidx] = (Ask)&#123;<span class="number">-1</span>, i, x2, y2, z1, <span class="number">0</span> &#125;;</span><br><span class="line">                    Q[++qidx] = (Ask)&#123; <span class="number">1</span>, i, x2, y1, z1, <span class="number">0</span> &#125;;</span><br><span class="line">                    Q[++qidx] = (Ask)&#123; <span class="number">1</span>, i, x1, y2, z1, <span class="number">0</span> &#125;;</span><br><span class="line">                    Q[++qidx] = (Ask)&#123; <span class="number">1</span>, i, x1, y1, z2, <span class="number">0</span> &#125;;</span><br><span class="line">                    Ans[i] = <span class="number">0</span>, B[++nB] = z1, B[++nB] = z2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERR\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// solve</span></span><br><span class="line">        sort(B+<span class="number">1</span>, B+<span class="number">1</span>+nB);</span><br><span class="line">        nB = unique(B+<span class="number">1</span>, B+<span class="number">1</span>+nB) - B - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 这一维要丢到 BIT 里, 于是离散化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qidx; ++i)</span><br><span class="line">            Q[i].z = lower_bound(B+<span class="number">1</span>, B+<span class="number">1</span>+nB, Q[i].z) - B;</span><br><span class="line">        CDQ2d(<span class="number">1</span>, qidx);</span><br><span class="line">        <span class="comment">// output</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (~Ans[i]) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="整体二分"><a href="#整体二分" class="headerlink" title="整体二分"></a>整体二分</h3><p>对于一个询问, 例如区间第 K 小, 有一个朴素的想法: 每次二分答案的值域, 看当前二分值是否恰好在区间的排名为 K.</p><p>这样看起来很慢, 于是可以将所有操作视为一个整体进行二分, 每次给定一个答案区间和一个操作区间, 这就是整体二分了.</p><h4 id="Luogu-P3834【模板】可持久化线段树-1（主席树）"><a href="#Luogu-P3834【模板】可持久化线段树-1（主席树）" class="headerlink" title="Luogu P3834【模板】可持久化线段树 1（主席树）"></a>Luogu P3834【模板】可持久化线段树 1（主席树）</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P3834" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3834</a></li></ul><p>可持久化线段树 $\times$ 静态区间第 k 小 $\checkmark$</p><p>算是整体二分的经典问题了. 直接使用之前说过的思路, 整体二分即可.</p><p>具体地说, 对于原序列上的数, 按当前二分的值域进行划分; 而对于操作, 则统计当前操作对应区间内数的个数, 以当前操作第 k 小为依据进行划分.</p><p><strong>代码实现</strong></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3834</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> opt, idx, L, R, k;</span><br><span class="line">&#125; Q[MAXN &lt;&lt; <span class="number">1</span>], tmpL[MAXN &lt;&lt; <span class="number">1</span>], tmpR[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, qidx;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN], nB;</span><br><span class="line"><span class="keyword">int</span> Ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">    <span class="keyword">int</span> C[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; pos, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= n; i += lowbit(i)) C[i] += val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i; i -= lowbit(i)) ret += C[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R)</span> </span>&#123; <span class="keyword">return</span> Qry(R) - Qry(L<span class="number">-1</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opL &gt; opR) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = opL; i &lt;= opR; ++i)</span><br><span class="line">            <span class="keyword">if</span> (Q[i].opt == <span class="number">1</span>) Ans[Q[i].idx] = L;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, p = <span class="number">0</span>, q = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = opL; i &lt;= opR; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Q[i].opt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Q[i].R &lt;= Mid)</span><br><span class="line">                BIT::Mdy(Q[i].L, Q[i].k), tmpL[++p] = Q[i];</span><br><span class="line">            <span class="keyword">else</span> tmpR[++q] = Q[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> w = BIT::Qry(Q[i].L, Q[i].R);</span><br><span class="line">            <span class="keyword">if</span> (Q[i].k &lt;= w) tmpL[++p] = Q[i];</span><br><span class="line">            <span class="keyword">else</span> Q[i].k -= w, tmpR[++q] = Q[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; ++i)</span><br><span class="line">        <span class="keyword">if</span> (tmpL[i].opt == <span class="number">0</span>) BIT::Mdy(tmpL[i].L, -tmpL[i].k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) Q[opL+i<span class="number">-1</span>] = tmpL[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) Q[opL+p+i<span class="number">-1</span>] = tmpR[i];</span><br><span class="line">    divide(L, Mid, opL, opL + p - <span class="number">1</span>), divide(Mid+<span class="number">1</span>, R, opL + p, opR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]), B[++nB] = A[i];</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    sort(B+<span class="number">1</span>, B+<span class="number">1</span>+nB);</span><br><span class="line">    nB = unique(B+<span class="number">1</span>, B+<span class="number">1</span>+nB) - B - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        A[i] = lower_bound(B+<span class="number">1</span>, B+<span class="number">1</span>+nB, A[i]) - B;</span><br><span class="line">        Q[++qidx] = (Ask)&#123; <span class="number">0</span>, <span class="number">-1</span>, i, A[i], <span class="number">1</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> L, R, k;</span><br><span class="line">        read(L), read(R), read(k);</span><br><span class="line">        Q[++qidx] = (Ask)&#123; <span class="number">1</span>, i, L, R, k &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    divide(<span class="number">1</span>, nB, <span class="number">1</span>, qidx);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, B[Ans[i]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h4 id="Luogu-P3242-HNOI2015-接水果"><a href="#Luogu-P3242-HNOI2015-接水果" class="headerlink" title="Luogu P3242 [HNOI2015] 接水果"></a>Luogu P3242 [HNOI2015] 接水果</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P3242" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3242</a></li></ul><p>通过对路径两端点的 dfs 序的讨论, 路径之间的相互包含可以看作是在二维矩阵中数点, 放在这道题中就是二维矩阵中查询第 k 小了.</p><p><del>这东西可以写可持久化树套树, 我…</del></p><p>我当然是把矩阵拆成扫描线, 然后整体二分进行统计.</p><p><strong>代码实现</strong></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3242</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">4e4</span>+<span class="number">5</span>, MAXM = <span class="number">5</span> * MAXN;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> opt, idx, u, L, R, k, val;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Ask&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> u &lt; rhs.u || (u == rhs.u &amp;&amp; opt &lt; rhs.opt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Q[MAXM], tmpL[MAXM], tmpR[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, qc, qidx;</span><br><span class="line"><span class="keyword">int</span> st[MAXN], ed[MAXN];</span><br><span class="line"><span class="keyword">int</span> Ans[MAXN], B[MAXN], nB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HLD &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">int</span> size[MAXN], depth[MAXN], pre[MAXN], son[MAXN];</span><br><span class="line">    <span class="keyword">int</span> topfa[MAXN], dfs_clock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">        pre[u] = fa, size[u] = <span class="number">1</span>, son[u] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) == fa) <span class="keyword">continue</span>;</span><br><span class="line">            dfs1(v, u), size[u] += size[v];</span><br><span class="line">            <span class="keyword">if</span> (son[u] == <span class="number">-1</span> || size[v] &gt; size[son[u]]) son[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">        topfa[u] = top, st[u] = ++dfs_clock;</span><br><span class="line">        <span class="keyword">if</span> (~son[u]) dfs2(son[u], top);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) != pre[u] &amp;&amp; v != son[u]) dfs2(v, v);</span><br><span class="line">        ed[u] = dfs_clock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (topfa[u] != topfa[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth[topfa[u]] &lt; depth[topfa[v]]) swap(u, v);</span><br><span class="line">            u = pre[topfa[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth[u] &gt; depth[v]? v: u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findson</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (topfa[u] != topfa[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[topfa[u]] == v) <span class="keyword">return</span> topfa[u];</span><br><span class="line">            u = pre[topfa[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> son[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>)</span> </span>&#123; dfs1(root, <span class="number">0</span>), dfs2(root, root); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">    <span class="keyword">int</span> C[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; pos, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= n; i += lowbit(i)) C[i] += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        Mdy(L, val), Mdy(R+<span class="number">1</span>, -val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i; i -= lowbit(i)) ret += C[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opL &gt; opR) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = opL; i &lt;= opR; ++i)</span><br><span class="line">            <span class="keyword">if</span> (Q[i].opt == <span class="number">1</span>) Ans[Q[i].idx] = B[L];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, p = <span class="number">0</span>, q = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = opL; i &lt;= opR; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Q[i].opt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Q[i].k &lt;= Mid)</span><br><span class="line">                BIT::Mdy(Q[i].L, Q[i].R, Q[i].val), tmpL[++p] = Q[i];</span><br><span class="line">            <span class="keyword">else</span> tmpR[++q] = Q[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> w = BIT::Qry(Q[i].L);</span><br><span class="line">            <span class="keyword">if</span> (Q[i].k &lt;= w) tmpL[++p] = Q[i];</span><br><span class="line">            <span class="keyword">else</span> Q[i].k -= w, tmpR[++q] = Q[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; ++i)</span><br><span class="line">        <span class="keyword">if</span> (tmpL[i].opt == <span class="number">0</span>) BIT::Mdy(tmpL[i].L, tmpL[i].R, -tmpL[i].val);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) Q[opL + i - <span class="number">1</span>] = tmpL[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) Q[opL + p + i - <span class="number">1</span>] = tmpR[i];</span><br><span class="line">    divide(L, Mid, opL, opL + p - <span class="number">1</span>), divide(Mid+<span class="number">1</span>, R, opL + p, opR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m), read(qc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        read(u), read(v), Graph::AddEdge(u, v), Graph::AddEdge(v, u);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    HLD::solve();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, w, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        read(u), read(v), read(w);</span><br><span class="line">        <span class="keyword">if</span> (st[u] &gt; st[v]) swap(u, v);</span><br><span class="line">        B[++nB] = w;</span><br><span class="line">        <span class="keyword">if</span> (HLD::LCA(u, v) == u) &#123;</span><br><span class="line">            <span class="keyword">int</span> z = HLD::findson(v, u);</span><br><span class="line">            <span class="keyword">if</span> (st[z] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                Q[++qidx] = (Ask)&#123; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, st[v], ed[v], w, <span class="number">1</span> &#125;;</span><br><span class="line">                Q[++qidx] = (Ask)&#123; <span class="number">0</span>, <span class="number">-1</span>, st[z], st[v], ed[v], w, <span class="number">-1</span> &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ed[z] &lt; n) &#123;</span><br><span class="line">                Q[++qidx] = (Ask)&#123; <span class="number">0</span>, <span class="number">-1</span>, st[v], ed[z]+<span class="number">1</span>, n, w, <span class="number">1</span> &#125;;</span><br><span class="line">                Q[++qidx] = (Ask)&#123; <span class="number">0</span>, <span class="number">-1</span>, ed[v]+<span class="number">1</span>, ed[z]+<span class="number">1</span>, n, w, <span class="number">-1</span> &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Q[++qidx] = (Ask)&#123; <span class="number">0</span>, <span class="number">-1</span>, st[u], st[v], ed[v], w, <span class="number">1</span> &#125;;</span><br><span class="line">            Q[++qidx] = (Ask)&#123; <span class="number">0</span>, <span class="number">-1</span>, ed[u]+<span class="number">1</span>, st[v], ed[v], w, <span class="number">-1</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(B+<span class="number">1</span>, B+<span class="number">1</span>+nB);</span><br><span class="line">    nB = unique(B+<span class="number">1</span>, B+<span class="number">1</span>+nB) - B - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qidx; ++i)</span><br><span class="line">        Q[i].k = lower_bound(B+<span class="number">1</span>, B+<span class="number">1</span>+nB, Q[i].k) - B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, k, i = <span class="number">1</span>; i &lt;= qc; ++i) &#123;</span><br><span class="line">        read(u), read(v), read(k);</span><br><span class="line">        <span class="keyword">if</span> (st[u] &gt; st[v]) swap(u, v);</span><br><span class="line">        Q[++qidx] = (Ask)&#123; <span class="number">1</span>, i, st[u], st[v], <span class="number">-1</span>, k, <span class="number">0</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(Q+<span class="number">1</span>, Q+<span class="number">1</span>+qidx);</span><br><span class="line">    divide(<span class="number">1</span>, nB, <span class="number">1</span>, qidx);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qc; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>遇到毒瘤出题人强制在线就挂了 = =, 所以还需要一些在线解决问题的科技.</p><h3 id="可持久化"><a href="#可持久化" class="headerlink" title="可持久化"></a>可持久化</h3><p>刚开始学可持久化的时候感觉这个好高级啊, 后来感觉…</p><p>这不就是个数据结构的前缀和吗 = =</p><h4 id="Luogu-P3834【模板】可持久化线段树-1（主席树）-1"><a href="#Luogu-P3834【模板】可持久化线段树-1（主席树）-1" class="headerlink" title="Luogu P3834【模板】可持久化线段树 1（主席树）"></a>Luogu P3834【模板】可持久化线段树 1（主席树）</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P3834" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3834</a></li></ul><p>建权值线段树, 动态开点.</p><p>按照初始序列建可持久化线段树, 每个位置对应的线段树, 就是包含这个位置前缀信息的线段树了.</p><p>具体地说, 先建出一个空树, 然后对于每个位置, 在上一个位置的基础上拓展, 尽量利用之前以及储存过的信息, 再建出一颗新树. 这样每次新增的节点数为 $O(\log n)$, 总共建出 $n$ 颗线段树, 总空间复杂度为 $O(n \log n + n \log n)$.</p><p>这样对于每个询问 $[L,\ R]$, 按照前缀和的基本思想, 在 $L-1,\ R$ 两颗树上进行二分就好了, 即记录当前二分到的两颗树的左子树 size 之差 (因为是求第 $k$ 小), 然后分类讨论移动到左子树还是右子树.</p><p>时间复杂度: $O(n \log n)$</p><p><strong>代码实现</strong></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3834</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, nB;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN], rt[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> <span class="keyword">int</span> lc, rc, sum; &#125; dat[MAXN &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> nidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span>&amp; nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        nd = ++nidx;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        build(dat[nd].lc, L, Mid), build(dat[nd].rc, Mid+<span class="number">1</span>, R);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nxt = ++nidx;</span><br><span class="line">        dat[nxt] = dat[nd], ++dat[nxt].sum;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> nxt;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (val &lt;= Mid) dat[nxt].lc = Mdy(dat[nxt].lc, L, Mid, val);</span><br><span class="line">        <span class="keyword">else</span> dat[nxt].rc = Mdy(dat[nxt].rc, Mid+<span class="number">1</span>, R, val);</span><br><span class="line">        <span class="keyword">return</span> nxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> L;</span><br><span class="line">        <span class="keyword">int</span> d = dat[dat[y].lc].sum - dat[dat[x].lc].sum, Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= d) <span class="keyword">return</span> Qry(dat[x].lc, dat[y].lc, L, Mid, k);</span><br><span class="line">        <span class="keyword">return</span> Qry(dat[x].rc, dat[y].rc, Mid+<span class="number">1</span>, R, k - d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]), B[i] = A[i];</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    sort(B+<span class="number">1</span>, B+<span class="number">1</span>+n);</span><br><span class="line">    nB = unique(B+<span class="number">1</span>, B+<span class="number">1</span>+n) - B - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) A[i] = lower_bound(B+<span class="number">1</span>, B+<span class="number">1</span>+nB, A[i]) - B;</span><br><span class="line">    SGT::build(rt[<span class="number">0</span>], <span class="number">1</span>, nB);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rt[i] = SGT::Mdy(rt[i<span class="number">-1</span>], <span class="number">1</span>, nB, A[i]);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> L, R, K;</span><br><span class="line">        read(L), read(R), read(K);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, B[SGT::Qry(rt[L<span class="number">-1</span>], rt[R], <span class="number">1</span>, nB, K)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h4 id="Luogu-P3168-CQOI2015-任务查询系统"><a href="#Luogu-P3168-CQOI2015-任务查询系统" class="headerlink" title="Luogu P3168 [CQOI2015] 任务查询系统"></a>Luogu P3168 [CQOI2015] 任务查询系统</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P3168" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3168</a></li></ul><p>刚才是单点修改, 区间求和, 而现在是区间修改, 单点求和, 那么差分即可解决.</p><p><del>尝试了不先建出空树的写法, 感觉还行 ?</del></p><p>对时间建权值线段树, 把每次区间操作差分, 挂在对应的时间点上, 记录最后操作对应的节点为当前时间点的节点, 对于询问直接在对应时间点的树上二分即可.</p><p><strong>代码实现</strong></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3168</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span>+<span class="number">5</span>, MAXV = <span class="number">1e7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> rt[MAXN], pos[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PSGT &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mid ((L + R) / 2)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> <span class="keyword">int</span> lc, rc, size; LL sum; &#125; dat[MAXN &lt;&lt; <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">int</span> nidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Abs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123; <span class="keyword">return</span> v &gt; <span class="number">0</span>? v: -v; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nxt = ++nidx;</span><br><span class="line">        dat[nxt] = dat[nd], dat[nxt].size += (val &lt; <span class="number">0</span>? <span class="number">-1</span>: <span class="number">1</span>), dat[nxt].sum += val;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> nxt;</span><br><span class="line">        <span class="keyword">if</span> (Abs(val) &lt;= Mid) dat[nxt].lc = Mdy(dat[nxt].lc, L, Mid, val);</span><br><span class="line">        <span class="keyword">else</span> dat[nxt].rc = Mdy(dat[nxt].rc, Mid+<span class="number">1</span>, R, val);</span><br><span class="line">        <span class="keyword">return</span> nxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> k * L;</span><br><span class="line">        <span class="keyword">int</span> d = dat[dat[nd].lc].size;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= d) <span class="keyword">return</span> Qry(dat[nd].lc, L, Mid, k);</span><br><span class="line">        <span class="keyword">return</span> Qry(dat[nd].rc, Mid+<span class="number">1</span>, R, k - d) + dat[dat[nd].lc].sum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> Mid</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(m), read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> L, R, val;</span><br><span class="line">        read(L), read(R), read(val);</span><br><span class="line">        A[L].push_back(val), A[R+<span class="number">1</span>].push_back(-val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">int</span> nidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> k = <span class="number">0</span>; k &lt; A[i].size(); ++k)</span><br><span class="line">            ++nidx, rt[nidx] = PSGT::Mdy(rt[nidx<span class="number">-1</span>], <span class="number">1</span>, MAXV, A[i][k]);</span><br><span class="line">        pos[i] = nidx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x, a, b, c, k, nd; <span class="keyword">static</span> LL pre = <span class="number">1</span>;</span><br><span class="line">        read(x), read(a), read(b), read(c);</span><br><span class="line">        k = <span class="number">1</span> + (a * pre + b) % c, nd = pos[x];</span><br><span class="line">        <span class="keyword">if</span> (PSGT::dat[rt[nd]].size &gt; k) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, pre = PSGT::Qry(rt[nd], <span class="number">1</span>, MAXV, k));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, pre = PSGT::dat[rt[nd]].sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="K-D-Tree"><a href="#K-D-Tree" class="headerlink" title="K-D Tree"></a>K-D Tree</h3><p>解决 K 维问题 !</p><p>K-D Tree 类似于二叉搜索树, 建树选择一个维度对当前元素进行分割, 采用合适选择方法和优秀实现, 建树的时间复杂度为 $O(n \log n)$. 详情请 <a href="https://oi-wiki.org/ds/kdt/" target="_blank" rel="noopener">OI Wiki</a>.</p><p>考虑到 K-D Tree 的结构, 插入采用类似替罪羊树的平衡方法, 如果有一个节点某一子树的大小超过限制, 就直接重构这个以这一节点为根的子树.</p><p>查询直接仿照二叉搜索树了, 注意到 K-D Tree 某些情况下可以剪枝, 可以多维护一些信息来排除掉一些子树.</p><p>可以证明, 在 $k$ 维情况下, 单次查询时间复杂度为 $O(n ^ {1 - \frac{1}{k}} + \log n )$.</p><p>不过值得注意的是, 这里的查询是类似于矩阵查询的偏序维护, 来个平面最近点对单次操作还是最劣 $O(n)$.</p><h4 id="Luogu-P4148-简单题"><a href="#Luogu-P4148-简单题" class="headerlink" title="Luogu P4148 简单题"></a>Luogu P4148 简单题</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P4148" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P4148</a></li></ul><p>感觉 K-D Tree 的模板题, 没什么好说的, 把 K-D Tree 的操作汇总就好了.</p><p><del>然而我重构写挂了调了好久…</del></p><p><strong>代码实现</strong></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P4148</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> alpha = <span class="number">0.725</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, nidx, root;</span><br><span class="line"><span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span> <span class="keyword">int</span> x, y, val; &#125; A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> KDT &#123;</span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>][MAXN], d[MAXN], g[MAXN], t;</span><br><span class="line">    <span class="keyword">int</span> size[MAXN], datSum[MAXN], mnL[MAXN], mxR[MAXN], mnD[MAXN], mxU[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123; <span class="keyword">return</span> A[a].x &lt; A[b].x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123; <span class="keyword">return</span> A[a].y &lt; A[b].y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> &amp;lc = ch[<span class="number">0</span>][nd], &amp;rc = ch[<span class="number">1</span>][nd];</span><br><span class="line">        size[nd] = <span class="number">1</span>, datSum[nd] = A[nd].val;</span><br><span class="line">        mnL[nd] = mxR[nd] = A[nd].x, mnD[nd] = mxU[nd] = A[nd].y;</span><br><span class="line">        <span class="keyword">if</span> (lc) &#123;</span><br><span class="line">            size[nd] += size[lc], datSum[nd] += datSum[lc];</span><br><span class="line">            mnL[nd] = min(mnL[nd], mnL[lc]), mxR[nd] = max(mxR[nd], mxR[lc]);</span><br><span class="line">            mnD[nd] = min(mnD[nd], mnD[lc]), mxU[nd] = max(mxU[nd], mxU[lc]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            size[nd] += size[rc], datSum[nd] += datSum[rc];</span><br><span class="line">            mnL[nd] = min(mnL[nd], mnL[rc]), mxR[nd] = max(mxR[nd], mxR[rc]);</span><br><span class="line">            mnD[nd] = min(mnD[nd], mnD[rc]), mxU[nd] = max(mxU[nd], mxU[rc]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> avx = <span class="number">0</span>, avy = <span class="number">0</span>, x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) avx += A[g[i]].x, avy += A[g[i]].y;</span><br><span class="line">        avx /= (R - L + <span class="number">1.0</span>), avy /= (R - L + <span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">            x += (A[g[i]].x - avx) * (A[g[i]].x - avx);</span><br><span class="line">            y += (A[g[i]].y - avy) * (A[g[i]].y - avy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">            nth_element(g+L, g+Mid, g+R+<span class="number">1</span>, cmp1), d[g[Mid]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nth_element(g+L, g+Mid, g+R+<span class="number">1</span>, cmp2), d[g[Mid]] = <span class="number">2</span>;</span><br><span class="line">        ch[<span class="number">0</span>][g[Mid]] = build(L, Mid<span class="number">-1</span>), ch[<span class="number">1</span>][g[Mid]] = build(Mid+<span class="number">1</span>, R);</span><br><span class="line">        <span class="keyword">return</span> maintain(g[Mid]), g[Mid];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nd) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>][nd]) dfs(ch[<span class="number">0</span>][nd]);</span><br><span class="line">        g[++t] = nd;</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">1</span>][nd]) dfs(ch[<span class="number">1</span>][nd]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span>&amp; nd)</span> </span>&#123;</span><br><span class="line">        t = <span class="number">0</span>, dfs(nd), nd = build(<span class="number">1</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">canrb</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> alpha * size[nd] &lt;= max(size[ch[<span class="number">0</span>][nd]], size[ch[<span class="number">1</span>][nd]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span>&amp; nd, <span class="keyword">const</span> <span class="keyword">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nd) &#123; nd = pos, maintain(nd); <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (d[nd] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[pos].x &lt;= A[nd].x) Ins(ch[<span class="number">0</span>][nd], pos);</span><br><span class="line">            <span class="keyword">else</span> Ins(ch[<span class="number">1</span>][nd], pos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[pos].y &lt;= A[nd].y) Ins(ch[<span class="number">0</span>][nd], pos);</span><br><span class="line">            <span class="keyword">else</span> Ins(ch[<span class="number">1</span>][nd], pos);</span><br><span class="line">        &#125;</span><br><span class="line">        maintain(nd);</span><br><span class="line">        <span class="keyword">if</span> (canrb(nd)) rebuild(nd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nd || x1 &gt; mxR[nd] || x2 &lt; mnL[nd] || y1 &gt; mxU[nd] || y2 &lt; mnD[nd])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x1 &lt;= mnL[nd] &amp;&amp; mxR[nd] &lt;= x2 &amp;&amp; y1 &lt;= mnD[nd] &amp;&amp; mxU[nd] &lt;= y2)</span><br><span class="line">            <span class="keyword">return</span> datSum[nd];</span><br><span class="line">        <span class="keyword">if</span> (x1 &lt;= A[nd].x &amp;&amp; A[nd].x &lt;= x2 &amp;&amp; y1 &lt;= A[nd].y &amp;&amp; A[nd].y &lt;= y2)</span><br><span class="line">            <span class="keyword">return</span> Qry(ch[<span class="number">0</span>][nd]) + Qry(ch[<span class="number">1</span>][nd]) + A[nd].val;</span><br><span class="line">        <span class="keyword">return</span> Qry(ch[<span class="number">0</span>][nd]) + Qry(ch[<span class="number">1</span>][nd]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"11.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">int</span> opt, val, lastans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (read(opt), opt != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            read(x1), read(y1), read(val);</span><br><span class="line">            x1 ^= lastans, y1 ^= lastans, val ^= lastans;</span><br><span class="line">            A[++nidx] = (Point)&#123; x1, y1, val &#125;;</span><br><span class="line">            KDT::Ins(root, nidx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">            read(x1), read(y1), read(x2), read(y2);</span><br><span class="line">            x1 ^= lastans, y1 ^= lastans, x2 ^= lastans, y2 ^= lastans;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lastans = KDT::Qry(root));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h4 id="Luogu-P5471-NOI2019-弹跳"><a href="#Luogu-P5471-NOI2019-弹跳" class="headerlink" title="Luogu P5471 [NOI2019] 弹跳"></a>Luogu P5471 [NOI2019] 弹跳</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P5471" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P5471</a></li></ul><p><em>如果直接用 K-D Tree 建图, <del>如果用四分树甚至可以 AC</del>, 可以收获 88 pts 的好成绩</em></p><p><em>卡卡常可以卡过? 为什么不尝试更快的做法呢…</em></p><p>那么怎么做呢? 考虑模拟 Dijkstra 的过程, 把这个 K-D Tree 当成堆使用, 记录子树内最小路径长度 (用于更新答案), 以及最大路径长度 (用于剪枝).</p><p>具体地说, 因为每个点的最短距离只会被更新一次, 所以 K-D Tree 要维护</p><ol><li>当前子树覆盖矩阵范围</li><li>当前节点到起点的最短路, 视作当前点的权值</li><li>子树内最小权值, 用于查找节点及更新答案</li><li>当前节点是否被更新过, 换言之, 在 Dijkstra 维护的点集中是否被删去</li></ol><p>另外有一个剪枝: 维护一个子树内最大权值, 这样在修改值 (也就是一个矩阵内更新最小值) 的时候遇到 “最大值比修改值还要小” 的情况就可以剪枝.</p><p>还有一些细节, 在修改整块矩阵的时候打一个类似于线段树的标记, 以及对于已删除节点值的情况要注意分类讨论.</p><p><strong>代码实现</strong></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P5471</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">7e4</span>+<span class="number">5</span>, MAXM = <span class="number">15e4</span>, MAXD = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x[MAXD], idx;</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">int</span>&amp; i) &#123; <span class="keyword">return</span> x[i]; &#125;</span><br><span class="line">&#125; A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, W, H;</span><br><span class="line"><span class="keyword">int</span> pos[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> KDT &#123;</span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>][MAXN], mn[MAXD][MAXN], mx[MAXD][MAXN];</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXN];</span><br><span class="line">    <span class="keyword">int</span> tag[MAXN], datMin[MAXN], datMax[MAXN], datVal[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; nd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> &amp;lc = ch[<span class="number">0</span>][nd], &amp;rc = ch[<span class="number">1</span>][nd];</span><br><span class="line">        <span class="keyword">if</span> (vis[nd]) &#123;</span><br><span class="line">            datMin[nd] = INF, datMax[nd] = -INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; MAXD; ++d) mn[d][nd] = INF, mx[d][nd] = -INF;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            datMin[nd] = datMax[nd] = datVal[nd];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; MAXD; ++d) mn[d][nd] = mx[d][nd] = A[nd][d];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lc) &#123;</span><br><span class="line">            datMin[nd] = min(datMin[nd], datMin[lc]);</span><br><span class="line">            datMax[nd] = max(datMax[nd], datMax[lc]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; MAXD; ++d) &#123;</span><br><span class="line">                mn[d][nd] = min(mn[d][nd], mn[d][lc]);</span><br><span class="line">                mx[d][nd] = max(mx[d][nd], mx[d][lc]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            datMin[nd] = min(datMin[nd], datMin[rc]);</span><br><span class="line">            datMax[nd] = max(datMax[nd], datMax[rc]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; MAXD; ++d) &#123;</span><br><span class="line">                mn[d][nd] = min(mn[d][nd], mn[d][rc]);</span><br><span class="line">                mx[d][nd] = max(mx[d][nd], mx[d][rc]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushTag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; nd, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (val &gt;= datMax[nd] || val &gt;= tag[nd]) <span class="keyword">return</span>;</span><br><span class="line">        datMax[nd] = tag[nd] = val;</span><br><span class="line">        datMin[nd] = min(datMin[nd], val);</span><br><span class="line">        <span class="keyword">if</span> (!vis[nd]) datVal[nd] = min(datVal[nd], val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nd || tag[nd] == INF) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> &amp;lc = ch[<span class="number">0</span>][nd], &amp;rc = ch[<span class="number">1</span>][nd];</span><br><span class="line">        <span class="keyword">if</span> (lc) pushTag(lc, tag[nd]);</span><br><span class="line">        <span class="keyword">if</span> (rc) pushTag(rc, tag[nd]);</span><br><span class="line">        tag[nd] = INF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp0</span><span class="params">(<span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b)</span> </span>&#123; <span class="keyword">return</span> a.x[<span class="number">0</span>] &lt; b.x[<span class="number">0</span>]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b)</span> </span>&#123; <span class="keyword">return</span> a.x[<span class="number">1</span>] &lt; b.x[<span class="number">1</span>]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> avx = <span class="number">0</span>, avy = <span class="number">0</span>, x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) avx += A[i][<span class="number">0</span>], avy += A[i][<span class="number">1</span>];</span><br><span class="line">        avx /= (R - L + <span class="number">1.0</span>), avy /= (R - L + <span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">            x += (avx - A[i][<span class="number">0</span>]) * (avx - A[i][<span class="number">0</span>]);</span><br><span class="line">            y += (avy - A[i][<span class="number">1</span>]) * (avy - A[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) nth_element(A + L, A + Mid, A + R + <span class="number">1</span>, cmp0);</span><br><span class="line">        <span class="keyword">else</span> nth_element(A + L, A + Mid, A + R + <span class="number">1</span>, cmp1);</span><br><span class="line">        pos[Mid] = A[Mid].idx;</span><br><span class="line">        tag[Mid] = INF, datVal[Mid] = (pos[Mid] == <span class="number">1</span>)? <span class="number">0</span>: INF;</span><br><span class="line">        ch[<span class="number">0</span>][Mid] = build(L, Mid<span class="number">-1</span>), ch[<span class="number">1</span>][Mid] = build(Mid+<span class="number">1</span>, R);</span><br><span class="line">        <span class="keyword">return</span> maintain(Mid), Mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; D, <span class="keyword">const</span> <span class="keyword">int</span>&amp; U)</span> </span>&#123;</span><br><span class="line">        pushdown(nd);</span><br><span class="line">        <span class="keyword">if</span> (datMax[nd] &lt;= val) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (L &gt; mx[<span class="number">0</span>][nd] || R &lt; mn[<span class="number">0</span>][nd] || D &gt; mx[<span class="number">1</span>][nd] || U &lt; mn[<span class="number">1</span>][nd]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= mn[<span class="number">0</span>][nd] &amp;&amp; mx[<span class="number">0</span>][nd] &lt;= R &amp;&amp; D &lt;= mn[<span class="number">1</span>][nd] &amp;&amp; mx[<span class="number">1</span>][nd] &lt;= U)</span><br><span class="line">            <span class="keyword">return</span> pushTag(nd, val);</span><br><span class="line">        <span class="keyword">if</span> (!vis[nd] &amp;&amp; L &lt;= A[nd][<span class="number">0</span>] &amp;&amp; A[nd][<span class="number">0</span>] &lt;= R &amp;&amp; D &lt;= A[nd][<span class="number">1</span>] &amp;&amp; A[nd][<span class="number">1</span>] &lt;= U)</span><br><span class="line">            datVal[nd] = min(datVal[nd], val);</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>][nd]) Mdy(ch[<span class="number">0</span>][nd], val, L, R, D, U);</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">1</span>][nd]) Mdy(ch[<span class="number">1</span>][nd], val, L, R, D, U);</span><br><span class="line">        maintain(nd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        pushdown(nd);</span><br><span class="line">        <span class="keyword">if</span> (!vis[nd] &amp;&amp; datVal[nd] == val) &#123;</span><br><span class="line">            vis[nd] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> maintain(nd), nd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>][nd] &amp;&amp; datMin[ch[<span class="number">0</span>][nd]] == val) &#123;</span><br><span class="line">            <span class="keyword">int</span> ret = Qry(ch[<span class="number">0</span>][nd], val);</span><br><span class="line">            <span class="keyword">return</span> maintain(nd), ret;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ret = Qry(ch[<span class="number">1</span>][nd], val);</span><br><span class="line">            <span class="keyword">return</span> maintain(nd), ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> L, R, D, U, w; &#125;; </span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; G[MAXN];</span><br><span class="line">    <span class="keyword">int</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> D, <span class="keyword">int</span> U, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        G[from].push_back((Edge)&#123; L, R, D, U, w &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = KDT::build(<span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> nd = KDT::Qry(root, KDT::datMin[root]);</span><br><span class="line">            <span class="keyword">int</span> u = pos[nd];</span><br><span class="line">            dist[u] = KDT::datVal[nd];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> k = <span class="number">0</span>; k &lt; G[u].size(); ++k) &#123;</span><br><span class="line">                <span class="keyword">const</span> Edge&amp; e = G[u][k];</span><br><span class="line">                KDT::Mdy(root, dist[u] + e.w, e.L, e.R, e.D, e.U);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dist[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m), read(W), read(H);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        A[i].idx = i, read(A[i][<span class="number">0</span>]), read(A[i][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> p, w, L, R, D, U;</span><br><span class="line">        read(p), read(w), read(L), read(R), read(D), read(U);</span><br><span class="line">        Graph::AddEdge(p, L, R, D, U, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    Graph::Dijkstra();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="树套树"><a href="#树套树" class="headerlink" title="树套树"></a>树套树</h3><p>字面意思, 嵌套数据结构.</p><p>带有巨大常数, 占用大量空间.</p><h4 id="Luogu-P3380【模板】二逼平衡树（树套树）"><a href="#Luogu-P3380【模板】二逼平衡树（树套树）" class="headerlink" title="Luogu P3380【模板】二逼平衡树（树套树）"></a>Luogu P3380【模板】二逼平衡树（树套树）</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P3380" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3380</a></li></ul><p>采用线段树套平衡树的方法, 为了好些一些, 内层平衡树我选择了 无旋 Treap.</p><ol><li><p>$k$ 在区间内的排名</p><p>把区间丢到线段树上处理, 把区间拆分后得到的排名相加即可. 单次操作时间复杂度 $O(\log^2 n)$</p><p>注意一些细节: 数值 $k$ 可能在区间内的贡献可能被计算多次, 所以每次查询内层平衡树时把得到的排名 $-1$, 最后得出答案时再把自己加上.</p></li><li><p>查询区间内排名为 $k$ 的值</p><p>这个问题在普通的平衡树上可以通过二分解决, 但是在多棵平衡树的情况下进行二分好像很困难…</p><p>所以直接采用二分值域的方式, 判断当前二分的值是否在区间内排名为 $k$, 单次操作时间复杂度 $O(\log ^3 n)$.</p><p>(好像在多个 Trie 上二分很可做, 或者用树状数组套 Trie 来维护, 可以做到 $O(\log ^2 n)$, 还没写过, 值得尝试)</p></li><li><p>修改某一位值上的数值</p><p>在线段树上跑一遍单点修改的操作, 沿途把原来的值删除, 再把修改的值加入就好了. 时间复杂度 $O(\log^2 n)$.</p></li><li><p>查询 $k$ 在区间内的前驱</p></li><li><p>查询 $k$ 在区间内的后继</p><p>也是把区间丢到线段树上, 注意把前驱取 $\max$, 后缀取 $\min$. 时间复杂度 $O(\log^2 n)$</p></li></ol><p><strong>代码实现</strong></p><p>只有靠 O2 才勉强续命的样子.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3380</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e4</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Treap &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = ::MAXN &lt;&lt; <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>][MAXN], size[MAXN], rnd[MAXN], val[MAXN], nidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">        size[nd] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>][nd]) size[nd] += size[ch[<span class="number">0</span>][nd]];</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">1</span>][nd]) size[nd] += size[ch[<span class="number">1</span>][nd]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val[++nidx] = v, size[nidx] = <span class="number">1</span>, rnd[nidx] = rand(), nidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nd) <span class="keyword">return</span> <span class="keyword">void</span>( x = y = <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">if</span> (val[nd] &lt;= k) x = nd, split(ch[<span class="number">1</span>][nd], k, ch[<span class="number">1</span>][nd], y);</span><br><span class="line">        <span class="keyword">else</span> y = nd, split(ch[<span class="number">0</span>][nd], k, x, ch[<span class="number">0</span>][nd]);</span><br><span class="line">        maintain(nd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line">        <span class="keyword">if</span> (rnd[x] &lt; rnd[y]) <span class="keyword">return</span> ch[<span class="number">1</span>][x] = merge(ch[<span class="number">1</span>][x], y), maintain(x), x;</span><br><span class="line">        <span class="keyword">return</span> ch[<span class="number">0</span>][y] = merge(x, ch[<span class="number">0</span>][y]), maintain(y), y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>&amp; root, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x, y; x = y = <span class="number">0</span>;</span><br><span class="line">        split(root, v, x, y), root = merge(merge(x, newnode(v)), y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span>&amp; root, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x, y, z; x = y = z = <span class="number">0</span>;</span><br><span class="line">        split(root, v, x, z), split(x, v<span class="number">-1</span>, x, y);</span><br><span class="line">        y = merge(ch[<span class="number">0</span>][y], ch[<span class="number">1</span>][y]), root = merge(merge(x, y), z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Rnk</span><span class="params">(<span class="keyword">int</span>&amp; root, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x, y, ret; x = y = ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> split(root, v<span class="number">-1</span>, x, y), ret = size[x] + <span class="number">1</span>, root = merge(x, y), ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Kth</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (nd) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = ch[<span class="number">0</span>][nd]? size[ch[<span class="number">0</span>][nd]] + <span class="number">1</span>: <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (k == t) <span class="keyword">return</span> nd;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; t) k -= t, nd = ch[<span class="number">1</span>][nd];</span><br><span class="line">            <span class="keyword">else</span> nd = ch[<span class="number">0</span>][nd];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pre</span><span class="params">(<span class="keyword">int</span>&amp; root, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x, y, ret; x = y = ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> split(root, v<span class="number">-1</span>, x, y), ret = x? val[Kth(x, size[x])]: -INT_MAX, root = merge(x, y), ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Suf</span><span class="params">(<span class="keyword">int</span>&amp; root, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x, y, ret; x = y = ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> split(root, v, x, y), ret = y? val[Kth(y, <span class="number">1</span>)]: INT_MAX, root = merge(x, y), ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>][u]) dfs(ch[<span class="number">0</span>][u]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, val[u]);</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">1</span>][u]) dfs(ch[<span class="number">1</span>][u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (nd&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (nd&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mid ((L + R) / 2)</span></span><br><span class="line">    <span class="keyword">int</span> rt[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) Treap::insert(rt[nd], A[i]);</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">        build(lc, L, Mid), build(rc, Mid+<span class="number">1</span>, R);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; pos, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        Treap::remove(rt[nd], A[pos]), Treap::insert(rt[nd], val);</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= Mid) Mdy(lc, L, Mid, pos, val);</span><br><span class="line">        <span class="keyword">else</span> Mdy(rc, Mid+<span class="number">1</span>, R, pos, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Rnk</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> Treap::Rnk(rt[nd], val) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> Rnk(lc, L, Mid, opL, opR, val);</span><br><span class="line">        <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> Rnk(rc, Mid+<span class="number">1</span>, R, opL, opR, val);</span><br><span class="line">        <span class="keyword">return</span> Rnk(lc, L, Mid, opL, opR, val) + Rnk(rc, Mid+<span class="number">1</span>, R, opL, opR, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Kth</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = <span class="number">1e8</span>, ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Rnk(<span class="number">1</span>, <span class="number">1</span>, n, opL, opR, Mid) + <span class="number">1</span> &lt;= k) ret = Mid, L = Mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> R = Mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Pre</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> Treap::Pre(rt[nd], val);</span><br><span class="line">        <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> Pre(lc, L, Mid, opL, opR, val);</span><br><span class="line">        <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> Pre(rc, Mid+<span class="number">1</span>, R, opL, opR, val);</span><br><span class="line">        <span class="keyword">return</span> max(Pre(lc, L, Mid, opL, opR, val), Pre(rc, Mid+<span class="number">1</span>, R, opL, opR, val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Suf</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> Treap::Suf(rt[nd], val);</span><br><span class="line">        <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> Suf(lc, L, Mid, opL, opR, val);</span><br><span class="line">        <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> Suf(rc, Mid+<span class="number">1</span>, R, opL, opR, val);</span><br><span class="line">        <span class="keyword">return</span> min(Suf(lc, L, Mid, opL, opR, val), Suf(rc, Mid+<span class="number">1</span>, R, opL, opR, val));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> Mid</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    srand( time(<span class="literal">nullptr</span>) );</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    SGT::build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> opt, L, R, K;</span><br><span class="line">        read(opt), read(L), read(R); <span class="keyword">if</span> (opt != <span class="number">3</span>) read(K);</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, SGT::Rnk(<span class="number">1</span>, <span class="number">1</span>, n, L, R, K) + <span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, SGT::Kth(L, R, K)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: SGT::Mdy(<span class="number">1</span>, <span class="number">1</span>, n, L, R), A[L] = R; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, SGT::Pre(<span class="number">1</span>, <span class="number">1</span>, n, L, R, K)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, SGT::Suf(<span class="number">1</span>, <span class="number">1</span>, n, L, R, K)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERR\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h4 id="Luogu-P3332-ZJOI2013-K-大数查询"><a href="#Luogu-P3332-ZJOI2013-K-大数查询" class="headerlink" title="Luogu P3332 [ZJOI2013] K 大数查询"></a>Luogu P3332 [ZJOI2013] K 大数查询</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P3332" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3332</a></li></ul><p>大概是权值线段树套普通线段树 ?</p><p><strong>代码实现</strong></p><p>活在 O2 之下.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3332</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e4</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> opt, L, R; LL c;</span><br><span class="line">&#125; Q[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">LL B[MAXN], nB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DSGT &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = ::MAXN * <span class="number">17</span> * <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">int</span> lc[MAXN], rc[MAXN], nidx;</span><br><span class="line">    LL datSum[MAXN], tagAdd[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (max(l1, l2) &gt; min(r1, r2)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> min(r1, r2) - max(l1, l2) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">        datSum[nd] += calc(L, R, opL, opR);</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> <span class="keyword">void</span>( ++tagAdd[nd] );</span><br><span class="line">        <span class="keyword">if</span> (!lc[nd]) lc[nd] = ++nidx;</span><br><span class="line">        <span class="keyword">if</span> (!rc[nd]) rc[nd] = ++nidx;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= Mid) Mdy(lc[nd], L, Mid, opL, opR);</span><br><span class="line">        <span class="keyword">if</span> (opR &gt; Mid) Mdy(rc[nd], Mid+<span class="number">1</span>, R, opL, opR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR, <span class="keyword">const</span> <span class="keyword">int</span>&amp; tag = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> datSum[nd] + tag * (R-L+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= Mid) ret += Qry(lc[nd], L, Mid, opL, opR, tag + tagAdd[nd]);</span><br><span class="line">        <span class="keyword">if</span> (opR &gt; Mid) ret += Qry(rc[nd], Mid+<span class="number">1</span>, R, opL, opR, tag + tagAdd[nd]);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (nd&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (nd&lt;&lt;1|1)</span></span><br><span class="line">    <span class="keyword">int</span> rt[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR, <span class="keyword">const</span> <span class="keyword">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!rt[nd]) rt[nd] = ++DSGT::nidx;</span><br><span class="line">        DSGT::Mdy(rt[nd], <span class="number">1</span>, n, opL, opR);</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= Mid) Mdy(lc, L, Mid, opL, opR, pos);</span><br><span class="line">        <span class="keyword">else</span> Mdy(rc, Mid+<span class="number">1</span>, R, opL, opR, pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Kth</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR, <span class="keyword">const</span> LL&amp; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> L;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        LL d = DSGT::Qry(rt[rc], <span class="number">1</span>, n, opL, opR);</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= d) <span class="keyword">return</span> Kth(rc, Mid+<span class="number">1</span>, R, opL, opR, k);</span><br><span class="line">        <span class="keyword">return</span> Kth(lc, L, Mid, opL, opR, k - d);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> opt, L, R; <span class="keyword">static</span> LL c;</span><br><span class="line">        read(opt), read(L), read(R), read(c);</span><br><span class="line">        Q[i] = (Ask)&#123; opt, L, R, c &#125;;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) B[++nB] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    sort(B+<span class="number">1</span>, B+<span class="number">1</span>+nB);</span><br><span class="line">    nB = unique(B+<span class="number">1</span>, B+<span class="number">1</span>+nB) - B - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">if</span> (Q[i].opt == <span class="number">1</span>) Q[i].c = lower_bound(B+<span class="number">1</span>, B+<span class="number">1</span>+nB, Q[i].c) - B;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> Ask&amp; q = Q[i];</span><br><span class="line">        <span class="keyword">switch</span> (q.opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: SGT::Mdy(<span class="number">1</span>, <span class="number">1</span>, nB, q.L, q.R, q.c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, B[SGT::Kth(<span class="number">1</span>, <span class="number">1</span>, nB, q.L, q.R, q.c)]); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERR\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h4 id="Luogu-P3759-TJOI2017-不勤劳的图书管理员"><a href="#Luogu-P3759-TJOI2017-不勤劳的图书管理员" class="headerlink" title="Luogu P3759 [TJOI2017] 不勤劳的图书管理员"></a>Luogu P3759 [TJOI2017] 不勤劳的图书管理员</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P3759" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3759</a></li></ul><p>带权动态逆序对.</p><p><strong>代码实现</strong></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3759</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e4</span>+<span class="number">5</span>, P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], v[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = ::MAXN * <span class="number">16</span> * <span class="number">16</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> size, sum;</span><br><span class="line">        Node() &#123; size = sum = <span class="number">0</span>; &#125;</span><br><span class="line">        Node(<span class="keyword">int</span> _s, <span class="keyword">int</span> _v): size(_s), sum(_v) &#123; &#125;</span><br><span class="line">        Node <span class="keyword">operator</span> + (<span class="keyword">const</span> Node&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Node((size + rhs.size) % P, (sum + rhs.sum) % P);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; dat[MAXN];</span><br><span class="line">    <span class="keyword">int</span> lc[MAXN], rc[MAXN], nidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; pos, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val, <span class="keyword">const</span> <span class="keyword">int</span>&amp; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nd) nd = ++nidx;</span><br><span class="line">        dat[nd].size = (dat[nd].size + <span class="number">1L</span>L * type) % P;</span><br><span class="line">        dat[nd].sum = (dat[nd].sum + <span class="number">1L</span>L * type * val) % P;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> nd;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= Mid) lc[nd] = Mdy(lc[nd], L, Mid, pos, val, type);</span><br><span class="line">        <span class="keyword">else</span> rc[nd] = Mdy(rc[nd], Mid+<span class="number">1</span>, R, pos, val, type);</span><br><span class="line">        <span class="keyword">return</span> nd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> dat[nd];</span><br><span class="line">        <span class="keyword">if</span> (!nd) <span class="keyword">return</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> Qry(lc[nd], L, Mid, opL, opR);</span><br><span class="line">        <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> Qry(rc[nd], Mid+<span class="number">1</span>, R, opL, opR);</span><br><span class="line">        <span class="keyword">return</span> Qry(lc[nd], L, Mid, opL, opR) + Qry(rc[nd], Mid+<span class="number">1</span>, R, opL, opR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">    <span class="keyword">using</span> SGT::Node;</span><br><span class="line">    <span class="keyword">int</span> rt[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; d1, <span class="keyword">const</span> <span class="keyword">int</span>&amp; d2, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val, <span class="keyword">const</span> <span class="keyword">int</span>&amp; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = d1; i &lt;= n; i += lowbit(i)) &#123;</span><br><span class="line">            rt[i] = SGT::Mdy(rt[i], <span class="number">1</span>, n, d2, val, type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; d1, <span class="keyword">const</span> <span class="keyword">int</span>&amp; d2, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = d1; i; i -= lowbit(i)) &#123;</span><br><span class="line">            Node tmp = SGT::Qry(rt[i], <span class="number">1</span>, n, d2, n);</span><br><span class="line">            ret = (ret + tmp.sum + <span class="number">1L</span>L * val * tmp.size) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i -= lowbit(i)) &#123;</span><br><span class="line">            Node tmp = SGT::Qry(rt[i], <span class="number">1</span>, n, <span class="number">1</span>, d2);</span><br><span class="line">            ret = (ret + tmp.sum + <span class="number">1L</span>L * val * tmp.size) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = d1; i; i -= lowbit(i)) &#123;</span><br><span class="line">            Node tmp = SGT::Qry(rt[i], <span class="number">1</span>, n, <span class="number">1</span>, d2);</span><br><span class="line">            ret = (ret - (tmp.sum + <span class="number">1L</span>L * val * tmp.size) % P + P) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        read(A[i]), read(v[i]);</span><br><span class="line">        ans = (ans + BIT::Qry(i, A[i], v[i])) % P;</span><br><span class="line">        BIT::Mdy(i, A[i], v[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> L, R;</span><br><span class="line">        read(L), read(R);</span><br><span class="line">        <span class="comment">// remove</span></span><br><span class="line">        ans = (ans - BIT::Qry(L, A[L], v[L]) + P) % P;</span><br><span class="line">        BIT::Mdy(L, A[L], v[L], <span class="number">-1</span>);</span><br><span class="line">        ans = (ans - BIT::Qry(R, A[R], v[R]) + P) % P;</span><br><span class="line">        BIT::Mdy(R, A[R], v[R], <span class="number">-1</span>);</span><br><span class="line">        swap(A[L], A[R]), swap(v[L], v[R]);</span><br><span class="line">        <span class="comment">// add</span></span><br><span class="line">        BIT::Mdy(L, A[L], v[L], <span class="number">1</span>);</span><br><span class="line">        ans = (ans + BIT::Qry(L, A[L], v[L])) % P;</span><br><span class="line">        BIT::Mdy(R, A[R], v[R], <span class="number">1</span>);</span><br><span class="line">        ans = (ans + BIT::Qry(R, A[R], v[R])) % P;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>数据结构还是学不明白啊, 真是活该退役.png</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>nzhtl1477, 简单数据结构</li><li>__stdcall, <a href="https://www.cnblogs.com/mlystdcall/p/6219421.html" target="_blank" rel="noopener">简易 CDQ 分治教程 &amp; 学习笔记</a></li><li>Owen_codeisking, <a href="https://www.luogu.com.cn/blog/Owencodeisking/post-xue-xi-bi-ji-cdq-fen-zhi-hu-zheng-ti-er-fen" target="_blank" rel="noopener">[学习笔记] CDQ 分治和整体二分</a></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;拜读了毒瘤的数据结构课件, 深受启发, &lt;del&gt;甚是谔谔, 当即感觉自己之前一直在玩泥巴&lt;/del&gt;.&lt;/p&gt;
&lt;p&gt;初学数据结构, 恳请指正.&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://depletedprism.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Data Structure" scheme="https://depletedprism.github.io/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>「十二省联考 2019」字符串问题 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P5284/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P5284/</id>
    <published>2020-02-04T14:24:45.000Z</published>
    <updated>2020-02-20T06:00:29.853Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>谨以此题纪念自己颓废的, 什么都不会的高一 (bushi</p></blockquote><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P5284" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P5284</a></li></ul><p>SAM 优化建图 + 拓扑排序求最长路.</p><p>写这道题啊, 只是感到自己的高一很可笑吧, 连题意都不大能读清, 正解的算法听都没有听过, 输出样例就弃疗离场.</p><a id="more"></a><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>考虑目标串 $T$ 的构造过程, 可以发现 $A,\ B$ 串可以视为节点, 支配关系和前缀可以看作边, $T$ 就对应图中一条路径, 那么把图建出来跑最长路就好了.</p><p>另外可以发现, 如果图上存在环就说明可以构造出无限长的串 $T$, 输出 <code>-1</code>, 否则这就是个 DAG, 最长路跑拓扑排序就好了.</p><p>进一步考虑建边</p><ol><li><p>$A_{id_i} \rightarrow B$</p><p>支配关系是题目给出的, 直接把 $A,\ B$ 串对应节点连起来就好了.</p></li><li><p>$B_j \rightarrow A_i$, 其中 $B_j$ 为 $A_i$ 的前缀</p><p>这里就有些意思了, <del>如果直接暴力建边就可以拿到 10 pts 的好成绩</del></p><p>考虑前缀, 就是反串的后缀, 我们可以想到对 $S$ 的反串建出 SAM, 把串 $A,\ B$ 放到 SAM 上匹配, 这一步可以套路地用倍增解决. 假设匹配到 SAM 上的节点 $u$, 那么就新建一个节点 $v$ 表示当前匹配串, 点权为匹配串长度, 并把 $v$ 挂在 $u$ 上.</p><p>对于 SAM 上的一个节点 $u$, <del>上面挂这一堆节点表示 A, B 串</del>, 我们将这些节点以点权为第一关键字, 是否为 $B$ 串为第二关键字从小到大排序, 并根据这个顺序依次连边.</p><p>另外还需考虑 SAM 上节点 $u$ 和后缀链接 $\text{lnk}(u)$ 的关系, 对于反串中的前缀, 存在一个前缀是另一前缀的前缀, 那么就是从 $\text{lnk}(u)$ 向 $u$ 连边了. 当然, 由于上一步的连边此处 $\text{lnk}(u)$ 的实际节点稍有不同.</p><p><del>具体实现代码里很清晰, 正确性很显然</del></p></li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>细节不多的题还是好码一点的.<br><del>这就是你抄题解还 WA 了一发的原因了 ?</del> (</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P5284</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span>+<span class="number">5</span>, LOG = <span class="number">20</span>, MAXV = MAXN &lt;&lt; <span class="number">2</span>, MAXE = MAXN * <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, na, nb, uidx;</span><br><span class="line"><span class="keyword">char</span> S[MAXN];</span><br><span class="line"><span class="keyword">bool</span> isA[MAXV];</span><br><span class="line"><span class="keyword">int</span> Aidx[MAXN], Bidx[MAXN], lst[MAXN &lt;&lt; <span class="number">1</span>], pos[MAXN], pre[LOG][MAXN &lt;&lt; <span class="number">1</span>], len[MAXV];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SAM &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = ::MAXN &lt;&lt; <span class="number">1</span>, SIGMA = <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][SIGMA], lnk[MAXN], nidx, last;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        last = nidx = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ch[<span class="number">1</span>], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        len[++nidx] = l, lnk[nidx] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ch[nidx], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[nidx]);</span><br><span class="line">        <span class="keyword">return</span> nidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nd = newnode(len[last] + <span class="number">1</span>), p = last;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !ch[p][val]) ch[p][val] = nd, p = lnk[p];</span><br><span class="line">        <span class="keyword">if</span> (!p) lnk[nd] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> q = ch[p][val];</span><br><span class="line">            <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) lnk[nd] = q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> nxt = newnode(len[p] + <span class="number">1</span>);</span><br><span class="line">                lnk[nxt] = lnk[q];</span><br><span class="line">                <span class="built_in">memcpy</span>(ch[nxt], ch[q], <span class="keyword">sizeof</span> ch[nxt]);</span><br><span class="line">                <span class="keyword">while</span> (p &amp;&amp; ch[p][val] == q) ch[p][val] = nxt, p = lnk[p];</span><br><span class="line">                lnk[q] = lnk[nd] = nxt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last = nd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXE];</span><br><span class="line">    <span class="keyword">int</span> head[MAXV], eidx, in[MAXV];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span> in);</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        ++in[to];</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">Toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> LL f[MAXV];</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= uidx; ++i) &#123;</span><br><span class="line">            f[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!in[i]) Q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        LL ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            ans = max(ans, f[u] + len[u]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = edges[i].to;</span><br><span class="line">                f[v] = max(f[v], f[u] + len[u]);</span><br><span class="line">                <span class="keyword">if</span> (!(--in[v])) Q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= uidx; ++i)</span><br><span class="line">            <span class="keyword">if</span> (in[i]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> Ti;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        SAM::init(), Graph::init();</span><br><span class="line">        <span class="built_in">memset</span>(isA, <span class="literal">false</span>, <span class="keyword">sizeof</span> isA);</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// build SAM</span></span><br><span class="line">        n = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(S+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i)</span><br><span class="line">            SAM::insert(S[i] - <span class="string">'a'</span>), pos[i] = SAM::last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= SAM::nidx; ++i)</span><br><span class="line">            pre[<span class="number">0</span>][i] = SAM::lnk[i], G[i].clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; LOG; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= SAM::nidx; ++i) pre[j][i] = pre[j<span class="number">-1</span>][pre[j<span class="number">-1</span>][i]];</span><br><span class="line">        <span class="comment">// find A in SAM</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;na);</span><br><span class="line">        uidx = SAM::nidx;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L, R, i = <span class="number">1</span>; i &lt;= na; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">            <span class="keyword">int</span> lgt = R - L + <span class="number">1</span>, u = pos[L];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = LOG<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">                <span class="keyword">if</span> (pre[j][u] &amp;&amp; len[pre[j][u]] &gt;= lgt) u = pre[j][u];</span><br><span class="line">            len[++uidx] = lgt, Aidx[i] = uidx, isA[uidx] = <span class="literal">true</span>;</span><br><span class="line">            G[u].push_back(uidx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// find B in SAM</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;nb);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L, R, i = <span class="number">1</span>; i &lt;= nb; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">            <span class="keyword">int</span> lgt = R - L + <span class="number">1</span>, u = pos[L];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = LOG<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">                <span class="keyword">if</span> (pre[j][u] &amp;&amp; len[pre[j][u]] &gt;= lgt) u = pre[j][u];</span><br><span class="line">            len[++uidx] = lgt, Bidx[i] = uidx;</span><br><span class="line">            G[u].push_back(uidx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// link edges in SAM</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, u = <span class="number">1</span>; u &lt;= SAM::nidx; ++u) &#123;</span><br><span class="line">            <span class="keyword">int</span> last = u;</span><br><span class="line">            sort(G[u].begin(), G[u].end(),</span><br><span class="line">                    [](<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)&#123; <span class="keyword">return</span> len[a] &lt; len[b] || (len[a] == len[b] &amp;&amp; isA[a] &lt; isA[b]); &#125;);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; G[u].size(); ++i) &#123;</span><br><span class="line">                Graph::AddEdge(last, v = G[u][i]);</span><br><span class="line">                <span class="keyword">if</span> (!isA[v]) last = v;</span><br><span class="line">            &#125;</span><br><span class="line">            lst[u] = last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= SAM::nidx; ++i)</span><br><span class="line">            Graph::AddEdge(lst[SAM::lnk[i]], i);</span><br><span class="line">        <span class="comment">// clean unexisted value</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= uidx; ++u)</span><br><span class="line">            <span class="keyword">if</span> (!isA[u]) len[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// link A, B</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), Graph::AddEdge(Aidx[u], Bidx[v]);</span><br><span class="line">        <span class="comment">// solve &amp; output</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Graph::Toposort());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;谨以此题纪念自己颓废的, 什么都不会的高一 (bushi&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://www.luogu.com.cn/problem/P5284&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.com.cn/problem/P5284&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SAM 优化建图 + 拓扑排序求最长路.&lt;/p&gt;
&lt;p&gt;写这道题啊, 只是感到自己的高一很可笑吧, 连题意都不大能读清, 正解的算法听都没有听过, 输出样例就弃疗离场.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
      <category term="String" scheme="https://depletedprism.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>第一 / 二类 Stirling 数的一些平庸求法</title>
    <link href="https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/stirling-polynomial/"/>
    <id>https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/stirling-polynomial/</id>
    <published>2020-01-28T12:19:12.000Z</published>
    <updated>2020-02-15T05:34:25.658Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>看到洛谷上有求 Stirling 数的神奇板子, 于是就想写 = =</p><p><del>虽然不知道会有什么用处, 其实是不想写题又不敢颓废吧</del></p><p>大概是一些式子推推推然后拉板子算算算…</p><a id="more"></a><h3 id="第一类-Stirling-数"><a href="#第一类-Stirling-数" class="headerlink" title="第一类 Stirling 数"></a>第一类 Stirling 数</h3><p>本文采用 $\begin{bmatrix} n \\ m \end{bmatrix}$ 表示第一类 Stirling 数.</p><h4 id="Part-1-行"><a href="#Part-1-行" class="headerlink" title="Part 1 行"></a>Part 1 行</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P5408" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P5408</a></li></ul><p>我们知道, $x$ 的 $n$ 次上升幂就是第 $n$ 行第一类 Stirling 数的生成函数, 即<br>$$x^{\overline n} = \prod_{i=0}^{n-1} (x + i) = \sum_{i=0}^n \begin{bmatrix} n \\ i \end{bmatrix} x^i$$</p><p>论据如下, 归纳法易证 $$ \begin{bmatrix} n \\ m \end{bmatrix} = \begin{bmatrix} n-1 \\ m-1 \end{bmatrix} + (n-1) \cdot \begin{bmatrix} n-1 \\ m \end{bmatrix}$$</p><p>此时通过分治 FFT 可以在 $O(n \log^2 n)$ 的时间复杂度内计算.</p><p>但是用倍增可以做到 $O(n \log n)$.</p><p>考虑倍增, 有<br>$$x^{\overline {2n}} = x^{\overline{n}} (x+n)^{\overline{n}}$$</p><p>写成这个形式鬼知道怎么推, 于是<br>$$x^{\overline{2n}} = \prod_{i=0}^{n-1} (x+i) \prod_{i=0}^{n-1} (x+i+n)$$</p><p>设 $f(x) = \prod_{i=0}^{n-1} (x+i) = \sum_{i=0}^n a_i x^i$, 如果能根据 $f(x)$ 算 $f(x+n)$ 就可以了.<br>$$f(x+n) = \sum_{i=0}^n a_i (x+n)^i = \sum_{i=0}^n a_i \sum_{j=0}^{i} \binom{i}{j} x^i n^{i-j} $$</p><p>交换 $i$, $j$ 枚举顺序, 得<br>$$f(x+n) = \sum_{i=0}^n x^i \sum_{j=i}^n \binom{j}{i} n^{j-i} a_i$$</p><p>展开, 有<br>$$f(x+n) = \sum_{i=0}^n \frac{x^i}{i!} \sum_{j=i}^n \frac{n^{j-i}}{(j-i)!} j!\ a_j$$</p><p>最后一个和式的卷积形式并不显然, 还要将其中一项翻转…</p><p>写起来有很多细节, 中途出了无数锅, 以及我现在都不知道为什么我写的迭代和开区间会死…</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P5408</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">524295</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">167772161</span>, G = <span class="number">3</span>, iG = <span class="number">55924054</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fac[MAXN], ifac[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> m = P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * base * ret % m;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> Lim, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> unit = fpow(type &gt; <span class="number">0</span>? G: iG, (P<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j, w = <span class="number">1L</span>L * w * unit % P) &#123;</span><br><span class="line">                    <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1L</span>L * w * f[i+j+Mid] % P;</span><br><span class="line">                    f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> inv = fpow(Lim, P<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * inv % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> Mid, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">        <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*Mid) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> powk = <span class="number">1</span>, i = <span class="number">0</span>; i &lt; Mid; ++i, powk = <span class="number">1L</span>L * powk * k % P) &#123;</span><br><span class="line">            A[Mid-i<span class="number">-1</span>] = <span class="number">1L</span>L * f[i] * fac[i] % P;</span><br><span class="line">            B[i] = <span class="number">1L</span>L * powk * ifac[i] % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">        init(Lim, L), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = <span class="number">1L</span>L * A[i] * B[i] % P;</span><br><span class="line">        NTT(A, Lim, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) g[i] = <span class="number">1L</span>L * A[Mid-i<span class="number">-1</span>] * ifac[i] % P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="keyword">void</span>( f[<span class="number">0</span>] = <span class="number">1</span> );</span><br><span class="line">        <span class="keyword">int</span> Mid = n / <span class="number">2</span>, Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">        solve(f, Mid);</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt;= n) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">        <span class="comment">// 得到 f(x + Mid)</span></span><br><span class="line">        calc(f, A, Mid+<span class="number">1</span>, Mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Mid; ++i) B[i] = f[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid+<span class="number">1</span>; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">        init(Lim, L), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = <span class="number">1L</span>L * A[i] * B[i] % P;</span><br><span class="line">        NTT(A, Lim, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// n 为奇数时, 有乘 (x + (n-1)) 的情况, 此时直接乘就好了.</span></span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">            f[i] = ((i? A[i<span class="number">-1</span>]: <span class="number">0</span>) + <span class="number">1L</span>L * A[i] * (n<span class="number">-1</span>) % P) % P;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) f[i] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    ifac[<span class="number">0</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = <span class="number">1L</span>L * fac[i<span class="number">-1</span>] * i % P;</span><br><span class="line">    ifac[n] = fpow(fac[n], P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) ifac[i<span class="number">-1</span>] = <span class="number">1L</span>L * ifac[i] * i % P;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    Poly::solve(f, n);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, f[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h4 id="Part-2-列"><a href="#Part-2-列" class="headerlink" title="Part 2 列"></a>Part 2 列</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P5409" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P5409</a></li></ul><p>首先有第一类 Stirling 数的一个性质, 即<br>$$x^{\underline n} = \prod_{i=0}^{n-1} (x-i) = \sum_{i=0}^n (-1)^{n-i} \begin{bmatrix} n \\ i \end{bmatrix} x^i$$</p><p>同样也是归纳法易证.</p><p>对于 $(1+x)^t$, 由牛顿二项式定理, 可知<br>$$(1+x)^t = \sum_{i=0}^\infty \binom{t}{i} x^i$$</p><p>其中 $\binom{t}{i} = \frac{t (t-1) \cdots (t-i+1)}{i!}$, 不妨写作<br>$$(1+x)^t = \sum_{i=0}^\infty \frac{t^{\underline i}}{i!} x^i$$</p><p>愉快套公式, 得<br>$$(1+x)^t = \sum_{i=0}^\infty \frac{1}{i!} x^i \sum_{j=0}^i (-1)^{i-j} \begin{bmatrix} i \\ j \end{bmatrix} t^j$$</p><p>交换枚举顺序, 得<br>$$(1+x)^t = \sum_{i=0}^\infty t^i \sum_{j=i}^\infty \frac{1}{j!} x^j (-1)^{j-i} \begin{bmatrix}j \\ i \end{bmatrix} $$</p><p>同时, 有<br>$$(1+x)^t = \exp (t \cdot \ln (1+x)) = \sum_{i=0}^\infty \frac{1}{i!} \ln^i (1+x)\ t^i$$</p><p>对应项系数相等, 得<br>$$\frac{1}{i!} \ln^i (1+x) = \sum_{j=i}^\infty \frac{1}{j!} (-1)^{j-i} \begin{bmatrix}j \\ i \end{bmatrix} x^j$$</p><p>可以看到, 其中 $i$ 为给定的值, 利用多项式幂函数算就好了.</p><p>值得注意的是, $[x^0] \ln (1+x)$ 有不等于 $1$ 的可能, 所以要用鲁棒性更强的板子 = =</p><p>时间复杂度是带常数的 $O(n \log n)$, 大概是跑不过 $O(n \log^2 n)$ 的带常数吧</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P5409</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">131075</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">167772161</span>, G = <span class="number">3</span>, iG = <span class="number">55924054</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fac[MAXN], ifac[MAXN], inv[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> m = P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % m;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> Lim, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> unit = fpow(type &gt; <span class="number">0</span>? G: iG, (P<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j, w = <span class="number">1L</span>L * w * unit % P) &#123;</span><br><span class="line">                    <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1L</span>L * w * f[i+j+Mid] % P;</span><br><span class="line">                    f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> inv = fpow(Lim, P<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * inv * f[i] % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">        g[<span class="number">0</span>] = fpow(f[<span class="number">0</span>], P<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">0</span>, Lim = <span class="number">1</span>, Mid = <span class="number">2</span>; Mid &lt; <span class="number">2</span>*n; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*Mid) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) A[i] = f[i], B[i] = g[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">            init(Lim, L), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i)</span><br><span class="line">                g[i] = ((B[i] + B[i]) % P - <span class="number">1L</span>L * A[i] * B[i] % P * B[i] % P + P) % P;</span><br><span class="line">            NTT(g, Lim, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = min(Mid, n); i &lt; Lim; ++i) g[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Der</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) g[i<span class="number">-1</span>] = <span class="number">1L</span>L * i * f[i] % P;</span><br><span class="line">        g[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Int</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        g[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i; --i) g[i] = <span class="number">1L</span>L * inv[i] * f[i<span class="number">-1</span>] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ln</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">        Der(f, A, n), Inv(f, B, n);</span><br><span class="line">        <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*n) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">        init(Lim, L), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = <span class="number">1L</span>L * A[i] * B[i] % P;</span><br><span class="line">        NTT(A, Lim, <span class="number">-1</span>), Int(A, g, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Exp</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN], lng[MAXN];</span><br><span class="line">        g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">0</span>, Lim = <span class="number">1</span>, Mid = <span class="number">2</span>; Mid &lt; <span class="number">2</span>*n; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            Ln(g, lng, Mid);</span><br><span class="line">            <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*Mid) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) A[i] = (f[i] - lng[i] + P) % P, B[i] = g[i];</span><br><span class="line">            A[<span class="number">0</span>] = (A[<span class="number">0</span>] + <span class="number">1</span>) % P;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">            init(Lim, L), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) g[i] = <span class="number">1L</span>L * A[i] * B[i] % P;</span><br><span class="line">            NTT(g, Lim, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = min(Mid, n); i &lt; Lim; ++i) g[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> lng[MAXN];</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!f[pos]) ++pos;</span><br><span class="line">        <span class="keyword">int</span> Mid = n - pos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) g[i] = f[i+pos];</span><br><span class="line">        <span class="keyword">int</span> base = g[<span class="number">0</span>], inv = fpow(base, P<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) g[i] = <span class="number">1L</span>L * g[i] * inv % P;</span><br><span class="line">        Ln(g, lng, Mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) lng[i] = <span class="number">1L</span>L * lng[i] * K % P;</span><br><span class="line">        Exp(lng, g, Mid);</span><br><span class="line">        base = fpow(base, K);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) g[i] = <span class="number">1L</span>L * g[i] * base % P;</span><br><span class="line">        pos = min(pos * K, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= pos; --i) g[i] = g[i-pos];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos; ++i) g[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K;</span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;K);</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="keyword">int</span> N = n;</span><br><span class="line">    ifac[<span class="number">0</span>] = fac[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) inv[i] = <span class="number">1L</span>L * (P - P / i) * inv[P % i] % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) fac[i] = <span class="number">1L</span>L * i * fac[i<span class="number">-1</span>] % P;</span><br><span class="line">    ifac[N] = fpow(fac[N], P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i; --i) ifac[i<span class="number">-1</span>] = <span class="number">1L</span>L * i * ifac[i] % P;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    Poly::Ln(f, f, n+<span class="number">1</span>); Poly::Pow(f, f, n+<span class="number">1</span>, K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) f[i] = <span class="number">1L</span>L * f[i] * ifac[K] % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        f[i] = <span class="number">1L</span>L * f[i] * fac[i] % P * (((i-K) &amp; <span class="number">1</span>)? P<span class="number">-1</span>: <span class="number">1</span>) % P;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, f[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h3><p>本文采用 $\begin{Bmatrix} n \\ m \end{Bmatrix}$ 表示第二类 Stirling 数.</p><h4 id="Part-1-行-1"><a href="#Part-1-行-1" class="headerlink" title="Part 1 行"></a>Part 1 行</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P5395" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P5395</a></li></ul><p><del>感觉这个是最简单的了</del></p><p>考虑第二类 Stirling 数的组合意义, 也就是把 $n$ 个有区别的小球放入 $m$ 个无区别的盒子里的方案数.</p><p>其实这个东西是可以用容斥算的, 可以得到<br>$$\begin{Bmatrix} n \\ m \end{Bmatrix} = \frac{1}{m!} \sum_{k=0}^n (-1)^{k} \binom{m}{k} (m-k)^n$$</p><p>右边和式的意义为, 在 $m$ 个<strong>有区别</strong>的盒子里挑 $k$ 个空盒子, 然后把 $n$ 个小球丢到盒子里. 因为容斥时假设盒子有区别, 最后还要除以 $m!$.</p><p>把这个式子展开就可以看到卷积的形式了.<br>$$\begin{Bmatrix} n \\ m \end{Bmatrix} = \sum_{k=0}^n \frac{(-1)^k}{k!} \frac{(m-k)^n}{(m-k)!}$$</p><p>通过 NTT 就可以在 $O(n \log n)$ 的时间复杂度内计算.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P5395</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">167772161</span>, G = <span class="number">3</span>, iG = <span class="number">55924054</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> m = P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % m;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> Lim, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> unit = fpow(type &gt; <span class="number">0</span>? G: iG, (P<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j, w = <span class="number">1L</span>L * w * unit % P) &#123;</span><br><span class="line">                    <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1L</span>L * w * f[i+j+Mid] % P;</span><br><span class="line">                    f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> inv = fpow(Lim, P<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * inv % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[MAXN], g[MAXN];</span><br><span class="line"><span class="keyword">int</span> fac[MAXN], ifac[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = <span class="number">1L</span>L * fac[i<span class="number">-1</span>] * i % P;</span><br><span class="line">    ifac[n] = fpow(fac[n], P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) ifac[i<span class="number">-1</span>] = <span class="number">1L</span>L * ifac[i] * i % P;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i] = (i &amp; <span class="number">1</span>)? P - ifac[i]: ifac[i];</span><br><span class="line">        g[i] = <span class="number">1L</span>L * fpow(i, n) * ifac[i] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*n) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">    Poly::init(Lim, L), Poly::NTT(f, Lim, <span class="number">1</span>), Poly::NTT(g, Lim, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * g[i] % P;</span><br><span class="line">    Poly::NTT(f, Lim, <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, f[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h4 id="Part-2-列-1"><a href="#Part-2-列-1" class="headerlink" title="Part 2 列"></a>Part 2 列</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P5396" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P5396</a></li></ul><p>设第二类 Stirling 数一列的生成函数为 $S_m$, 即<br>$$S_m (x) = \sum_{i=0}^\infty \begin{Bmatrix} i \\ m \end{Bmatrix} x^i$$</p><p>根据第二类 Stirling 数递推式, 可以得到<br>$$S_m (x) = \sum_{i=1}^\infty \begin{Bmatrix} i-1 \\ m-1 \end{Bmatrix} x^i  + m \sum_{i=1}^\infty \begin{Bmatrix} i-1 \\ m \end{Bmatrix} x^i$$</p><p>$$S_m (x) = x \cdot S_{m-1} (x) + m x \cdot S_m (x)$$</p><p>移项并整理, 得<br>$$S_m (x) = \frac{x}{1-mx} S_{m-1} (x) = \frac{x^m}{\prod_{i=1}^m (1-ix)}$$</p><p>分式的分母可以使用分治 FFT 得到, 然后求逆并乘一个单项式 (也就是把系数右移) 即可.</p><p>所以我们就得到了 $O(n \log^2 n)$ 的做法, 然而存在 $O(n\log n)$ 且小常数的倍增优秀做法, 只是我学不动了…</p><p>佐以 O2 食用更佳.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P5396</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">131075</span> &lt;&lt; <span class="number">1</span>, LOG = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">167772161</span>, G = <span class="number">3</span>, iG = <span class="number">55924054</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> m = P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * base * ret % m;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    <span class="keyword">int</span> tmp[LOG][MAXN], ptr = <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> Lim, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> unit = fpow(type &gt; <span class="number">0</span>? G: iG, (P<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j, w = <span class="number">1L</span>L * w * unit % P) &#123;</span><br><span class="line">                    <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1L</span>L * w * f[i+j+Mid] % P;</span><br><span class="line">                    f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> inv = fpow(Lim, P<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * inv % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">        g[<span class="number">0</span>] = fpow(f[<span class="number">0</span>], P<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">0</span>, Lim = <span class="number">1</span>, Mid = <span class="number">2</span>; Mid &lt; <span class="number">2</span>*n; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*Mid) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) A[i] = f[i], B[i] = g[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">            init(Lim, L), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i)</span><br><span class="line">                g[i] = ((B[i] + B[i]) % P - <span class="number">1L</span>L * A[i] * B[i] % P * B[i] % P + P) % P;</span><br><span class="line">            NTT(g, Lim, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = min(Mid, n); i &lt; Lim; ++i) g[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> f[<span class="number">0</span>] = <span class="number">1</span>, <span class="keyword">void</span>( f[<span class="number">1</span>] = P - L );</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, *f0 = tmp[++ptr], *f1 = tmp[++ptr];</span><br><span class="line">        solve(f0, L, Mid), solve(f1, Mid+<span class="number">1</span>, R);</span><br><span class="line">        <span class="keyword">int</span> Lim = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt;= R-L+<span class="number">1</span>) Lim &lt;&lt;= <span class="number">1</span>, ++l;</span><br><span class="line">        init(Lim, l), NTT(f0, Lim, <span class="number">1</span>), NTT(f1, Lim, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f0[i] * f1[i] % P, f0[i] = f1[i] = <span class="number">0</span>;</span><br><span class="line">        NTT(f, Lim, <span class="number">-1</span>), ptr -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K;</span><br><span class="line"><span class="keyword">int</span> f[MAXN], g[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;K);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    Poly::solve(f, <span class="number">1</span>, K);</span><br><span class="line">    Poly::Inv(f, g, n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i+K &lt;= n; ++i) f[i+K] = g[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; ++i) f[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, f[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>Richard A. Brualdi. 组合数学. 机械工业出版社, 2012.4.</li><li><a href="https://www.cnblogs.com/y2823774827y/p/10700231.html" target="_blank" rel="noopener">斯特林数及斯特林反演 by y2823774827y</a></li><li><a href="https://www.luogu.com.cn/blog/NaCly-Fish-blog/solution-p5408" target="_blank" rel="noopener">题解 P5408 【模板】第一类斯特林数·行 by NaCly_Fish</a></li><li><a href="https://www.luogu.com.cn/blog/user7035/solution-p5409" target="_blank" rel="noopener">题解 P5409 【模板】第一类斯特林数·列 by Great_Influence</a></li><li><a href="https://www.luogu.com.cn/blog/user7035/solution-p5396" target="_blank" rel="noopener">题解 P5396 【模板】第二类斯特林数·列 by Great_Influence</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;看到洛谷上有求 Stirling 数的神奇板子, 于是就想写 = =&lt;/p&gt;
&lt;p&gt;&lt;del&gt;虽然不知道会有什么用处, 其实是不想写题又不敢颓废吧&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;大概是一些式子推推推然后拉板子算算算…&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://depletedprism.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Polynomial" scheme="https://depletedprism.github.io/tags/Polynomial/"/>
    
  </entry>
  
  <entry>
    <title>牛顿二项式定理 学习笔记</title>
    <link href="https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/binomial-theorem/"/>
    <id>https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/binomial-theorem/</id>
    <published>2020-01-21T03:52:42.000Z</published>
    <updated>2020-01-26T12:05:06.611Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>数学就是用的时候不够用的东西. = =</p></blockquote><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>牛顿二项式定理是对二项式定理的推广, <del>那直接叫广义二项式定理不好吗</del>, 刚开始看 &lt;组合数学&gt; 的时候见到这个东西, 以为没什么用 = =, 后来…</p><p>当然本文作者没有仔细严谨地学习相关的数学知识, 内容充满谬误, 恳请指正.</p><a id="more"></a><h2 id="陈述"><a href="#陈述" class="headerlink" title="陈述"></a>陈述</h2><h3 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h3><p>对于正整数 $n$ 和任意 $x,\ y$, 有<br>$$(x + y) ^ n = \sum_{k=0}^n\; \binom{n}{k} x^k y ^{n-k}$$</p><p>这就是最常见的二项式定理, 其中 $n$ 可以推广到任意实数, 即</p><h3 id="牛顿二项式定理"><a href="#牛顿二项式定理" class="headerlink" title="牛顿二项式定理"></a>牛顿二项式定理</h3><p>设 $\alpha$ 是实数, 对于所有满足 $0 \leq |x| &lt; |y|$ 的 $x$,  $y$, 有<br>$$(x+y)^\alpha = \sum_{k=0}^\infty\; \binom{\alpha}{k} x^k y^{n-k}$$</p><p>其中<br>$$\binom{\alpha}{k} = \frac{\alpha (\alpha - 1) \cdots (\alpha - k + 1)}{k!} $$</p><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>在此不证.</p><h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><p>看到这个和式上的无穷的时候, <del>顷刻留下了感动的泪水</del>…</p><h3 id="一些拓展"><a href="#一些拓展" class="headerlink" title="一些拓展"></a>一些拓展</h3><p>设 $z = \frac{x}{y}$, 那么上述定理可以转述为</p><p>对于所有满足 $|z| &lt; 1$ 的任意 $z$, 有<br>$$(1+z) ^ \alpha = \sum_{k=0}^\infty\; \binom{\alpha}{k} z^k$$</p><p>设 $n$ 为正整数, 取 $\alpha$ 为负整数 $-n$, 则<br>$$\binom{\alpha}{k} = \binom{-n}{k} = \frac{-n (-n-1) \cdots (-n-k+1)}{k!} = (-1)^k \binom{n+k-1}{k}$$</p><p>所以<br>$$(1+z)^{-n} = \frac{1}{(1+z)^n} = \sum_{k=0}^\infty\; (-1)^k \binom{n+k-1}{k} z^k$$</p><p>为了干掉那个 $-1$, 令 $-z$ 代替 $z$, 得<br>$$(1-z)^{-n} = \frac{1}{(1-z)^n} = \sum_{k=0}^\infty\; \binom{n+k-1}{k} z^k$$</p><p>取 $n=1$, 有 $\binom{n+k-1}{k} = \binom{k}{k} = 1$, 所以<br>$$\frac{1}{1-z} = \sum_{k=0}^\infty\; z^k = 1 + z + z^2 + z^3 + \cdots$$</p><p>类似地, 有<br>$$\frac{1}{1+z} = \sum_{k=0}^\infty\; (-1)^k z^k = 1 - z + z^2 - z^3 \cdots$$</p><p>稍微总结一下</p><p>如果 $n$ 是正整数, $r$ 是非 $0$ 实数, 那么<br>$$(1-rx)^{-n} = \sum_{k=0}^\infty\; \binom{-n}{k} (-rx)^k$$</p><p>或等价地, 有<br>$$\frac{1}{(1-rx)^n} = \sum_{k=0}^\infty\; \binom{n+k-1}{k} r^k x^k$$ 其中 $|x| &lt; \frac{1}{|r|}$.</p><h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><p>可能在生成函数有关的题目会用到这些东西吧…</p><p>$$1 + x + x^2 + \cdots = \frac{1}{1-x} \\<br>1 + x^2 + x^4 + \cdots = 1 + (x)^2 + (x^2)^2 + \cdots = \frac{1}{1 - x^2} \\<br>x + x^2 + x^3 + \cdots = x\; (1 + x + x^2 + \cdots) = \frac{x}{1 - x} \\<br>1 + x + x^2 + x^3 + x^4 = \frac{1 - x^5}{1-x}$$</p><p>最后一个式子似乎是乱入的… 不过还好是显然的, 直接通分验证即可</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="BZOJ-3028-食物"><a href="#BZOJ-3028-食物" class="headerlink" title="BZOJ 3028 食物"></a>BZOJ 3028 食物</h4><ul><li>题目链接: <a href="https://lydsy.com/JudgeOnline/problem.php?id=3028" target="_blank" rel="noopener">https://lydsy.com/JudgeOnline/problem.php?id=3028</a></li></ul><p><del>乐色 OJ 什么都是权限题</del> = =</p><p>首先您要学会生成函数, 然后这就是一道裸题.</p><p>设生成函数为 $g(x)$, 化简后得<br>$$g(x) = \frac{x}{(1-x)^4} = x \sum_{k=0}^\infty\; \binom{k+3}{k} x^k = \sum_{k=0}^\infty\; \binom{k+2}{k-1} x^k$$</p><p>所以第 $n$ 项系数, 即答案, 为 $\binom{n+2}{n-1} = \binom{n+2}{3} = \frac{1}{6} n(n+1)(n+2)$</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>Richard A. Brualdi. 组合数学. 机械工业出版社, 2012.4.</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;数学就是用的时候不够用的东西. = =&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;牛顿二项式定理是对二项式定理的推广, &lt;del&gt;那直接叫广义二项式定理不好吗&lt;/del&gt;, 刚开始看 &amp;lt;组合数学&amp;gt; 的时候见到这个东西, 以为没什么用 = =, 后来…&lt;/p&gt;
&lt;p&gt;当然本文作者没有仔细严谨地学习相关的数学知识, 内容充满谬误, 恳请指正.&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://depletedprism.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Combinatorics" scheme="https://depletedprism.github.io/tags/Combinatorics/"/>
    
  </entry>
  
  <entry>
    <title>「51nod 1348」乘积之和 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/51nod-1348/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/51nod-1348/</id>
    <published>2020-01-18T16:41:47.000Z</published>
    <updated>2020-02-06T03:35:32.288Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接: <a href="https://www.51nod.com/Challenge/Problem.html#problemId=1348" target="_blank" rel="noopener">https://www.51nod.com/Challenge/Problem.html#problemId=1348</a></li></ul><p>分治 FFT 如果使用三模数 NTT, 那么每次合并只需要记录实际模数下的答案…</p><a id="more"></a><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>首先容易发现, 多次询问是个假的限制, 实际上我们可以预先计算出所以答案, 然后每次 $O(1)$ 回答…</p><p>对于每个数, 有选和不选两种选择, 容易构造出生成函数 $g(x)$ 如下, 选择 $k$ 个数的乘积即为 $x^k$ 对应项的系数.<br>$$g(x) = \prod_{i=1}^n (a_i x + 1)$$</p><p>现在的问题就是如何计算这个式子, 有一种无脑且直接的方法就是分治 FFT…</p><p>不过值得注意的是, 这屑题的模数为 $100003 = 2\times 3\times 7\times 2381 + 1$, 并不是友好的 NTT 模数, 于是使用三模数 NTT, (实际上这个模数很小, 用双模数 NTT 就足够了), 统计答案的时候中国剩余定理合并即可.</p><p>然后我就写出了这样的乐色代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span>* a, Num* f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> f[<span class="number">0</span>] = Num(<span class="number">1</span>), <span class="keyword">void</span>( f[<span class="number">1</span>] = Num(a[L]) );</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, Lim = <span class="number">1</span>, K = <span class="number">0</span>;</span><br><span class="line">    Num *f0 = tmp[++idx], *f1 = tmp[++idx];</span><br><span class="line">    divide(L, Mid, a, f0), divide(Mid+<span class="number">1</span>, R, a, f1);</span><br><span class="line">    <span class="keyword">while</span> (Lim &lt;= R-L+<span class="number">1</span>) Lim &lt;&lt;= <span class="number">1</span>, ++K;</span><br><span class="line">    init(Lim, K), NTT(f0, Lim, <span class="number">1</span>), NTT(f1, Lim, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = f0[i] * f1[i], f0[i] = f1[i] = Num(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 注意到这里 f 为在三模数意义下的三个值, 而不是模 100003 意义下的答案 (</span></span><br><span class="line">    NTT(f, Lim, <span class="number">-1</span>), idx -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后接下来就调了好长时间 = =, 终于发现了这个锅,  <del>其实想一想也挺有道理的</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span>* a, <span class="keyword">int</span>* f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> f[<span class="number">0</span>] = <span class="number">1</span>, <span class="keyword">void</span>( f[<span class="number">1</span>] = a[L] );</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, *f0 = tmp[++idx], *f1 = tmp[++idx];</span><br><span class="line">    divide(L, Mid, a, f0), divide(Mid+<span class="number">1</span>, R, a, f1);</span><br><span class="line">    <span class="keyword">int</span> Lim = <span class="number">1</span>, K = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Lim &lt;= R-L+<span class="number">1</span>) Lim &lt;&lt;= <span class="number">1</span>, ++K;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Mid-L+<span class="number">1</span>; ++i) A[i] = Num(f0[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid-L+<span class="number">2</span>; i &lt; Lim; ++i) A[i] = Num(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= R-Mid; ++i) B[i] = Num(f1[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = R-Mid+<span class="number">1</span>; i &lt; Lim; ++i) B[i] = Num(<span class="number">0</span>);</span><br><span class="line">    init(Lim, K), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = A[i] * B[i], f0[i] = f1[i] = <span class="number">0</span>;</span><br><span class="line">    NTT(A, Lim, <span class="number">-1</span>), idx -= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= R-L+<span class="number">1</span>; ++i) f[i] = A[i].Merge();</span><br><span class="line">    <span class="comment">// 只记录模 100003 下的答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 51nod 1348</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e5</span>+<span class="number">5</span>, invP1 = <span class="number">669690699</span>, invP12 = <span class="number">354521948</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P1 = <span class="number">998244353</span>, P2 = <span class="number">1004535809</span>, P3 = <span class="number">469762049</span>, G = <span class="number">3</span>, mod = <span class="number">100003</span>;</span><br><span class="line"><span class="keyword">const</span> LL P12 = <span class="number">1L</span>L * P1 * P2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Num</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    Num() &#123; a = b = c = <span class="number">0</span>; &#125;</span><br><span class="line">    Num(<span class="keyword">int</span> _x): a(_x), b(_x), c(_x) &#123; &#125;</span><br><span class="line">    Num(<span class="keyword">int</span> _a, <span class="keyword">int</span> _b, <span class="keyword">int</span> _c): a(_a), b(_b), c(_c) &#123; &#125;</span><br><span class="line">    <span class="function">Num <span class="title">Mod</span><span class="params">(<span class="keyword">const</span> Num&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Num(x.a + (x.a &gt;&gt; <span class="number">31</span> &amp; P1), x.b + (x.b &gt;&gt; <span class="number">31</span> &amp; P2), x.c + (x.c &gt;&gt; <span class="number">31</span> &amp; P3));</span><br><span class="line">    &#125;</span><br><span class="line">    Num <span class="keyword">operator</span> + (<span class="keyword">const</span> Num&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Mod(Num(a + rhs.a - P1, b + rhs.b - P2, c + rhs.c - P3)); &#125;</span><br><span class="line">    Num <span class="keyword">operator</span> - (<span class="keyword">const</span> Num&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Mod(Num(a - rhs.a, b - rhs.b, c - rhs.c)); &#125;</span><br><span class="line">    Num <span class="keyword">operator</span> * (<span class="keyword">const</span> Num&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Num(<span class="number">1L</span>L * a * rhs.a % P1, <span class="number">1L</span>L * b * rhs.b % P2, <span class="number">1L</span>L * c * rhs.c % P3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Merge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LL x = <span class="number">1L</span>L * (b - a + P2) % P2 * invP1 % P2 * P1 + a;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1L</span>L * (c - x % P3 + P3) % P3 * invP12 % P3 * (P12 % mod) % mod + x) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * base * ret % P;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    Num A[MAXN], B[MAXN];</span><br><span class="line">    <span class="keyword">int</span> r[MAXN], tmp[<span class="number">31</span>][MAXN], idx = <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(Num* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="function">Num <span class="title">unit</span><span class="params">( fpow(type &gt; <span class="number">0</span>? G: fpow(G, P1<span class="number">-2</span>, P1), (P1<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>), P1), </span></span></span><br><span class="line"><span class="function"><span class="params">                      fpow(type &gt; <span class="number">0</span>? G: fpow(G, P2<span class="number">-2</span>, P2), (P2<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>), P2),</span></span></span><br><span class="line"><span class="function"><span class="params">                      fpow(type &gt; <span class="number">0</span>? G: fpow(G, P3<span class="number">-2</span>, P3), (P3<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>), P3) )</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="function">Num <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j, w = w * unit) &#123;</span><br><span class="line">                    Num f0 = f[i+j], f1 = w * f[i+j+Mid];</span><br><span class="line">                    f[i+j] = f0 + f1, f[i+j+Mid] = f0 - f1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function">Num <span class="title">inv</span><span class="params">( fpow(Lim, P1<span class="number">-2</span>, P1), fpow(Lim, P2<span class="number">-2</span>, P2), fpow(Lim, P3<span class="number">-2</span>, P3) )</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = f[i] * inv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span>* a, <span class="keyword">int</span>* f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> f[<span class="number">0</span>] = <span class="number">1</span>, <span class="keyword">void</span>( f[<span class="number">1</span>] = a[L] );</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, *f0 = tmp[++idx], *f1 = tmp[++idx];</span><br><span class="line">        divide(L, Mid, a, f0), divide(Mid+<span class="number">1</span>, R, a, f1);</span><br><span class="line">        <span class="keyword">int</span> Lim = <span class="number">1</span>, K = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt;= R-L+<span class="number">1</span>) Lim &lt;&lt;= <span class="number">1</span>, ++K;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Mid-L+<span class="number">1</span>; ++i) A[i] = Num(f0[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid-L+<span class="number">2</span>; i &lt; Lim; ++i) A[i] = Num(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= R-Mid; ++i) B[i] = Num(f1[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = R-Mid+<span class="number">1</span>; i &lt; Lim; ++i) B[i] = Num(<span class="number">0</span>);</span><br><span class="line">        init(Lim, K), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = A[i] * B[i], f0[i] = f1[i] = <span class="number">0</span>;</span><br><span class="line">        NTT(A, Lim, <span class="number">-1</span>), idx -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= R-L+<span class="number">1</span>; ++i) f[i] = A[i].Merge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    Poly::divide(<span class="number">1</span>, n, A, f);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> K;</span><br><span class="line">        read(K), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[K]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://www.51nod.com/Challenge/Problem.html#problemId=1348&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.51nod.com/Challenge/Problem.html#problemId=1348&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分治 FFT 如果使用三模数 NTT, 那么每次合并只需要记录实际模数下的答案…&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Polynomial" scheme="https://depletedprism.github.io/tags/Polynomial/"/>
    
  </entry>
  
  <entry>
    <title>「BZOJ 5093」图的价值 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/BZOJ-5093/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/BZOJ-5093/</id>
    <published>2020-01-17T14:27:41.000Z</published>
    <updated>2020-01-19T05:16:09.365Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p> 组合数学学不明白祭.</p></blockquote><ul><li>题目链接: <a href="https://lydsy.com/JudgeOnline/problem.php?id=5093" target="_blank" rel="noopener">https://lydsy.com/JudgeOnline/problem.php?id=5093</a></li></ul><p>根据题意列出式子, 并通过第二类 Stirling 数对式子进行化简, 在合适的时间内计算出结果.</p><a id="more"></a><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><ul><li>NTT</li><li><p>第二类 Stirling 数的一些性质</p><ul><li><p>$m^n=\sum_{i=0}^{m} \begin{Bmatrix}n \\ i\end{Bmatrix}\  i! \cdot  \binom{m}{i}$<br>提供了一个计算自然数幂的新思路.</p></li><li><p>$\begin{Bmatrix} n\\ m\end{Bmatrix} =  \sum_{i=0}^{m} \frac{(-1)^i}{i!} \frac{(m-i)^n}{(m-i)!}$<br>显然是一个卷积的形式, 可以在 $O(n \log n)$ 的时间复杂度计算.</p><p>详尽的解释可以在这里找到: <a href="https://www.cnblogs.com/y2823774827y/p/10700231.html" target="_blank" rel="noopener">https://www.cnblogs.com/y2823774827y/p/10700231.html</a></p></li></ul></li></ul><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>考虑单独枚举一个点的度数 $i$, 那么答案可以表示为 $$n \cdot \sum_{i=0}^{n-1} \binom{n-1}{i} i^k \cdot 2^{\frac{1}{2} (n-1)(n-2)}$$</p><p>如何理解呢? 首先, 每个点在枚举时是等价的, 所以最终结果乘 $n$</p><p>其次, 当前点的贡献为 $i^k$, 考虑度数为 $k$, 即在剩余的 $n-1$ 个点中选择 $i$ 个点. 要求无向图无重边, 剩余的边随意, 方案数为 $2^{\frac{1}{2} (n-1)(n-2)}$.</p><p>整理, 得 $$n \cdot 2^{\frac{1}{2} (n-1)(n-2)} \sum_{i=0}^{n-1} \ \binom{n-1}{i} i^k$$</p><p>现在的问题主要在后半部分, 由第二类 Stirling 数的性质, 得 $$\sum_{i=0}^{n-1} \ \binom{n-1}{i} \sum_{j=0}^{i} \  \begin{Bmatrix}k \\ j \end{Bmatrix}\ j!\ \binom{i}{j}$$</p><p>改变 $i, j$ 的枚举顺序, 有 $$\sum_{j=0}^{n-1}\ \begin{Bmatrix} k\\ j \end{Bmatrix} \cdot j! \ \sum_{i = j}^{n - 1}\ \binom{n-1}{i} \binom{i}{j}$$<br>不过要注意到 $\forall \ m &gt; n,\ \begin{Bmatrix} n \\ m \end{Bmatrix} = 0$</p><p>接下来的 trick 来源于 <a href="https://www.cnblogs.com/Tiw-Air-OAO/p/10286501.html" target="_blank" rel="noopener">Tiw’s Blog</a>, 考虑右边和式的组合意义, 即在 $n-1$ 个物品中选取 $i$ 个物品, 并在 $i$ 个物品中选择 $j$ 个的方案数. 可以发现, 这样等同于在 $n-1$ 个物品中选择 $j$ 个, 剩下部分可选可不选, 这样就同 $i$ 无关了. 可得 $$\sum_{j=0}^{n-1}\ \begin{Bmatrix} k\\ j \end{Bmatrix} \cdot j! \ \binom{n-1}{j}\ 2^{ n-1-j } \\ \sum_{j=0}^{n-1}\ \begin{Bmatrix} k\\ j \end{Bmatrix} \ \frac{(n-1)!}{(n-1-j)!}\ 2^{ n-1-j }$$</p><p>接下来就可以写了…</p><p>先计算 $k$ 对应的第二类 Stirling 数, 之后 $O(n)$ 扫一遍统计答案. 式子中间的一项在 $j$ 增加的过程中每次只多出一个乘积, 顺手维护就好了.</p><p>最后答案 $$n \cdot 2^{\frac{1}{2} (n-1)(n-2)} \sum_{j=0}^{n-1}\ \begin{Bmatrix} k\\ j \end{Bmatrix} \ \frac{(n-1)!}{(n-1-j)!}\ 2^{ n-1-j }$$</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">    Problem: 5093</span></span><br><span class="line"><span class="comment">    User: DepletedPrism</span></span><br><span class="line"><span class="comment">    Language: C++</span></span><br><span class="line"><span class="comment">    Result: Accepted</span></span><br><span class="line"><span class="comment">    Time:10104 ms</span></span><br><span class="line"><span class="comment">    Memory:20352 kb</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// BZOJ 5093</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>, G = <span class="number">3</span>, iG = <span class="number">332748118</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> m = P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % m;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> Lim, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> unit = fpow(type &gt; <span class="number">0</span>? G: iG, (P<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j, w = <span class="number">1L</span>L * w * unit % P) &#123;</span><br><span class="line">                    <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1L</span>L * w * f[i+j+Mid] % P;</span><br><span class="line">                    f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> inv = fpow(Lim, P<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * inv % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n, K;</span><br><span class="line"><span class="keyword">int</span> f[MAXN], g[MAXN];</span><br><span class="line"><span class="keyword">int</span> inv[MAXN], fac[MAXN];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;K);</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    inv[<span class="number">0</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i) fac[i] = <span class="number">1L</span>L * fac[i<span class="number">-1</span>] * i % P;</span><br><span class="line">    inv[K] = fpow(fac[K], P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = K; i; --i) inv[i<span class="number">-1</span>] = <span class="number">1L</span>L * i * inv[i] % P;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= K; ++i) &#123;</span><br><span class="line">        f[i] = (i &amp; <span class="number">1</span>)? P-inv[i]: inv[i];</span><br><span class="line">        g[i] = <span class="number">1L</span>L * fpow(i, K) * inv[i] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Lim &lt;= <span class="number">2</span>*K) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">    Poly::init(Lim, L), Poly::NTT(f, Lim, <span class="number">1</span>), Poly::NTT(g, Lim, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * g[i] % P;</span><br><span class="line">    Poly::NTT(f, Lim, <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, b = <span class="number">1L</span>L * (n<span class="number">-1</span>) * (n<span class="number">-2</span>) / <span class="number">2</span> % (P<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> inv2 = fpow(<span class="number">2</span>, P<span class="number">-2</span>), mul = <span class="number">1</span>, pow2 = fpow(<span class="number">2</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; i &lt;= K; ++i) &#123;</span><br><span class="line">        ans = (ans + <span class="number">1L</span>L * f[i] * mul % P * pow2 % P) % P;</span><br><span class="line">        mul = <span class="number">1L</span>L * mul * (n-i<span class="number">-1</span>) % P, pow2 = <span class="number">1L</span>L * pow2 * inv2 % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, <span class="number">1L</span>L * ans * fpow(<span class="number">2</span>, b) % P * n % P);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt; 组合数学学不明白祭.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://lydsy.com/JudgeOnline/problem.php?id=5093&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://lydsy.com/JudgeOnline/problem.php?id=5093&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据题意列出式子, 并通过第二类 Stirling 数对式子进行化简, 在合适的时间内计算出结果.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Combinatorics" scheme="https://depletedprism.github.io/tags/Combinatorics/"/>
    
      <category term="Polynomial" scheme="https://depletedprism.github.io/tags/Polynomial/"/>
    
  </entry>
  
  <entry>
    <title>小学数学之前 n 个正整数的 a 次方之和</title>
    <link href="https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/sum-of-n/"/>
    <id>https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/sum-of-n/</id>
    <published>2020-01-09T05:09:38.000Z</published>
    <updated>2020-01-28T14:58:26.256Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>我不如小学生.png</p></blockquote><p>作为高中生, 被小学奥 (chang) 数 (shi) 针对了.</p><p>于是, 这里集中了形如 $\sum_{i=1}^n i^a,\ (a = 1,\ 2,\ 3,\ \ldots )$, 即前 $n$ 个正整数的 $a$ 次方和的计算公式.</p><a id="more"></a><h2 id="简单结论"><a href="#简单结论" class="headerlink" title="简单结论"></a>简单结论</h2><p>首先, 有以下结论</p><p>$$\sum_{i=1}^n i = \frac{n(n+1)}{2}$$</p><p>$$\sum_{i=1}^n i^2 = \frac{n(n+1)(2n+1)}{6}$$</p><p>$$\sum_{i=1}^n i^{3} = \frac{n^2(n+1)^2}{4}$$</p><p>至此, 本文结束, <del>你不应该在这个乐色结论上浪费太多时间 (</del>.</p><h2 id="结论证明"><a href="#结论证明" class="headerlink" title="结论证明"></a>结论证明</h2><ul><li><p>$a = 1$</p><p>设 $S_n = \sum_{i=1}^n i$, 并容易发现这就是个公差为 $1$ 的等差数列, 直接上求和公式即可.</p><p>但是, 这是小学生的数学, 我们换一种方式</p><p>$$S_n = 1 + 2 + 3 + \cdots + (n-2) + (n-1) + n \\ S_n = n + (n-1) + (n-2) + \cdots + 3 + 2 + 1$$</p><p>显然有</p><p>$$2S_n = (n+1) + (n+1) + (n+1) + \cdots + (n+1) + (n+1) \\ S_n = \frac{n(n+1)}{2}$$</p><p>这是个数列里普通的技巧 “倒序相加”, <del>也就能拿来骗小学生玩了</del></p><p>但是这个方法不能推广到 $a=2$ 的情况, 于是继续换一种方式</p><p>我们有 $(k-1)^2 = k^2 - 2k + 1$, 移项得 $k^2 - (k-1)^2 = 2k - 1$</p><p>所以 $$\sum_{k=1}^n k^2 - \sum_{k=1}^n (k-1)^2 = 2\sum_{k=1}^n k - n$$</p><p>$$\sum_{k=1}^n k^2 - \sum_{k=1}^{n-1} k^2 = 2\sum_{k=1}^n k - n$$</p><p>所以 $$n^2 = 2S_n - n \\ S_n = \frac{n(n+1)}{2}$$</p></li><li><p>$a = 2$</p><p>同样, 设 $S_n = \sum_{i=1}^n i^2$, 有 $(k-1)^3 = k^3 - 3k^2 + 3k - 1$</p><p>移项, 得 $$k^3 - (k-1)^3 = 3k^2 - 3k + 1$$</p><p>所以 $$\sum_{i=1}^n k^3 - \sum_{i=1}^n (k-1)^3 = 3 \sum_{k=1}^n k^2 - 3 \sum_{i=1}^n k + n$$</p><p>$$\sum_{i=1}^n k^3 - \sum_{i=1}^{n-1} k^3 = n^3 = 3 \sum_{k=1}^n k^2 - 3 \sum_{i=1}^n k + n$$</p><p>经过一番代换, 有 $$\sum_{k=1}^n k^2 = \frac{1}{3} n^3 + \frac{1}{2} n^2 + \frac{1}{6} n = \frac{n(n+1)(2n+1)}{6}$$</p></li><li><p>$a = 3$</p><p>同理可得, 留给读者当作练习 (</p><p>$$\sum_{i=1}^n i^3 = \frac{n^2(n+1)^2}{4}$$</p><p>当然, 这个公式有另一种理解方式  $$\sum_{i=1}^n i^3 = (\sum_{i=1}^n i)^2 = \frac{n(n+1)}{2} \cdot \frac{n(n+1)}{2}$$</p><p>这是为什么呢, 可以参考 <a href="https://proofwiki.org/wiki/Sum_of_Sequence_of_Cubes/Proof_by_Nicomachus" target="_blank" rel="noopener">Nicomachus’s Proof</a></p></li><li><p>$a \geq 4$</p><p>可以用很多方法做, 然而我只会拉格朗日插值.</p><ul><li><p>拉格朗日插值</p><p>详见 <a href="https://codeforces.com/problemset/problem/622/F" target="_blank" rel="noopener">CF622F The Sum of the k-th Powers</a>, 好的实现可以在 $O(a)$ 的时间内计算.</p></li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://brilliant.org/wiki/sum-of-n-n2-or-n3/" target="_blank" rel="noopener">https://brilliant.org/wiki/sum-of-n-n2-or-n3/</a></li><li><a href="https://proofwiki.org/wiki/Sum_of_Sequence_of_Cubes" target="_blank" rel="noopener">https://proofwiki.org/wiki/Sum_of_Sequence_of_Cubes</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;我不如小学生.png&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为高中生, 被小学奥 (chang) 数 (shi) 针对了.&lt;/p&gt;
&lt;p&gt;于是, 这里集中了形如 $\sum_{i=1}^n i^a,\ (a = 1,\ 2,\ 3,\ \ldots )$, 即前 $n$ 个正整数的 $a$ 次方和的计算公式.&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://depletedprism.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Polynomial" scheme="https://depletedprism.github.io/tags/Polynomial/"/>
    
  </entry>
  
  <entry>
    <title>「CERC2014」Virus synthesis 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P4762/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P4762/</id>
    <published>2020-01-07T11:01:44.000Z</published>
    <updated>2020-02-24T08:55:07.157Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P4762" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P4762</a></li></ul><p>一道回文自动机 + DP 的题, 感觉能启发思路以及学习到一些技巧, 故记之.</p><a id="more"></a><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>假设字符串 $S$ 的长度为 $n$, 容易想到 $O(n^3)$ 的区间 DP 做法, 但是不大可取 = =, 状态数就已经到达了 $O(n^2)$.</p><p>于是换一种思路, 设 $f(i)$ 表示构造 PAM 上第 $i$ 个节点所代表的回文串, 且 $len(i)$ 为偶数, 所需要的最少操作次数, 那么</p><ul><li><p>对于 $i$ 的子节点 $j$, 有 $f(j) = f(i) + 1$</p><p>因为 PAM 的节点表示一个回文串, 那么 $j$ 代表的回文串可以视为 $i$ 代表的回文串两端多出一个字符. 因为 $i$ 是回文串, 考虑在构造字符串 $i$ 时, 一定会有一次 2 操作, 否则就不是最优解. 那么, 我们就可以在这次 2 操作之前, 在 $i$ 的某端添加一个字符, 这样从 $i$ 到 $j$ 只需要一次操作.</p></li><li><p>假设 $j$ 是 $i$ 的一个回文后缀, 且满足 $2 \cdot len(j) \leq len(i)$, 有  $$f(i) = \min{f(j) + 1 + len(i) / 2 - len(j)}$$</p><p>这里将 $i$ 视为 $j$ 通过 1 操作填到一半, 再通过一次 2 操作构造而来.</p></li></ul><p>然后答案很好统计了, 可以把最终的字符串视为一个回文串和多次 1 操作堆叠而成, 那么 $$ans = \min{f(i) + n - len(i)}$$</p><p>现在的问题就是如何实现转移. </p><p>对于第一个转移, 没什么好说的, 在 PAM 偶节点从上到下 BFS 一遍就好了, (似乎有在线的做法, 在新加入节点时更新 $f(i)$ 的值).</p><p>对于第二个转移, 需要处理出满足 $i$ 满足 $2 \cdot len(j) \leq len(i)$ 的最长回文后缀, 记为 $trans(i)$ 可以通过求 fail 类似的方法维护, 只是在跳 fail 的时候多了一个限制条件, 相同的技巧也在 <a href="https://www.luogu.com.cn/problem/P4287" target="_blank" rel="noopener">[SHOI2011]双倍回文</a> 使用过.</p><h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P4762</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">5</span>, SIGMA = <span class="number">4</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> M[<span class="number">128</span>], f[MAXN];</span><br><span class="line"><span class="keyword">char</span> S[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PAM &#123;</span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][SIGMA], len[MAXN], trans[MAXN], fail[MAXN], last, nidx, ptr;</span><br><span class="line">    <span class="keyword">char</span> S[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="keyword">sizeof</span> ch);</span><br><span class="line">        last = <span class="number">0</span>, nidx = <span class="number">1</span>;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>, fail[<span class="number">0</span>] = <span class="number">1</span>, len[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        S[ptr = <span class="number">0</span>] = <span class="string">'$'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getfail</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (S[ptr-len[u]<span class="number">-1</span>] != S[ptr]) u = fail[u];</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        S[++ptr] = c;</span><br><span class="line">        <span class="keyword">int</span> val = M[(<span class="keyword">int</span>) c], nd = getfail(last);</span><br><span class="line">        <span class="keyword">if</span> (!ch[nd][val]) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = ++nidx;</span><br><span class="line">            len[p] = len[nd] + <span class="number">2</span>;</span><br><span class="line">            fail[p] = ch[getfail(fail[nd])][val];</span><br><span class="line">            <span class="keyword">if</span> (len[p] &lt;= <span class="number">2</span>) trans[p] = fail[p];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> u = trans[nd];</span><br><span class="line">                <span class="comment">// int u = fail[nd];</span></span><br><span class="line">                <span class="comment">// 如果写成以上写法, 复杂度就是假的 = =</span></span><br><span class="line">                <span class="keyword">while</span> (S[ptr-len[u]<span class="number">-1</span>] != S[ptr] || <span class="number">2</span>*(len[u]+<span class="number">2</span>) &gt; len[p]) u = fail[u];</span><br><span class="line">                trans[p] = ch[u][val];</span><br><span class="line">            &#125;</span><br><span class="line">            ch[nd][val] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        last = ch[nd][val];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> Q[MAXN], head, tail, ret;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        ret = n, f[<span class="number">0</span>] = <span class="number">1</span>, Q[head = tail = <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意答案的最大值为 n, 如果不存在长度为偶数的回文串, 那么 min&#123;f&#125; = INF...</span></span><br><span class="line">        <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q[head++];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; SIGMA; ++c) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = ch[u][c];</span><br><span class="line">                <span class="keyword">if</span> (!i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> j = trans[i];</span><br><span class="line">                f[i] = min(f[i], min(f[u] + <span class="number">1</span>, f[j] + <span class="number">1</span> + len[i] / <span class="number">2</span> - len[j]));</span><br><span class="line">                ret = min(ret, f[i] + n - len[i]);</span><br><span class="line">                Q[++tail] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"1.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    M[<span class="string">'A'</span>] = <span class="number">0</span>, M[<span class="string">'C'</span>] = <span class="number">1</span>, M[<span class="string">'G'</span>] = <span class="number">2</span>, M[<span class="string">'T'</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> Ti;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        PAM::init();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S+<span class="number">1</span>);</span><br><span class="line">        n = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(S+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) PAM::insert(S[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, PAM::solve());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h4><p>上述代码成功拿到了 67 pts 的好成绩, 在第一个点跑了很久…</p><p>通过学习其他人的卡常技巧, 算是卡了过去</p><ol><li>用到再初始化 <code>ch</code> 的值</li><li>BFS 遍历 PAM 时, 每个节点只更新一次</li><li>给 $f(i)$ 赋初值为节点的长度 $len(i)$, 并只在 $len(i)$ 为偶数的时候更新 $f(i)$</li><li>使用 <code>ckmin</code> 更新最小值</li></ol><p>话说用 <code>static</code> 把数组开到函数里会快一点? 不明所以.png</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P4762</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">5</span>, SIGMA = <span class="number">4</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> M[<span class="number">128</span>], f[MAXN];</span><br><span class="line"><span class="keyword">char</span> S[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PAM &#123;</span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][SIGMA], len[MAXN], trans[MAXN], fail[MAXN], last, nidx, ptr;</span><br><span class="line">    <span class="keyword">char</span> S[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.</span></span><br><span class="line">        <span class="built_in">memset</span>(ch[<span class="number">0</span>], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">memset</span>(ch[<span class="number">1</span>], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[<span class="number">1</span>]);</span><br><span class="line">        last = <span class="number">0</span>, nidx = <span class="number">1</span>;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>, fail[<span class="number">0</span>] = <span class="number">1</span>, len[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        S[ptr = <span class="number">0</span>] = <span class="string">'$'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getfail</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (S[ptr-len[u]<span class="number">-1</span>] != S[ptr]) u = fail[u];</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        S[++ptr] = c;</span><br><span class="line">        <span class="keyword">int</span> val = M[(<span class="keyword">int</span>) c], nd = getfail(last);</span><br><span class="line">        <span class="keyword">if</span> (!ch[nd][val]) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = ++nidx;</span><br><span class="line">            <span class="comment">// 1.</span></span><br><span class="line">            <span class="built_in">memset</span>(ch[p], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[p]);</span><br><span class="line">            len[p] = len[nd] + <span class="number">2</span>;</span><br><span class="line">            fail[p] = ch[getfail(fail[nd])][val];</span><br><span class="line">            <span class="keyword">if</span> (len[p] &lt;= <span class="number">2</span>) trans[p] = fail[p];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> u = trans[nd];</span><br><span class="line">                <span class="keyword">while</span> (S[ptr-len[u]<span class="number">-1</span>] != S[ptr] || <span class="number">2</span>*(len[u]+<span class="number">2</span>) &gt; len[p]) u = fail[u];</span><br><span class="line">                trans[p] = ch[u][val];</span><br><span class="line">            &#125;</span><br><span class="line">            ch[nd][val] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        last = ch[nd][val];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ckmin</span><span class="params">(T&amp; x, <span class="keyword">const</span> T&amp; y)</span> </span>&#123; <span class="keyword">if</span> (x &gt; y) x = y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> vis[MAXN], Time, Q[MAXN], head, tail, ret;</span><br><span class="line">        ++Time;</span><br><span class="line">        <span class="comment">// 3.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nidx; ++i) f[i] = len[i];</span><br><span class="line">        ret = n, f[<span class="number">0</span>] = <span class="number">1</span>, Q[head = tail = <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q[head++];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; SIGMA; ++c) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = ch[u][c];</span><br><span class="line">                <span class="keyword">if</span> (!i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> j = trans[i];</span><br><span class="line">                f[i] = f[u] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 3.</span></span><br><span class="line">                <span class="keyword">if</span> (len[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                    ckmin(f[i], f[j] + <span class="number">1</span> + len[i] / <span class="number">2</span> - len[j]);</span><br><span class="line">                ckmin(ret, f[i] + n - len[i]);</span><br><span class="line">                <span class="comment">// 2.</span></span><br><span class="line">                <span class="keyword">if</span> (vis[i] != Time) Q[++tail] = i, vis[i] = Time;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"1.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    M[<span class="string">'A'</span>] = <span class="number">0</span>, M[<span class="string">'C'</span>] = <span class="number">1</span>, M[<span class="string">'G'</span>] = <span class="number">2</span>, M[<span class="string">'T'</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> Ti;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        PAM::init();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S+<span class="number">1</span>);</span><br><span class="line">        n = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(S+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) PAM::insert(S[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, PAM::solve());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://www.luogu.com.cn/problem/P4762&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.com.cn/problem/P4762&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一道回文自动机 + DP 的题, 感觉能启发思路以及学习到一些技巧, 故记之.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Dynamic Programing" scheme="https://depletedprism.github.io/tags/Dynamic-Programing/"/>
    
      <category term="String" scheme="https://depletedprism.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>「SCOI2012」喵星球上的点名 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2336/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2336/</id>
    <published>2020-01-02T12:47:48.000Z</published>
    <updated>2020-02-24T08:53:16.725Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P2336" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P2336</a></li></ul><p>一道后缀数组的题, 毒瘤了我大半个晚上, 故写题解以纪念.</p><a id="more"></a><h4 id="一些约定"><a href="#一些约定" class="headerlink" title="一些约定"></a>一些约定</h4><ol><li>字符串下标从 $1$ 开始</li><li>记 $sa[i]$ 表示字符串所有后缀排序后第 $i$ 大的后缀的编号, $rnk[i]$ 表示后缀 $i$ 在 $sa$ 中的下标, 即后缀 $i$ 在所有后缀中的排名</li></ol><h4 id="运用到-SA-的性质"><a href="#运用到-SA-的性质" class="headerlink" title="运用到 SA 的性质"></a>运用到 SA 的性质</h4><ol><li><p>SA 中前缀相同的串排在一起, 也就是说, SA 按照字典序对所有后缀排序</p></li><li><p>两子串最长公共前缀 $$\text{LCP}(sa[i], sa[j]) = \min_{k = i+1}^j { \text{height[k]} }$$</p></li></ol><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>首先, 我们的任务是确定一个字符串是不是一个字符串的子串, 可以联想到的算法有 AC 自动机, 哈希之类的东西… 不过这道题的字符集大小达到了 $10^4$, 感觉 SA 似乎更可做一点.</p><p>那么, 怎么用 SA 确定一个字符串是否是另一个字符串的子串呢? 可以通过 LCP 来做.</p><p>现在有一个显然的事情, 如果一个字符串 $S$ 是 $T$ 的子串, 那么 $T$ 存在一个后缀 $T’$, 使得 $\text{LCP}(S, T’) = |S|$.</p><p>对于一个 $S$ 和一个 $T$, 可以将 $S,\ T$ 拼接成一个新串, 中间用一个从未出现过的字符连接, 通过对新串求后缀数组, 然后再二分判定.</p><p>回到这道题上来, 对于多个 $S$, $T$, 也可以用相同的方式. 对于一个 “点名串” $S$, 包含 $S$ 的字符串一定在 $sa$ 是一段连续的区间. 那么, 现在的问题就是序列上的问题了.</p><ol><li>区间 $[L, R]$ 中不同猫的个数;</li><li>询问完之后猫的点名次数.</li></ol><p><del>存在使用树状数组 / 线段树的做法, 可惜实在学不会, 于是使用了莫队</del></p><p>考虑莫队, 第一个问题比较经典, 开一个桶记录猫在现在维护区间内出现次数, 在出现次数改变为 0 / 1 时更新答案就可以了. 对于第二个问题, 参考了 <a href="https://www.luogu.com.cn/blog/hl666/solution-p2336" target="_blank" rel="noopener">hl666 的题解</a> = =, 每次有新的猫进入区间, 或者一只猫已经完全离开现在的区间时, 更新当前情况下被点到次数的最大值.</p><p>但是这样为什么是对的呢? 考虑一只猫进出区间的两个过程, 虽然我们在进入区间的时候给他算上了最大的可能点名次数, 但是在离开又减去了可能的最大值. 感性理解一下, 差值就像是正确答案…</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>写起来 rnk, sa, idx 翻来覆去 = =</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P2336</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"><span class="comment">// 普通的读入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span>+<span class="number">5</span>, MAXM = <span class="number">1e4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> block;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> idx, L, R;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Ask&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> R / block == rhs.R / block? (L == rhs.L? <span class="number">0</span>: ((R / block) &amp; <span class="number">1</span>) &amp; (L &lt; rhs.L)): R &lt; rhs.R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Q[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, N, q;</span><br><span class="line"><span class="keyword">int</span> A[MAXN];</span><br><span class="line"><span class="keyword">int</span> S[MAXN]; <span class="comment">// 拼接后的数组</span></span><br><span class="line"><span class="keyword">int</span> idx[MAXN]; <span class="comment">// 拼接后第 i 个位置对应原字符串的编号</span></span><br><span class="line"><span class="keyword">int</span> firstpos[MAXN]; <span class="comment">// 点名串对应在 S 中的位置, 二分区间左右端点使用</span></span><br><span class="line"><span class="keyword">int</span> qlen[MAXN]; <span class="comment">// 点名串长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> id)</span> </span>&#123; S[++n] = val, idx[n] = id; &#125; <span class="comment">// 更新 S</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SA &#123;</span><br><span class="line">    <span class="keyword">int</span> sa[MAXN], rnk[MAXN], id[MAXN], px[MAXN], ht[MAXN], cnt[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[x] == id[y] &amp;&amp; id[x+k] == id[y+k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, k, p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) ++cnt[rnk[i] = S[i]];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i) cnt[i] += cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i = n; i; --i) sa[cnt[rnk[i]]--] = i;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n &amp;&amp; p &lt; n; k &lt;&lt;= <span class="number">1</span>, m = p) &#123;</span><br><span class="line">            <span class="keyword">for</span> (p = <span class="number">0</span>, i = n; i &gt; n-k; --i) id[++p] = i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (sa[i] &gt; k) id[++p] = sa[i]-k;</span><br><span class="line">            <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> (<span class="keyword">int</span>) * (m+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) ++cnt[px[i] = rnk[id[i]]];</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i) cnt[i] += cnt[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span> (i = n; i; --i) sa[cnt[px[i]]--] = id[i]; <span class="comment">// 这里打挂过</span></span><br><span class="line">            swap(rnk, id), rnk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++i) rnk[sa[i]] = cmp(sa[i], sa[i<span class="number">-1</span>], k)? p: ++p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) rnk[sa[i]] = i; <span class="comment">// 这里打挂过</span></span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>, i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k) --k;</span><br><span class="line">            <span class="keyword">while</span> (S[i + k] == S[sa[rnk[i]<span class="number">-1</span>] + k]) ++k;</span><br><span class="line">            ht[rnk[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> SA::rnk; <span class="keyword">using</span> SA::sa;</span><br><span class="line"><span class="comment">// SA 倍增实现模板</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ST &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> LOG = <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">int</span> minHt[LOG][MAXN], lg2[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) minHt[<span class="number">0</span>][i] = SA::ht[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; LOG; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span> &lt;= n; ++i)</span><br><span class="line">                minHt[j][i] = min(minHt[j<span class="number">-1</span>][i], minHt[j<span class="number">-1</span>][i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))]);</span><br><span class="line">        lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) lg2[i] = lg2[i/<span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">RMQ</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = lg2[R-L+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> min(minHt[k][L], minHt[k][R-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现 RMQ</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MoAlg &#123;</span><br><span class="line">    <span class="keyword">int</span> L, R, ans1;</span><br><span class="line">    <span class="keyword">int</span> Ans1[MAXN], Ans2[MAXN], cnt[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        pos = idx[pos];</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= N &amp;&amp; ++cnt[pos] == <span class="number">1</span>) ++ans1, Ans2[pos] += q-cur+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 只统计编号在猫范围之内的种类数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        pos = idx[pos];</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= N &amp;&amp; --cnt[pos] == <span class="number">0</span>) --ans1, Ans2[pos] -= q-cur+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 只统计编号在猫范围之内的种类数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        block = <span class="keyword">int</span>( n / <span class="built_in">sqrt</span>(q) );</span><br><span class="line">        sort(Q+<span class="number">1</span>, Q+<span class="number">1</span>+q);</span><br><span class="line">        L = <span class="number">1</span>, R = ans1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> Ask&amp; qr = Q[i];</span><br><span class="line">            <span class="keyword">while</span> (L &gt; qr.L) add(sa[--L], i);</span><br><span class="line">            <span class="keyword">while</span> (R &gt; qr.R) del(sa[R--], i);</span><br><span class="line">            <span class="keyword">while</span> (L &lt; qr.L) del(sa[L++], i);</span><br><span class="line">            <span class="keyword">while</span> (R &lt; qr.R) add(sa[++R], i);</span><br><span class="line">            Ans1[qr.idx] = ans1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> MoAlg::Ans1; <span class="keyword">using</span> MoAlg::Ans2;</span><br><span class="line"><span class="comment">// 莫队</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(N), read(q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k, i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        read(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) read(A[j]), add(A[j]+<span class="number">1</span>, i);</span><br><span class="line">        add(MAXM + <span class="number">2</span>*i<span class="number">-1</span>, N+<span class="number">1</span>);</span><br><span class="line">        read(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) read(A[j]), add(A[j]+<span class="number">1</span>, i);</span><br><span class="line">        add(MAXM + <span class="number">2</span>*i, N+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k, i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        read(k), qlen[i] = k, firstpos[i] = n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) read(A[j]), add(A[j]+<span class="number">1</span>, N + i);</span><br><span class="line">        add(MAXM + <span class="number">2</span>*N + i, N+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    SA::build(MAXM + <span class="number">2</span>*N + q), ST::init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> L, R, qL, qR;</span><br><span class="line">        L = <span class="number">1</span>, R = rnk[firstpos[i]]<span class="number">-1</span>, qL = rnk[firstpos[i]];</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// LCP, 注意到 +1</span></span><br><span class="line">            <span class="keyword">if</span> (ST::RMQ(Mid + <span class="number">1</span>, rnk[firstpos[i]]) &gt;= qlen[i]) qL = Mid, R = Mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> L = Mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        L = rnk[firstpos[i]]+<span class="number">1</span>, R = n, qR = rnk[firstpos[i]];</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// LCP, 注意到 +1</span></span><br><span class="line">            <span class="keyword">if</span> (ST::RMQ(rnk[firstpos[i]] + <span class="number">1</span>, Mid) &gt;= qlen[i]) qR = Mid, L = Mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> R = Mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Q[i] = (Ask)&#123; i, qL, qR &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    MoAlg::solve();</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans1[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, Ans2[i], <span class="string">" \n"</span>[i==N]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="得出的一些调试的经验"><a href="#得出的一些调试的经验" class="headerlink" title="得出的一些调试的经验?"></a>得出的一些调试的经验?</h4><ol><li>如果不保证模板的正确性, 先检查以下板子… = =</li><li><del>抄题解的时候注意一些细节, 以免调试半天发现是细节问题</del></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://www.luogu.com.cn/problem/P2336&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.com.cn/problem/P2336&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一道后缀数组的题, 毒瘤了我大半个晚上, 故写题解以纪念.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Data Structure" scheme="https://depletedprism.github.io/tags/Data-Structure/"/>
    
      <category term="String" scheme="https://depletedprism.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>2019 CSP-S 游记</title>
    <link href="https://depletedprism.github.io/%E9%9A%8F%E7%AC%94/CSP-S-2019/"/>
    <id>https://depletedprism.github.io/%E9%9A%8F%E7%AC%94/CSP-S-2019/</id>
    <published>2019-11-17T10:04:45.000Z</published>
    <updated>2019-12-07T13:11:44.150Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>公无渡河，公竟渡河！</p><p>堕河而死，其奈公何！</p></blockquote><p>新的 OI 赛事又要开始了.</p><a id="more"></a><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>早一天 (Day -1) 就回家了, 看了考场还算满意, 或许是自己的要求不够高? 熟悉的 win7 x86 &amp; 2 GB RAM 令人想起之前的老台式… 不过 win7 内存占用很少, 考场系统除了红蜘蛛以外还算干净, 因此 2 GB 用起来还算流畅.</p><p>软件配置和去年类似, 有 Vim 和 Dev-cpp 我就满足了. Dev-cpp 虽然不好用, 但是作为现场唯一提供的 C++ IDE 还是要尊重一下的 (雾, 毕竟 windows 的 cmd 用起来有种说不出的别扭, 有朝一日在考场用上 Linux, 再用命令行编译吧.</p><p>手写注册表改了改键盘映射, 罪恶的 Caps 和 Esc 回到了科学的位置, 临时背的注册表好像有点锅, 不想修了. 本想在试机的时候刷个板子熟悉一下键盘, 后来因为有家长在等就作罢了.</p><p>HA 省机房槽点还是挺多的, 键盘主键盘区的 Enter 生怕不被误触而做的出奇的大, Backspace 为鼓励不写错而惊人的小… 其次就是空调足以把人热 sha, 通风也不是很好, 整体的空气有一种封闭的感觉.</p><p>到家后开始刷知乎, <del>我也不知道为什么就刷了很久</del>, 晚上意识到自己太颓, 随便找了到自己鸽掉的 NOIP 真题写了一道, 思路不假, 只是可惜实现时还是参考题解, 希望在明天自己的代码思路能更明了一些吧.</p><p>回想了最近复习的流程, 还有些不常打的模板没有写, 因为不常打所以不熟, 然后就不想打 = =. 一意识到自己还有没打好的板子, 有种晕眩的紧张感. (还是不要太紧张好了.) 复习的过程还是有漏洞, 对于以往难写一点的 NOIP 题目, 应该在这周再写写, 同学从 qbxt 带来的模拟题, 也是要写写的. 但是这些事情都没有做, 只好携我两袖清风, 踏上考场了.</p><p>这周在学校的几个晚上不能用电脑, 无聊翻翻紫书权作复习. LRJ 的书果然是 OI 真理啊</p><blockquote><p>但是有一点需要注意: 理解一个题解和自己独立推导出所有细节还是不一样的, 所以在看完一个难题题解之后最好把它做两遍: 一遍是刚看完题解以后 “趁热打铁”, 一遍是等忘掉题解后自己从头推导一遍.</p><p>—— 刘汝佳 &lt;算法竞赛入门经典 (第 2 版)&gt;</p></blockquote><p>附, windows 下修改注册表使得 Esc 和 Caps 互换的注册表文件, <del>还是喜欢 Linux 一行命令解决的简单方式</del>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Kayboard Layout]</span><br><span class="line">&quot;Scancode Map&quot;=hex:00,00,00,00,00,00,00,00,03,00,00,00,3A,00,01,00,01,00,3A,00,00,00,00,00</span><br></pre></td></tr></table></figure><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>七点五十多的时候发现大家都到了, 其实我到得还算早, 只是恰饭浪费了时间… 会合后照例谈笑风生, 开始各路毒奶:</p><blockquote><p>“请问有省四这种奖吗?”</p><p>“我现在开坑 CSP-S 2019 Day 1 题解, CCF 会不会把我禁赛三年啊?”</p><p>“我 Day 1 是不可能 200 分以上的, 我要是考到 200 分以上就女装.”</p><p>“我拿一等我就女装.”‘</p><p>“您是不是 AK Day 1, 明天就不用来了?”</p><p>……</p></blockquote><p><del>啊, 这群人考好点就有戏看了</del>~</p><p>咳咳咳.</p><p><strong>Ren2Zhen0Si1Kao9?</strong></p><p>进场后, 空气比昨天要好很多了, 配置考场环境也没有出什么大问题. </p><p>拿到题后, 强迫自己看完三题题意, 本想直接写 T1 的, <del>怕不是 CF 写多了</del>, 后来还是等半小时后再动键盘.</p><ul><li><p>T1</p><p>看到给出 “格雷码” 的完整构造方案以为这题和 <a href="https://www.luogu.org/problem/P2615" target="_blank" rel="noopener">神奇的幻方</a> 同源, 看完数据范围后才发现直接模拟会挂…</p><p>考虑了一下, 写出了一个构造方案, 感觉可行就直接写代码了, (但是应去手算一下样例的, 这样就可以避免接下来会出现的错误了)</p><p>结果没过第二个样例, 确认代码没什么问题之后就又去读了一遍题, 果然是题目细节有疏漏, 修修补补算是过了三个给定的样例.</p><p>考试时 WA T1 就直接重读题意的想法来自昨天刷知乎得到的经验, 这里想引用一句话</p><blockquote><p>一般这种题写挂就是没读懂题意, 回去重读题意就好了.</p></blockquote><p><del>你看我刷逼乎还是有点用的</del> (大雾)</p><p>最大的遗憾就是没有写暴力拍 T1</p></li><li><p>T2</p><p>看到题目后就有 $O(n^4)$ 的带暴力想法, 本着 <del>NOIP</del> CSP-S 暴力打满的精神就先写暴力, 写出来前两个样例直接过了, 开始考虑怎么优化. 想了一会有 $O(n^3)$ 的 DP. 当时我兴致勃勃的去打这个 $O(n^3)$ 的 DP, 因为我算错复杂度以为这是 $O(n^2)$ 能拿到 $50\ pts$.</p><p>好在写出来之后及时发现时间复杂度是假的, 更好的事情是, 再优化到 $O(n^2)$ 也不算难. 改完没能过样例, 心态有点爆炸, 调整一会心态之后部分重构了, 算是过了第二组大样例.</p><p>临近考试结束, 拿着 $O(n^3)$ 的暴力拍了一下, 即便用脚随的数据很假也算是过了几十组. 脑子一热拿这破机子去跑了 恶 臭 不 堪 的第三组样例, 本机上 RE, 检查了一下认为是本地爆栈的问题就不打算管了, 毕竟我也不会手动开栈这种 “禁赛三年” 的操作… (雾, 你的手动 O2 是怎么学会的)</p><p>感觉这题放在 Day 1 T2 应该不会是难题, 可能是我有关键点没有把握, 没能想出来正解是我的无能. 如果因为 T2 退役也是不会令人懊恼的事了. 竞赛的事情啊, 还是以个人实力为基础吧.</p></li><li><p>T3</p><p>很像是贪心的样子, 不过有贪心策略就能在 $O(n)$ 的时间得到答案, 所以我一直在想枚举一点, 贪心一点的算法. </p><p>只是…没有什么好策略.</p><p>刚开始拿到题目之后, 肤浅地认为这题的分应该好拿, 解决特殊性质和小数据就可以得到不错的分数, 而链和菊花的情况也会好想一点. 后来的事, 就是我想多了.</p><p>$O(T\cdot n!)$ 的带暴力好哇! 虽然写的时候心不在焉, 导致自己调了好久…</p></li></ul><p>离开考场之后见到 star, <del>听完情况之后一脸失望.jpg</del>.</p><p>下午看了看民间数据, 好多人表示 “T1 大样例都过了, 可是交上去却没拿满.”, 有点心慌, 看来对拍一定要写, CSP-S 还是稳一点好. T2 有 $O(n)$ 的 DP 做法, 没想到的原因除去我太菜, 还有时间复杂度死找 log… 最近写比赛总是被数据范围误导, Day 2 要抛开 &amp;&amp; 灵活一点了.</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>昨天周围的人大多没有考得很好（指达到贵乎 $210 pts$ 水平），今天表情都挺阴沉的，可能都在想翻盘的事吧</p><p><strong>@zhuajin1SHIJIAN7</strong></p><ul><li><p>T1</p><blockquote><p>只要我 T1 能写出来，在 HA 我可以绝杀！NOIp 提高组 Day 2 T1 你能秒我，我当场就把这个电脑屏幕，给吃、下、去！</p></blockquote><p>好的，T1 愉快的写炸了</p><p>开考前毒奶“今天不会有数数题吧？”，算是奶到了？开始认为是组合计数、容斥原理之类的东西，加加减减乘乘除除就可以了，以及模拟赛计数题就没有写对几题的经验，开考之后把 T1 先搁置了，愉快地去看 T2 以及 T3 了</p><p>T2，T3 暴力写完之后一直在想 T1 的正解，无果，于是就有了上面那段自嘲的段子。结果到 11:30 的时候 T1 暴力搜索还没有打出来，心态近乎崩溃，有一种挣扎无望的感觉，最后提交代码的时候也只好交了过不了第二个样例的假暴力。</p><p>实际上暴力可以拿到 $40 pts$，没有打的确可惜啊</p></li><li><p>T2<br>一眼看过去有斜率优化 DP 的味道，推了推式子感觉能做，写的时候发现假了，要求新数据的规模能够递增这个限制没有考虑到</p><p>想到 T1 没有 A 掉的把握心有点凉 = =，所以愉快地打起了 $O(n^3)$ 的暴力 DP，没能优化到 $O(n^2)$ 或是 $O(n^2\log n)$，于是 $36 pts$ 滚粗</p><p>考虑 T2 的时候有监考老师过来：“对于 type=0 的所有测试点，保证最后输出的答案 $\leq 4×10^{18}$”。赛后出题人称使用高精是为了防止取模会直接 pass 掉 DP 做法，不过贪心策略也没能想出来，告辞</p></li><li><p>T3<br>动态求重心 X<br>暴力求重心 X<br>大暴力求重心 √</p><p>重心板子执意没有复习，论据：“重心这东西也就点分治用过啊，CSP-S 不会考点分治吧？”诚然，没有考点分治，但是这一点都不影响 CSP-S 考重心 = =</p><p>原来的期望做法为 $O(n)$ 枚举边，$O(n)$ 求重心，总计 $O(n^2)$ 可拿到 $40 pts$，不过忘记了 $O(n)$ 求重心的做法，考场脑补了一会也只给出了 $O(n^2)$ 的做法，于是总计 $O(n^3)$ $25 pts$ 结 束 战 斗</p></li></ul><p>今年的 CSP-S 结束了，明天就要回班里补文化课了。估了一下分数, 可能算是省二左右的分数吧. 如果就此退役, 也没有什么不好. 或许是之前的想法太过于极端了, 偏执地认为不学 OI 就没有什么想要继续去做的事情了, 但是如果真的发生了, 还是会偏向默默接受的态度吧.</p><p>期望得分: $100 + 50 + 10 + 0 + 36 + 25 = 221 pts$</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>CCF 的官方成绩出来了, 比期望得分要高一些, 看教练那里的排名, 借着 HA 省是弱省的优势也能够拿到省一了.</p><p>实际得分: $100 + 50 + 10 + 8 + 36 + 40 = 244 pts$</p><p>Day2 T3 的 $O(n^3)$ 暴力似乎拿到了 $O(n^2)$ 的分数? 感谢 CCF 少爷机 (</p><p>今年的遗憾就是没能 CSP-S 没能上 $300 pts$ 了, Day 2 发挥的尤为不好, 坐在考场上没有蓄势待发, 激情四射的感觉, 从内心似乎有些颓势吧, 思维也不是相当的活跃. 之前总是有一种错觉, 偏执地认为自己是 “大赛型” 选手, 平常写不出来的题, 到考场上或许就能写出来了; 平时容易错的东西, 到考场上也许就可以不出锅了. 其实不是这样.</p><p>原来自己之前只是机械的找题, 写题, 学算法, 没有注重于自己独立思索的能力. 以后要多加注意了. </p><p>省选, 再会了.</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;公无渡河，公竟渡河！&lt;/p&gt;
&lt;p&gt;堕河而死，其奈公何！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;新的 OI 赛事又要开始了.&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://depletedprism.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>最小路径覆盖问题 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2764/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2764/</id>
    <published>2019-10-14T12:57:30.000Z</published>
    <updated>2019-10-14T13:08:42.678Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接：<a href="https://www.luogu.org/problem/P2764" target="_blank" rel="noopener">https://www.luogu.org/problem/P2764</a></li></ul><p>匈牙利算法就是好</p><a id="more"></a><p>尽管洛谷把网络构造方法给明了，但是拦不住我写匈牙利啊 = =</p><p>先不加证明地给出一个定理：</p><blockquote><p>有向无环图的最小路径点覆盖包含的路径条数 = 点数 - 其拆点二分图的最大匹配数。</p></blockquote><p>拆点二分图根据原图构造。</p><p>将原图的每个点 $i$，拆为 $i$，$i’$。对于原图的一条边 $(u,\ v)$，在二分图中连边 $(u,\ v’)$</p><p>输出方案则根据匹配边输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P2764</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span>&amp; <span class="title">x</span>) &#123;</span></span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f |= ch == <span class="string">'-'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">505</span>, MAXM = <span class="number">6005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> nxt, to;</span><br><span class="line">    &#125; edges[MAXM];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN &lt;&lt; <span class="number">1</span>], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head); eidx = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> KM &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">int</span> left[MAXN], T[MAXN], Time;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edges[i].to;</span><br><span class="line">            <span class="keyword">if</span> (T[v] == Time) <span class="keyword">continue</span>;</span><br><span class="line">            T[v] = Time;</span><br><span class="line">            <span class="keyword">if</span> (left[v] == <span class="number">-1</span> || match(left[v])) &#123;</span><br><span class="line">                left[v] = u; left[u] = v;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        u += n;</span><br><span class="line">        <span class="keyword">while</span> (~u) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, u - n);</span><br><span class="line">            T[u-n] = Time;</span><br><span class="line">            u = left[u-n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">km</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(left, <span class="number">-1</span>, <span class="keyword">sizeof</span> left);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            ++Time;</span><br><span class="line">            <span class="keyword">if</span> (match(i)) ++ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n); read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        read(u); read(v);</span><br><span class="line">        Graph::AddEdge(u, v+n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">int</span> ans = KM::km();</span><br><span class="line">    ++KM::Time;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (KM::T[i] != KM::Time) KM::print(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接：&lt;a href=&quot;https://www.luogu.org/problem/P2764&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.org/problem/P2764&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;匈牙利算法就是好&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>汽车加油行驶问题 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P4009/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P4009/</id>
    <published>2019-10-02T15:13:57.000Z</published>
    <updated>2019-10-02T15:38:50.730Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接：<a href="https://www.luogu.org/problem/P4009" target="_blank" rel="noopener">https://www.luogu.org/problem/P4009</a></li></ul><p>流量为 $1$ 的费用流没有必要跑费用流，跑最短路就好了</p><a id="more"></a><p>容易看出来是一道分层图最短路的题，但是以什么为根据分层就不是那么显然了</p><p>我开始想的是根据建造的油库分层，发现不大可做。正解则是根据剩余油量建图，此时建造油库就可以看作在一个非油库的地点花费一定费用加满油。</p><p>这里用 $k$ 表示剩余流量为 $k$，建图过程就成模拟过程了。</p><p>对于一个地点，考虑如下情况：</p><ul><li>存在油库，花费 $A$ 加满油，仅从满油状态向周围移动</li><li>不存在油库<ul><li>花费 $A+C$ 加满油</li><li>枚举剩余油量，向周围移动</li></ul></li></ul><p>还有一个问题，即建造出的油库第二次经过时，建造费用计算两次。但是我为什么要经过两次同一地点并都需要加油呢…</p><p>注意答案取终点时所有可能剩余油量的最小值，坑点为油库都是强买强卖的，经过就一定会加满油。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P4009</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span>&amp; <span class="title">x</span>) &#123;</span></span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f |= ch == <span class="string">'-'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">105</span>, MAXV = (<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">5</span>, MAXE = (<span class="keyword">int</span>)<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K, A, B, C;</span><br><span class="line"><span class="keyword">int</span> G[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, dist; &#125; edges[MAXE];</span><br><span class="line">    <span class="keyword">int</span> head[MAXV], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head); eidx = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dist)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, dist &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Dijkstra &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">int</span> d[MAXV];</span><br><span class="line">    <span class="keyword">bool</span> done[MAXV];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; PQ;</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">        <span class="built_in">memset</span>(done, <span class="literal">false</span>, <span class="keyword">sizeof</span> done);</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        PQ.push(make_pair(-d[s], s));</span><br><span class="line">        <span class="keyword">while</span> (!PQ.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = PQ.top().second; PQ.pop();</span><br><span class="line">            <span class="comment">// printf("%d\n", u);</span></span><br><span class="line">            <span class="keyword">if</span> (done[u]) <span class="keyword">continue</span>;</span><br><span class="line">            done[u] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = edges[i].to;</span><br><span class="line">                <span class="keyword">if</span> (d[v] &gt; d[u] + edges[i].dist)</span><br><span class="line">                    d[v] = d[u] + edges[i].dist, PQ.push(make_pair(-d[v], v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> n*n*type + (x<span class="number">-1</span>)*n + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n); read(K); read(A); read(B); read(C);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) read(G[i][j]);</span><br><span class="line">    <span class="comment">// build graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (G[i][j]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= K; ++k)</span><br><span class="line">                    Graph::AddEdge(idx(k, i, j), idx(K, i, j), A);</span><br><span class="line">                <span class="keyword">if</span> (i &lt; n) Graph::AddEdge(idx(K, i, j), idx(K<span class="number">-1</span>, i+<span class="number">1</span>, j), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (j &lt; n) Graph::AddEdge(idx(K, i, j), idx(K<span class="number">-1</span>, i, j+<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">1</span>) Graph::AddEdge(idx(K, i, j), idx(K<span class="number">-1</span>, i<span class="number">-1</span>, j), B);</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">1</span>) Graph::AddEdge(idx(K, i, j), idx(K<span class="number">-1</span>, i, j<span class="number">-1</span>), B);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= K; ++k)</span><br><span class="line">                    Graph::AddEdge(idx(k, i, j), idx(K, i, j), A+C);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= K; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; n) Graph::AddEdge(idx(k, i, j), idx(k<span class="number">-1</span>, i+<span class="number">1</span>, j), <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (j &lt; n) Graph::AddEdge(idx(k, i, j), idx(k<span class="number">-1</span>, i, j+<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">1</span>) Graph::AddEdge(idx(k, i, j), idx(k<span class="number">-1</span>, i<span class="number">-1</span>, j), B);</span><br><span class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">1</span>) Graph::AddEdge(idx(k, i, j), idx(k<span class="number">-1</span>, i, j<span class="number">-1</span>), B);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    Dijkstra::dijkstra(idx(K, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= K; ++k)</span><br><span class="line">        ans = min(ans, Dijkstra::d[idx(k, n, n)]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接：&lt;a href=&quot;https://www.luogu.org/problem/P4009&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.org/problem/P4009&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;流量为 $1$ 的费用流没有必要跑费用流，跑最短路就好了&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>餐巾计划问题 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P1251/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P1251/</id>
    <published>2019-10-02T14:17:25.000Z</published>
    <updated>2019-10-02T14:58:38.631Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接：<a href="https://www.luogu.org/problem/P1251" target="_blank" rel="noopener">https://www.luogu.org/problem/P1251</a></li></ul><p>上下界最小费用可行流，用了都说好</p><a id="more"></a><p>看到题目后想起来 <code>Rujia Liu</code> 蓝书网络流最后一道例题，不过那道题限制没有这道题多，仅用费用流就可以解决。两题相同的地方为：根据天数建图，并把天数拆点。</p><p>建图前先统一变量名，令 $p$ 是每块新餐巾的费用，$qd$ 是快洗部洗一块餐巾需用天数，$qc$ 是快洗部洗一块餐巾需要的费用，$sd$ 是慢洗部洗一块餐巾需用天数，$sc$ 是慢洗部洗一块餐巾需要的费用。</p><ul><li>建图流程<ul><li>新建附加源、汇点 $s, t$</li><li>对于一天 $i$，拆成 $i$，$i’$，意义为接受餐巾和转移餐巾，<del>或者可以理解为每天的早上和晚上</del></li><li>对于一天 $i$<ul><li>连边 $(s,i)$，容量 $[0,+\infty]$，费用为 $p$，表示购买餐巾</li><li>连边 $(i’, t)$，容量 $[0,+\infty]$，费用为 $0$，表示多余的餐巾可以一直搁着</li><li>连边 $(i, i’)$，容量限定为 $A_i$，即每天需用的餐巾数，费用为 $0$，表示需求</li><li>连边 $(i, i+1)$，容量 $[0,+\infty]$，费用为 $0$，表示今天用不完的餐巾可以明天用</li><li>在天数合法情况下，连边 $(i’, i+qd)$，容量 $[0,A_i]$，费用为 $qc$，表示今天用完的餐巾拿去快洗</li><li>在天数合法情况下，连边 $(i’, i+sd)$，容量 $[0,A_i]$，费用为 $sc$，表示今天用完的餐巾拿去慢洗</li></ul></li></ul></li></ul><p>之后就是套路式上下界了，详见 <a href="https://www.cnblogs.com/mlystdcall/p/6734852.html" target="_blank" rel="noopener">__stdcall 的【教程】上下界网络流建模方法总结</a>，以及膜 __stdcall Orz</p><p>关于坑点就是点数和边数要开够…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P1251</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span>&amp; <span class="title">x</span>) &#123;</span></span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f |= ch == <span class="string">'-'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2005</span>, MAXV = MAXN * <span class="number">2</span>, MAXE = MAXN * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, sd, qd, S, T;</span><br><span class="line">LL p, sc, qc;</span><br><span class="line"><span class="keyword">int</span> A[MAXN]; LL d[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; LL cap, flow, cost; &#125; edges[MAXE &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXV], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head); eidx = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, LL cap, LL cost)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, cap, <span class="number">0</span>, cost &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[to], from, <span class="number">0</span>, <span class="number">0</span>, -cost &#125;;</span><br><span class="line">        head[to] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, LL b, LL c, LL cost)</span> </span>&#123;</span><br><span class="line">        d[to] += b; d[from] -= b;</span><br><span class="line">        AddEdge(from, to, c-b, cost);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MCMF &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">bool</span> inq[MAXV];</span><br><span class="line">    LL d[MAXV], a[MAXV]; <span class="keyword">int</span> pre[MAXV];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(LL&amp; flow, LL&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">        <span class="built_in">memset</span>(inq, <span class="literal">false</span>, <span class="keyword">sizeof</span> inq);</span><br><span class="line">        Q.push(S);</span><br><span class="line">        inq[S] = <span class="literal">true</span>; d[S] = pre[S] = <span class="number">0</span>; a[S] = INF;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            inq[u] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">const</span> Edge&amp; e = edges[i];</span><br><span class="line">                <span class="keyword">if</span> (d[e.to] &gt; d[u] + e.cost &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                    a[e.to] = min(a[u], e.cap - e.flow);</span><br><span class="line">                    d[e.to] = d[u] + e.cost; pre[e.to] = i;</span><br><span class="line">                    <span class="keyword">if</span> (!inq[e.to]) inq[e.to] = <span class="literal">true</span>, Q.push(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d[T] == INF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        flow += a[T]; cost += a[T] * d[T];</span><br><span class="line">        <span class="keyword">int</span> u = T;</span><br><span class="line">        <span class="keyword">while</span> (u != S) &#123;</span><br><span class="line">            edges[pre[u]].flow += a[T];</span><br><span class="line">            edges[pre[u]^<span class="number">1</span>].flow -= a[T];</span><br><span class="line">            u = edges[pre[u]^<span class="number">1</span>].to;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">MCMF</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LL flow = <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (SPFA(flow, cost)) ;</span><br><span class="line">        <span class="keyword">return</span> cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]);</span><br><span class="line">    read(p); read(qd); read(qc); read(sd); read(sc);</span><br><span class="line">    <span class="comment">// build graph</span></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">2</span>*n+<span class="number">1</span>, t = <span class="number">2</span>*n+<span class="number">2</span>;</span><br><span class="line">    S = <span class="number">2</span>*n+<span class="number">3</span>; T = <span class="number">2</span>*n+<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        Graph::AddEdge(i, n+i, A[i], A[i], <span class="number">0</span>);</span><br><span class="line">        Graph::AddEdge(s, i, INF, p);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) Graph::AddEdge(i, i+<span class="number">1</span>, INF, <span class="number">0</span>);</span><br><span class="line">        Graph::AddEdge(n+i, t, INF, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i+qd &lt;= n) Graph::AddEdge(i+n, i+qd, <span class="number">0</span>, A[i], qc);</span><br><span class="line">        <span class="keyword">if</span> (i+sd &lt;= n) Graph::AddEdge(i+n, i+sd, <span class="number">0</span>, A[i], sc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    Graph::AddEdge(t, s, INF, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i] &gt; <span class="number">0</span>) Graph::AddEdge(S, i, d[i], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (d[i] &lt; <span class="number">0</span>) Graph::AddEdge(i, T, -d[i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, MCMF::MCMF());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接：&lt;a href=&quot;https://www.luogu.org/problem/P1251&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.org/problem/P1251&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上下界最小费用可行流，用了都说好&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>圆桌问题 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P3254/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P3254/</id>
    <published>2019-09-28T11:04:14.000Z</published>
    <updated>2019-09-28T11:16:08.035Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接：<a href="https://www.luogu.org/problem/P3254" target="_blank" rel="noopener">https://www.luogu.org/problem/P3254</a></li></ul><p><del>奇奇怪怪的贪心可以写的题</del></p><p>较为明显的二分图模型，带权匹配单位和餐桌，然后没了</p><a id="more"></a><ul><li>建图流程<ul><li>设源点 $S$，汇点 $T$</li><li>对于每个单位 $i$，连边 $(S, i)$，容量为代表数 $A_i$</li><li>对于每个餐桌 $j$，连边 $(j, T)$，容量为餐桌容量 $B_j$</li><li>对于每个单位 $i$，向每个餐桌 $j$ 连边 $(i, j)$，容量为 $1$，表示同一个单位来的代表不在同一个餐桌就餐</li></ul></li></ul><p>输出方案时遍历每个单位的出边，找到满流输出就好了</p><p>坑点：$A$，$B$ 范围不要写反，以及仅当最大流等于代表总数时才有解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3254</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span>&amp; <span class="title">x</span>) &#123;</span></span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f |= ch == <span class="string">'-'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">155</span>, MAXN = <span class="number">275</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = MAXN + MAXM, MAXE = MAXN * MAXM + MAXV;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, S, T;</span><br><span class="line"><span class="keyword">int</span> A[MAXM], B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, cap, flow; &#125; edges[MAXE &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXV], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head); eidx = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, cap, <span class="number">0</span> &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[to], from, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        head[to] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k, <span class="built_in">putchar</span>(<span class="string">'\n'</span>))</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[k]; ~i; i = edges[i].nxt)</span><br><span class="line">                <span class="keyword">if</span> (edges[i].cap &gt;= edges[i].flow &amp;&amp; edges[i].flow &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d "</span>, edges[i].to - m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Dinic &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXV];</span><br><span class="line">    <span class="keyword">int</span> cur[MAXV], depth[MAXV];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        Q.push(S);</span><br><span class="line">        depth[S] = <span class="number">0</span>; vis[S] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">const</span> Edge&amp; e = edges[i];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow)</span><br><span class="line">                    vis[e.to] = <span class="literal">true</span>, depth[e.to] = depth[u] + <span class="number">1</span>, Q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[T];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == T || !a) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> f, flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            Edge&amp; e = edges[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[e.to] == depth[u] + <span class="number">1</span> &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                flow += f; a -= f;</span><br><span class="line">                e.flow += f; edges[i^<span class="number">1</span>].flow -= f;</span><br><span class="line">                <span class="keyword">if</span> (!a) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span> cur);</span><br><span class="line">            flow += DFS(S, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    read(m); read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) read(A[i]), sum += A[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) read(B[j]);</span><br><span class="line">    <span class="comment">// build graph</span></span><br><span class="line">    S = <span class="number">0</span>; T = n+m+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        Graph::AddEdge(S, i, A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        Graph::AddEdge(j+m, T, B[j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            Graph::AddEdge(i, j+m, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">int</span> flow = Dinic::Maxflow();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, flow == sum? <span class="number">1</span>: <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 当 flow == sum 才有解</span></span><br><span class="line">    <span class="keyword">if</span> (flow == sum) Graph::solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接：&lt;a href=&quot;https://www.luogu.org/problem/P3254&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.org/problem/P3254&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;del&gt;奇奇怪怪的贪心可以写的题&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;较为明显的二分图模型，带权匹配单位和餐桌，然后没了&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>方格取数问题 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2774/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2774/</id>
    <published>2019-09-28T10:11:13.000Z</published>
    <updated>2019-09-28T11:18:10.609Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接：<a href="https://www.luogu.org/problem/P2774" target="_blank" rel="noopener">https://www.luogu.org/problem/P2774</a></li></ul><p>满足没有公共边的网格图可以看作二分图，也就是“黑白相间”</p><a id="more"></a><p>如果正向考虑，每个方格要向非四联通的方格连边，边数较多。不如反向考虑，假设选择所有的方格，减去为满足条件剔除的方格。如果让这个答案最大，就需要让挑出的方格权值和最小。</p><p>又由最小联想到最小割，可以通过最大流求出，于是</p><ul><li>建图流程<ul><li>设源点 $S$，$T$</li><li>对于每个白方格 $i$，连边 $(S, i)$，容量为权值 $A_i$，并向四周连边，容量为 INF</li><li>对于每个黑方格 $i$，连边 $(T, i)$，容量为权值 $A_i$</li></ul></li></ul><p>$S$，$T$ 不联通之日，必是满足题目限制之时 <del>(大雾</del></p><p>这题就做完了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P2774</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span>&amp; <span class="title">x</span>) &#123;</span></span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f |= ch == <span class="string">'-'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">105</span>, MAXV = MAXN * MAXN, MAXE = MAXN * MAXN * <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, dy[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, S, T;</span><br><span class="line"><span class="keyword">int</span> A[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, cap, flow; &#125; edges[MAXE &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXV], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head); eidx = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, cap, <span class="number">0</span> &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[to], from, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        head[to] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Dinic &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXV];</span><br><span class="line">    <span class="keyword">int</span> depth[MAXV], cur[MAXV];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        Q.push(S);</span><br><span class="line">        depth[S] = <span class="number">0</span>; vis[S] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">const</span> Edge&amp; e = edges[i];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow)</span><br><span class="line">                    vis[e.to] = <span class="literal">true</span>, depth[e.to] = depth[u] + <span class="number">1</span>, Q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[T];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == T || !a) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> f, flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            Edge&amp; e = edges[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[e.to] == depth[u] + <span class="number">1</span> &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                flow += f; a -= f;</span><br><span class="line">                e.flow += f; edges[i^<span class="number">1</span>].flow -= f;</span><br><span class="line">                <span class="keyword">if</span> (!a) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span> cur);</span><br><span class="line">            flow += DFS(S, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> m * (i<span class="number">-1</span>) + j; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    read(n); read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) read(A[i][j]), sum += A[i][j];</span><br><span class="line">    <span class="comment">// build graph</span></span><br><span class="line">    S = <span class="number">0</span>; T = idx(n, m) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i + j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                Graph::AddEdge(S, idx(i, j), A[i][j]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + dx[k], y = j + dy[k];</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; n || y &lt; <span class="number">1</span> || y &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">                    Graph::AddEdge(idx(i, j), idx(x, y), INF);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Graph::AddEdge(idx(i, j), T, A[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum - Dinic::Maxflow());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接：&lt;a href=&quot;https://www.luogu.org/problem/P2774&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.org/problem/P2774&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;满足没有公共边的网格图可以看作二分图，也就是“黑白相间”&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>最长不下降子序列问题 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2766/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2766/</id>
    <published>2019-09-28T08:52:34.000Z</published>
    <updated>2019-09-28T11:23:13.713Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接：<a href="https://www.luogu.org/problem/P2766" target="_blank" rel="noopener">https://www.luogu.org/problem/P2766</a></li></ul><p>不看题解死都想不出来祭</p><a id="more"></a><p>对于第一问，考虑 DP 求解，不过不同于 $O(n \log n)$  的做法，我们使用 $O(n^2)$ 的做法，以方便维护更多的信息。</p><p>设 $dp[i]$ 为序列 $\text{1~i}$ 的最长不下降子序列长度，显然有转移</p><p>$$dp[i] = \max \{ \ dp[j] + 1 \}$$ </p><p>其中 $A_j \leq A_i,\ j &lt; i$，初始状态有 $dp[i] = 1$，最长长度 $\text{MaxL}$ 为 $\max_{i=1}^{n} dp[i]$</p><p>对于第二三问，考虑网络流求解。</p><p>怎么把序列个数同网络流联系起来呢？我们可以考虑一种方法，使得到汇点的每一份流量，对应一种序列的构造方案。这样询问个数就可以转化为最大流问题了。</p><ul><li>第二问建图流程<ul><li>设源点 $S$，$T$</li><li>对于一个子序列，一个数显然只能统计一次，所以考虑拆点，将位置 $i$ 拆为 $i$，$i’$，连边 $(i, i’)$，容量为 $1$</li><li>对于一个位置 $i$，若<ul><li>$dp[i] = 1$，连边 $(S, i)$，容量为 $1$</li><li>$dp[i] = \text{MaxL}$，连边 $(i’,T)$，容量为 $1$</li></ul></li><li>类似 DP 的过程，对于位置 $i$，若有 $j &lt; i,\ A_i \geq A_j$ 且 $dp[i] = dp[j] + 1$，连边 $(j’,i)$，容量为 $1$</li></ul></li></ul><p>对于到 $T$ 的流量，满足 DP 的条件，也就是一种合法方案，即该网络最大流为第二问答案</p><p>对于第三问，改变 $A_1$，$A_n$ 的流量限制，即</p><ul><li>连边 $(1,1’)$，$(S,1)$，容量为 INF</li><li>若第 $n$ 位有 $dp[n] = \text{MaxL}$，连边 $(n,n’)$，$(n’,T)$，容量为 INF</li></ul><p>在原基础上求流量增加量，加上第二问答案即可</p><p>坑点有第三问连接 $n$ 和 $T$ 时，一定存在条件 $dp[n] = \text{MaxL}$，总之我被坑了 = =</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P2766</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span>&amp; <span class="title">x</span>) &#123;</span></span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f |= ch == <span class="string">'-'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = Gc(); &#125;</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">505</span>, MAXV = MAXN &lt;&lt; <span class="number">1</span>, MAXE = MAXV &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, S, T;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, cap, flow; &#125; edges[MAXE &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXV], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head); eidx = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, cap, <span class="number">0</span> &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[to], from, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        head[to] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Dinic &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXV];</span><br><span class="line">    <span class="keyword">int</span> depth[MAXV], cur[MAXV];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        Q.push(S);</span><br><span class="line">        depth[S] = <span class="number">0</span>; vis[S] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">const</span> Edge&amp; e = edges[i];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow)</span><br><span class="line">                    vis[e.to] = <span class="literal">true</span>, depth[e.to] = depth[u] + <span class="number">1</span>, Q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[T];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == T || !a) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> f, flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            Edge&amp; e = edges[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[e.to] == depth[u] + <span class="number">1</span> &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                flow += f; a -= f;</span><br><span class="line">                e.flow += f; edges[i^<span class="number">1</span>].flow -= f;</span><br><span class="line">                <span class="keyword">if</span> (!a) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span> cur);</span><br><span class="line">            flow += DFS(S, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="keyword">int</span> MaxL = <span class="number">0</span>;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="comment">// dp</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt;= A[j]) dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        MaxL = max(MaxL, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Q1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, MaxL);</span><br><span class="line">    <span class="comment">// build graph for Q2</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    S = <span class="number">0</span>; T = <span class="number">2</span>*n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == <span class="number">1</span>) Graph::AddEdge(S, i, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == MaxL) Graph::AddEdge(i+n, T, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        Graph::AddEdge(i, i+n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt;= A[j] &amp;&amp; dp[i] == dp[j] + <span class="number">1</span>)</span><br><span class="line">                Graph::AddEdge(j+n, i, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// Q2</span></span><br><span class="line">    <span class="keyword">int</span> flow = Dinic::Maxflow();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, flow);</span><br><span class="line">    <span class="comment">// extra edges for Q3</span></span><br><span class="line">    Graph::AddEdge(<span class="number">1</span>, <span class="number">1</span>+n, INF); Graph::AddEdge(S, <span class="number">1</span>, INF);</span><br><span class="line">    <span class="keyword">if</span> (dp[n] == MaxL) Graph::AddEdge(n, n+n, INF), Graph::AddEdge(n+n, T, INF);</span><br><span class="line">    <span class="comment">// Q3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, flow + Dinic::Maxflow());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接：&lt;a href=&quot;https://www.luogu.org/problem/P2766&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.org/problem/P2766&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不看题解死都想不出来祭&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>魔术球问题 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2765/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/luogu-P2765/</id>
    <published>2019-09-28T04:40:58.000Z</published>
    <updated>2019-09-28T09:05:37.552Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接：<a href="https://www.luogu.org/problem/P2765" target="_blank" rel="noopener">https://www.luogu.org/problem/P2765</a></li></ul><p><del>似乎可以用奇奇怪怪的贪心来写</del></p><p>可以发现，球放在哪里和柱子是没有关系的，对于一个编号为 <code>now</code> 的球，如果现有柱子上的球不能满足组成完全平方数的条件，就新建一个柱子存放 <code>now</code>，否则就放在可以存在的位置上。由贪心的思想，得到的结果一定是最优的。</p><a id="more"></a><p>那么，怎么用网络流的模型来实现呢？</p><p>考虑每个球只能使用一次，容易想到拆点，在代码中体现为 <code>now --&gt; 2*now, 2*now + 1</code>，这样对于拆出的两点，编号 /2 就是原编号，输出方案时比较方便。</p><ul><li>建图流程<ul><li>设源点 $S$，汇点 $T$</li><li>将球 $A$ 拆为 $A’$，$A’’$，连边 $(S, A’)$，$(A’’,T)$，容量为 $1$</li><li>对于球 $A$，$B$，若有编号之和为完全平方数的情况，连边 $(B’,A’’)$，容量为 $1$</li></ul></li></ul><p>若加入一个球后新增流量大于 $0$，则说明该球可以放在已经存在的柱子上，否则新建柱子存放。</p><p>如果新建柱子数超过 $n$，此时能放的球数达到最大。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu P2765</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">65</span>, MAXV = (<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">5</span>, MAXE = (<span class="keyword">int</span>)<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, S, T;</span><br><span class="line"><span class="keyword">bool</span> done[MAXV];</span><br><span class="line"><span class="keyword">int</span> List[MAXN], pre[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, cap, flow; &#125; edges[MAXE &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXV], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head); eidx = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, cap, <span class="number">0</span> &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[to], from, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        head[to] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Dinic &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXV];</span><br><span class="line">    <span class="keyword">int</span> depth[MAXV], cur[MAXV];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        Q.push(S);</span><br><span class="line">        depth[S] = <span class="number">0</span>; vis[S] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">const</span> Edge&amp; e = edges[i];</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow)</span><br><span class="line">                    vis[e.to] = <span class="literal">true</span>, depth[e.to] = depth[u] + <span class="number">1</span>, Q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[T];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == T || !a) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> f, flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            Edge&amp; e = edges[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[e.to] == depth[u] + <span class="number">1</span> &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                flow += f; a -= f;</span><br><span class="line">                e.flow += f; edges[i^<span class="number">1</span>].flow -= f;</span><br><span class="line">                <span class="keyword">if</span> (e.to != T) pre[u/<span class="number">2</span>] = e.to/<span class="number">2</span>;</span><br><span class="line">                <span class="comment">// 某个球放在哪里，只和前一个球的编号相关</span></span><br><span class="line">                <span class="keyword">if</span> (!a) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span> cur);</span><br><span class="line">            flow += DFS(S, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="comment">// build graph</span></span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>, cntP = <span class="number">0</span>;</span><br><span class="line">    S = <span class="number">0</span>; T = MAXV - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cntP &lt;= n) &#123;</span><br><span class="line">        ++now;</span><br><span class="line">        Graph::AddEdge(S, now*<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        Graph::AddEdge(now*<span class="number">2</span>+<span class="number">1</span>, T, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 向源点与汇点连边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">sqrt</span>(now) + <span class="number">1</span>; i*i &lt; now*<span class="number">2</span>; ++i)</span><br><span class="line">            Graph::AddEdge((i*i-now)*<span class="number">2</span>, now*<span class="number">2</span>+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 枚举构成完全平方数的情况</span></span><br><span class="line">        <span class="keyword">int</span> flow = Dinic::Maxflow();</span><br><span class="line">        <span class="keyword">if</span> (!flow) List[++cntP] = now;</span><br><span class="line">        <span class="comment">// 新建一个柱子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, now - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i, <span class="built_in">putchar</span>(<span class="string">'\n'</span>)) <span class="keyword">if</span> (!done[List[i]])</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = List[i]; u; u = pre[u])</span><br><span class="line">            <span class="keyword">if</span> (!done[u]) &#123; done[u] = <span class="literal">true</span>, <span class="built_in">printf</span>(<span class="string">"%d "</span>, u); &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接：&lt;a href=&quot;https://www.luogu.org/problem/P2765&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.org/problem/P2765&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;del&gt;似乎可以用奇奇怪怪的贪心来写&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;可以发现，球放在哪里和柱子是没有关系的，对于一个编号为 &lt;code&gt;now&lt;/code&gt; 的球，如果现有柱子上的球不能满足组成完全平方数的条件，就新建一个柱子存放 &lt;code&gt;now&lt;/code&gt;，否则就放在可以存在的位置上。由贪心的思想，得到的结果一定是最优的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
  </entry>
  
</feed>
