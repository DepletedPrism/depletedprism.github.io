<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DepletedPrism&#39;s Blog</title>
  
  <subtitle>知其然而不知其所以然是可悲的.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://depletedprism.github.io/"/>
  <updated>2020-02-08T08:16:18.437Z</updated>
  <id>https://depletedprism.github.io/</id>
  
  <author>
    <name>DepletedPrism</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「置顶」算法教程合辑</title>
    <link href="https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/compilation/"/>
    <id>https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/compilation/</id>
    <published>9102-11-14T00:11:23.000Z</published>
    <updated>2020-02-08T08:16:18.437Z</updated>
    
    <content type="html"><![CDATA[<hr><p>这个 idea 来源于 <a href="https://www.cnblogs.com/mlystdcall/p/8078467.html" target="_blank" rel="noopener">__stdcall 的教程合辑</a>, 觉得这个很好, 所以学习了.</p><a id="more"></a><p><del>Hexo 博客的强制置顶</del></p><h4 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h4><ul><li>树状数组进阶<ul><li><a href="https://www.cnblogs.com/RabbitHu/p/BIT.html" target="_blank" rel="noopener">https://www.cnblogs.com/RabbitHu/p/BIT.html</a></li></ul></li></ul><h4 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h4><ul><li>网络流入门<ul><li><a href="https://www.xht37.com/二分图与网络流-学习笔记/" target="_blank" rel="noopener">https://www.xht37.com/二分图与网络流-学习笔记/</a></li></ul></li><li>上下界网络流<ul><li><a href="https://www.cnblogs.com/mlystdcall/p/6734852.html" target="_blank" rel="noopener">https://www.cnblogs.com/mlystdcall/p/6734852.html</a></li></ul></li></ul><h4 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h4><ul><li>基础构造<ul><li><a href="https://oi.men.ci/linear-basis-notes/" target="_blank" rel="noopener">https://oi.men.ci/linear-basis-notes/</a></li></ul></li><li>可重集 Kth 异或和<ul><li><a href="https://blog.csdn.net/qaq__qaq/article/details/53812883" target="_blank" rel="noopener">https://blog.csdn.net/qaq__qaq/article/details/53812883</a></li></ul></li></ul><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul><li>四边形不等式优化<ul><li><a href="https://oi-wiki.org/dp/opt/quadrangle/" target="_blank" rel="noopener">https://oi-wiki.org/dp/opt/quadrangle/</a></li></ul></li></ul><h4 id="Link-Cut-Tree"><a href="#Link-Cut-Tree" class="headerlink" title="Link Cut Tree"></a>Link Cut Tree</h4><ul><li>应用 &amp; 题单<ul><li><a href="https://www.cnblogs.com/flashhu/p/9498517.html" target="_blank" rel="noopener">https://www.cnblogs.com/flashhu/p/9498517.html</a></li></ul></li></ul><h4 id="左偏树"><a href="#左偏树" class="headerlink" title="左偏树"></a>左偏树</h4><ul><li>特点及应用<ul><li><a href="https://files-cdn.cnblogs.com/files/shenben/算法合集之《左偏树的特点及其应用》.pdf" target="_blank" rel="noopener">https://files-cdn.cnblogs.com/files/shenben/算法合集之《左偏树的特点及其应用》.pdf</a></li></ul></li></ul><h4 id="Min-Max-容斥"><a href="#Min-Max-容斥" class="headerlink" title="Min-Max 容斥"></a>Min-Max 容斥</h4><ul><li>证明及应用<ul><li><a href="https://www.cnblogs.com/GXZlegend/p/11563330.html" target="_blank" rel="noopener">https://www.cnblogs.com/GXZlegend/p/11563330.html</a></li></ul></li></ul><h4 id="Stirling-数及-Stirling-反演"><a href="#Stirling-数及-Stirling-反演" class="headerlink" title="Stirling 数及 Stirling 反演"></a>Stirling 数及 Stirling 反演</h4><ul><li>性质及应用<ul><li><a href="https://www.cnblogs.com/y2823774827y/p/10700231.html" target="_blank" rel="noopener">https://www.cnblogs.com/y2823774827y/p/10700231.html</a></li></ul></li></ul><h4 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h4><ul><li>证明及应用<ul><li><a href="https://www.cnblogs.com/GXZlegend/p/11407185.html" target="_blank" rel="noopener">https://www.cnblogs.com/GXZlegend/p/11407185.html</a></li></ul></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;这个 idea 来源于 &lt;a href=&quot;https://www.cnblogs.com/mlystdcall/p/8078467.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;__stdcall 的教程合辑&lt;/a&gt;, 觉得这个很好, 所以学习了.&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://depletedprism.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>HAOI 2018 大赏</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/HAOI-2018-sol/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/HAOI-2018-sol/</id>
    <published>2020-03-12T08:00:47.000Z</published>
    <updated>2020-03-13T06:00:05.842Z</updated>
    
    <content type="html"><![CDATA[<hr><p>先祭上出题人题解.</p><ul><li><a href="https://dy0607.github.io/%E7%9C%81%E9%80%89/oi%E5%8E%86%E7%A8%8B/2018/04/24/HAOI2018-Round1-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A.html" target="_blank" rel="noopener">dy0607 的 HAOI2018 Round1 解题报告</a></li></ul><p>然而没有找到 Round 2 的官方题解 (</p><a id="more"></a><h3 id="「HAOI2018」奇怪的背包"><a href="#「HAOI2018」奇怪的背包" class="headerlink" title="「HAOI2018」奇怪的背包"></a>「HAOI2018」奇怪的背包</h3><p>要命的 $\gcd$…</p><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2523" target="_blank" rel="noopener">https://loj.ac/problem/2523</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>所求即为满足</p><p>$$\sum_{i \in S} a_i V_i \equiv w \pmod P$$</p><p>的不同集合 $S$ 个数, 其中 $a_i &gt; 0$, 表示物品选择个数.</p><p>写成不定方程的形式, 即</p><p>$$\sum_{i \in S} a_i V_i + yP = w$$</p><p>根据裴蜀定理, 该方程有解, 则需满足 $\gcd(V_1, V_2, \ldots, P) \mid w$.</p><p>可以发现, 对所有值, 同 $P$ 取 $\gcd$ 并不会影响答案, 那么枚举 $P$ 的约数, 直接 DP 即可.</p><p>直接 DP… 令 $d(P)$ 表示 $P$ 的约数个数, 容易得到时间复杂度 $O(nd(P)$ 的做法, 但是可以进一步优化.</p><p>枚举 $P$ 的约数, 对于同 $P$ 取 $\gcd$ 相同的, 在 DP 时一起算即可.</p><p>具体地, 设 $f(i, j)$ 表示选择 $P$ 前 $i$ 个约数, 得到 $P$ 的第 $j$ 个约数的方案数. 记 $s(i)$ 表示第 $i$ 个约数在 $\gcd(V_j, P)$ 中的出现次数, $d_i$ 表示 $P$ 第 $i$ 个约数. 那么有</p><p>$$f(i, k) = f(i-1, k) + \sum_{\gcd(d_i, d_j) = d_k} f(i-1, j) \cdot (2 ^ {s(i)} -1)$$</p><p>由于 $P$ 的约数中可能存在一些整除关系, 最后 $O(d^2(P))$ 枚举一遍把贡献加起来就好了.</p><p>时间复杂度 $O(\sqrt{P} + n \log P + d ^ 2(P) \log P)$.</p><p>另外祭上某张流传已久的表格…</p><div style="text-align:center;"><img src="/images/HAOI-2018-sol/wd.jpg"> </div><p><em><p style="text-align:center;">图源 UOJ 用户群, 至少我是从那里找到的</p></em></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2523</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">5</span>, MAXD = <span class="number">2e3</span> + <span class="number">5</span>, MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, P, idx;</span><br><span class="line"><span class="keyword">int</span> id1[MAXN], id2[MAXN], pow2[MAXN];</span><br><span class="line"><span class="keyword">int</span> fact[MAXD], s[MAXD], f[MAXD][MAXD], g[MAXD];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> !b? a: gcd(b, a  % b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(q), read(P);</span><br><span class="line">    m = <span class="built_in">sqrt</span>(P);</span><br><span class="line">    <span class="comment">// sovle</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d * d &lt;= P; ++d) <span class="keyword">if</span> (P % d == <span class="number">0</span>) &#123;</span><br><span class="line">        fact[++idx] = d, id1[d] = idx;</span><br><span class="line">        <span class="keyword">if</span> (d * d != P) fact[++idx] = P / d, id2[d] = idx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v, i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        read(v), v = gcd(v, P), ++s[(v &lt;= m)? id1[v]: id2[P / v]];</span><br><span class="line">    pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) pow2[i] = <span class="number">2L</span>L * pow2[i<span class="number">-1</span>] % MOD;</span><br><span class="line">    f[<span class="number">0</span>][id2[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= idx; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= idx; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = gcd(fact[i], fact[j]), k = (w &lt;= m)? id1[w]: id2[P / w];</span><br><span class="line">            f[i][k] = (f[i][k] + <span class="number">1L</span>L * f[i<span class="number">-1</span>][j] * (pow2[s[i]] - <span class="number">1</span> + MOD) % MOD) % MOD;</span><br><span class="line">            f[i][j] = (f[i][j] + f[i<span class="number">-1</span>][j]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= idx; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= idx; ++j)</span><br><span class="line">            <span class="keyword">if</span> (fact[i] % fact[j] == <span class="number">0</span>) g[i] = (g[i] + f[idx][j]) % MOD;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> w;</span><br><span class="line">        read(w), w = gcd(w, P), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, g[(w &lt;= m)? id1[w]: id2[P / w]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「HAOI2018」反色游戏"><a href="#「HAOI2018」反色游戏" class="headerlink" title="「HAOI2018」反色游戏"></a>「HAOI2018」反色游戏</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2524" target="_blank" rel="noopener">https://loj.ac/problem/2524</a></li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先有一个简洁的结论, 所求的方案数为 $2^{m - n + p}$, 其中 $m$ 为边数, $n$ 为点数, $p$ 为连通分量个数.</p><p>官方题解从图论和线性代数两个角度解释了这个结论, 然而我只能流下学不会线性代数的泪水…</p><p>于是从图的连通性入手解释这个结论.</p><p>单独考虑每一个连通分量, 如果该连通分量中存在偶数个黑点, 那么一定存在可行方案; 否则不存在.</p><p>考虑将该连通分量中的黑点任意两两配对, 由于存在偶数个黑点, 所以没有多余. 可以发现</p><ul><li>对于两黑点间的任意一条路径, 不论经过的边数是奇是偶, 总可以构造出一种方案, 使得路径上只有这两个黑点颜色反转.</li><li>对于这些路径的交, 每次把边选 / 不选的状态取反, 不会影响到原来的局面.</li></ul><p>如果存在奇数个黑点, 则不存在以上性质… 因而不存在合法方案.</p><p>同时我们知道了, 配对数和方案数是等价的. 换言之, 每种黑点两两匹配的方案, 唯一对应着一个合法解.</p><p>所以对于一个点数为 $n$ 的连通分量, 有解的情况有 $2^{n-1}$ 种 (拿组合数加起来推一推可知), 由于边数为 $m$, 共 $2^m$ 种情况, 所以每种有解的情况下, 解的个数为 $2^{m-n+1}$. 对 $p$ 个连通分量进行推广, 答案即为 $2 ^ {m - n + p}$.</p><p>似乎还可以从另一个角度解释? 参见 <a href="https://www.cnblogs.com/xjqxjq/p/11781185.html" target="_blank" rel="noopener">https://www.cnblogs.com/xjqxjq/p/11781185.html</a>.</p><p>知道结论后的做法就很明晰了, 跑 tarjan 求割点, 讨论是否有解, 以及删边后整体边数, 点数, 连通分量个数的变化即可.</p><p>时间复杂度 $O(n + m)$.</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2524</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> V[MAXN], pow2[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], deg[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(deg, <span class="number">0</span>, <span class="keyword">sizeof</span> deg), <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">        ++deg[to];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> Even[MAXN];</span><br><span class="line">    <span class="keyword">int</span> cut[MAXN], dfn[MAXN], low[MAXN], dfs_clock;</span><br><span class="line">    <span class="keyword">int</span> Idx[MAXN], size[MAXN], sub[MAXN], idx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">        Idx[u] = idx, size[u] = V[u];</span><br><span class="line">        low[u] = dfn[u] = ++dfs_clock;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v = edges[i].to]) &#123;</span><br><span class="line">                tarjan(v, u);</span><br><span class="line">                size[u] += size[v], ++child;</span><br><span class="line">                low[u] = min(low[u], low[v]);</span><br><span class="line">                <span class="keyword">if</span> (low[v] &gt;= dfn[u])</span><br><span class="line">                    ++cut[u], sub[u] += size[v], Even[u] &amp;= !(size[v] &amp; <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dfn[v] &lt; dfn[u] &amp;&amp; v != fa)</span><br><span class="line">                low[u] = min(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!fa) --cut[u];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        dfs_clock = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">            Even[u] = <span class="literal">true</span>, sub[u] = dfn[u] = low[u] = cut[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// solve</span></span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">            <span class="keyword">if</span> (!dfn[u]) idx = u, ++p, tarjan(u, <span class="number">0</span>), s += size[u] &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// output</span></span><br><span class="line">        <span class="keyword">int</span> tot = m - n + p;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, s &gt; <span class="number">0</span>? <span class="number">0</span>: pow2[tot]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!deg[u]) <span class="built_in">printf</span>(<span class="string">"%d"</span>, s - size[u] &gt; <span class="number">0</span>? <span class="number">0</span>: pow2[tot]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>, (!Even[u] || s - (size[Idx[u]] &amp; <span class="number">1</span>) &gt; <span class="number">0</span> || ((size[Idx[u]] - V[u] - sub[u]) &amp; <span class="number">1</span>))?</span><br><span class="line">                    <span class="number">0</span>: pow2[tot - deg[u] + <span class="number">1</span> + cut[u]]);</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">" \n"</span>[u == n]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; ++i) pow2[i] = <span class="number">2L</span>L * pow2[i<span class="number">-1</span>] % P;</span><br><span class="line">    <span class="keyword">int</span> Ti;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        Graph::init();</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            Graph::AddEdge(u, v), Graph::AddEdge(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%1d"</span>, V+i);</span><br><span class="line">        <span class="comment">// solve</span></span><br><span class="line">        Graph::solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「HAOI2018」字串覆盖"><a href="#「HAOI2018」字串覆盖" class="headerlink" title="「HAOI2018」字串覆盖"></a>「HAOI2018」字串覆盖</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2525" target="_blank" rel="noopener">https://loj.ac/problem/2525</a></li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>听说是一道字符串套路工业题? 先咕着…</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div><h3 id="「HAOI2018」苹果树"><a href="#「HAOI2018」苹果树" class="headerlink" title="「HAOI2018」苹果树"></a>「HAOI2018」苹果树</h3><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2526" target="_blank" rel="noopener">https://loj.ac/problem/2526</a></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>先吐槽出题人不把模数的限制写详细一点…</p><p>不过不怎么影响做题来着.</p><p>首先可以发现, 期望再乘 $n!$ 就是大忽悠 = =, 所求即为所有节点数为 $n$ 的二叉树, 两两距离之和的和.</p><p>有一个性质, 一条边 $(i,\ j)$ 被经过的次数为 $s (n - s)$, 其中 $s$ 为 $j$ 对应子树大小. 考虑到 $n \le 2000$, 可以枚举一个点, 以及对应这个点对应子树大小来计算答案.</p><p>设当前枚举到第 $i$ 个点, 前 $i$ 个点的位置都确定了, 且节点 $i$ 某一个儿子的子树大小为 $j$.</p><p>$$\sum_{i=1}^n i! \sum_{j=1}^{n-i} j(n-j) \cdot 2\ \binom{n-i}{j} j! \cdot \prod_{k=i}^{n-j-1}k$$</p><p>再稍微解释一下, 前 $i$ 个点的选择顺序是一个排列, $i$ 到其某一个儿子的边被经过 $j(n-j)$ 次.</p><p>考虑大小为 $j$ 子树的内节点排布情况, 也就是在剩余 $n-i$ 个节点中挑出 $j$ 个节点做一个排列, 由于是二叉树, 方案数 $\times 2$.</p><p>再考虑该子树外的情况, 对于剩下的 $n - j - i$ 个节点, 不能挂在该子树内, 依次有 $i,\ i+1,\ \ldots, n-j-1$ 种选择 (因为每次都新加了一个节点), 由乘法原理乘起来就好了.</p><p>似乎做完了, 其实已经做完了, 后面的累乘预处理一下就好了.</p><p>其实后面的累乘化简一下就消掉了, 也就是</p><p>$$2\sum_{i=1}^n i!(n-i)! \sum_{j=1}^{n-i} j(n-j) \binom{n-j-1}{i-1}$$</p><p>总感觉这个式子有着什么高妙的组合意义.</p><p>时间复杂度 $O(n^2)$.</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p>代码中使用了 1 式.</p><p>2 式代码也交在 loj 上了, 常数小了一倍…</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2526</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, Mod;</span><br><span class="line"><span class="keyword">int</span> fac[MAXN], C[MAXN][MAXN], f[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;Mod);</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) C[i][j] = (C[i<span class="number">-1</span>][j<span class="number">-1</span>] + C[i<span class="number">-1</span>][j]) % Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) f[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; ++j) f[i][j] = <span class="number">1L</span>L * f[i][j<span class="number">-1</span>] * j % Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = <span class="number">1L</span>L * fac[i<span class="number">-1</span>] * i % Mod;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n - i; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> s1 = <span class="number">1L</span>L * j * (n-j) % Mod;</span><br><span class="line">            <span class="keyword">int</span> s2 = <span class="number">2L</span>L * C[n-i][j] * fac[j] % Mod;</span><br><span class="line">            now = (now + <span class="number">1L</span>L * s1 * s2 % Mod * f[i][n - j - <span class="number">1</span>] % Mod) % Mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (ans + <span class="number">1L</span>L * fac[i] * now % Mod) % Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「HAOI2018」染色"><a href="#「HAOI2018」染色" class="headerlink" title="「HAOI2018」染色"></a>「HAOI2018」染色</h3><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2527" target="_blank" rel="noopener">https://loj.ac/problem/2527</a></li></ul><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>如果想到了二项式反演, 那么这道题还算套路吧…</p><p><del>可惜没有, 溜了溜了, 还在化卷积上浪费时间, 退役稳了</del></p><p>设 $f(x)$ 表示钦定 $x$ 种颜色出现 $S$ 次, $g(x)$ 表示恰好 $x$ 种颜色出现 $S$ 次.</p><p>记 $N = \min \{ m,\ \lfloor \dfrac{n}{S} \rfloor \}$, 那么答案即为</p><p>$$\sum_{k=0}^N W_k \cdot g(k)$$</p><p>先考虑如何计算 $f(x)$, 也就是在 $m$ 种颜色中挑出 $x$ 种出现 $S$ 次, 任意排列, 且不管其余位置的颜色, 那么可以得到</p><p>$$f(x) = \binom{m}{x} \cdot \frac{n!}{(S!)^x \cdot (n-Sx)!} \cdot (m-x)^{n-Sx}$$</p><p>(中间部分是一个多重集合的排列数, 为了方便就拆开了)</p><p>对于 $f(x)$ 和 $g(x)$, 有</p><p>$$f(x) = \sum_{i=x}^N \binom{i}{x} g(i)$$</p><p>二项式反演一通之后可以得到</p><p>$$g(x) = \sum_{i=x}^N (-1) ^ {i-x} \binom{i}{x} f(i)$$</p><p>把组合数展开, 得</p><p>$$g(x) \cdot x! = \sum_{i=x}^N \frac{(-1)^{i-x}}{(i-x)!}\ i! \cdot f(i)$$</p><p>接下来, 卷积登场. 记 $h(x) = \frac{(-1)^{N-x}}{(N-x)!}$, 那么</p><p>$$g(x) \cdot x! = \sum_{i=x}^N h(N+x-i)\ i!\cdot f(i)$$</p><p>用 NTT 优化计算即可. 时间复杂度 $O(n \log n)$.</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2527</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">1e7</span> + <span class="number">5</span>, MAXN = <span class="number">1</span> &lt;&lt; <span class="number">19</span> | <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1004535809</span>, G = <span class="number">3</span>, iG = <span class="number">334845270</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fac[MAXL], ifac[MAXL];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; m)? <span class="number">0</span>: <span class="number">1L</span>L * fac[n] * ifac[n-m] % P * ifac[m] % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % P;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> unit = fpow(type &gt; <span class="number">0</span>? G: iG, (P - <span class="number">1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j, w = <span class="number">1L</span>L * w * unit % P) &#123;</span><br><span class="line">                    <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1L</span>L * w * f[i+j+Mid] % P;</span><br><span class="line">                    f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> inv = fpow(Lim, P<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * inv % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, S;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], f[MAXN], g[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m), read(S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) read(A[i]);</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="keyword">int</span> N = max(max(n, m), S);</span><br><span class="line">    ifac[<span class="number">0</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) fac[i] = <span class="number">1L</span>L * fac[i<span class="number">-1</span>] * i % P;</span><br><span class="line">    ifac[N] = fpow(fac[N], P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i; --i) ifac[i<span class="number">-1</span>] = <span class="number">1L</span>L * ifac[i] * i % P;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    N = min(m, n / S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> s1 = <span class="number">1L</span>L * fac[n] * fpow(ifac[S], i) % P * ifac[n - S * i] % P;</span><br><span class="line">        <span class="keyword">int</span> s2 = <span class="number">1L</span>L * fpow(m - i, n - S * i) * fac[i] % P;</span><br><span class="line">        f[i] = <span class="number">1L</span>L * C(m, i) * s1 % P * s2 % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        g[i] = ifac[N - i];</span><br><span class="line">        <span class="keyword">if</span> ((N - i) &amp; <span class="number">1</span>) g[i] = P - g[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Lim &lt;= N + N) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">    Poly::init(Lim, L), Poly::NTT(f, Lim, <span class="number">1</span>), Poly::NTT(g, Lim, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) g[i] = <span class="number">1L</span>L * g[i] * f[i] % P;</span><br><span class="line">    Poly::NTT(g, Lim, <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++i) ans = (ans + <span class="number">1L</span>L * g[i+N] * ifac[i] % P * A[i] % P) % P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;先祭上出题人题解.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://dy0607.github.io/%E7%9C%81%E9%80%89/oi%E5%8E%86%E7%A8%8B/2018/04/24/HAOI2018-Round1-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;dy0607 的 HAOI2018 Round1 解题报告&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然而没有找到 Round 2 的官方题解 (&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>九省联考 2018 大赏</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/union-2018-sol/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/union-2018-sol/</id>
    <published>2020-03-11T03:13:32.000Z</published>
    <updated>2020-03-12T06:08:05.876Z</updated>
    
    <content type="html"><![CDATA[<hr><p>高一玩泥巴的时候陪着学长做过… 然而只是暴力的忠实选手.</p><p><del>结果现在还是暴力的忠实选手.</del></p><a id="more"></a><h3 id="「九省联考-2018」一双木棋"><a href="#「九省联考-2018」一双木棋" class="headerlink" title="「九省联考 2018」一双木棋"></a>「九省联考 2018」一双木棋</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2471" target="_blank" rel="noopener">https://loj.ac/problem/2471</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>当年真是菜啊… 看不懂状压.</p><p>落子的规则很有意思, 手玩以后可以发现, 落子的形状是一个上三角…</p><p>考虑到 $n,\ m \le 10$, 可以状压表示这个上三角的轮廓. 具体地说, 用一条包含 <code>0</code> / <code>1</code> 的序列表示一条从左下角到右上角的轮廓线. </p><p>假如用 <code>1</code> 表示轮廓线中横线, 用 <code>0</code> 表示竖线, 那么起始状态就是 <code>((1 &lt;&lt; m) - 1) &lt;&lt; n</code>, 最终的状态为 <code>(1 &lt;&lt; m) - 1</code>. (从低位到高位, 从左下角到右上角)</p><p>此时每落一子就是把形同 <code>10</code> 的位置改为 <code>01</code>. 在扫描状态的同时确定就可以确定落子位置.</p><p>接下来就很常规了. 记 $f(S)$ 表示状态 $S$ 最大得分差值. 考虑到转移比较抽象, 于是用记忆化搜索实现, 并记录当前是轮到谁落子, 在转移时对应取 $\max$ / $\min$ 以确保正确性.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2471</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> A[MAXN][MAXN], B[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1</span> &lt;&lt; (MAXN &lt;&lt; <span class="number">1</span>)];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1</span> &lt;&lt; (MAXN &lt;&lt; <span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> sta, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[sta]) <span class="keyword">return</span> f[sta];</span><br><span class="line">    <span class="keyword">int</span>&amp; ret = f[sta];</span><br><span class="line">    ret = s? -INF: INF;</span><br><span class="line">    <span class="keyword">int</span> x = n, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + m - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sta &gt;&gt; i) &amp; <span class="number">1</span>) ++y; <span class="keyword">else</span> --x;</span><br><span class="line">        <span class="keyword">if</span> (((sta &gt;&gt; i) &amp; <span class="number">3</span>) != <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (s) ret = max(ret, dfs(sta ^ (<span class="number">3</span> &lt;&lt; i), s ^ <span class="number">1</span>) + A[x][y]);</span><br><span class="line">        <span class="keyword">else</span> ret = min(ret, dfs(sta ^ (<span class="number">3</span> &lt;&lt; i), s ^ <span class="number">1</span>) - B[x][y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[sta] = <span class="literal">true</span>, ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, A[i] + j);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, B[i] + j);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">int</span> ed = (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>;</span><br><span class="line">    vis[ed] = <span class="literal">true</span>, f[ed] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dfs(((<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>) &lt;&lt; n, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「九省联考-2018」IIIDX"><a href="#「九省联考-2018」IIIDX" class="headerlink" title="「九省联考 2018」IIIDX"></a>「九省联考 2018」IIIDX</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2472" target="_blank" rel="noopener">https://loj.ac/problem/2472</a></li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>可以发现曲目的解锁顺序构成了一个树形结构, 要求当前节点的权值 $\le$ 其子树内的权值.</p><p>于是有一个朴素的想法, 即后序遍历这棵树, 把权值从大到小依次填进去.</p><p>但是存在相同权值的时候这个贪心会有问题. 为什么?</p><p>考虑一组样例 from <a href="https://www.cnblogs.com/HocRiser/p/8742680.html" target="_blank" rel="noopener">HocRiser</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 2.0</span><br><span class="line">1 1 1 2</span><br></pre></td></tr></table></figure><p>这样在填以 $2$ 为根的子树的时候, 节点 $4$ 的点权为 $2$. 但此时 $4$ 的点权为 $1$, 而把权值 $2$ 丢给 $3$ 可以得到更优的答案…</p><p>接下来考虑如何避免相等权值的影响.</p><p>首先有一个事实, 可能填入权值的节点一定和已经填入权值的节点相邻.</p><p>现在我们维护出节点 $u$ 子树大小 <code>size[u]</code>. 并加入一个 “预约” 操作, 也就是把当前可填但未填的节点 (也就是其父亲都填完了) 的子树大小放入线段树中.</p><p>每次填入权值时, 处理出相同权值所在区间 $[L,\ R]$. 从后往前枚举, 设当前是第 $k$ 个相等权值, 填入时在线段树上二分, 找到从右到左第一个满足大于其标号的子树大小总和 $s &gt; k$ 的节点 $u$, 把当前权值填入 $u$, 并把 $u$ 的子树大小从线段树中删去, 再将 $u$ 儿子 $v$ 的子树大小加入线段树.</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2472</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; <span class="keyword">double</span> K;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], Ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (nd&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (nd&lt;&lt;1|1)</span></span><br><span class="line">    <span class="keyword">int</span> datSum[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; pos, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        datSum[nd] += val;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= Mid) Mdy(lc, L, Mid, pos, val);</span><br><span class="line">        <span class="keyword">else</span> Mdy(rc, Mid+<span class="number">1</span>, R, pos, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> L;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, d = datSum[rc];</span><br><span class="line">        <span class="keyword">if</span> (k &gt; d) <span class="keyword">return</span> Qry(lc, L, Mid, k - d);</span><br><span class="line">        <span class="keyword">return</span> Qry(rc, Mid+<span class="number">1</span>, R, k);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx, size[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">        size[from] += size[to];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// pre done</span></span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) size[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) AddEdge(<span class="built_in">floor</span>(i / K), i);</span><br><span class="line">        <span class="comment">// solve</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[<span class="number">0</span>]; ~i; i = edges[i].nxt)</span><br><span class="line">            v = edges[i].to, SGT::Mdy(<span class="number">1</span>, <span class="number">1</span>, n, v, size[v]);</span><br><span class="line">        sort(A+<span class="number">1</span>, A+<span class="number">1</span>+n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">1</span>; L &lt;= n; ++L) &#123;</span><br><span class="line">            <span class="keyword">int</span> R = L;</span><br><span class="line">            <span class="keyword">while</span> (R &lt; n &amp;&amp; A[R+<span class="number">1</span>] == A[L]) ++R;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = R - L + <span class="number">1</span>; j; --j) &#123;</span><br><span class="line">                <span class="keyword">int</span> u = SGT::Qry(<span class="number">1</span>, <span class="number">1</span>, n, j);</span><br><span class="line">                Ans[u] = A[L], SGT::Mdy(<span class="number">1</span>, <span class="number">1</span>, n, u, -size[u]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">                    v = edges[i].to, SGT::Mdy(<span class="number">1</span>, <span class="number">1</span>, n, v, size[v]);</span><br><span class="line">            &#125;</span><br><span class="line">            L = R;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// output</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, Ans[i], <span class="string">" \n"</span>[i == n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%lf"</span>, &amp;n, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]);</span><br><span class="line">    Graph::solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「九省联考-2018」秘密袭击"><a href="#「九省联考-2018」秘密袭击" class="headerlink" title="「九省联考 2018」秘密袭击"></a>「九省联考 2018」秘密袭击</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2473" target="_blank" rel="noopener">https://loj.ac/problem/2473</a></li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>首先, 有正解 “<a href="https://zhang-rq.github.io/2018/05/04/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%832018-%E7%A7%98%E5%AF%86%E8%A2%AD%E5%87%BBCoaT/" target="_blank" rel="noopener">线段树合并, 拉格朗日插值, 生成函数, 以及整体 DP</a>“.</del></p><p>考虑到本题时限 5s, 以及正解繁杂常数大, 于是暴力碾标算…</p><p>枚举 Access Globe 所操控士兵潜入的城市 $u$, 考虑潜入 $u$ 的方案数.</p><p>如果节点 $u$ 可以对答案产生贡献, 那么包含 $u$ 的连通块内一定有 $k-1$ 个满足 $d_i &gt; d_u$ 的节点. 把权值小于 $d_u$ 的节点大小标记为 $0$, 把权值大于 $d_u$ 的节点标记为 $1$, 做一个类似于树形背包的 DP 即可.</p><p>那么权值等于 $d_u$ 的呢? 为避免对某个节点重复计算, 在权值相等的时候, 仅考虑编号大于等于 (别忘了自己) $u$ 的节点.</p><p>具体地说, 设 $f(i, j)$ 表示深度最小节点为 $i$, 大小和为 $j$ 的连通块个数.</p><p>枚举每条边 $(u,\ v)$, 设 $g(i)$ 表示选择 $u$ 其余节点, 以及 $v$ 的子树内节点, 大小总和为 $i$ 的连通块个数, 显然转移是一个卷积的形式, 最后把 $g(i)$ 累加到 $f(u, i)$ 上就好了.</p><p>以及一些卡常的方法.</p><ol><li>使用 SDOI 2017 苹果树 同样的技巧, DP 数组 $f$ 开成一维, 减少 cache miss.</li><li>转移数组 $g$ 使用 <code>long long</code>, 减少取模次数.</li><li>考虑到树是一个稀疏图, 于是使用 <code>vector</code> 存图, 相比手写链表访问加快.</li></ol><p><del>然后没了, 难道要把 <code>g</code> 的转移用 MTT 优化?</del></p><p>时间复杂度 $O(nk(n-k))$.</p><p><del>如果有机会, 我一定会去学正解</del></p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2473</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1675</span>, P = <span class="number">64123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K, W, T, M;</span><br><span class="line">LL g[MAXN];</span><br><span class="line"><span class="keyword">int</span> A[MAXN], V[MAXN], f[MAXN * MAXN], size[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f + u * M, <span class="number">0</span>, T);</span><br><span class="line">    f[u * M + V[u]] = <span class="number">1</span>, size[u] = V[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v: G[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= K &amp;&amp; j &lt;= size[u]; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= K &amp;&amp; k &lt;= size[v]; ++k)</span><br><span class="line">                g[j + k] += <span class="number">1L</span>L * f[u * M + j] * f[v * M + k];</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= K &amp;&amp; j &lt;= size[u]; ++j)</span><br><span class="line">            f[u * M + j] = (f[u * M + j] + g[j]) % P, g[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(K), read(W);</span><br><span class="line">    M = K + <span class="number">1</span>, T = M * <span class="keyword">sizeof</span> (<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        read(u), read(v), G[u].push_back(v), G[v].push_back(u);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cnt, u = <span class="number">1</span>; u &lt;= n; ++u) &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            V[i] = (A[i] &gt; A[u] || (A[i] == A[u] &amp;&amp; i &gt;= u)), cnt += V[i];</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; K) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(u, <span class="number">0</span>), ans = (ans + A[u] * f[u * M + K] % P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「九省联考-2018」劈配"><a href="#「九省联考-2018」劈配" class="headerlink" title="「九省联考 2018」劈配"></a>「九省联考 2018」劈配</h3><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2477" target="_blank" rel="noopener">https://loj.ac/problem/2477</a></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>容易发现, 题目要求我们做的就是一个二分图匹配. 考虑用网络流解决这个问题.</p><p>对于第一问, 从 $1$ 到 $n$ 依次考虑每个选手 $i$ 的匹配情况.</p><p>如果只有一位选手 $i$, 那么</p><ul><li>新建源汇 $S$, $T$, 其中 $S$ 对选手 $i$ 连边, 容量为 $1$; 每位导师 $j$ 向 $T$ 连边, 容量为 $b_j$.</li><li>枚举选手志愿, $i$ 向该档志愿导师 $j$ 连边, 容量为 $1$.<ul><li>如果此时存在增广路, 那么该选手被该档志愿录取</li><li>否则继续枚举志愿, 直到选手被录取 / 出局</li></ul></li></ul><p>考虑其他选手的影响. 由录取方案的最优性可知, 只有排名比 $i$ 靠前的选手对 $i$ 有影响, 那么每位选手直接在上一位选手的残量网络上建边即可.</p><p>未被枚举到的志愿录取时, 需要及时把此档志愿所建的边回退掉, 以避免多出用不到的废边, 从而影响时间复杂度的正确性…</p><p>对于第二问, 可以发现答案可以二分 — 如果选手到了第 $1$ 名, 还不能达到自己的要求, 那肯定会沮丧了.</p><p>我们二分一个答案 $x$, 表示选手 $i$ 不沮丧时的 <strong>最小排名</strong>. <code>check</code> 的时候前 $x-1$ 名选手的录取情况并不会改变, 再次基础上加入选手 $i$ 的前 $s_i$ 个志愿, 判断新图是否存在增广路即可.</p><p>每次都建一次新图, 并把前 $x-1$ 名选手匹配好有些麻烦, 时间复杂度还很高. 考虑到解决第一问时, 已经把这些匹配求过一遍了, 所以记录选手录取情况的前缀图, 每次 <code>check</code> 调用即可. 因为点数很小, 所以可以保证每次暴力复制的复杂度.</p><p>时间复杂度大概是 $O(\ T(n^2m + n^2 \log n)\ )$?</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p>由于这道题的特殊性, Dinic 当前弧优化并不适用.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2477</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">205</span>, MAXV = MAXN &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, C, S, T;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> Ans1[MAXN], Ans2[MAXN], B[MAXN], s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, flow, cap;</span><br><span class="line">    Edge() &#123; &#125;</span><br><span class="line">    Edge(<span class="keyword">int</span> _v, <span class="keyword">int</span> _c): to(_v), cap(_c) &#123; flow = <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXV];</span><br><span class="line">    <span class="keyword">int</span> depth[MAXV], vis[MAXV], Time;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        edges.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + m + <span class="number">1</span>; ++i) G[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        edges.push_back(Edge(to, c)), edges.push_back(Edge(from, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> eidx = edges.size() - <span class="number">1</span>;</span><br><span class="line">        G[from].push_back(eidx - <span class="number">1</span>), G[to].push_back(eidx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DelEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        G[from].pop_back(), G[to].pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        Q.push(S), vis[S] = ++Time, depth[S] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; G[u].size(); ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> Edge&amp; e = edges[G[u][i]];</span><br><span class="line">                <span class="keyword">if</span> (vis[e.to] != Time &amp;&amp; e.cap &gt; e.flow)</span><br><span class="line">                    vis[e.to] = Time, depth[e.to] = depth[u] + <span class="number">1</span>, Q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[T] == Time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == T || !a) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> f, flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; G[u].size(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[u][i]];</span><br><span class="line">            <span class="keyword">if</span> (depth[e.to] == depth[u] + <span class="number">1</span> &amp;&amp; (f = DFS(e.to, min(a, e.cap-e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                flow += f, a -= f, e.flow += f, edges[G[u][i]^<span class="number">1</span>].flow -= f;</span><br><span class="line">                <span class="keyword">if</span> (!a) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> Mid, <span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Graph now;</span><br><span class="line">    now = G[Mid - <span class="number">1</span>], now.AddEdge(S, u, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s[u]; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> k = <span class="number">0</span>; k &lt; A[u][j].size(); ++k) now.AddEdge(u, n + A[u][j][k], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> now.BFS();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> Ti; read(Ti), read(C);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        read(n), read(m);</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        S = <span class="number">0</span>, T = n + m + <span class="number">1</span>;</span><br><span class="line">        G[<span class="number">0</span>].init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) A[i][j].clear();</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) read(B[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x, i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) read(x), A[i][x].push_back(j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(s[i]);</span><br><span class="line">        <span class="comment">// solve</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) G[<span class="number">0</span>].AddEdge(n + i, T, B[i]);</span><br><span class="line">        <span class="comment">// Q1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            Ans1[i] = <span class="number">0</span>;</span><br><span class="line">            G[i] = G[i - <span class="number">1</span>], G[i].AddEdge(S, i, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> k = <span class="number">0</span>; k &lt; A[i][j].size(); ++k) G[i].AddEdge(i, n + A[i][j][k], <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (G[i].BFS()) &#123; G[i].DFS(S, INF), Ans1[i] = j; <span class="keyword">break</span>; &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> k = <span class="number">0</span>; k &lt; A[i][j].size(); ++k) G[i].DelEdge(i, n + A[i][j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!Ans1[i]) Ans1[i] = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Q2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            Ans2[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= Ans1[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> L = <span class="number">1</span>, R = i - <span class="number">1</span>, ans = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">                <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (check(Mid, i)) ans = Mid, L = Mid + <span class="number">1</span>; <span class="keyword">else</span> R = Mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Ans2[i] = (ans == <span class="number">-1</span>)? i: i - ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// output</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, Ans1[i], <span class="string">" \n"</span>[i == n]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, Ans2[i], <span class="string">" \n"</span>[i == n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「九省联考-2018」林克卡特树"><a href="#「九省联考-2018」林克卡特树" class="headerlink" title="「九省联考 2018」林克卡特树"></a>「九省联考 2018」林克卡特树</h3><p>人生第一道 DP 凸优化…</p><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2478" target="_blank" rel="noopener">https://loj.ac/problem/2478</a></li></ul><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先对题意做一步转化, </p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2478</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> &#123;</span></span><br><span class="line">    LL a; <span class="keyword">int</span> b;</span><br><span class="line">    Item(LL _a = <span class="number">0</span>, <span class="keyword">int</span> _b = <span class="number">0</span>): a(_a), b(_b) &#123; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; rhs.a || (a == rhs.a &amp;&amp; b &gt; rhs.b);</span><br><span class="line">    &#125;</span><br><span class="line">    Item <span class="keyword">operator</span> + (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Item(a + rhs.a, b + rhs.b); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K;</span><br><span class="line">Item f[MAXN][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, w; &#125; edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, w &#125;, head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">const</span> LL&amp; s)</span> </span>&#123;</span><br><span class="line">        f[u][<span class="number">0</span>] = f[u][<span class="number">1</span>] = Item(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        f[u][<span class="number">2</span>] = max(Item(<span class="number">0</span>, <span class="number">0</span>), Item(-s, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) == fa) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(v, u, s);</span><br><span class="line">            f[u][<span class="number">2</span>] = max(f[u][<span class="number">2</span>], max(f[u][<span class="number">2</span>] + f[v][<span class="number">0</span>], f[u][<span class="number">1</span>] + f[v][<span class="number">1</span>] + Item(edges[i].w - s, <span class="number">1</span>)));</span><br><span class="line">            f[u][<span class="number">1</span>] = max(f[u][<span class="number">1</span>], max(f[u][<span class="number">1</span>] + f[v][<span class="number">0</span>], f[u][<span class="number">0</span>] + f[v][<span class="number">1</span>] + Item(edges[i].w)));</span><br><span class="line">            f[u][<span class="number">0</span>] = max(f[u][<span class="number">0</span>], f[u][<span class="number">0</span>] + f[v][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        f[u][<span class="number">0</span>] = max(f[u][<span class="number">0</span>], max(f[u][<span class="number">1</span>] + Item(-s, <span class="number">1</span>), f[u][<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(K), ++K;</span><br><span class="line">    LL L = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, w, i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        read(u), read(v), read(w);</span><br><span class="line">        L = min(L, <span class="number">-1L</span>L * w), R += max(<span class="number">0</span>, w);</span><br><span class="line">        Graph::AddEdge(u, v, w), Graph::AddEdge(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    LL ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        LL Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        Graph::dfs(<span class="number">1</span>, <span class="number">0</span>, Mid);</span><br><span class="line">        <span class="keyword">if</span> (f[<span class="number">1</span>][<span class="number">0</span>].b &lt;= K) ans = Mid, R = Mid - <span class="number">1</span>; <span class="keyword">else</span> L = Mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Graph::dfs(<span class="number">1</span>, <span class="number">0</span>, ans);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[<span class="number">1</span>][<span class="number">0</span>].a + ans * K);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「九省联考-2018」制胡窜"><a href="#「九省联考-2018」制胡窜" class="headerlink" title="「九省联考 2018」制胡窜"></a>「九省联考 2018」制胡窜</h3><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2479" target="_blank" rel="noopener">https://loj.ac/problem/2479</a></li></ul><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>有着很复杂的分类讨论, 以及相当繁琐的细节…</p><p><del>还是 <a href="http://labelray.top/2019/03/01/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83-2018-%E5%88%B6%E8%83%A1%E7%AA%9C/" target="_blank" rel="noopener">Labelray</a> 讲地好哇.</del></p><p>还是拿 Labelray 的题解再展开说一点东西.</p><p>对于 Case 2.1, 我个人认为最终的答案应为</p><p>$$\sum_{i=1}^{n-1} (r_{i+1} - l_n) \cdot (l_{i+1} - l_i)$$</p><p>化简之后可以得到</p><p>$$\sum_{i=1}^{n-1} r_{i+1} (r_{i+1}-r_i) - l_n \cdot \sum_{i=1}^{n-1} (r_{i+1} - r_i) $$</p><p>以及 Case 3, 在满足限制 $l_n &lt; r_{i+1} &lt; r_1 + len - 1$ 时, 直接在线段树上查询区间 $(l_n,\ r_1 + len - 1]$, 则会缺失左边界.</p><p>具体地说, 由于使用右端点 $r_i$ 的差代替左端点 $l_i$ 的差, 在计算时会漏掉 $r_i &lt; l_n &lt; r_{i+1}$ 的情况, 但此时对应左边一刀切在 $(l_i, l_{i+1})$ 的情况仍然合法. 于是在统计中需要加入 $[1,\ l_n]$ 的最大端点, 同线段树查询结果合并即可.</p><p>时间复杂度 $O(n \log n + q \log n)$.</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2479</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>, MAXM = <span class="number">2e5</span> + <span class="number">5</span>, LOG = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1L</span>L * n * (n<span class="number">-1</span>) / <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">char</span> S[MAXN];</span><br><span class="line"><span class="keyword">int</span> rt[MAXM], pos[MAXN], pre[LOG][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mx, mn; LL s1, s2;</span><br><span class="line"></span><br><span class="line">    Data() &#123; mx = -MAXN, mn = MAXN, s1 = s2 = <span class="number">0</span>; &#125;</span><br><span class="line">    Data(<span class="keyword">int</span> _mx, <span class="keyword">int</span> _mn, LL _s1, LL _s2): mx(_mx), mn(_mn), s1(_s1), s2(_s2) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Data <span class="keyword">operator</span> + (<span class="keyword">const</span> Data&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mx == -MAXN &amp;&amp; mn == MAXN) <span class="keyword">return</span> rhs;</span><br><span class="line">        <span class="keyword">if</span> (rhs.mx == -MAXN &amp;&amp; rhs.mn == MAXN) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> Data(rhs.mx, mn, s1 + rhs.s1 + <span class="number">1L</span>L * rhs.mn * (rhs.mn - mx),</span><br><span class="line">                s2 + rhs.s2 + (rhs.mn - mx));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> lc, rc; Data d;</span><br><span class="line">        Node() &#123; lc = rc = <span class="number">0</span>; d = Data(); &#125;</span><br><span class="line">    &#125; dat[MAXM &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> nidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> &amp;lc = dat[nd].lc, &amp;rc = dat[nd].rc;</span><br><span class="line">        dat[nd].d = dat[lc].d + dat[rc].d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> <span class="keyword">void</span>( dat[nd].d.mn = dat[nd].d.mx = pos );</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= Mid) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dat[nd].lc) dat[nd].lc = ++nidx;</span><br><span class="line">            Mdy(dat[nd].lc, L, Mid, pos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dat[nd].rc) dat[nd].rc = ++nidx;</span><br><span class="line">            Mdy(dat[nd].rc, Mid+<span class="number">1</span>, R, pos);</span><br><span class="line">        &#125;</span><br><span class="line">        maintain(nd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Mrg</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line">        <span class="keyword">int</span> nd = ++nidx;</span><br><span class="line">        dat[nd].lc = Mrg(dat[x].lc, dat[y].lc);</span><br><span class="line">        dat[nd].rc = Mrg(dat[x].rc, dat[y].rc);</span><br><span class="line">        <span class="keyword">return</span> maintain(nd), nd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Data <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nd) <span class="keyword">return</span> Data();</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> dat[nd].d;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> Qry(dat[nd].lc, L, Mid, opL, opR);</span><br><span class="line">        <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> Qry(dat[nd].rc, Mid+<span class="number">1</span>, R, opL, opR);</span><br><span class="line">        <span class="keyword">return</span> Qry(dat[nd].lc, L, Mid, opL, opR) + Qry(dat[nd].rc, Mid+<span class="number">1</span>, R, opL, opR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> lgt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r1 = dat[nd].d.mn, ln = dat[nd].d.mx - lgt + <span class="number">1</span>;</span><br><span class="line">        Data d = Qry(nd, <span class="number">1</span>, n, <span class="number">1</span>, ln);</span><br><span class="line">        LL ret = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Case 1</span></span><br><span class="line">        <span class="keyword">if</span> (d.mx - lgt + <span class="number">1</span> &gt;= r1) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Case 2</span></span><br><span class="line">        <span class="keyword">if</span> (r1 &gt; ln) &#123;</span><br><span class="line">            ret += dat[nd].d.s1 - <span class="number">1L</span>L * ln * dat[nd].d.s2;</span><br><span class="line">            ret += <span class="number">1L</span>L * (r1 - ln) * (n - lgt) + C2(r1 - ln);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Case 3</span></span><br><span class="line">        <span class="keyword">if</span> (ln &lt; r1 + lgt - <span class="number">1</span>) &#123;</span><br><span class="line">            Data p = Data(d.mx, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) + Qry(nd, <span class="number">1</span>, n, ln + <span class="number">1</span>, r1 + lgt - <span class="number">1</span>);</span><br><span class="line">            ret += p.s1 - <span class="number">1L</span>L * ln * p.s2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ri = Qry(nd, <span class="number">1</span>, n, <span class="number">1</span>, r1 + lgt - <span class="number">1</span>).mx, ri1 = Qry(nd, <span class="number">1</span>, n, r1 + lgt, n).mn;</span><br><span class="line">        <span class="keyword">if</span> (ri != -MAXN &amp;&amp; ri1 != MAXN) ret += max(<span class="number">0L</span>L, <span class="number">1L</span>L * (r1 - (ri-lgt+<span class="number">1</span>)) * (ri1 - ln));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SAM &#123;</span><br><span class="line">    <span class="keyword">int</span> ch[MAXM][<span class="number">10</span>], len[MAXM], lnk[MAXM], nidx, last;</span><br><span class="line">    <span class="keyword">int</span> cnt[MAXM], idx[MAXM];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; nidx = last = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nd = ++nidx, p = last;</span><br><span class="line">        len[nd] = len[last] + <span class="number">1</span>, SGT::Mdy(rt[nd] = ++SGT::nidx, <span class="number">1</span>, n, i);</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !ch[p][val]) ch[p][val] = nd, p = lnk[p];</span><br><span class="line">        <span class="keyword">if</span> (!p) lnk[nd] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> q = ch[p][val];</span><br><span class="line">            <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) lnk[nd] = q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> nxt = ++nidx;</span><br><span class="line">                len[nxt] = len[p] + <span class="number">1</span>, lnk[nxt] = lnk[q];</span><br><span class="line">                <span class="built_in">memcpy</span>(ch[nxt], ch[q], <span class="keyword">sizeof</span> ch[nxt]);</span><br><span class="line">                <span class="keyword">while</span> (p &amp;&amp; ch[p][val] == q) ch[p][val] = nxt, p = lnk[p];</span><br><span class="line">                lnk[nd] = lnk[q] = nxt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last = nd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nidx; ++i) ++cnt[len[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cnt[i] += cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nidx; ++i) idx[cnt[len[i]]--] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u, i = nidx; i &gt; <span class="number">1</span>; --i)</span><br><span class="line">            u = idx[i], rt[lnk[u]] = SGT::Mrg(rt[lnk[u]], rt[u]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nidx; ++i) pre[<span class="number">0</span>][i] = lnk[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; LOG; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nidx; ++i)</span><br><span class="line">                pre[j][i] = pre[j<span class="number">-1</span>][pre[j<span class="number">-1</span>][i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Jump</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; lgt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = LOG<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">            <span class="keyword">if</span> (pre[j][u] &amp;&amp; len[pre[j][u]] &gt;= lgt) u = pre[j][u];</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = Jump(pos[R], R - L + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> SGT::Qry(rt[u], R - L + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    SAM::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;n, &amp;q, S+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        SAM::insert(S[i] - <span class="string">'0'</span>, i), pos[i] = SAM::last;</span><br><span class="line">    SAM::build();</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> L, R;</span><br><span class="line">        read(L), read(R);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, C2(n - <span class="number">1</span>) - SAM::Qry(L, R));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;高一玩泥巴的时候陪着学长做过… 然而只是暴力的忠实选手.&lt;/p&gt;
&lt;p&gt;&lt;del&gt;结果现在还是暴力的忠实选手.&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>AHOI / HNOI 2017 大赏</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/AHOI-HNOI-2017-sol/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/AHOI-HNOI-2017-sol/</id>
    <published>2020-03-10T12:17:51.000Z</published>
    <updated>2020-03-10T16:51:48.501Z</updated>
    
    <content type="html"><![CDATA[<hr><p>如果说 “我做了一套 AHOI”, 恐怕和 “我做了一套 HNOI” 给人的感觉不太一样…</p><p>但其实是一样的? <del>OI 什么时候能实现地域的平衡啊.</del> 这辈子不可能了.</p><a id="more"></a><p>其实不如 SDOI R2 毒瘤 (</p><h3 id="「AHOI-HNOI2017」单旋"><a href="#「AHOI-HNOI2017」单旋" class="headerlink" title="「AHOI / HNOI2017」单旋"></a>「AHOI / HNOI2017」单旋</h3><blockquote><p>“邪恶的「卡」带着他的邪恶的「常数」来企图毁灭 H 国.”</p></blockquote><p>可以说是很形象了.</p><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2018" target="_blank" rel="noopener">https://loj.ac/problem/2018</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这是一道性质题.</p><p>本题最重要的性质就是, 如果把某个节点 $u$ “spaly” 到根, 那么整棵二叉搜索树的形态不会发生较大改变.</p><p>具体地说, 假设当前要把最小值对应节点 $u$ “spaly” 到根, 实际上只做了这几个操作:</p><ol><li>$u$ 的右儿子接到 $u$ 父亲 $f$ 的左儿子上.</li><li>把 $u$ 设成根, 然后把原来的根接到 $u$ 的右儿子上.</li></ol><p>考虑这个过程中的节点深度变化, 可以发现 $u$ 的深度变为 $1$, $u$ 原来的右儿子深度不变, 其余点的深度 $+1$.</p><p>那么可以用 BIT 维护这个深度了.</p><p>既然关键码互不相同, 那我们直接把关键码离散化后的值视作节点编号, 这样子树内编号一定是连续的. 因为操作的特殊性: 只选择最大值和最小值, 所以直接修改到 1 / n 即可.</p><p>再考虑插入操作怎么实现. </p><p>注意道每次插入一个节点 $u$, $u$ 的父亲 $f$ 一定是 $u$ 的前驱 / 后继中深度较深的一个, 使用 STL 里的 <code>set</code> 直接维护即可.</p><p>时间复杂度 $O(n\log n)$.</p><p><del>感谢这道题让我知道 spaly 多么蠢…</del></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>代码实现中有一些简单的技巧…</p><p>诸如预先在 <code>set</code> 中插入 <code>0</code>, <code>n+1</code> 以避免讨论, 以及利用平衡树旋转时的技巧简化代码.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2018</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator IT;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nB, m, ans;</span><br><span class="line"><span class="keyword">int</span> Q[MAXN], A[MAXN], B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">    <span class="keyword">int</span> C[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i; i -= lowbit(i)) ret += C[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; pos, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= nB + <span class="number">1</span>; i += lowbit(i)) C[i] += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        Mdy(L, val), Mdy(R+<span class="number">1</span>, -val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实 spaly 的名字只是来哗众取宠的</span></span><br><span class="line"><span class="keyword">namespace</span> Spaly &#123;</span><br><span class="line">    <span class="keyword">int</span> pre[MAXN], ch[<span class="number">2</span>][MAXN], root;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; S.insert(<span class="number">0</span>), S.insert(nB + <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类似于 splay 中的 connect ?</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spaly</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> fa = pre[u];</span><br><span class="line">        <span class="keyword">if</span> (w) BIT::Mdy(<span class="number">1</span>, fa, <span class="number">1</span>); <span class="keyword">else</span> BIT::Mdy(fa, nB, <span class="number">1</span>);</span><br><span class="line">        BIT::Mdy(u, u, <span class="number">1</span> - ans);</span><br><span class="line">        ch[w][fa] = ch[w ^ <span class="number">1</span>][u];</span><br><span class="line">        <span class="keyword">if</span> (ch[w][fa]) pre[ch[w][fa]] = fa;</span><br><span class="line">        ch[w ^ <span class="number">1</span>][u] = root, pre[root] = u, pre[root = u] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = lower_bound(B+<span class="number">1</span>, B+<span class="number">1</span>+nB, v) - B;</span><br><span class="line">        <span class="keyword">if</span> (!root) root = u, ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            IT ite = S.lower_bound(u), suf = ite, nxt = --ite;</span><br><span class="line">            <span class="keyword">int</span> fa = BIT::Qry(*nxt) &gt; BIT::Qry(*suf)? *nxt: *suf;</span><br><span class="line">            ans = BIT::Qry(fa) + <span class="number">1</span>, pre[u] = fa, ch[fa == *nxt][fa] = u;</span><br><span class="line">        &#125;</span><br><span class="line">        S.insert(u), BIT::Mdy(u, u, ans - BIT::Qry(u));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Nxt</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = w? *(++S.rbegin()): *(++S.begin());</span><br><span class="line">        <span class="keyword">return</span> ans = BIT::Qry(u), spaly(u, w), u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rmv</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = Nxt(w);</span><br><span class="line">        S.erase(u), pre[root = ch[w ^ <span class="number">1</span>][u]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (w) BIT::Mdy(<span class="number">1</span>, u, <span class="number">-1</span>); <span class="keyword">else</span> BIT::Mdy(u, nB, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        read(Q[i]);</span><br><span class="line">        <span class="keyword">if</span> (Q[i] == <span class="number">1</span>) read(A[i]), B[++nB] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    Spaly::init();</span><br><span class="line">    sort(B+<span class="number">1</span>, B+<span class="number">1</span>+nB);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (Q[i]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: Spaly::insert(A[i]); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: Spaly::Nxt(<span class="number">0</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: Spaly::Nxt(<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: Spaly::Rmv(<span class="number">0</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>: Spaly::Rmv(<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERR\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「AHOI-HNOI2017」影魔"><a href="#「AHOI-HNOI2017」影魔" class="headerlink" title="「AHOI / HNOI2017」影魔"></a>「AHOI / HNOI2017」影魔</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2019" target="_blank" rel="noopener">https://loj.ac/problem/2019</a></li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>直接统计不好维护, 于是将操作离线, 枚举每个位置, 依次加入贡献 / 差分统计贡献.</p><p>记 $c = \max \{ k_s \mid i &lt; s &lt; j \}$, 依次讨论什么情况下对答案会有 $p_1$ / $p_2$ 的贡献.</p><ol><li><p>$i + 1 = j$</p><p>此时不存在此 $c$, 对答案有 $p_1$ 的贡献.</p></li><li><p>$c \le \min \{k_i,\ k_j \}$</p><p>此时有 $p_1$ 的贡献. 但是不好直接统计, 于是转化一下, 考虑某个位置 $i$ 对答案有贡献的情况.</p><p>对于每个位置 $i$, 利用单调栈处理出左侧第一个比 $k_i$ 的位置 $L_i$, 以及右侧第一个比 $k_i$ 大的位置 $R_i$. 可以得到</p><ul><li>如果一个询问完全包含 $[L_i,\ R_i]$, 那么对答案有 $p_1$ 的贡献.</li></ul></li><li><p>$\min \{ k_i,\ k_j \} &lt; c &lt; \max \{ k_i,\ k_j \}$</p><p>此处有 $p_2$ 的贡献. 沿用 Case 2 的思路. 可以发现</p><ul><li>如果一个区间包含 $L_i$, 那么 $L_i$ 可以在 $[i+1,\ R_i - 1]$ 对答案有 $p_2$ 的贡献.</li><li>如果一个区间包含 $R_i$, 那么 $R_i$ 可以在 $[L_i + 1,\ i-1]$ 对答案有 $p_2$ 的贡献.</li></ul></li></ol><p>这样就做完了. 实际代码实现并不复杂…</p><p>考虑到拆成扫描线之后修改 / 查询的操作总和达到了 $10^6$ 的级别…</p><p>于是使用 BIT 实现区间加 / 区间求和, 时间复杂度 $O(n \log n)$.</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2019</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span> + <span class="number">5</span>, MAXM = <span class="number">5</span> * MAXN;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> type, x, L, R, val;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Ask&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; rhs.x || (x == rhs.x &amp;&amp; type &lt; rhs.type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Q[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, qidx;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], p1, p2;</span><br><span class="line"><span class="keyword">int</span> Lpos[MAXN], Rpos[MAXN], stk[MAXN], top;</span><br><span class="line">LL Ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">    LL C1[MAXN], C2[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; pos, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= n; i += lowbit(i)) C1[i] += val, C2[i] += <span class="number">1L</span>L * val * pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123; Mdy(L, val), Mdy(R+<span class="number">1</span>, -val); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        LL ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i; i -= lowbit(i)) ret += C1[i] * (pos + <span class="number">1</span>) - C2[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R)</span> </span>&#123; <span class="keyword">return</span> Qry(R) - Qry(L<span class="number">-1</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m), read(p1), read(p2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    stk[top = <span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &amp;&amp; A[stk[top]] &lt; A[i]) Rpos[stk[top--]] = i;</span><br><span class="line">        Lpos[i] = stk[top], stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (top) Rpos[stk[top--]] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n)</span><br><span class="line">            Q[++qidx] = (Ask)&#123; <span class="number">0</span>, i + <span class="number">1</span>, i, i, p1 &#125;;</span><br><span class="line">        <span class="keyword">if</span> (Lpos[i] &gt;= <span class="number">1</span> &amp;&amp; Rpos[i] &lt;= n)</span><br><span class="line">            Q[++qidx] = (Ask)&#123; <span class="number">0</span>, Rpos[i], Lpos[i], Lpos[i], p1 &#125;;</span><br><span class="line">        <span class="keyword">if</span> (Lpos[i] &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= Rpos[i] - <span class="number">1</span>)</span><br><span class="line">            Q[++qidx] = (Ask)&#123; <span class="number">0</span>, Lpos[i], i + <span class="number">1</span>, Rpos[i] - <span class="number">1</span>, p2 &#125;;</span><br><span class="line">        <span class="keyword">if</span> (Rpos[i] &lt;= n + <span class="number">1</span> &amp;&amp; Lpos[i] + <span class="number">1</span> &lt;= i - <span class="number">1</span>)</span><br><span class="line">            Q[++qidx] = (Ask)&#123; <span class="number">0</span>, Rpos[i], Lpos[i] + <span class="number">1</span>, i - <span class="number">1</span>, p2 &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> L, R, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        read(L), read(R);</span><br><span class="line">        Q[++qidx] = (Ask)&#123; i, L<span class="number">-1</span>, L, R, <span class="number">-1</span> &#125;;</span><br><span class="line">        Q[++qidx] = (Ask)&#123; i, R, L, R, <span class="number">1</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(Q+<span class="number">1</span>, Q+<span class="number">1</span>+qidx);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qidx; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Q[i].type == <span class="number">0</span>) BIT::Mdy(Q[i].L, Q[i].R, Q[i].val);</span><br><span class="line">        <span class="keyword">else</span> Ans[Q[i].type] += Q[i].val * BIT::Qry(Q[i].L, Q[i].R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「AHOI-HNOI2017」礼物"><a href="#「AHOI-HNOI2017」礼物" class="headerlink" title="「AHOI / HNOI2017」礼物"></a>「AHOI / HNOI2017」礼物</h3><p>当年入门多项式的时候写的题…</p><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2020" target="_blank" rel="noopener">https://loj.ac/problem/2020</a></li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先旋转的操作可以看作是在枚举一个起始点 $k$, 超出部分复制一遍 $x_i$ 接到 $x_n$ 后面即可. 把差异值形式地写下来就是</p><p>$$\min_{c, k} \{ \sum_{i=1}^n (x_{i+k} - y_i + c) ^ 2 \}$$</p><p>展开, 得</p><p>$$\sum_{i=1}^n (x_i^2 + y_i^2) + 2c \cdot \sum_{i=1}^n (x_i - y_i) + n c^2 - 2 \sum_{i=1}^n x_{i+k} y_i$$</p><p>除了最后面的和式, 其余部分直接统计 / 二次函数极值就可以解决.</p><p>考虑构造一个序列 $t_i = x_{n-i+1}$, 那么</p><p>$$\sum_{i=1}^n x_{i+k} y_i = \sum_{i=1}^n t_{n-i+1+k} y_i$$</p><p>这就是一个卷积的形式了, 使用 FFT / NTT 优化这一过程即可.</p><p>时间复杂度 $O(n \log n)$.</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2020</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>, G = <span class="number">3</span>, iG = <span class="number">332748118</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % P;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> unit = fpow(type &gt; <span class="number">0</span>? G: iG, (P - <span class="number">1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j, w = <span class="number">1L</span>L * w * unit % P) &#123;</span><br><span class="line">                    <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1L</span>L * w * f[i+j+Mid] % P;</span><br><span class="line">                    f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> inv = fpow(Lim, P<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * inv % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line"><span class="keyword">int</span> a[MAXN], b[MAXN], t[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(b[i]);</span><br><span class="line">    <span class="comment">// calc c</span></span><br><span class="line">    <span class="keyword">int</span> B = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ans += a[i] * a[i] + b[i] * b[i], B += a[i] - b[i];</span><br><span class="line">    <span class="keyword">int</span> c1 = <span class="built_in">floor</span>(<span class="number">-1.0</span> * B / n), c2 = <span class="built_in">ceil</span>(<span class="number">-1.0</span> * B / n);</span><br><span class="line">    ans += min(n * c1 * c1 + <span class="number">2</span> * B * c1, n * c2 * c2 + <span class="number">2</span> * B * c2);</span><br><span class="line">    <span class="comment">// polynomial</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) t[n + i] = t[i] = a[n - i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Lim &lt;= <span class="number">2</span>*n + n) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">    Poly::init(Lim, L), Poly::NTT(t, Lim, <span class="number">1</span>), Poly::NTT(b, Lim, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) t[i] = <span class="number">1L</span>L * t[i] * b[i] % P;</span><br><span class="line">    Poly::NTT(t, Lim, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> p2 = -P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++i) p2 = max(p2, <span class="number">2</span> * t[i]);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans - p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「AHOI-HNOI2017」大佬"><a href="#「AHOI-HNOI2017」大佬" class="headerlink" title="「AHOI / HNOI2017」大佬"></a>「AHOI / HNOI2017」大佬</h3><p>很真实的题面.</p><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2021" target="_blank" rel="noopener">https://loj.ac/problem/2021</a></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先有一个朴素的 DP, 把能丢到状态的都丢进去…</p><p>考虑到打倒大佬可以分为两部分, 也就是保证自己存活, 以及摧毁大佬自信.</p><p>注意到 “保证存活” 这一限制和每天采用什么策略有关, 而 “摧毁自信” 只和总天数有关.</p><p>于是可以 DP 出保证存活的条件下最大斗争天数.</p><p>设 $f(i, j)$ 表示第 $i$ 天, 自信值为 $j$ 时用于打倒大佬的最大天数. 则有转移</p><p>$$f(i, j - a_i) = \max \{\ f(i-1, j) + 1\ \}$$</p><p>表示这天选择同大佬斗争.</p><p>$$f(i, j - a_i + w_i) = \max \{\ f(i-1, j)\ \}$$</p><p>表示这天去做水题 <del>续命</del>…</p><p>在得到最大斗争天数 $md$ 后, 直接 BFS 计算这些天内能积累的的讽刺能力 $F$, 以及所用天数 $D$.</p><p>那么对于一个自信值为 $C$ 的大佬, 依次枚举 “怼大佬” 的次数, 即 0, 1, 2, 并判定即可.</p><p>对于使用两次 “怼大佬” 操作的情况, 利用 Two-Pointer 的技巧配合 $F$ 的单调性枚举即可.</p><p>具体地说, 当前合法的两次操作 $i,\ j$ 满足 $F_i + F_j \le C$, 且 $C - F_i - F_j + D_i + D_j \le md$.</p><p>(换言之, 不能直接把大佬自信值嘲讽到负, 且剩余部分可以还嘴解决)</p><p>这种带搜索的题目, 时间复杂度不想分析了, $O(\texttt{能过})$.</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2021</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">105</span>, MAXM = <span class="number">1e6</span> + <span class="number">5</span>, MAXC = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, mc, md;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], W[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> F[MAXM], D[MAXM], nF;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; M;</span><br><span class="line"><span class="built_in">map</span>&lt;Pii, <span class="keyword">bool</span>&gt; vis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> QF[MAXM], QL[MAXM], Qd[MAXM];</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line">    QF[++tail] = <span class="number">1</span>, QL[tail] = <span class="number">0</span>, Qd[tail] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">        <span class="keyword">int</span> fe = QF[head], l = QL[head], d = Qd[head]; ++head;</span><br><span class="line">        <span class="keyword">if</span> (!M.count(fe)) M[fe] = d;</span><br><span class="line">        <span class="keyword">if</span> (d &gt;= md || <span class="number">1L</span>L * fe * l &gt; MAXC) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!vis[Pii(l+<span class="number">1</span>, fe)]) &#123;</span><br><span class="line">            QF[++tail] = fe, QL[tail] = l + <span class="number">1</span>, Qd[tail] = d + <span class="number">1</span>;</span><br><span class="line">            vis[Pii(l+<span class="number">1</span>, fe)] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> &lt; l &amp;&amp; <span class="number">1L</span>L * fe * l &lt;= MAXC &amp;&amp; !vis[Pii(l, fe * l)]) &#123;</span><br><span class="line">            QF[++tail] = fe * l, QL[tail] = l, Qd[tail] = d + <span class="number">1</span>;</span><br><span class="line">            vis[Pii(l, fe * l)] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m), read(mc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(W[i]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = A[i]; j &lt;= mc; ++j) &#123;</span><br><span class="line">            f[i][j - A[i]] = max(f[i][j - A[i]], f[i<span class="number">-1</span>][j] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> p = min(mc, j - A[i] + W[i]);</span><br><span class="line">            f[i][p] = max(f[i][p], f[i<span class="number">-1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= mc; ++j) md = max(md, f[i][j]);</span><br><span class="line">    BFS();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ite = M.begin(); ite != M.end(); ++ite)</span><br><span class="line">        F[++nF] = ite-&gt;first, D[nF] = ite-&gt;second;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> C, ans;</span><br><span class="line">        read(C), ans = C &lt;= md;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nF &amp;&amp; !ans; ++i)</span><br><span class="line">            ans |= F[i] &lt;= C &amp;&amp; D[i] + C - F[i] &lt;= md;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, i = nF; i &amp;&amp; !ans; --i)</span><br><span class="line">            <span class="keyword">while</span> (!ans &amp;&amp; j &lt;= nF &amp;&amp; F[i] + F[j] &lt;= C)</span><br><span class="line">                ans |= D[i] + D[j] + C - F[i] - F[j] &lt;= md, ++j;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「AHOI-HNOI2017」队长快跑"><a href="#「AHOI-HNOI2017」队长快跑" class="headerlink" title="「AHOI / HNOI2017」队长快跑"></a>「AHOI / HNOI2017」队长快跑</h3><p>这是一道 <del>计算几何</del> <code>nan</code> 题, 至少当年是这样.</p><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2022" target="_blank" rel="noopener">https://loj.ac/problem/2022</a></li></ul><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>似乎这道题 6-10 的数据是错的, 嘿嘿.</p><p>于是去学习了某一种广为流传的做法, 希望做法不假.</p><p>首先有一步转化, 每一个机关, 都可以根据其对起点 $S$ 到终点 $T$ 的影响, 看作倾角为 $\frac{\pi}{2}$ 或 $\frac{\pi}{2}$ 的两条射线.</p><p><del>感觉不画图是不会明白的, 那么祭上 <a href="https://www.luogu.com.cn/blog/xuanmenghuolong/solution-p3725" target="_blank" rel="noopener">lb2003 的题解</a> 吧</del></p><p>此时的情况就比较少了, 利用两个单调队列, 维护一条合法路径即可. 由维护路径的过程可以得知, 此时得到的答案一定是最优的.</p><p>时间复杂度 $O(n)$.</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><p>能用整数的地方就用整数来提高精度…</p><p>再利用单调队列的时候, 使用了一些技巧来简化代码.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2022</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Geo &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> INFD = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line">        LL x, y;</span><br><span class="line">        Vector(LL _x = <span class="number">0</span>, LL _y = <span class="number">0</span>): x(_x), y(_y) &#123; &#125;</span><br><span class="line">        Vector <span class="keyword">operator</span> + (<span class="keyword">const</span> Vector&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Vector(x + rhs.x, y + rhs.y); &#125;</span><br><span class="line">        Vector <span class="keyword">operator</span> - (<span class="keyword">const</span> Vector&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Vector(x - rhs.x, y - rhs.y); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">typedef</span> Vector Point;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">Dot</span><span class="params">(<span class="keyword">const</span> Vector&amp; A, <span class="keyword">const</span> Vector&amp; B)</span> </span>&#123; <span class="keyword">return</span> A.x * B.x + A.y * B.y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">Cross</span><span class="params">(<span class="keyword">const</span> Vector&amp; A, <span class="keyword">const</span> Vector&amp; B)</span> </span>&#123; <span class="keyword">return</span> A.x * B.y - A.y * B.x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Length</span><span class="params">(<span class="keyword">const</span> Vector&amp; A)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(Dot(A, A)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">angle</span><span class="params">(<span class="keyword">const</span> Vector&amp; v)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">atan2</span>(v.y, v.x); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Geo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(Point&amp; p)</span> </span>&#123; <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;p.x, &amp;p.y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, nA;</span><br><span class="line"><span class="keyword">double</span> theta[MAXN];</span><br><span class="line">Point A[MAXN], P[MAXN], S, T;</span><br><span class="line"><span class="keyword">int</span> Q[<span class="number">2</span>][MAXN], head[<span class="number">2</span>], tail[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> pre[MAXN], idx[MAXN], t[MAXN], type[MAXN]; <span class="comment">// 0: up, 1: down</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> P[x].x &lt; P[y].x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), read(T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        read(P[i]), <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, theta + i);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    S = Point(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">double</span> angl = angle(S - P[i]), angr = angle(T - P[i]);</span><br><span class="line">        <span class="comment">// 注意处理 angl &gt; angr 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (angl &gt; angr) type[i] = !(angr &lt; theta[i] &amp;&amp; theta[i] &lt; angl);</span><br><span class="line">        <span class="keyword">else</span> type[i] = angl &lt; theta[i] &amp;&amp; theta[i] &lt; angr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) idx[i] = i;</span><br><span class="line">    sort(idx+<span class="number">1</span>, idx+<span class="number">1</span>+n, cmp);</span><br><span class="line">    A[++nA] = S;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; P[idx[i]].x &lt; T.x; ++i)</span><br><span class="line">        <span class="keyword">if</span> (S.x &lt; P[idx[i]].x) A[++nA] = P[idx[i]], t[nA] = type[idx[i]];</span><br><span class="line">    A[++nA] = T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">2</span>; ++d) Q[d][head[d] = tail[d] = <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nA; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> d = t[i], sign = (d &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> &amp;head0 = head[d], &amp;tail0 = tail[d], *Q0 = Q[d];</span><br><span class="line">        <span class="keyword">int</span> &amp;head1 = head[d^<span class="number">1</span>], &amp;tail1 = tail[d^<span class="number">1</span>], *Q1 = Q[d^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (head1 &lt; tail1 &amp;&amp; Cross(A[i] - A[Q1[head1]], A[Q1[head1+<span class="number">1</span>]] - A[Q1[head1]]) * sign &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (head1 &lt; tail1 &amp;&amp;</span><br><span class="line">                    Cross(A[i] - A[Q1[head1]], A[Q1[head1+<span class="number">1</span>]] - A[Q1[head1]]) * sign &lt;= <span class="number">0</span>) ++head1;</span><br><span class="line">            pre[i] = Q1[head1];</span><br><span class="line">            head0 = ++tail0, Q0[tail0] = Q1[head1];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (head0 &lt; tail0 &amp;&amp;</span><br><span class="line">                    Cross(A[i] - A[Q0[tail0<span class="number">-1</span>]], A[Q0[tail0]] - A[Q0[tail0<span class="number">-1</span>]]) * sign &lt;= <span class="number">0</span>) --tail0;</span><br><span class="line">            pre[i] = Q0[tail0];</span><br><span class="line">        &#125;</span><br><span class="line">        Q0[++tail0] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nA; i != <span class="number">1</span>; i = pre[i]) ans += Length(A[i] - A[pre[i]]), assert(i != <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「AHOI-HNOI2017」抛硬币"><a href="#「AHOI-HNOI2017」抛硬币" class="headerlink" title="「AHOI / HNOI2017」抛硬币"></a>「AHOI / HNOI2017」抛硬币</h3><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2023" target="_blank" rel="noopener">https://loj.ac/problem/2023</a></li></ul><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>这是一道组合数学题. 分 $a = b$ 和 $a &gt; b$ 两种情况讨论.</p><ul><li><p>$a = b$</p><p>先考虑所有情况数, 即 $2 ^ {a + b}$.</p><p>如果把硬币全部翻转, 最后输赢的结果却不一定翻转. 所以此时要统计 $A$ 获胜的情况, 需要减去翻转前后 $A$ 都输给 $B$, 也就是平局的方案数. 那么答案为</p><p>$$\frac{1}{2}\ (\ 2 ^ {a + b} - \sum_{i=1}^a \binom{a}{i} \binom{b}{i})$$ </p><p>考虑右侧和式的组合意义, 即两次在 $a$ 个物品中选出 $i$ 个. 等价于一次选出 $i$ 个, 另一次选出 $a-i$ 个. 也就是在 $2a$ 个物品中选出 $a$ 个. 即</p><p>$$\frac{1}{2}\ (\ 2 ^ {a + b} - \sum_{i=1}^a \binom{a}{i} \binom{a}{a-i}) = \frac{1}{2}\ (\ 2 ^ {a + b} - \binom{2a}{a})$$</p><p>式子中有个 / $2$, 但 $2$ 在这些个模数下不存在逆元, 于是可以认为模数为 $2 \times 10^k$, 最后直接将结果 / $2$ 即可.</p><p>但是这样有些… 考虑 <a href="https://zh.wikipedia.org/wiki/%E5%B8%95%E6%96%AF%E5%8D%A1%E6%B3%95%E5%89%87" target="_blank" rel="noopener">帕斯卡法则</a>, 有</p><p>$$\binom{2a}{a} = \binom{2a-1}{a-1} + \binom{2a-1}{a}$$</p><p>而 $\binom{2a-1}{a-1} = \binom{2a-1}{a}$, 所以答案为</p><p>$$2 ^ {a + b - 1} + \binom{2a - 1}{a - 1}$$</p><p>从而避开了 / $2$ 的操作.</p></li><li><p>$a &gt; b$</p><p>还是从翻转硬币的角度入手, 这次要考虑翻转前后 $A$ 都获胜的情况. 那么答案为</p><p>$$\frac{1}{2}\ (\ 2 ^ {a + b} + \sum_{i=0}^b \sum_{j=1}^{a-b-1} \binom{b}{i} \binom{a}{i + j})$$</p><p>改变枚举顺序, 得</p><p>$$\frac{1}{2}\ (\ 2 ^ {a + b} + \sum_{i=1}^{a-b-1}\sum_{j=0}^b \binom{b}{b-j}\binom{a}{i+j} ) = \frac{1}{2}\ (\ 2 ^ {a + b} + \sum_{i=1}^{a-b-1} \binom{a+b}{b+i} )$$</p><p>稍微整理一下, 得</p><p>$$\frac{1}{2}\ (\ 2 ^ {a + b} + \sum_{i=1+b}^{a-1} \binom{a+b}{i} )$$</p><p>利用上一情况的处理方法处理掉 / $2$ 即可. (如果把和式处理掉, 那就是后文的优化 3 了)</p></li></ul><p>推出来式子之后直接抄了一份鲁棒性良好的拓展卢卡斯的板子上去, 喜获第一个点跑 10s 的好成绩.</p><p>接下来的问题在于如何卡常…</p><ol><li><p>考虑到模数一定形如 $10^k$, 也就是质因数仅包含 $2$ 和 $5$.</p><p>那么枚举质因数的过程可以省略, 中国剩余定理的过程也可以简化不少.</p></li><li><p>在能用 <code>int</code> 的情况下, 避免使用 <code>long long</code>.</p><p>在现代评测机下效果并不显著…</p></li><li><p>考虑到组合数具有对称性, 计算组合数只需要算一半即可, 常数减半.</p><p>具体实现的时候, 需要讨论 $a + b$ 奇偶性来避免少加一项的麻烦.</p></li><li><p>预处理一个 “伪阶乘”, 即在阶乘中除去 $2$ / $5$ 的倍数, 用于优化拓展 Lucas 计算.</p><p>此处优化最为明显.</p></li></ol><p>还有一个小地方就是 $2^9 = 512$, 远小于 $5^9 = 1953125$, 开在一起对缓存不友好…</p><p>不过可以简化代码 doge</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2023</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">25</span>, MAXN = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> exgcd(b, a % b, y, x), y -= a / b * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; n, <span class="keyword">const</span> <span class="keyword">int</span>&amp; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">return</span> exgcd(n % m, m, x, y), (x % m + m) % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(LL base, LL b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * base % m;</span><br><span class="line">        base = base * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Ctl[MAXL];</span><br><span class="line"><span class="keyword">int</span> M[MAXL], pow2[MAXL], pow5[MAXL], fac[<span class="number">2</span>][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(LL n, <span class="keyword">int</span> d, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// "伪阶乘" 使用</span></span><br><span class="line">    <span class="keyword">int</span> s = fpow(fac[d == <span class="number">5</span>][p - <span class="number">1</span>], n / p, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1L</span>L * s * fac[d == <span class="number">5</span>][n % p] % p * calc(n / d, d, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MultiLucas</span><span class="params">(LL n, LL m, <span class="keyword">int</span> d, <span class="keyword">int</span> p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (LL i = n; i; i /= d) c += i / d;</span><br><span class="line">    <span class="keyword">for</span> (LL i = m; i; i /= d) c -= i / d;</span><br><span class="line">    <span class="keyword">for</span> (LL i = n-m; i; i /= d) c -= i / d;</span><br><span class="line">    <span class="comment">// 这里也是优化</span></span><br><span class="line">    <span class="keyword">if</span> (c &gt;= k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1L</span>L * fpow(d, c, p) * calc(n, d, p) % p *</span><br><span class="line">        inv(calc(m, d, p), p) % p * inv(calc(n-m, d, p), p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ExLucas</span><span class="params">(LL n, LL m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;fact1 = pow2[k], &amp;fact2 = pow5[k];</span><br><span class="line">    <span class="keyword">int</span> a1 = MultiLucas(n, m, <span class="number">2</span>, fact1, k), a2 = MultiLucas(n, m, <span class="number">5</span>, fact2, k);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1L</span>L * inv(fact2, fact1) * fact2 % M[k] * a1 % M[k];</span><br><span class="line">    ret = (ret + <span class="number">1L</span>L * inv(fact1, fact2) * fact1 % M[k] * a2 % M[k]) % M[k];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    fac[<span class="number">0</span>][<span class="number">0</span>] = fac[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">512</span>; ++i) <span class="comment">// 2 ^ 9</span></span><br><span class="line">        fac[<span class="number">0</span>][i] = (i % <span class="number">2</span> == <span class="number">0</span>)? fac[<span class="number">0</span>][i<span class="number">-1</span>]: <span class="number">1L</span>L * i * fac[<span class="number">0</span>][i<span class="number">-1</span>] % <span class="number">512</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1953125</span>; ++i) <span class="comment">// 5 ^ 9</span></span><br><span class="line">        fac[<span class="number">1</span>][i] = (i % <span class="number">5</span> == <span class="number">0</span>)? fac[<span class="number">1</span>][i<span class="number">-1</span>]: <span class="number">1L</span>L * i * fac[<span class="number">1</span>][i<span class="number">-1</span>] % <span class="number">1953125</span>;</span><br><span class="line">    pow2[<span class="number">0</span>] = pow5[<span class="number">0</span>] = M[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i)</span><br><span class="line">        M[i] = M[i<span class="number">-1</span>] * <span class="number">10</span>, pow2[i] = pow2[i<span class="number">-1</span>] * <span class="number">2</span>, pow5[i] = pow5[i<span class="number">-1</span>] * <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    LL a, b; <span class="keyword">int</span> K;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%lld%lld%d"</span>, &amp;a, &amp;b, &amp;K) != EOF) &#123;</span><br><span class="line">        <span class="comment">// solve</span></span><br><span class="line">        <span class="keyword">int</span> Mod = M[K], ans = fpow(<span class="number">2</span>, a + b - <span class="number">1</span>, Mod);</span><br><span class="line">        <span class="keyword">if</span> (a == b) ans = (ans - ExLucas(a + a - <span class="number">1</span>, a - <span class="number">1</span>, K) + Mod) % Mod;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (LL i = (a + b) / <span class="number">2</span> + <span class="number">1</span>; i &lt; a; ++i)</span><br><span class="line">                ans = (ans + ExLucas(a + b, i, K)) % Mod;</span><br><span class="line">            <span class="keyword">if</span> ((a + b) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                ans = (ans + ExLucas(a + b - <span class="number">1</span>, (a + b) / <span class="number">2</span>, K)) % Mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// output</span></span><br><span class="line">        <span class="built_in">sprintf</span>(Ctl, <span class="string">"%%0%dd\n"</span>, K), <span class="built_in">printf</span>(Ctl, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;如果说 “我做了一套 AHOI”, 恐怕和 “我做了一套 HNOI” 给人的感觉不太一样…&lt;/p&gt;
&lt;p&gt;但其实是一样的? &lt;del&gt;OI 什么时候能实现地域的平衡啊.&lt;/del&gt; 这辈子不可能了.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>SDOI 2017 Round 2 大赏</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/SDOI-2017-R2-sol/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/SDOI-2017-R2-sol/</id>
    <published>2020-03-08T13:24:57.000Z</published>
    <updated>2020-03-10T12:03:24.517Z</updated>
    
    <content type="html"><![CDATA[<hr><div style="text-align:center;"><img src="/images/SDOI-2017-sol/SDOI.jpg"> </div><p><em><p style="text-align:center;">图源 <a href="https://www.cnblogs.com/zzqsblog/p/7523003.html" target="_blank" rel="noopener">ZZQ’s Blog</a>, 至少我是从那里找到的</p></em></p><p>这 Round 2 也太毒瘤了 = =</p><a id="more"></a><p>久 等 了.</p><h3 id="「SDOI2017」龙与地下城"><a href="#「SDOI2017」龙与地下城" class="headerlink" title="「SDOI2017」龙与地下城"></a>「SDOI2017」龙与地下城</h3><p>验题人在多测的情况下总算是写了十行代码?</p><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2267" target="_blank" rel="noopener">https://loj.ac/problem/2267</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先有一个多项式做法.</p><p>构造一个生成函数 $g(x)$, 其 $k$ 次项系数表示掷一次骰子造成伤害 $k$ 的概率, 则</p><p>$$g(x) = \sum_{k=0}^{X-1} \frac{1}{X} x^k$$</p><p>那么 $g(x)^Y$ 的 $A_i$ 到 $B_i$ 次项和即为答案.</p><p>对于这个多项式幂函数的计算, 可以用带大常数的 $O(n \log n)$ 多项式 $\exp$ , 或者朴素快速幂 $O(n \log ^2 n)$.</p><p>但是有精巧的做法, 此处直接把点值做 $Y$ 次幂就好了.</p><p>当年考场 AC 似乎有更为精巧的优化方法, 好像 myy 的论文 &lt;再探快速傅里叶变换&gt; 里有涉及, <del>以后再说以后再说</del></p><p>对于大数据 <del>如果问什么是大数据, 那就是 FFT 跑不过的数据</del>, 则要用到 <a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86#%E6%9E%97%E5%BE%B7%E4%BC%AF%E6%A0%BC%EF%BC%8D%E5%88%97%E7%BB%B4%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">中心极限定理</a>.</p><p>记 $\zeta_{n} = \dfrac{\bar X - \mu}{\sigma / \sqrt n} = \dfrac{\sum\limits_{i=1}^n X_i - n \mu}{\sqrt {n \sigma ^2 }}$, 根据中心极限定理, 当 $n \rightarrow \infty$ 时, 认为其满足正态分布 $N(0, 1)$.</p><p>而正态分布 $N(\mu, \sigma^2)$ 的概率密度函数为</p><p>$$f(x) = \frac{1}{\sqrt{ 2 \sigma^2 \pi }} e ^{ -\frac {(x-\mu)^2}{2 \sigma ^2} }$$</p><p>对于 $N(0, 1)$, 带进去可得</p><p>$$f(x) = \frac{1}{\sqrt{ 2 \pi}} e ^{ -\frac{x^2}{2} }$$</p><p>具体应用到这道题中, 用自适应 Simpson 计算</p><p>$$\int _a^b f(x)\ dx$$</p><p>就好了, 其中 $a = \dfrac{A_i - Y \mu}{\sqrt{ Y \sigma ^2 }},\ b = \dfrac{B_i - Y\mu}{\sqrt{ Y \sigma ^ 2}}$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>就这样吧 = =, 只能流下没有数理基础的眼泪.</p><p>至今不知道为什么直接大力 Simpson $[L, R]$ 会挂, 取端点做差就对了 = =</p><p>可能是因为 $L$ 正负性的问题?</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2267</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">262145</span> &lt;&lt; <span class="number">1</span>, MAXM = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Complex(<span class="keyword">double</span> _x = <span class="number">0.0</span>, <span class="keyword">double</span> _y = <span class="number">0.0</span>): x(_x), y(_y) &#123; &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> + (<span class="keyword">const</span> Complex&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Complex(x + rhs.x, y + rhs.y); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> - (<span class="keyword">const</span> Complex&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Complex(x - rhs.x, y - rhs.y); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> * (<span class="keyword">const</span> Complex&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">fpow</span><span class="params">(Complex base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">ret</span><span class="params">(<span class="number">1.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * base;</span><br><span class="line">        base = base * base, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex* f, <span class="keyword">int</span> Lim, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="function">Complex <span class="title">unit</span><span class="params">(<span class="built_in">cos</span>(PI / Mid), type * <span class="built_in">sin</span>(PI / Mid))</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += (Mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j, w = w * unit) &#123;</span><br><span class="line">                    Complex f0 = f[i+j], f1 = w * f[i+j+Mid];</span><br><span class="line">                    f[i+j] = f0 + f1, f[i+j+Mid] = f0 - f1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i].x /= Lim;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> X, Y;</span><br><span class="line"><span class="keyword">int</span> A[MAXM], B[MAXM];</span><br><span class="line">Complex g[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> frac = <span class="number">1.0</span> / <span class="built_in">sqrt</span>(<span class="number">2.0</span> * PI);</span><br><span class="line">    <span class="keyword">return</span> frac * <span class="built_in">exp</span>(x * x / <span class="number">-2.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">simpson</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; L, <span class="keyword">const</span> <span class="keyword">double</span>&amp; R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (R - L) / <span class="number">6.0</span> * (f(L) + f(R) + <span class="number">4.0</span> * f((L + R) / <span class="number">2.0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">asr</span><span class="params">(<span class="keyword">double</span> L, <span class="keyword">double</span> R, <span class="keyword">const</span> <span class="keyword">double</span>&amp; eps, <span class="keyword">double</span> ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Mid = (L + R) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">double</span> fl = simpson(L, Mid), fr = simpson(Mid, R);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(fl + fr - ans) &lt; <span class="number">15</span> * eps) <span class="keyword">return</span> fl + fr + (fl + fr - ans) / <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">return</span> asr(L, Mid, eps / <span class="number">2.0</span>, fl) + asr(Mid, R, eps / <span class="number">2.0</span>, fr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> Ti;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;X, &amp;Y);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXM; ++i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, A+i, B+i);</span><br><span class="line">        <span class="comment">// solve</span></span><br><span class="line">        <span class="keyword">if</span> (X * Y &lt; MAXN) &#123;</span><br><span class="line">            <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (Lim &lt;= X * Y) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">            Poly::init(Lim, L);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; X; ++i) g[i].x = <span class="number">1.0</span> / X;</span><br><span class="line">            Poly::FFT(g, Lim, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) g[i] = fpow(g[i], Y);</span><br><span class="line">            Poly::FFT(g, Lim, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXM; ++i) &#123;</span><br><span class="line">                <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = A[i]; j &lt;= B[i]; ++j) ans += g[j].x;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> mu = (X - <span class="number">1.0</span>) / <span class="number">2.0</span>, sigma2 = (X * X - <span class="number">1.0</span>) / <span class="number">12.0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXM; ++i) &#123;</span><br><span class="line">                <span class="keyword">double</span> L = (A[i] - Y * mu) / <span class="built_in">sqrt</span>(Y * sigma2),</span><br><span class="line">                       R = (B[i] - Y * mu) / <span class="built_in">sqrt</span>(Y * sigma2);</span><br><span class="line">                <span class="comment">// printf("%.7lf\n", asr(L, R, 1e-9, simpson(L, R)));</span></span><br><span class="line">                <span class="comment">// 如果使用以上写法, 某些答案为 1.0 的情况, 算出来是 0.0 = =</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%.7lf\n"</span>, asr(<span class="number">0</span>, R, <span class="number">1e-9</span>, simpson(<span class="number">0</span>, R)) - asr(<span class="number">0</span>, L, <span class="number">1e-9</span>, simpson(<span class="number">0</span>, L)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SDOI2017」苹果树"><a href="#「SDOI2017」苹果树" class="headerlink" title="「SDOI2017」苹果树"></a>「SDOI2017」苹果树</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2268" target="_blank" rel="noopener">https://loj.ac/problem/2268</a></li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>观察题意可以发现, 关于 $k$ 的限定可以看作免费取一条从根开始的链, 再取 $k$ 个物品, 取儿子必须取至少一个父亲的树形依赖背包. 棘手的地方在于链的处理.</p><p>考虑怎么把链干掉. 可以发现, 树上点权都是正的, 如果取一条链, 那么一定从根一直取到叶子. 所以可以枚举叶子, 把树分成链左半部分和右半部分.</p><p>再看一遍树的结构, 实际上把树分成了 3 部分</p><ol><li>链上免费取的部分</li><li>链左边付费取的部分 (我们把链上付费取的部分归到这里)</li><li>链右边付费取的部分</li></ol><p>所以设 $f(i, j)$ 表示第 $i$ 个节点, 体积为 $j$ 的最大收益, 也就是在计算第 2 部分的答案.</p><p>类似地, 设 $g(i, j)$ 表示 DFS 序翻转后, 第 $i$ 个节点, 体积为 $j$ 的最大收益, 也就是在计算第 3 部分的答案.</p><p>树上依赖的关系不好处理, 考虑将每个物品数 $a_i &gt; 1$ 节点拆开, 拆成一个物品数为 $1$ 的节点留在原来的位置, 以及一个物品数为 $a_i - 1$ 的节点挂在另外一个节点旁.</p><p>(实际上建图的时候并不必要把这个点真的拆开, 在转移的时候额外判断就好了).</p><p>最后枚举叶子, 累加第 1 部分, 把另外两部分拼起来即可. (也就是 $f(i, j) + g(i, j-k)$)</p><p>注意到对于每个节点的转移, 实际上是一个多重背包, 使用单调队列优化即可.</p><p>时间复杂度 $O(Qnk)$.</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>实现参考了 <a href="https://www.cnblogs.com/clrs97/p/7842530.html" target="_blank" rel="noopener">Claris</a>.</p><p>有些卡常, 需要把 DP 的二维数组开成一维, 增加缓存命中率.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2268</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e4</span> + <span class="number">5</span>, MAXK = <span class="number">5e5</span> + <span class="number">5</span>, MAXM = <span class="number">2</span> * MAXK + <span class="number">25e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K, M, ans;</span><br><span class="line"><span class="keyword">int</span> pre[MAXN], A[MAXN], V[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXM], g[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>* F, <span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> Q[MAXK], W[MAXK], head, tail;</span><br><span class="line">    Q[head = <span class="number">1</span>] = tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt;= K; ++i, j += v) &#123;</span><br><span class="line">        F[i] -= j;</span><br><span class="line">        <span class="keyword">while</span> (head &lt;= tail &amp;&amp; F[Q[tail]] &lt; F[i]) --tail;</span><br><span class="line">        Q[++tail] = i;</span><br><span class="line">        <span class="keyword">while</span> (head &lt;= tail &amp;&amp; i - Q[head] &gt; a) ++head;</span><br><span class="line">        W[i] = F[Q[head]] + j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(F, W, M * <span class="keyword">sizeof</span> (<span class="keyword">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, (n + <span class="number">1</span>) * <span class="keyword">sizeof</span> (<span class="keyword">int</span>)), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs0</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A[u]) solve(f + M * u, A[u], V[u]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edges[i].to;</span><br><span class="line">            <span class="built_in">memcpy</span>(f + M * v, f + M * u, M * <span class="keyword">sizeof</span> (<span class="keyword">int</span>));</span><br><span class="line">            dfs0(v);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; ++j)</span><br><span class="line">                f[M * u + j] = max(f[M * u + j], f[M * v + j - <span class="number">1</span>] + V[v]);</span><br><span class="line">            <span class="comment">// "至少取一个父节点的物品" 的限制就体现在这里了, g(i, j) 同理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edges[i].to;</span><br><span class="line">            <span class="built_in">memcpy</span>(g + M * v, g + M * u, M * <span class="keyword">sizeof</span> (<span class="keyword">int</span>));</span><br><span class="line">            dfs1(v, s + V[u]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; ++j)</span><br><span class="line">                g[M * u + j] = max(g[M * u + j], g[M * v + j - <span class="number">1</span>] + V[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head[u] == <span class="number">-1</span>) <span class="comment">// leaf</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= K; ++j)</span><br><span class="line">                ans = max(ans, V[u] + s + f[M * u + j] + g[M * u + K - j]);</span><br><span class="line">        <span class="keyword">if</span> (A[u]) solve(g + M * u, A[u], V[u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> Ti; read(Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        read(n), read(K);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            read(pre[i]), read(A[i]), read(V[i]), --A[i];</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        ans = <span class="number">0</span>, M = K + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f + M, <span class="number">0</span>, M * <span class="keyword">sizeof</span> (<span class="keyword">int</span>));</span><br><span class="line">        <span class="built_in">memset</span>(g + M, <span class="number">0</span>, M * <span class="keyword">sizeof</span> (<span class="keyword">int</span>));</span><br><span class="line">        <span class="comment">// solve</span></span><br><span class="line">        Graph::init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) Graph::AddEdge(pre[i], i);</span><br><span class="line">        Graph::dfs0(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 对于 "DFS 翻转", 反着建图即可</span></span><br><span class="line">        Graph::init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">2</span>; --i) Graph::AddEdge(pre[i], i);</span><br><span class="line">        Graph::dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// output</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SDOI2017」切树游戏"><a href="#「SDOI2017」切树游戏" class="headerlink" title="「SDOI2017」切树游戏"></a>「SDOI2017」切树游戏</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2269" target="_blank" rel="noopener">https://loj.ac/problem/2269</a></li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>先祭上 <a href="http://immortalco.blog.uoj.ac/blog/2625" target="_blank" rel="noopener">猫锟的解题报告</a>.</p><p>然后就是动态 DP 了.</p><p>此处信息仍具有可减性, 维护数非 0 部分的积, 以及乘积中 0 的个数即可了.</p><p>落实到代码中就是那个 <code>Num</code> 了.</p><p>还有个可以借鉴的 Trick 就是化简矩阵减小常数了. 直接搬来 immortalCO 的公式.</p><p>$$\begin{pmatrix} \underline{a_1} &amp; \underline{b_1} &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ \underline{c_1} &amp; \underline{d_1} &amp; 1 \end{pmatrix} \times \begin{pmatrix} \underline{a_2} &amp; \underline{b_2} &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ \underline{c_2} &amp; \underline{d_2} &amp; 1 \end{pmatrix} = \begin{pmatrix} \underline{a_1 a_2} &amp; \underline{b_1 + a_1 b_2} &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ \underline{a_2 c_1 + c_2} &amp; \underline{b_2 c_1 + d_1 + d_2} &amp; 1 \end{pmatrix}$$</p><p>运用这个 Trick 的时候, 需要额外注意矩阵的运算顺序.</p><p>动态 DP 采用树链剖分实现, 时间复杂度 $O(n\log ^ 3 n)$.</p><p><del>最近一群毒瘤看着这个 log^3 不爽, 看来要去学 DDP 的 LCT 实现了</del></p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2269</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read; <span class="keyword">using</span> IO::Gc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e4</span>+<span class="number">5</span>, MAXM = <span class="number">128</span>, P = <span class="number">10007</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FWT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> Lim, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> LL inv2 = <span class="number">5004</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, Mid = <span class="number">2</span>; Mid &lt;= Lim; Mid &lt;&lt;= <span class="number">1</span>, k &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> f0 = f[i+j], f1 = f[i+j+k];</span><br><span class="line">                f[i+j] = (f0 + f1) % P, f[i+j+k] = (f0 - f1 + P) % P;</span><br><span class="line">                <span class="keyword">if</span> (type == <span class="number">-1</span>) f[i+j] = inv2 * f[i+j] % P, f[i+j+k] = inv2 * f[i+j+k] % P;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">int</span> E[MAXM][MAXM], V[MAXN], inv[P];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXM], g[MAXN][MAXM], lg[MAXN][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Num</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, c;</span><br><span class="line">    Num() &#123; x = c = <span class="number">0</span>; &#125;</span><br><span class="line">    Num(<span class="keyword">int</span> _x): x((_x == <span class="number">0</span>)? <span class="number">1</span>: _x), c(_x == <span class="number">0</span>) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">val</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c? <span class="number">0</span>: x; &#125;</span><br><span class="line">    Num&amp; <span class="keyword">operator</span>*= (<span class="keyword">const</span> <span class="keyword">int</span>&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rhs != <span class="number">0</span>) x = <span class="number">1L</span>L * x * rhs % P; <span class="keyword">else</span> ++c;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Num&amp; <span class="keyword">operator</span>/= (<span class="keyword">const</span> <span class="keyword">int</span>&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rhs != <span class="number">0</span>) x = <span class="number">1L</span>L * x * inv[rhs] % P; <span class="keyword">else</span> --c;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; lf[MAXN][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HLD &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">int</span> son[MAXN], pre[MAXN], depth[MAXN], size[MAXN];</span><br><span class="line">    <span class="keyword">int</span> dfn[MAXN], Ed[MAXN], rnk[MAXN], topfa[MAXN], dfs_clock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">        size[u] = <span class="number">1</span>, son[u] = <span class="number">-1</span>, pre[u] = fa;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) f[u][j] = E[V[u]][j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) == fa) <span class="keyword">continue</span>;</span><br><span class="line">            dfs1(v, u), size[u] += size[v];</span><br><span class="line">            <span class="keyword">if</span> (son[u] == <span class="number">-1</span> || size[v] &gt; size[son[u]]) son[u] = v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                f[u][j] = (f[u][j] + <span class="number">1L</span>L * f[u][j] * f[v][j] % P) % P;</span><br><span class="line">                g[u][j] = (g[u][j] + g[v][j]) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) g[u][j] = (g[u][j] + f[u][j]) % P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">        topfa[u] = top;</span><br><span class="line">        dfn[u] = ++dfs_clock, rnk[dfs_clock] = u, Ed[top] = dfs_clock;</span><br><span class="line">        <span class="keyword">if</span> (~son[u]) dfs2(son[u], top);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) lf[u][j] = Num(E[<span class="number">0</span>][j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) == pre[u] || v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">            dfs2(v, v);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">                lf[u][j] *= (<span class="number">1</span> + f[v][j]) % P, lg[u][j] = (lg[u][j] + g[v][j]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt = <span class="number">1</span>)</span> </span>&#123; dfs1(rt, <span class="number">0</span>), dfs2(rt, rt); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> A[MAXM], B[MAXM], C[MAXM], D[MAXM];</span><br><span class="line">    Node() &#123; <span class="built_in">memset</span>(<span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">sizeof</span> *<span class="keyword">this</span>); &#125;</span><br><span class="line">    Node <span class="keyword">operator</span> * (<span class="keyword">const</span> Node&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        Node ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            ret.A[i] = <span class="number">1L</span>L * A[i] * rhs.A[i] % P;</span><br><span class="line">            ret.B[i] = (<span class="number">1L</span>L * A[i] * rhs.B[i] % P + B[i]) % P;</span><br><span class="line">            ret.C[i] = (<span class="number">1L</span>L * rhs.A[i] * C[i] % P + rhs.C[i]) % P;</span><br><span class="line">            ret.D[i] = (<span class="number">1L</span>L * C[i] * rhs.B[i] % P + rhs.D[i] + D[i]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (nd&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (nd&lt;&lt;1|1)</span></span><br><span class="line">    Node dat[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123; dat[nd] = dat[rc] * dat[lc]; &#125;</span><br><span class="line">    <span class="comment">// 注意 maintain 合并两矩阵的顺序</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">1L</span>L * lf[u][i].val() * E[V[u]][i] % P;</span><br><span class="line">            dat[nd].A[i] = dat[nd].B[i] = dat[nd].C[i] = a;</span><br><span class="line">            dat[nd].D[i] = (a + lg[u][i]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> newnode(nd, HLD::rnk[L]);</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        build(lc, L, Mid), build(rc, Mid+<span class="number">1</span>, R);</span><br><span class="line">        maintain(nd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> newnode(nd, HLD::rnk[L]);</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= Mid) Mdy(lc, L, Mid, pos);</span><br><span class="line">        <span class="keyword">else</span> Mdy(rc, Mid+<span class="number">1</span>, R, pos);</span><br><span class="line">        maintain(nd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> dat[nd];</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> Qry(lc, L, Mid, opL, opR);</span><br><span class="line">        <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> Qry(rc, Mid+<span class="number">1</span>, R, opL, opR);</span><br><span class="line">        <span class="keyword">return</span> Qry(rc, Mid+<span class="number">1</span>, R, opL, opR) * Qry(lc, L, Mid, opL, opR);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t1[MAXN], t2[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HLD &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        Node res = SGT::Qry(<span class="number">1</span>, <span class="number">1</span>, n, dfn[u], Ed[u]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) t1[i] = res.C[i], t2[i] = res.D[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        V[u] = val;</span><br><span class="line">        <span class="keyword">while</span> (u &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> fa = pre[topfa[u]];</span><br><span class="line">            Qry(topfa[u]);</span><br><span class="line">            <span class="keyword">if</span> (fa) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">                lf[fa][i] /= (t1[i] + <span class="number">1</span>) % P, lg[fa][i] = (lg[fa][i] - t2[i] + P) % P;</span><br><span class="line">            SGT::Mdy(<span class="number">1</span>, <span class="number">1</span>, n, dfn[u]);</span><br><span class="line">            Qry(topfa[u]);</span><br><span class="line">            <span class="keyword">if</span> (fa) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">                lf[fa][i] *= (t1[i] + <span class="number">1</span>) % P, lg[fa][i] = (lg[fa][i] + t2[i]) % P;</span><br><span class="line">            u = fa;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; P; ++i) inv[i] = <span class="number">1L</span>L * (P - P / i) * inv[P % i] % P;</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(V[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        read(u), read(v), Graph::AddEdge(u, v), Graph::AddEdge(v, u);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) E[i][i] = <span class="number">1</span>, FWT(E[i], m, <span class="number">1</span>);</span><br><span class="line">    HLD::solve(), SGT::build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    read(q);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> opt, x, y;</span><br><span class="line">        opt = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isspace</span>(opt)) opt = Gc();</span><br><span class="line">        read(x);</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>: read(y), HLD::Mdy(x, y); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'Q'</span>: HLD::Qry(<span class="number">1</span>), FWT(t2, m, <span class="number">-1</span>), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t2[x]); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERR\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SDOI2017」天才黑客"><a href="#「SDOI2017」天才黑客" class="headerlink" title="「SDOI2017」天才黑客"></a>「SDOI2017」天才黑客</h3><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2270" target="_blank" rel="noopener">https://loj.ac/problem/2270</a></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>如果把边看作点, 容易得到这样一个做法:</p><ol><li>枚举边, 假设当前枚举到的边为 $(a, b)$.</li><li>找到形如 $(b, c)$ 的边, 两者之间连边, 边权为两者 LCP, 也就是 Trie 树上 LCA 到根的距离.</li><li>跑 Dijkstra, 对于每个点 $u$, 找到形如 $(a, u)$ 的边更新答案.</li></ol><p>但是这个算法有一个明显的问题, 遇到原图中点数度数很大的情况就会连很多边…</p><p>考虑如何优化这个过程. </p><p>对于 Trie 上一个节点 $u$, 将 $u$ 周围一圈节点按 DFS 序排序, 类似于后缀数组, 设 $h_i = \operatorname{LCP}(s_i, s_{i+1})$, 那么</p><p>$$\operatorname{LCP}(s_L,\ s_R) = \min \{ h_j \mid L \le j \le R \}$$</p><p>利用后缀数组中常见套路, 可以利用单调栈求出 LCP 为 $h_i$ 的一段区间, 然后点向区间连边, 区间向点连边即可. 利用线段树优化建图即可.</p><p>但是有更加简便的办法. 还是引用 <a href="https://www.cnblogs.com/clrs97/p/7833797.html" target="_blank" rel="noopener">Claris 的博客</a>:</p><blockquote><p>枚举每个 $h_i$ 作为分界线，那么新图中两侧的点均可以通过不超过 $h_i$ 的代价互相访问.</p><p>建立一排前缀虚点和后缀虚点然后对应前后缀之间连边即可.</p></blockquote><p>具体地说, 前缀入点 <code>prei</code> 和前缀出点 <code>preo</code> 之间边权分别为 $0$, 每个 <code>prei[i]</code> 向 <code>preo[i+1]</code> 连边, 权值为 $h_i$.</p><p>这样连边就以较小的代价做了等效的事情. 后缀同理.</p><p>可能还是有些抽象, 不过在代码实现里还是很清晰的. 以及一些入点出点的细节也体现在代码里.</p><p>时间复杂度 $O(m \log m)$.</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p>你问我为什么执意写树剖求 LCA… 这… 我要是会倍增我不就写倍增了吗 = =</p><p>以及边拆为点时, 并不需要额外新增一条边记录初始边权, 直接视作点权在跑 Dijkstra 的过程中更新即可.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2270</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e4</span> + <span class="number">5</span>, MAXK = <span class="number">2e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = MAXN * <span class="number">10</span>, MAXE = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, K, uidx;</span><br><span class="line"><span class="keyword">int</span> U[MAXN], D[MAXN], Ans[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; In[MAXN], Out[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, w; &#125; edges[MAXE];</span><br><span class="line">    <span class="keyword">int</span> head[MAXV], eidx;</span><br><span class="line">    <span class="keyword">int</span> dist[MAXV], val[MAXV];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, w &#125;, head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;Pii, <span class="built_in">vector</span>&lt;Pii&gt;, greater&lt;Pii&gt; &gt; PQ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= uidx; ++i) dist[i] = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="keyword">if</span> (U[i] == <span class="number">1</span>) PQ.push(Pii(dist[i] = val[i], i));</span><br><span class="line">        <span class="keyword">while</span> (!PQ.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = PQ.top().first, u = PQ.top().second; PQ.pop();</span><br><span class="line">            <span class="keyword">if</span> (d != dist[u]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = edges[i].to;</span><br><span class="line">                <span class="keyword">if</span> (dist[v] &gt; val[v] + dist[u] + edges[i].w)</span><br><span class="line">                    PQ.push(Pii(dist[v] = val[v] + dist[u] + edges[i].w, v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">2</span>; u &lt;= n; ++u) &#123;</span><br><span class="line">            Ans[u] = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; In[u].size(); ++i)</span><br><span class="line">                Ans[u] = min(Ans[u], Graph::dist[In[u][i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HLD &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXK];</span><br><span class="line">    <span class="keyword">int</span> head[MAXK], eidx;</span><br><span class="line">    <span class="keyword">int</span> depth[MAXK], pre[MAXK], son[MAXK], size[MAXK];</span><br><span class="line">    <span class="keyword">int</span> topfa[MAXK], dfn[MAXK], dfs_clock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">        son[u] = <span class="number">-1</span>, size[u] = <span class="number">1</span>, pre[u] = fa;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            dfs1(v = edges[i].to, u), size[u] += size[v];</span><br><span class="line">            <span class="keyword">if</span> (son[u] == <span class="number">-1</span> || size[son[u]] &lt; size[v]) son[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">        topfa[u] = top, dfn[u] = ++dfs_clock;</span><br><span class="line">        <span class="keyword">if</span> (~son[u]) dfs2(son[u], top);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) != son[u]) dfs2(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        depth[<span class="number">0</span>] = <span class="number">-1</span>, dfs1(rt, <span class="number">0</span>), dfs2(rt, rt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (topfa[u] != topfa[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth[topfa[u]] &lt; depth[topfa[v]]) swap(u, v);</span><br><span class="line">            u = pre[topfa[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth[u] &gt; depth[v]? v: u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Abs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &lt; <span class="number">0</span>? -x: x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfn[D[Abs(x)]] &lt; dfn[D[Abs(y)]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> preo[MAXN], prei[MAXN], sufi[MAXN], sufo[MAXN], q[MAXN];</span><br><span class="line">        <span class="keyword">int</span> nq = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; In[u].size(); ++i) q[++nq] = In[u][i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; Out[u].size(); ++i) q[++nq] = -Out[u][i];</span><br><span class="line">        <span class="comment">// 区分出入点和出点</span></span><br><span class="line">        sort(q+<span class="number">1</span>, q+<span class="number">1</span>+nq, cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nq; ++i) &#123;</span><br><span class="line">            preo[i] = ++uidx, prei[i] = ++uidx, sufo[i] = ++uidx, sufi[i] = ++uidx;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                Graph::AddEdge(preo[i<span class="number">-1</span>], preo[i], <span class="number">0</span>), Graph::AddEdge(prei[i<span class="number">-1</span>], prei[i], <span class="number">0</span>);</span><br><span class="line">                Graph::AddEdge(sufo[i], sufo[i<span class="number">-1</span>], <span class="number">0</span>), Graph::AddEdge(sufi[i], sufi[i<span class="number">-1</span>], <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (q[i] &gt; <span class="number">0</span>)</span><br><span class="line">                Graph::AddEdge(q[i], prei[i], <span class="number">0</span>), Graph::AddEdge(q[i], sufi[i], <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                q[i] = -q[i], Graph::AddEdge(preo[i], q[i], <span class="number">0</span>), Graph::AddEdge(sufo[i], q[i], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nq; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> lca = LCA(D[q[i]], D[q[i + <span class="number">1</span>]]);</span><br><span class="line">            Graph::AddEdge(prei[i], preo[i + <span class="number">1</span>], depth[lca]);</span><br><span class="line">            Graph::AddEdge(sufi[i + <span class="number">1</span>], sufo[i], depth[lca]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> Ti; read(Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        Graph::init(), HLD::init();</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        read(n), read(m), read(K); uidx = m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            read(U[i]), read(v), read(Graph::val[i]), read(D[i]);</span><br><span class="line">            In[v].push_back(i), Out[U[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u, v, w, i = <span class="number">1</span>; i &lt; K; ++i)</span><br><span class="line">            read(u), read(v), read(w), HLD::AddEdge(u, v);</span><br><span class="line">        <span class="comment">// solve</span></span><br><span class="line">        HLD::solve();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) HLD::build(i);</span><br><span class="line">        Graph::Dijkstra();</span><br><span class="line">        <span class="comment">// output</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans[i]);</span><br><span class="line">        <span class="comment">// clear</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) Graph::val[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) In[i].clear(), Out[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SDOI2017」遗忘的集合"><a href="#「SDOI2017」遗忘的集合" class="headerlink" title="「SDOI2017」遗忘的集合"></a>「SDOI2017」遗忘的集合</h3><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/submission/759802" target="_blank" rel="noopener">https://loj.ac/submission/759802</a></li></ul><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>如果把所求和已知交换, 那么这道题就是一道生成函数套路题了.</p><p>设序列 $a_i$ 表示元素 $i$ 是否存在于集合 $S$ 中. 那么取 $S$ 中元素之和的方案数的生成函数为</p><p>$$F(x) = \prod_{i \in S} (\sum_{k=0}^{\infty} x^{ki}) = \prod_{i \in S} \frac{1}{1 - x^i} = \prod_{i=1}^n (\frac{1}{1 - x^i} ) ^ {a_i}$$</p><p>看到乘积不爽. 两边同时取 $\ln$, 得</p><p>$$- \ln F(x) = \sum_{i=1}^n a_i \ln (1-x^i)$$</p><p>记 $g(x) = \ln (1-x^i)$, 那么对 $g(x)$ 求导得到</p><p><del>这个技巧似乎叫做 “<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E6%95%B0%E5%BE%AE%E5%88%86%E6%B3%95" target="_blank" rel="noopener">对数微分法</a>“?</del></p><p>$$\frac{(1 - x^i)’}{1 - x^i} = \frac{-i x^{i-1}}{1 - x^i} = g’(x)$$</p><p>由广义二项式定理, 得</p><p>$$-ix^{i-1} \sum_{k=0}^{\infty} x ^{ki} = -\sum_{k=0}^{\infty} i x^{ki +i-1} = g’(x)$$</p><p>再积分, 得</p><p>$$-\sum_{k=0} ^ {\infty} \frac{i}{ki + i} x^{ki + i} = -\sum_{k=1}^{\infty} \frac{1}{k} x ^ {ki} = g(x) $$</p><p>所以我们就得到了</p><p>$$g(x) = \ln (1 - x^i) = -\sum_{k=1}^{\infty} \frac{1}{k} x^{ki}$$</p><p>代入原式, 可以得到</p><p>$$\ln F(x) = \sum_{i=1}^n a_i \sum_{k=1}^{\infty} \frac{1}{k} x^{ki}$$</p><p>设 $T = ki$, 并交换枚举顺序, 得</p><p>$$\ln F(x) = \sum_{T=1}^\infty (\sum_{d \mid T} a_d \frac{d}{T} ) x^T$$</p><p>至此, 这道题就做完了. 对给定的 $F(x)$ 求 $\ln$ 后莫比乌斯反演即可.</p><p>此处并不需要筛出来 $\mu$ 之后 $O(\sqrt n)$ 枚举约数… 直接利用 <a href="http://vfleaking.blog.uoj.ac/blog/87" target="_blank" rel="noopener">VFleaKing 反演课件</a> 里的技巧即可.</p><p>时间复杂度 $O(n\log n)$.</p><p>其实整个过程叫做 “Euler Transform”? 类似的技巧也在 <a href="https://www.luogu.com.cn/problem/P4389" target="_blank" rel="noopener">Luogu P4389 付公主的背包</a> 用到过.</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><p>先滚过去学了 MTT 才写了这道题 = =</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2271</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1</span> &lt;&lt; <span class="number">19</span>, M = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Complex(<span class="keyword">double</span> _x = <span class="number">0.0</span>, <span class="keyword">double</span> _y = <span class="number">0.0</span>): x(_x), y(_y) &#123; &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> + (<span class="keyword">const</span> Complex&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Complex(x + rhs.x, y + rhs.y); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> - (<span class="keyword">const</span> Complex&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Complex(x - rhs.x, y - rhs.y); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> * (<span class="keyword">const</span> Complex&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Complex <span class="title">conj</span><span class="params">(<span class="keyword">const</span> Complex&amp; p)</span> </span>&#123; <span class="keyword">return</span> Complex(p.x, -p.y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> P;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> m = P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % m;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    Complex W[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) W[i] = Complex(<span class="built_in">cos</span>(PI / Lim * i), <span class="built_in">sin</span>(PI / Lim * i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j) &#123;</span><br><span class="line">                    Complex f0 = f[i+j], f1 = W[<span class="number">1L</span>L * j * Lim / Mid] * f[i+j+Mid];</span><br><span class="line">                    f[i+j] = f0 + f1, f[i+j+Mid] = f0 - f1;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MTT</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* f, <span class="keyword">const</span> <span class="keyword">int</span>* g, <span class="keyword">int</span> Lim, <span class="keyword">int</span>* h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Complex A[MAXN], B[MAXN];</span><br><span class="line">        <span class="keyword">static</span> Complex dfta[MAXN], dftb[MAXN], dftc[MAXN], dftd[MAXN];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = Complex(f[i] &amp; M, f[i] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) B[i] = Complex(g[i] &amp; M, g[i] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">        FFT(A, Lim), FFT(B, Lim);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = (Lim - i) &amp; (Lim - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">static</span> Complex da, db, dc, dd;</span><br><span class="line">            da = (A[i] + conj(A[j])) * Complex(<span class="number">0.5</span>, <span class="number">0.0</span>);</span><br><span class="line">            db = (A[i] - conj(A[j])) * Complex(<span class="number">0.0</span>, <span class="number">-0.5</span>);</span><br><span class="line">            dc = (B[i] + conj(B[j])) * Complex(<span class="number">0.5</span>, <span class="number">0.0</span>);</span><br><span class="line">            dd = (B[i] - conj(B[j])) * Complex(<span class="number">0.0</span>, <span class="number">-0.5</span>);</span><br><span class="line">            dfta[j] = da * dc, dftb[j] = da * dd;</span><br><span class="line">            dftc[j] = db * dc, dftd[j] = db * dd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = dfta[i] + dftb[i] * Complex(<span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) B[i] = dftc[i] + dftd[i] * Complex(<span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        FFT(A, Lim), FFT(B, Lim);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> da = LL(A[i].x / Lim + <span class="number">0.5</span>) % P, db = LL(A[i].y / Lim + <span class="number">0.5</span>) % P;</span><br><span class="line">            <span class="keyword">int</span> dc = LL(B[i].x / Lim + <span class="number">0.5</span>) % P, dd = LL(B[i].y / Lim + <span class="number">0.5</span>) % P;</span><br><span class="line">            h[i] = (da + (LL(db + dc) &lt;&lt; <span class="number">15</span>) + (LL(dd) &lt;&lt; <span class="number">30</span>)) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN], ab[MAXN], abb[MAXN];</span><br><span class="line">        g[<span class="number">0</span>] = fpow(f[<span class="number">0</span>], P<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">0</span>, Lim = <span class="number">1</span>, Mid = <span class="number">2</span>; Mid &lt; <span class="number">2</span>*n; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*Mid) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">            init(Lim, L);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) A[i] = f[i], B[i] = g[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">            MTT(A, B, Lim, ab), MTT(ab, B, Lim, abb);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i)</span><br><span class="line">                g[i] = ((B[i] + B[i]) % P - abb[i] + P) % P;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = min(n, Mid); i &lt; Lim; ++i) g[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Der</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) g[i<span class="number">-1</span>] = <span class="number">1L</span>L * i * f[i] % P;</span><br><span class="line">        g[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Int</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        g[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) g[i] = <span class="number">1L</span>L * fpow(i, P<span class="number">-2</span>) * f[i<span class="number">-1</span>] % P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ln</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> df[MAXN], invf[MAXN];</span><br><span class="line">        Der(f, df, n), Inv(f, invf, n);</span><br><span class="line">        <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*n) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">        init(Lim, L);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; Lim; ++i) df[i] = invf[i] = <span class="number">0</span>;</span><br><span class="line">        MTT(df, invf, Lim, invf), Int(invf, g, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> Ans[MAXN], nA;</span><br><span class="line"><span class="keyword">int</span> f[MAXN], lnf[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(P), ++n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) read(f[i]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    Poly::Ln(f, lnf, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) lnf[i] = <span class="number">1L</span>L * i * lnf[i] % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; n; j += i) lnf[j] = (lnf[j] - lnf[i] + P) % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="keyword">if</span> (lnf[i]) Ans[++nA] = i;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, nA);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nA; ++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, Ans[i], <span class="string">" \n"</span>[i==nA]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SDOI2017」文本校正"><a href="#「SDOI2017」文本校正" class="headerlink" title="「SDOI2017」文本校正"></a>「SDOI2017」文本校正</h3><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2272" target="_blank" rel="noopener">https://loj.ac/problem/2272</a></li></ul><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>一道毒瘤的字符串匹配题.</p><p>假设串 $T$ 被拆分为形如 ABC 的三段, 有一个大力匹配的思路, 即枚举 $3!$ 种情况, 依次判定即可.</p><ol><li><p>ABC</p><p>直接用哈希判断两串是否相等即可…</p></li><li><p>CAB, BCA</p><p>以 CAB 为例, 注意到 AB 在 $T$ 中是连续的一段, 枚举 AB 和 C 的断点, 用哈希判断是否和 $S$ 中对应一段相等即可.</p><p>BCA 同理.</p></li><li><p>CBA</p><p>开 始 了.</p><p>我们先把 $T$ 倒过来再插入 $S$, 得到一个新串 $S_1 T_n S_2 T_{n-1} \cdots S_n T_1$, 那么 CBA 的判断就是在判断得到的新串是否可以被拆成 3 个偶回文串.</p><p>可以在新串上枚举一个拆分点, 现在的问题就是: 判断后缀是否构成一个双回文串.</p><p>有一个来自 <wc2017 金策="" 字符串算法选讲=""> 的结论</wc2017></p><blockquote><p>如果 $s = ab$, $a$, $b$ 都是回文串, 则称 $s$ 是一个双回文串.</p><p>如果 $s$ 是一个双回文串, 则存在一种拆分方法 $s = ab$, 使得 $a$ 是 $s$ 的最长回文前缀, 或者 $b$ 是 $s$ 的最长回文后缀.</p></blockquote><p>所以可以用 Manacher 处理出</p><ol><li><p>当前拆分点向右延伸的最长回文串的结束位置, 也就是最长回文前缀, 代码中为 <code>Rpos[i]</code>.</p></li><li><p>能够到达新串结尾的回文中心集合, 也就是最长回文后缀, 打标记后丢到队列里.</p></li></ol><p>假设当前枚举到的断点为 $i$, 若 $i$ 位置前是一个偶回文串, 依次用最长回文前缀和最长回文后缀判断 $i$ 位置后是否满足限制即可.</p></li><li><p>BAC, ACB</p><p>以 BAC 为例, 如果枚举 C 的位置, 利用上面的经验, 剩下的部分就是一个判断双回文串的问题…</p><p>但是有简单一些的办法.</p><p>回忆 Case 3 处理问题的过程, Manacher 其实在做一个最大匹配, 也就是说, 此处 BA 两串一定有一者是长度最大的, 利用 KMP 完成这个最大匹配即可. 剩下部分利用哈希判断就好了.</p><p>那么对于 ACB 的情况, 真的是字面意思上倒过来就可以了, 注意最后的答案, 先前的哈希值也要翻转. 当然再写一遍也是可以的, 有常数上的优势.</p></li></ol><p>时间复杂度 $O(n)$.</p><p>考场上我当然是选择 $O(n^2)$ 的暴力匹配 = =.</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2272</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">Pii Ans[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> S[MAXN], T[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双模数 Hash ...</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hash</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> P1 = <span class="number">998244353</span>, P2 = <span class="number">1e9</span>+<span class="number">7</span>, B = <span class="number">19260817</span>;</span><br><span class="line">    <span class="keyword">int</span> H1, H2;</span><br><span class="line"></span><br><span class="line">    Hash(<span class="keyword">int</span> _H1 = <span class="number">0</span>, <span class="keyword">int</span> _H2 = <span class="number">0</span>): H1(_H1), H2(_H2) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; ch)</span> </span>&#123;</span><br><span class="line">        H1 = (<span class="number">1L</span>L * H1 * B % P1 + ch) % P1, H2 = (<span class="number">1L</span>L * H2 * B % P2 + ch) % P2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Hash <span class="keyword">operator</span> + (<span class="keyword">const</span> Hash&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Hash((H1 + rhs.H1) % P1, (H2 + rhs.H2) % P2);</span><br><span class="line">    &#125;</span><br><span class="line">    Hash <span class="keyword">operator</span> - (<span class="keyword">const</span> Hash&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Hash((H1 - rhs.H1 + P1) % P1, (H2 - rhs.H2 + P2) % P2);</span><br><span class="line">    &#125;</span><br><span class="line">    Hash <span class="keyword">operator</span> * (<span class="keyword">const</span> Hash&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Hash(<span class="number">1L</span>L * H1 * rhs.H1 % P1, <span class="number">1L</span>L * H2 * rhs.H2 % P2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>== (<span class="keyword">const</span> Hash&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> H1 == rhs.H1 &amp;&amp; H2 == rhs.H2; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!= (<span class="keyword">const</span> Hash&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == rhs); &#125;</span><br><span class="line">&#125; A[MAXN], B[MAXN], powB[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Hash <span class="title">Part</span><span class="params">(Hash* H, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123; <span class="keyword">return</span> H[R] - H[L<span class="number">-1</span>] * powB[R-L+<span class="number">1</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ABC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A[n] != B[n]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> Ans[<span class="number">0</span>] = Pii(<span class="number">1</span>, <span class="number">1</span>), Ans[<span class="number">1</span>] = Pii(<span class="number">2</span>, <span class="number">2</span>), Ans[<span class="number">2</span>] = Pii(<span class="number">3</span>, n), <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CAB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (Part(A, <span class="number">1</span>, n - i + <span class="number">1</span>) == Part(B, i, n)</span><br><span class="line">                &amp;&amp; Part(A, n - i + <span class="number">2</span>, n) == Part(B, <span class="number">1</span>, i - <span class="number">1</span>)) &#123;</span><br><span class="line">            Ans[<span class="number">0</span>] = Pii(i, n), Ans[<span class="number">1</span>] = Pii(<span class="number">1</span>, <span class="number">1</span>), Ans[<span class="number">2</span>] = Pii(<span class="number">2</span>, i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BCA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">2</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (Part(A, <span class="number">1</span>, n - i) == Part(B, i + <span class="number">1</span>, n)</span><br><span class="line">                &amp;&amp; Part(A, n - i + <span class="number">1</span>, n) == Part(B, <span class="number">1</span>, i)) &#123;</span><br><span class="line">            Ans[<span class="number">0</span>] = Pii(i + <span class="number">1</span>, i + <span class="number">1</span>), Ans[<span class="number">1</span>] = Pii(i + <span class="number">2</span>, n), Ans[<span class="number">2</span>] = Pii(<span class="number">1</span>, i);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MaxR[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用回文半径判断回文串</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isP</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> Mid - L + <span class="number">1</span> &lt;= MaxR[Mid];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断双回文串, 其实只判定了长度...</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isDP</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L &lt; R &amp;&amp; (R - L) % <span class="number">4</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CBA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> C[MAXN &lt;&lt; <span class="number">1</span>], D[MAXN &lt;&lt; <span class="number">2</span>], nD, nC;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> Rpos[MAXN &lt;&lt; <span class="number">1</span>], Q[MAXN &lt;&lt; <span class="number">2</span>], head, tail;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> vis[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="comment">// C tansform</span></span><br><span class="line">    nD = nC = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) C[++nC] = S[i], C[++nC] = T[n - i + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// Manacher</span></span><br><span class="line">    D[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nC; ++i) D[++nD] = C[i], D[++nD] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nD; i += <span class="number">2</span>) vis[i] = <span class="literal">false</span>, Rpos[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Mid = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nD; ++i) &#123;</span><br><span class="line">        MaxR[i] = (i &lt; mx)? min(MaxR[Mid * <span class="number">2</span> - i], mx - i): <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= MaxR[i] &amp;&amp; D[i + MaxR[i]] == D[i - MaxR[i]]) ++MaxR[i];</span><br><span class="line">        <span class="keyword">if</span> (mx &lt; i + MaxR[i]) mx = i + MaxR[i], Mid = i;</span><br><span class="line">        Rpos[i - MaxR[i] + <span class="number">1</span>] = max(Rpos[i - MaxR[i] + <span class="number">1</span>], i + MaxR[i] - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i + MaxR[i] - <span class="number">1</span> == nD) vis[i - MaxR[i] + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Judge</span></span><br><span class="line">    Q[head = <span class="number">1</span>] = tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nD; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意此处的更新</span></span><br><span class="line">        Rpos[i] = max(Rpos[i], Rpos[i - <span class="number">2</span>] - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) Q[++tail] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// i 是断点, 真的是断点, 换言之, D[i] = -1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= nD; i += <span class="number">4</span>) <span class="keyword">if</span> (isP(<span class="number">0</span>, i)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (head &lt;= tail &amp;&amp; Q[head] &lt; i) ++head;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> Algt, Clgt;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (isDP(i, Rpos[i]) &amp;&amp; isDP(Rpos[i], nD) &amp;&amp; isP(Rpos[i], nD))</span><br><span class="line">            flag = <span class="literal">true</span>, Algt = i / <span class="number">4</span>, Clgt = (nD - Rpos[i]) / <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span> (!flag &amp;&amp; isDP(Q[head], nD) &amp;&amp; isDP(i, Q[head]) &amp;&amp; isP(i, Q[head]))</span><br><span class="line">            flag = <span class="literal">true</span>, Algt = i / <span class="number">4</span>, Clgt = (nD - Q[head]) / <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            Ans[<span class="number">0</span>] = Pii(n - Algt + <span class="number">1</span>, n);</span><br><span class="line">            Ans[<span class="number">1</span>] = Pii(Clgt + <span class="number">1</span>, n - Algt), Ans[<span class="number">2</span>] = Pii(<span class="number">1</span>, Clgt);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Sfail[MAXN], Tfail[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getFail</span><span class="params">(<span class="keyword">int</span>* P, <span class="keyword">int</span>* fail)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; P[i] != P[j + <span class="number">1</span>]) j = fail[j];</span><br><span class="line">        fail[i] = (j += P[i] == P[j + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BAC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Climit = n + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 注意要让 C 匹配上</span></span><br><span class="line">    <span class="keyword">while</span> (Climit &gt; <span class="number">1</span> &amp;&amp; S[Climit - <span class="number">1</span>] == T[Climit - <span class="number">1</span>]) --Climit;</span><br><span class="line">    <span class="keyword">int</span> ptrS = <span class="number">0</span>, ptrT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (ptrS &amp;&amp; S[ptrS+<span class="number">1</span>] != T[i]) ptrS = Sfail[ptrS];</span><br><span class="line">        <span class="keyword">if</span> (S[ptrS + <span class="number">1</span>] == T[i]) ++ptrS;</span><br><span class="line">        <span class="keyword">while</span> (ptrT &amp;&amp; T[ptrT+<span class="number">1</span>] != S[i]) ptrT = Tfail[ptrT];</span><br><span class="line">        <span class="keyword">if</span> (T[ptrT + <span class="number">1</span>] == S[i]) ++ptrT;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; Climit) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (Part(A, ptrS+<span class="number">1</span>, i) == Part(B, <span class="number">1</span>, i - ptrS)) &#123;</span><br><span class="line">            Ans[<span class="number">0</span>] = Pii(i - ptrS + <span class="number">1</span>, i);</span><br><span class="line">            Ans[<span class="number">1</span>] = Pii(<span class="number">1</span>, i - ptrS), Ans[<span class="number">2</span>] = Pii(i + <span class="number">1</span>, n);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Part(A, <span class="number">1</span>, i - ptrT) == Part(B, ptrT + <span class="number">1</span>, i)) &#123;</span><br><span class="line">            Ans[<span class="number">0</span>] = Pii(ptrT + <span class="number">1</span>, i);</span><br><span class="line">            Ans[<span class="number">1</span>] = Pii(<span class="number">1</span>, ptrT), Ans[<span class="number">2</span>] = Pii(i + <span class="number">1</span>, n);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ACB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Alimit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Alimit &lt; n &amp;&amp; S[Alimit + <span class="number">1</span>] == T[Alimit + <span class="number">1</span>]) ++Alimit;</span><br><span class="line">    <span class="keyword">int</span> ptrS = n+<span class="number">1</span>, ptrT = n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (ptrS != n+<span class="number">1</span> &amp;&amp; S[ptrS<span class="number">-1</span>] != T[i]) ptrS = n - Sfail[n-ptrS+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (S[ptrS - <span class="number">1</span>] == T[i]) --ptrS;</span><br><span class="line">        <span class="keyword">while</span> (ptrT != n+<span class="number">1</span> &amp;&amp; T[ptrT<span class="number">-1</span>] != S[i]) ptrT = n - Tfail[n-ptrT+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (T[ptrT - <span class="number">1</span>] == S[i]) --ptrT;</span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span> &gt; Alimit) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (Part(A, i, ptrS - <span class="number">1</span>) == Part(B, i + n - ptrS + <span class="number">1</span>, n)) &#123;</span><br><span class="line">            Ans[<span class="number">0</span>] = Pii(<span class="number">1</span>, i - <span class="number">1</span>), Ans[<span class="number">1</span>] = Pii(i + n - ptrS + <span class="number">1</span>, n);</span><br><span class="line">            Ans[<span class="number">2</span>] = Pii(i, i + n - ptrS);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Part(A, i + n - ptrT + <span class="number">1</span>, n) == Part(B, i, ptrT - <span class="number">1</span>)) &#123;</span><br><span class="line">            Ans[<span class="number">0</span>] = Pii(<span class="number">1</span>, i - <span class="number">1</span>), Ans[<span class="number">1</span>] = Pii(ptrT, n);</span><br><span class="line">            Ans[<span class="number">2</span>] = Pii(i, ptrT - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> Ti; read(Ti);</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    powB[<span class="number">0</span>] = Hash(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; ++i) powB[i] = powB[i<span class="number">-1</span>] * Hash(Hash::B, Hash::B);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        read(n), read(m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(S[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(T[i]);</span><br><span class="line">        <span class="comment">// solve &amp; output</span></span><br><span class="line">        getFail(S, Sfail), getFail(T, Tfail);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            A[i] = A[i<span class="number">-1</span>], A[i].insert(S[i]), B[i] = B[i<span class="number">-1</span>], B[i].insert(T[i]);</span><br><span class="line">        <span class="keyword">if</span> (ABC() || CAB() || BCA() || CBA() || BAC() || ACB()) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, Ans[i].first, Ans[i].second);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>本来想简单地写写, 后来发现自己言简意赅的能力不足 = =</p><p>以后尽量少写一点废话吧.</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;div style=&quot;text-align:center;&quot;&gt;&lt;img src=&quot;/images/SDOI-2017-sol/SDOI.jpg&quot;&gt; &lt;/div&gt;

&lt;p&gt;&lt;em&gt;&lt;p style=&quot;text-align:center;&quot;&gt;图源 &lt;a href=&quot;https://www.cnblogs.com/zzqsblog/p/7523003.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ZZQ’s Blog&lt;/a&gt;, 至少我是从那里找到的&lt;/p&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这 Round 2 也太毒瘤了 = =&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>SDOI 2017 Round 1 大赏</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/SDOI-2017-R1-sol/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/SDOI-2017-R1-sol/</id>
    <published>2020-03-06T08:17:15.000Z</published>
    <updated>2020-03-09T05:04:29.739Z</updated>
    
    <content type="html"><![CDATA[<hr><p>考虑到写详解有点花时间, 不写又容易忘 = =, 那就写个大概吧.</p><p>SD 两轮省选 (可能?) 会比较科学一点吧</p><a id="more"></a><p>不要因为 Round 1 而错怪 SDOI.</p><h3 id="「SDOI2017」数字表格"><a href="#「SDOI2017」数字表格" class="headerlink" title="「SDOI2017」数字表格"></a>「SDOI2017」数字表格</h3><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>求</p><p>$$\prod_{i=1}^n \prod_{j=1}^m f( \gcd(i, j) ) \mod 10^9 + 7$$</p><p>其中 $f(n)$ 为斐波那契数列数列第 $n$ 项, $1 \le n,m \le 10^6$, 多组测试数据, $1 \le T \le 1000$.</p><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2000" target="_blank" rel="noopener">https://loj.ac/problem/2000</a></li></ul><p>看到 $\gcd$ 不如来反演一波. 不妨令 $n \le m$.</p><p>枚举约数并整理, 有</p><p>$$\prod_{i=1}^n \prod_{j=1}^m \prod_{d = 1}^n f(d) [\gcd(i, j) = d]$$</p><p>$$\prod_{d=1}^n f(d) ^ {\sum\limits_{i=1}^n \sum\limits_{j=1}^m{\gcd(i, j) = d}}$$</p><p>由莫比乌斯反演的套路, 得</p><p>$$\prod_{d=1}^n f(d) ^ {\sum\limits_{T=1}^{\lfloor \frac{n}{d} \rfloor} \mu (T) \lfloor \frac{n}{Td} \rfloor \lfloor \frac{m}{Td} \rfloor}$$</p><p>$$\prod_{T=1}^n (\prod_{d\mid T} f(d) ^ {\mu (\frac{T}{d})}) ^ {\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor}$$</p><p>设 $g(T) = \prod_{d\mid T} f(d) ^ {\mu (\frac{T}{d})}$, 则所求即为</p><p>$$\prod_{T=1}^n g(T) ^ {\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor}$$</p><p>考虑计算 $g(T)$. 可以发现, 由于 $\mu(n)$ 取值只有 $0, -1, 1$, 计算 $g(T)$ 可以通过枚举倍数简单地实现. 时间复杂度 $O(n \ln n)$.</p><p>配合前缀积和数论分块即可, 注意快速幂时间复杂度 $O(\log b)$.</p><p>时间复杂度 $O(n \log P + n \ln n + T \cdot n \sqrt n \log P)$.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2000</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span>+<span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % P;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> notPrime[MAXN];</span><br><span class="line"><span class="keyword">int</span> Prime[MAXN], tot;</span><br><span class="line"><span class="keyword">int</span> mu[MAXN], invf[MAXN], f[MAXN], g[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EulerSieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    notPrime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    g[<span class="number">0</span>] = g[<span class="number">1</span>] = invf[<span class="number">1</span>] = f[<span class="number">1</span>] = mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAXN; ++i) &#123;</span><br><span class="line">        g[i] = <span class="number">1</span>;</span><br><span class="line">        f[i] = (f[i<span class="number">-1</span>] + f[i<span class="number">-2</span>]) % P;</span><br><span class="line">        invf[i] = fpow(f[i], P<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">if</span> (!notPrime[i]) Prime[++tot] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i*Prime[j] &lt; MAXN; ++j) &#123;</span><br><span class="line">            notPrime[i*Prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % Prime[j] == <span class="number">0</span>) &#123; mu[i*Prime[j]] = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">            mu[i*Prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; ++i) <span class="keyword">if</span> (mu[i] != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; MAXN; j += i)</span><br><span class="line">            g[j] = <span class="number">1L</span>L * g[j] * (mu[i] == <span class="number">1</span>? f[j / i]: invf[j / i]) % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAXN; ++i) g[i] = <span class="number">1L</span>L * g[i] * g[i<span class="number">-1</span>] % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    EulerSieve();</span><br><span class="line">    <span class="keyword">int</span> T; read(T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> n, m;</span><br><span class="line">        read(n), read(m);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; m) swap(n, m);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> R, L = <span class="number">1</span>; L &lt;= n; L = R + <span class="number">1</span>) &#123;</span><br><span class="line">            R = min(n / (n / L), m / (m / L));</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">1L</span>L * g[R] * fpow(g[L<span class="number">-1</span>], P<span class="number">-2</span>) % P;</span><br><span class="line">            ans = <span class="number">1L</span>L * ans * fpow(s, <span class="number">1L</span>L * (n / L) * (m / L) % (P<span class="number">-1</span>)) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SDOI2017」树点涂色"><a href="#「SDOI2017」树点涂色" class="headerlink" title="「SDOI2017」树点涂色"></a>「SDOI2017」树点涂色</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2001" target="_blank" rel="noopener">https://loj.ac/problem/2001</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>观察操作 1, 以及初始颜色都不相同, 可以发现每次把一条从根节点开始的链染成新颜色的操作类似与 LCT 中的 <code>access</code>. 另加考虑可以发现, 某个节点 $u$ 到根节点的颜色数, 就是在 LCT 上经过虚边的个数 + 1. (假设初始状态中, 树上的边在 LCT 上都是虚边)</p><p>根据这个思路, 操作 2 可以简单计算, 也就是 <code>dist(u) + dist(v) - 2 * dist(LCA) + 1</code>. (此处用 <code>dist</code> 指代当前节点到根的颜色数, 因为 LCA 被减两次所以答案 + 1)</p><p>那么操作 3 呢? 回想 LCT 维护子树信息的过程, 体现在这道题中也就是在更改 “实儿子” 和 “虚儿子” 子树的信息, 换言之, 子树内加减, 然后维护最值就好了. 可以计算出 DFS 序后使用线段树维护.</p><p>实现中在建树的时候直接使用深度作为初始最值, 以及 <code>access</code> 修改的时候需要 <code>findroot</code> 一下找到实际子树的根再修改.</p><p>时间复杂度 $O(m \log ^2 n)$, <del>最近一群毒瘤卡树剖, 不敢再有 log^3 了</del></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2001</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> LCT &#123;</span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>][MAXN], pre[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">which</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123; <span class="keyword">return</span> pre[u]? ch[<span class="number">1</span>][pre[u]] == u: <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">nroot</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre[u]? ch[<span class="number">0</span>][pre[u]] == u || ch[<span class="number">1</span>][pre[u]] == u: <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fa = pre[u], w = which(u);</span><br><span class="line">        pre[u] = pre[fa];</span><br><span class="line">        <span class="keyword">if</span> (nroot(fa)) ch[which(fa)][pre[fa]] = u;</span><br><span class="line">        ch[w][fa] = ch[w^<span class="number">1</span>][u];</span><br><span class="line">        <span class="keyword">if</span> (ch[w^<span class="number">1</span>][u]) pre[ch[w^<span class="number">1</span>][u]] = fa;</span><br><span class="line">        ch[w^<span class="number">1</span>][u] = fa, pre[fa] = u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (nroot(u)) &#123;</span><br><span class="line">            <span class="keyword">int</span> fa = pre[u];</span><br><span class="line">            <span class="keyword">if</span> (nroot(fa)) which(fa) == which(u)? rotate(fa): rotate(u);</span><br><span class="line">            rotate(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HLD &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">int</span> size[MAXN], son[MAXN], depth[MAXN], pre[MAXN];</span><br><span class="line">    <span class="keyword">int</span> topfa[MAXN], dfn[MAXN], rnk[MAXN], dfs_clock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">        size[u] = <span class="number">1</span>, son[u] = <span class="number">-1</span>, LCT::pre[u] = pre[u] = fa;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) == fa) <span class="keyword">continue</span>;</span><br><span class="line">            dfs1(v, u), size[u] += size[v];</span><br><span class="line">            <span class="keyword">if</span> (son[u] == <span class="number">-1</span> || size[v] &gt; size[son[u]]) son[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">        topfa[u] = top;</span><br><span class="line">        dfn[u] = ++dfs_clock, rnk[dfs_clock] = u;</span><br><span class="line">        <span class="keyword">if</span> (~son[u]) dfs2(son[u], top);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) != pre[u] &amp;&amp; v != son[u]) dfs2(v, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (topfa[u] != topfa[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth[topfa[u]] &lt; depth[topfa[v]]) swap(u, v);</span><br><span class="line">            u = pre[topfa[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth[u] &gt; depth[v]? v: u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>)</span> </span>&#123; dfs1(root, <span class="number">0</span>), dfs2(root, root); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (nd&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (nd&lt;&lt;1|1)</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> HLD;</span><br><span class="line">    <span class="keyword">int</span> datMax[MAXN &lt;&lt; <span class="number">2</span>], tagAdd[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; nd)</span> </span>&#123;</span><br><span class="line">        datMax[nd] = max(datMax[lc], datMax[rc]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; nd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tagAdd[nd]) <span class="keyword">return</span>;</span><br><span class="line">        tagAdd[lc] += tagAdd[nd], datMax[lc] += tagAdd[nd];</span><br><span class="line">        tagAdd[rc] += tagAdd[nd], datMax[rc] += tagAdd[nd];</span><br><span class="line">        tagAdd[nd] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> <span class="keyword">void</span>( datMax[nd] = depth[rnk[L]] );</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        build(lc, L, Mid), build(rc, Mid+<span class="number">1</span>, R);</span><br><span class="line">        maintain(nd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> datMax[nd] += val, <span class="keyword">void</span>( tagAdd[nd] += val );</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        pushdown(nd);</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= Mid) Mdy(lc, L, Mid, opL, opR, val);</span><br><span class="line">        <span class="keyword">if</span> (opR &gt; Mid) Mdy(rc, Mid+<span class="number">1</span>, R, opL, opR, val);</span><br><span class="line">        maintain(nd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Mdy(<span class="number">1</span>, <span class="number">1</span>, n, dfn[u], dfn[u] + size[u] - <span class="number">1</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> datMax[nd];</span><br><span class="line">        pushdown(nd);</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= Mid) ret = max(ret, Qry(lc, L, Mid, opL, opR));</span><br><span class="line">        <span class="keyword">if</span> (opR &gt; Mid) ret = max(ret, Qry(rc, Mid+<span class="number">1</span>, R, opL, opR));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123; <span class="keyword">return</span> Qry(<span class="number">1</span>, <span class="number">1</span>, n, dfn[u], dfn[u]); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u)</span> </span>&#123; <span class="keyword">return</span> Qry(<span class="number">1</span>, <span class="number">1</span>, n, dfn[u], dfn[u] + size[u] - <span class="number">1</span>); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> LCT &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ch[<span class="number">0</span>][u]) u = ch[<span class="number">0</span>][u];</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; u; v = u, u = pre[u]) &#123;</span><br><span class="line">            splay(u);</span><br><span class="line">            <span class="keyword">if</span> (ch[<span class="number">1</span>][u]) SGT::Mdy(findroot(ch[<span class="number">1</span>][u]), <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (v) SGT::Mdy(findroot(v), <span class="number">-1</span>);</span><br><span class="line">            ch[<span class="number">1</span>][u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        read(u), read(v), Graph::AddEdge(u, v), Graph::AddEdge(v, u);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    HLD::solve(), SGT::build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> opt, x, y;</span><br><span class="line">        read(opt), read(x);</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: LCT::access(x); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: read(y), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, SGT::Qry(x) + SGT::Qry(y) - <span class="number">2</span> * SGT::Qry(HLD::LCA(x, y)) + <span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, SGT::Sub(x)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERR\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SDOI2017」序列计数"><a href="#「SDOI2017」序列计数" class="headerlink" title="「SDOI2017」序列计数"></a>「SDOI2017」序列计数</h3><p>高一刚学矩阵快速幂的时候整天写斐波那契数列的 n 倍经验 = =</p><p>然后某次学长测试, 出了一个矩阵快速幂, 差点就 A 了, 可惜矩阵写反了…</p><p>再然后就没独立写出过矩阵快速幂的题了, 凄惨 = =</p><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2002" target="_blank" rel="noopener">https://loj.ac/problem/2002</a></li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>要求和是 $p$ 的倍数, 那么显然是模 $p$ 意义下为 $0$ 了. 考虑到至少有一个数为质数的限制可以通过减法原理解决, 即计算一遍所有数的方案数, 再减去只用合数的答案.</p><p>容易想到一个暴力 DP:</p><p>设 $f(i, j)$ 表示选 $i$ 个数, 加起来模 $p$ 为 $j$ 的方案数. 则</p><p>$$f(i, j) = \sum_k f(i-1, (j - k)\mod p)$$</p><p>每次选择满足限制的 $k$ 就好了.</p><p>观察到 DP 中每次转移都是一样的, 考虑用矩阵快速幂优化.</p><p>容易想到 $O(mp)$ 的构造矩阵方法, 考虑在模 $p$ 意义下, 矩阵中某一列 (或者是某一行) 是循环的, 于是可以在 $O(m + p^2)$ 的时间内构造.</p><p>具体实现的时候有一些细节, 还是参考代码实现吧.</p><p>时间复杂度 $O(m + p^2 + p^3 \log n)$.</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>这道题中, 两个矩阵相乘可以通过某些方法优化到 $O(p^2)$, 研究不懂, $O(p^3)$ 养老…</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2002</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2e7</span>+<span class="number">5</span>, MAXP = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">20170408</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p;</span><br><span class="line"><span class="keyword">int</span> f[MAXP], g[MAXP];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> notPrime[MAXM];</span><br><span class="line"><span class="keyword">int</span> Prime[MAXM], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EulerSieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    notPrime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!notPrime[i]) Prime[++tot] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i*Prime[j] &lt;= m; ++j) &#123;</span><br><span class="line">            notPrime[i*Prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % Prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> g[MAXP][MAXP];</span><br><span class="line"></span><br><span class="line">    Matrix() &#123; <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g); &#125;</span><br><span class="line"></span><br><span class="line">    Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        Matrix ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; p; ++k)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p; ++j)</span><br><span class="line">                    ret.g[i][j] = (ret.g[i][j] + <span class="number">1L</span>L * g[i][k] * rhs.g[k][j] % MOD) % MOD;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; ++i) g[i][i] = <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">fpow</span><span class="params">(Matrix base, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    Matrix ret; ret.init();</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * base;</span><br><span class="line">        base = base * base, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Part1</span><span class="params">()</span> </span>&#123; <span class="comment">// 所有数部分</span></span><br><span class="line">    Matrix base;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ++f[i % p];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ++base.g[(-i % p + p) % p][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; p; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; ++i) base.g[i][j] = base.g[(i - <span class="number">1</span> + p) % p][j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    Matrix Ans = fpow(base, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; ++i)</span><br><span class="line">        ret = (ret + <span class="number">1L</span>L * f[i] * Ans.g[i][<span class="number">0</span>] % MOD) % MOD;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Part2</span><span class="params">()</span> </span>&#123; <span class="comment">// 合数部分</span></span><br><span class="line">    Matrix base;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="keyword">if</span> (notPrime[i]) ++g[i % p];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="keyword">if</span> (notPrime[i]) ++base.g[(-i % p + p) % p][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; p; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; ++i) base.g[i][j] = base.g[(i - <span class="number">1</span> + p) % p][j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    Matrix Ans = fpow(base, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; ++i)</span><br><span class="line">        ret = (ret + <span class="number">1L</span>L * g[i] * Ans.g[i][<span class="number">0</span>] % MOD) % MOD;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;p);</span><br><span class="line">    EulerSieve();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (Part1() - Part2() + MOD) % MOD);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SDOI2017」新生舞会"><a href="#「SDOI2017」新生舞会" class="headerlink" title="「SDOI2017」新生舞会"></a>「SDOI2017」新生舞会</h3><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2003" target="_blank" rel="noopener">https://loj.ac/problem/2003</a></li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>看到式子之后容易联想到 0/1 分数规划. 所以直接考虑二分答案.</p><p>假设当前答案 $\ge x$, 也就是</p><p>$$C = \frac{ \sum a_i’ }{ \sum b_i’ } \ge x$$</p><p>进一步转化,得</p><p>$$\sum (a_i’ - b_i’ x) \ge 0$$</p><p>然后就可以用二分图最大匹配解决了. 具体地说, 二分图内两两边权 $w_{i, j} = a_{i, j} - b_{i, j} x$, 如果最大权匹配 $\ge 0$ 则当前二分到的 $x$ 合法.</p><p>二分图最大权匹配部分采用 KM 算法, 时间复杂度 $O(n^3 \log w)$. 其中 $w$ 为权值上界.</p><p>突然有一种工程界很喜欢 KM 算法的错觉.</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p>听说写费用流有点卡常? 我这一个写 KM 的哪知道啊 = =</p><p>以及二分的时候不要玩弄 <code>eps</code>, 因为二分边界写挂调了好久.png</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2003</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-7</span>, INFD = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">fabs</span>(p) &lt; EPS)? <span class="number">0</span>: (p &lt; <span class="number">0</span>? <span class="number">-1</span>: <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> A[MAXN][MAXN], B[MAXN][MAXN];</span><br><span class="line"><span class="keyword">double</span> W[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> KM &#123;</span><br><span class="line">    <span class="keyword">int</span> S[MAXN], T[MAXN], Time;</span><br><span class="line">    <span class="keyword">int</span> left[MAXN];</span><br><span class="line">    <span class="keyword">double</span> Lx[MAXN], Ly[MAXN], slack[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        S[u] = Time;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; ++v) <span class="keyword">if</span> (T[v] != Time) &#123;</span><br><span class="line">            <span class="keyword">double</span> d = Lx[u] + Ly[v] - W[u][v];</span><br><span class="line">            <span class="keyword">if</span> (dcmp(d) == <span class="number">0</span>) &#123;</span><br><span class="line">                T[v] = Time;</span><br><span class="line">                <span class="keyword">if</span> (left[v] == <span class="number">-1</span> || dfs(left[v])) <span class="keyword">return</span> left[v] = u, <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> slack[v] = min(d, slack[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> a = INFD;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (T[j] != Time) a = min(a, slack[j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S[i] == Time) Lx[i] -= a;</span><br><span class="line">            <span class="keyword">if</span> (T[i] == Time) Ly[i] += a; <span class="keyword">else</span> slack[i] -= a;</span><br><span class="line">            <span class="comment">// 某篇讲 KM 算法的 CSDN 博客这里更新 slack 的时候写挂了 = =</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">KM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            left[i] = <span class="number">-1</span>, Lx[i] = *max_element(W[i]+<span class="number">1</span>, W[i]+<span class="number">1</span>+n), Ly[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) slack[i] = INFD;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                ++Time;</span><br><span class="line">                <span class="keyword">if</span> (!dfs(u)) update(); <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u) <span class="keyword">if</span> (~left[u]) ret += W[left[u]][u];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) W[i][j] = A[i][j] - x * B[i][j];</span><br><span class="line">    <span class="keyword">return</span> dcmp(KM::KM()) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) read(A[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) read(B[i][j]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">double</span> L = <span class="number">0.0</span>, R = <span class="number">1e6</span>;</span><br><span class="line">    <span class="keyword">while</span> (dcmp(R - L) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">double</span> Mid = (L + R) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(Mid)) L = Mid; <span class="keyword">else</span> R = Mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SDOI2017」硬币游戏"><a href="#「SDOI2017」硬币游戏" class="headerlink" title="「SDOI2017」硬币游戏"></a>「SDOI2017」硬币游戏</h3><blockquote><p>字符串题啊, 学提高的时候用哈希, 学省选的时候用 SAM 就够了.</p></blockquote><p>不知道从哪里听来这句屁话 = =</p><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2004" target="_blank" rel="noopener">https://loj.ac/problem/2004</a></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>还是 <a href="https://www.cnblogs.com/CQzhangyu/p/7054998.html" target="_blank" rel="noopener">CQzhangyu</a> 讲得好.</del></p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><p><code>0.5 ^ 300 = 4.909093465297727e-91</code></p><p><code>2.0 ^ 300 = 2.037035976334486e+90</code></p><p>你叫我用哪个…</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2004</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">305</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">fabs</span>(p) &lt; EPS)? <span class="number">0</span>: (p &lt; <span class="number">0</span>? <span class="number">-1</span>: <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> S[MAXN][MAXN];</span><br><span class="line"><span class="keyword">double</span> pow2[MAXN], A[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> AC &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = ::MAXN * ::MAXN;</span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>][MAXN], fail[MAXN], nidx;</span><br><span class="line">    <span class="keyword">int</span> len[MAXN], pos[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; nidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">val</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>&amp; c)</span> </span>&#123; <span class="keyword">return</span> c == <span class="string">'H'</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>* S, <span class="keyword">const</span> <span class="keyword">int</span>&amp; idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = val(S[i]);</span><br><span class="line">            <span class="keyword">if</span> (!ch[c][u]) ch[c][u] = ++nidx;</span><br><span class="line">            u = ch[c][u];</span><br><span class="line">        &#125;</span><br><span class="line">        pos[idx] = u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        fail[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">2</span>; ++c) &#123;</span><br><span class="line">            <span class="keyword">int</span>&amp; v = ch[c][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (v) Q.push(v), fail[v] = <span class="number">1</span>; <span class="keyword">else</span> v = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">2</span>; ++c) &#123;</span><br><span class="line">                <span class="keyword">int</span>&amp; v = ch[c][u];</span><br><span class="line">                <span class="keyword">if</span> (v) Q.push(v), fail[v] = ch[c][fail[u]];</span><br><span class="line">                <span class="keyword">else</span> v = ch[c][fail[u]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pow2[<span class="number">0</span>] = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) pow2[i] = pow2[i<span class="number">-1</span>] * <span class="number">0.5</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>, j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                u = ch[val(S[i][j])][u], len[u] = j;</span><br><span class="line">            A[i][n + <span class="number">1</span>] = -pow2[m];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> u = pos[j]; u &gt; <span class="number">1</span>; u = fail[u])</span><br><span class="line">                    <span class="keyword">if</span> (len[u]) A[i][j] += pow2[m - len[u]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>, j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                u = ch[val(S[i][j])][u], len[u] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) A[n + <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        A[n + <span class="number">1</span>][n + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Gauss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= n + <span class="number">1</span>; ++j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(A[j][i]) &gt; <span class="built_in">fabs</span>(A[r][i])) r = j;</span><br><span class="line">        <span class="comment">// assert(dcmp(A[r][i]) != 0);</span></span><br><span class="line">        <span class="keyword">if</span> (r != i) swap(A[r], A[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; ++j) <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">            <span class="keyword">double</span> d = A[j][i] / A[i][i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= n + <span class="number">2</span>; ++k) A[j][k] -= d * A[i][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (dcmp(A[i][i]) != <span class="number">0</span>) A[i][n + <span class="number">2</span>] /= A[i][i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    AC::init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S[i] + <span class="number">1</span>), AC::insert(S[i], i);</span><br><span class="line">    AC::getFail(), AC::build();</span><br><span class="line">    Gauss();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%.7lf\n"</span>, A[i][n + <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「SDOI2017」相关分析"><a href="#「SDOI2017」相关分析" class="headerlink" title="「SDOI2017」相关分析"></a>「SDOI2017」相关分析</h3><p>之前听 lxl 讲洛谷网课的时候看他吐槽过 SDOI “那个无聊的东西”, 大概是指的这个吧 (</p><p><del>的确挺无聊的 = =</del></p><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2005" target="_blank" rel="noopener">https://loj.ac/problem/2005</a></li></ul><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>读过高中必修课本的 (忘了是哪本了 = =) 都知道, 询问的 $\hat a$ 可以展开, 当然不知道这个式子也是可推的…</p><p>$$\hat a = \frac{\sum\limits_{i = L} ^ R (x_i - \bar{x})(y_i - \bar{y})}{\sum\limits_{i = L} ^ R (x_i - \bar{x}) ^ 2} = \frac{ \sum\limits_{i=L}^R x_i y_i - n \bar x \bar y }{\sum\limits_{i=L}^R x_i^2 - n \bar x^2}$$</p><p>对于询问, 直接用线段树维护 $\sum {x_i},\ \sum {y_i},\ \sum x_i y_i,\ \sum x_i ^ 2$ 就可以回答了.</p><p>区间加… 把这几个东西加起来再展开就好了.</p><p>$$\sum_{i=L}^R (x_i + S) = \sum_{i=L}^R x_i + (R-L+1) \cdot S$$</p><p>$$\sum_{i=L}^R (y_i + T) = \sum_{i=L}^R y_i + (R-L+1) \cdot T$$</p><p>$$\sum_{i=L}^R (x_i + S) (y_i + T) = \sum_{i=L}^R x_i y_i + T \sum_{i=L}^R x_i + S \sum_{i=L}^R y_i + (R-L+1) \cdot ST$$</p><p>$$\sum_{i=L}^R (x_i + S) ^ 2 = \sum_{i=L}^R x_i^2 + 2S \sum_{i=L}^R x_i + (R-L+1) \cdot S^2$$</p><p>区间赋值… 注意所赋值具有特殊性, 也就是第 $i$ 个位置改成 $i$, 然后再跑一遍区间加的操作就好了.</p><p><del>看错条件多推了一倍的式子, 人没了</del></p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><p>线段树的细节无非是传标记的时候容易挂… 然后就喜闻乐见地挂了.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2005</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">fabs</span>(p) &lt; EPS)? <span class="number">0</span>: (p &lt; <span class="number">0</span>? <span class="number">-1</span>: <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">s0</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123; <span class="keyword">return</span> R - L + <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">s1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n / <span class="number">2.0</span> * (n + <span class="number">1</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">s1</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123; <span class="keyword">return</span> s1(R) - s1(L - <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">s2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n / <span class="number">6.0</span> * (n + <span class="number">1</span>) * (<span class="number">2</span> * n + <span class="number">1</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">s2</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123; <span class="keyword">return</span> s2(R) - s2(L - <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> X[MAXN], Y[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (nd&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (nd&lt;&lt;1|1)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">double</span> x, x2, y, xy;</span><br><span class="line">        Node() &#123; x = y = xy = <span class="number">0</span>; &#125;</span><br><span class="line">        Node(<span class="keyword">double</span> _x, <span class="keyword">double</span> _x2, <span class="keyword">double</span> _y, <span class="keyword">double</span> _xy): x(_x), x2(_x2), y(_y), xy(_xy) &#123; &#125;</span><br><span class="line">        Node <span class="keyword">operator</span> + (<span class="keyword">const</span> Node&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Node(x + rhs.x, x2 + rhs.x2, y + rhs.y, xy + rhs.xy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (xy - x / s0(L, R) * y) / (x2 - x / s0(L, R) * x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; dat[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">double</span> tagAddX[MAXN &lt;&lt; <span class="number">2</span>], tagAddY[MAXN &lt;&lt; <span class="number">2</span>]; <span class="keyword">bool</span> tagSet[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; nd)</span> </span>&#123; dat[nd] = dat[lc] + dat[rc]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushAdd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; nd, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R, <span class="keyword">const</span> <span class="keyword">double</span>&amp; S, <span class="keyword">const</span> <span class="keyword">double</span>&amp; T)</span> </span>&#123;</span><br><span class="line">        dat[nd].x2 += <span class="number">2.0</span> * S * dat[nd].x + s0(L, R) * S * S;</span><br><span class="line">        dat[nd].xy += T * dat[nd].x + S * dat[nd].y + s0(L, R) * S * T;</span><br><span class="line">        dat[nd].x += s0(L, R) * S;</span><br><span class="line">        dat[nd].y += s0(L, R) * T;</span><br><span class="line">        tagAddX[nd] += S, tagAddY[nd] += T;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushSet</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; nd, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R)</span> </span>&#123;</span><br><span class="line">        dat[nd].y = dat[nd].x = s1(L, R);</span><br><span class="line">        dat[nd].x2 = dat[nd].xy = s2(L, R);</span><br><span class="line">        tagSet[nd] = <span class="literal">true</span>, tagAddX[nd] = tagAddY[nd] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; nd, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (tagSet[nd]) &#123;</span><br><span class="line">            pushSet(lc, L, Mid), pushSet(rc, Mid+<span class="number">1</span>, R);</span><br><span class="line">            tagSet[nd] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dcmp(tagAddX[nd]) || dcmp(tagAddY[nd])) &#123;</span><br><span class="line">            pushAdd(lc, L, Mid, tagAddX[nd], tagAddY[nd]);</span><br><span class="line">            pushAdd(rc, Mid+<span class="number">1</span>, R, tagAddX[nd], tagAddY[nd]);</span><br><span class="line">            tagAddX[nd] = tagAddY[nd] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> <span class="keyword">void</span>( dat[nd] = Node(X[L], <span class="number">1.0</span> * X[L] * X[L], Y[L], <span class="number">1.0</span> * X[L] * Y[L]) );</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        build(lc, L, Mid), build(rc, Mid+<span class="number">1</span>, R);</span><br><span class="line">        maintain(nd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR, <span class="keyword">const</span> <span class="keyword">double</span>&amp; S, <span class="keyword">const</span> <span class="keyword">double</span>&amp; T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> pushAdd(nd, L, R, S, T);</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        pushdown(nd, L, R);</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= Mid) Add(lc, L, Mid, opL, opR, S, T);</span><br><span class="line">        <span class="keyword">if</span> (opR &gt; Mid) Add(rc, Mid+<span class="number">1</span>, R, opL, opR, S, T);</span><br><span class="line">        maintain(nd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR, <span class="keyword">const</span> <span class="keyword">double</span>&amp; S, <span class="keyword">const</span> <span class="keyword">double</span>&amp; T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> pushSet(nd, L, R), pushAdd(nd, L, R, S, T);</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        pushdown(nd, L, R);</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= Mid) Mdy(lc, L, Mid, opL, opR, S, T);</span><br><span class="line">        <span class="keyword">if</span> (opR &gt; Mid) Mdy(rc, Mid+<span class="number">1</span>, R, opL, opR, S, T);</span><br><span class="line">        maintain(nd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> dat[nd];</span><br><span class="line">        pushdown(nd, L, R);</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> Qry(lc, L, Mid, opL, opR);</span><br><span class="line">        <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> Qry(rc, Mid+<span class="number">1</span>, R, opL, opR);</span><br><span class="line">        <span class="keyword">return</span> Qry(lc, L, Mid, opL, opR) + Qry(rc, Mid+<span class="number">1</span>, R, opL, opR);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(X[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(Y[i]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    SGT::build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> opt, L, R, S, T;</span><br><span class="line">        <span class="keyword">static</span> SGT::Node Ans;</span><br><span class="line">        read(opt), read(L), read(R);</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">"%.8lf\n"</span>, SGT::Qry(<span class="number">1</span>, <span class="number">1</span>, n, L, R).calc(L, R)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: read(S), read(T), SGT::Add(<span class="number">1</span>, <span class="number">1</span>, n, L, R, S, T); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: read(S), read(T), SGT::Mdy(<span class="number">1</span>, <span class="number">1</span>, n, L, R, S, T); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERR\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;考虑到写详解有点花时间, 不写又容易忘 = =, 那就写个大概吧.&lt;/p&gt;
&lt;p&gt;SD 两轮省选 (可能?) 会比较科学一点吧&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>HAOI 2017 大赏</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/HAOI-2017-sol/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/HAOI-2017-sol/</id>
    <published>2020-03-01T11:37:35.000Z</published>
    <updated>2020-03-13T05:41:27.411Z</updated>
    
    <content type="html"><![CDATA[<hr><p>HAOI 2017 的神秘弱省省选难度.</p><a id="more"></a><p>2017 年的 HAOI (大概? ) 是一天两试, 上午三题下午两题, 于是只有 5 道题了.</p><p>当年还有学长辛酸的故事…</p><h3 id="「HAOI2017」新型城市化"><a href="#「HAOI2017」新型城市化" class="headerlink" title="「HAOI2017」新型城市化"></a>「HAOI2017」新型城市化</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2276" target="_blank" rel="noopener">https://loj.ac/problem/2276</a></li></ul><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>给定一张图, 点数为 $n$, 给定 $m$ 条边 <strong>不连</strong>, 满足图可被分成不超过两个完全图.</p><p>现在要加入一条原先不存在的边, 使得加入这条边后, 图的最大团大小至少比原图最大团大小至少增加 $1$.</p><p>求所有满足该性质的边.</p><p>其中, $1 \le n \le 10^4,\ 0 \le m \le \min \{ 1.5 \times 10^5, \frac{1}{2} n (n+1) \}$.</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先可以发现, 给定的图, 也就是给定的不连接的边, 构成一张二分图.</p><p>考虑二分图的一些性质:</p><ol><li>图的最大团 = 补图的最大独立集</li><li>二分图最大独立集 = 点数 - 二分图最小点覆盖</li><li>二分图最小点覆盖 = 二分图最大匹配</li></ol><p>即使没有看出给定图为二分图, 由性质 1 也容易感性理解了.</p><p>根据这些性质, 容易发现我们直接用网络流跑二分图, 那么所求边就是二分图匹配中的必经边.</p><p>又有一些结论:</p><ol><li>二分图匹配必经边在网络中流量为 $1$, 且两端点在 <strong>残量网络</strong> 中属于 <strong>不同</strong> 的强连通分量.</li><li>二分图匹配可行边在网络中流量为 $1$, 且两端点在 <strong>残量网络</strong> 中属于 <strong>相同</strong> 的强连通分量.</li></ol><p>所以, 先将二分图黑白染色, 建图跑二分图最大匹配, 然后在残量网络上跑强连通分量, 最后依次判断给定边是否满足条件就好了.</p><p>时间复杂度为 $O(n + n \sqrt m + n + m + m \log m) = O(n \sqrt m)$.</p><p><del>看来二分图 &amp; 网络流的那一套东西又忘了, 该回去看看了</del></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2276</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e4</span>+<span class="number">5</span>, MAXM = <span class="number">15e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = MAXN, MAXE = MAXN * <span class="number">2</span> + MAXM, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, S, T;</span><br><span class="line">Pii E[MAXM];</span><br><span class="line"><span class="keyword">int</span> id[MAXM], col[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;Pii&gt; Ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (col[v = edges[i].to] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            col[v] = <span class="number">3</span> - col[u], dfs(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Dinic &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, cap, flow; &#125; edges[MAXE &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXV], cur[MAXV], depth[MAXV], vis[MAXV], Time, eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to, cap, <span class="number">0</span> &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[to], from, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        head[to] = eidx;</span><br><span class="line">        <span class="keyword">return</span> eidx - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        Q.push(S);</span><br><span class="line">        vis[S] = ++Time, depth[S] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">const</span> Edge&amp; e = edges[i];</span><br><span class="line">                <span class="keyword">if</span> (vis[e.to] != Time &amp;&amp; e.cap &gt; e.flow)</span><br><span class="line">                    vis[e.to] = Time, depth[e.to] = depth[u] + <span class="number">1</span>, Q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[T] == Time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == T || !a) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> f, flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            Edge&amp; e = edges[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[e.to] == depth[u] + <span class="number">1</span> &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                flow += f, a -= f, e.flow += f, edges[i^<span class="number">1</span>].flow -= f;</span><br><span class="line">                <span class="keyword">if</span> (!a) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS()) <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span> cur), flow += DFS(S, INF);</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SCC &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Dinic;</span><br><span class="line">    <span class="keyword">int</span> dfn[MAXV], low[MAXV], SCCidx[MAXV], SCCcnt, dfs_clock;</span><br><span class="line">    <span class="keyword">int</span> stk[MAXV], top;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        low[u] = dfn[u] = ++dfs_clock, stk[++top] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="comment">// 残量</span></span><br><span class="line">            <span class="keyword">if</span> (edges[i].flow == edges[i].cap) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v = edges[i].to]) &#123;</span><br><span class="line">                tarjan(v);</span><br><span class="line">                low[u] = min(low[u], low[v]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!SCCidx[v]) low[u] = min(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (low[u] == dfn[u]) &#123;</span><br><span class="line">            ++SCCcnt;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = stk[top--];</span><br><span class="line">                SCCidx[x] = SCCcnt;</span><br><span class="line">                <span class="keyword">if</span> (u == x) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n + <span class="number">2</span>; ++u) <span class="keyword">if</span> (!dfn[u]) tarjan(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> &amp;u = E[i].first, &amp;v = E[i].second;</span><br><span class="line">            <span class="keyword">if</span> (SCCidx[u] == SCCidx[v] || edges[id[i]].flow &lt; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            Ans.push_back(E[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init(), Dinic::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    S = n + <span class="number">1</span>, T = n + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        read(u), read(v);</span><br><span class="line">        <span class="keyword">if</span> (u &gt; v) swap(u, v);</span><br><span class="line">        E[i] = Pii(u, v);</span><br><span class="line">        Graph::AddEdge(u, v), Graph::AddEdge(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">        <span class="keyword">if</span> (col[u] == <span class="number">0</span>) col[u] = <span class="number">1</span>, Graph::dfs(u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> &amp;u = E[i].first, &amp;v = E[i].second;</span><br><span class="line">        <span class="keyword">if</span> (col[u] == <span class="number">1</span>) id[i] = Dinic::AddEdge(u, v, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (col[u] == <span class="number">2</span>) id[i] = Dinic::AddEdge(v, u, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[u] == <span class="number">1</span>) Dinic::AddEdge(S, u, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (col[u] == <span class="number">2</span>) Dinic::AddEdge(u, T, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Dinic::Maxflow();</span><br><span class="line">    SCC::solve();</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, Ans.size());</span><br><span class="line">    sort(Ans.begin(), Ans.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; Ans.size(); ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, Ans[i].first, Ans[i].second);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「HAOI2017」方案数"><a href="#「HAOI2017」方案数" class="headerlink" title="「HAOI2017」方案数"></a>「HAOI2017」方案数</h3><p><del>既然有东方的神秘力量, 那么为什么答案对 998244353 取模…</del></p><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2277" target="_blank" rel="noopener">https://loj.ac/problem/2277</a></li></ul><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>容易看出来这题是计数 DP + 容斥.</del></p><p>先考虑没有障碍怎么做.</p><p>可以发现一个性质: 到达某一个点 $(x,\ y,\ z)$ 的方案数, 只和每个坐标在二进制表示中 $1$ 的个数有关.</p><p>设 $f(x,\ y,\ z)$ 表示某个坐标中 $1$ 的个数分别为 $x,\ y,\ z$, 那么可以写出转移:</p><p>$$f(x,\ y,\ z) = \sum_{i=1}^x \binom{x}{i} f(x - i,\ y,\ z) + \sum_{j=1}^y \binom{y}{j} f(x,\ y - j,\ z) \\ + \sum_{k=1}^z \binom{z}{k} f(x,\ y,\ z - k)$$</p><p>那么 $f(x,\ y,\ z)$ 可以在 $O(\log^ 3 n)$ 的时间内计算. <del>听说数据弱, 这样就有 80 pts?</del></p><p>考虑加上障碍怎么做.</p><p>设 $g(i)$ 表示从出发点到第 $i$ 个障碍的方案数. 如果不考虑其他障碍的影响, 那么直接从 $f(x,\ y,\ z)$ 转移就好了. 如果考虑, 则需要减去 $O \rightarrow j \rightarrow i$ 的方案数, 其中 $O \rightarrow j$ 就是 $g(j)$, $j \rightarrow i$ 可以通过 $f(x,\ y,\ z)$ 计算.</p><p>形式化一点, 即</p><p>$$g(i) = f(x,\ y,\ z) - \sum_{j} g(j) \cdot f(x’, y’, z’)$$</p><p>其中的细节参考代码实现.</p><p>将终点 $(n,\ m,\ r)$ 加入障碍点, 则 $g(o)$ 即为答案.</p><p>时间复杂度 $O(\log^3 n + o \log o + o^2) = O(o^2)$. <del>o &lt;= 1e4 当然是按信仰跑.</del></p><p>为了便于实现以及方便计算, 将所有障碍点按坐标依次从小到大排序. 并通过预处理加速统计某个数二进制下 $1$ 的个数.</p><p><del>感觉以后写 DP 还是发现什么性质就写写方程试试… 万一就对了呢…</del></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>由于实现的问题, 所以我的代码跑得很满, 用时成功 loj 倒数第一.</p><p>以及这题数据比较弱, 每次只记录和 $(n,\ m,\ r)$ 有关的障碍, 就可以跑得飞快.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2277</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">61</span>, BASE = (<span class="number">1</span> &lt;&lt; <span class="number">16</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXO = <span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pls</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123; <span class="keyword">return</span> (a + b &lt; P)? a + b: a + b - P; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mns</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123; <span class="keyword">return</span> (a - b &gt;= <span class="number">0</span>)? a - b: a - b + P; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> &#123;</span></span><br><span class="line">    LL x, y, z;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (x == rhs.x)? ((y == rhs.y)? z &lt; rhs.z: y &lt; rhs.y): x &lt; rhs.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; A[MAXO];</span><br><span class="line"></span><br><span class="line">LL n, m, r, o;</span><br><span class="line"><span class="keyword">int</span> Bit[BASE + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> C[MAXN][MAXN], f[MAXN][MAXN][MAXN], g[MAXO];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过预处理, 计算一个 long long 范围数的 popcount</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">lowbit</span><span class="params">(<span class="keyword">const</span> LL&amp; x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __brute_popcount(LL x) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>) ++ret, x -= lowbit(x);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以将其拆为 4 个小于 BASE 的部分统计</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __block_popcount(<span class="keyword">const</span> LL&amp; x) &#123;</span><br><span class="line">    <span class="keyword">return</span> Bit[x &amp; BASE] + Bit[(x &gt;&gt; <span class="number">16</span>) &amp; BASE] + Bit[(x &gt;&gt; <span class="number">32</span>) &amp; BASE] + Bit[(x &gt;&gt; <span class="number">48</span>) &amp; BASE];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= BASE; ++i) Bit[i] = __brute_popcount(i);</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m), read(r);</span><br><span class="line">    read(o);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= o; ++i) read(A[i].x), read(A[i].y), read(A[i].z);</span><br><span class="line">    A[++o] = (Item)&#123; n, m, r &#125;;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; ++i) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) C[i][j] = (C[i<span class="number">-1</span>][j] + C[i<span class="number">-1</span>][j<span class="number">-1</span>]) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; MAXN; ++x)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; MAXN; ++y)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">0</span>; z &lt; MAXN; ++z) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++i)</span><br><span class="line">                    f[x][y][z] = pls(f[x][y][z], <span class="number">1L</span>L * f[x-i][y][z] * C[x][i] % P);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= y; ++j)</span><br><span class="line">                    f[x][y][z] = pls(f[x][y][z], <span class="number">1L</span>L * f[x][y-j][z] * C[y][j] % P);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= z; ++k)</span><br><span class="line">                    f[x][y][z] = pls(f[x][y][z], <span class="number">1L</span>L * f[x][y][z-k] * C[z][k] % P);</span><br><span class="line">            &#125;</span><br><span class="line">    sort(A+<span class="number">1</span>, A+<span class="number">1</span>+o);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= o; ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> Item&amp; now = A[i];</span><br><span class="line">        g[i] = f[__block_popcount(now.x)][__block_popcount(now.y)][__block_popcount(now.z)];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">const</span> Item&amp; nxt = A[j];</span><br><span class="line">            <span class="keyword">if</span> ((nxt.x &amp; now.x) != nxt.x || (nxt.y &amp; now.y) != nxt.y || (nxt.z &amp; now.z) != nxt.z) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> x = __block_popcount(now.x ^ nxt.x), y = __block_popcount(now.y ^ nxt.y),</span><br><span class="line">                z = __block_popcount(now.z ^ nxt.z);</span><br><span class="line">            g[i] = mns(g[i], <span class="number">1L</span>L * f[x][y][z] * g[j] % P);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, g[o]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「HAOI2017」字符串"><a href="#「HAOI2017」字符串" class="headerlink" title="「HAOI2017」字符串"></a>「HAOI2017」字符串</h3><p>好久没写 AC 自动机了, 看到这道题人没了 = =</p><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2278" target="_blank" rel="noopener">https://loj.ac/problem/2278</a></li></ul><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目中将文本串 $S$ 和多个模式串 $p_i$ 匹配, 容易想到 AC 自动机.</p><p><em>以下涉及到反串的位置, 都是以原串位置为准</em></p><p>考虑题意中的匹配是什么意思. 也就是两个失配位置间隔 $k+1$. 换言之, 假设 $S$ 匹配到了位置 $i$, 那么让 $S$ 以 $i+k+1$ 结尾的反串匹配到当前节点对应模式串 $p$ 的反串就可以了.</p><p>这样不好统计, 我们建出 fail 树, 并在 fail 树上统计.</p><p>对于 AC 自动机的某个节点 $u$, 假设 $S$ 到达 $u$ 时同某个模式串 $p$ 匹配到位置 $i$, 我们要在 $u$ 在子树中找到某个节点 $v$, 设 $v$ 上 $S$ 匹配到第 $j$ 个位置, 则位置 $j + k + 1$ 对应节点, 要在 $p$ 的反串第 $i + k + 1$ 位对应节点的 fail 树内, 询问这样的 $v$ 的个数.</p><p><del>这段话虽然主语混乱, 但是很重要.</del></p><p>这就是一个树上数点的问题了, 可以使用树状数组以及差分解决.</p><p>还有一个问题, 每次计算 $S$ 上位置 $i$ 以及 $i + k + 1$ 的匹配时, 如果位置 $i + k$ 匹配, 那么会算重, 需要单独计算这部分的贡献来去重.</p><p>于是可以得到算法流程:</p><p>对所有 $p_i$ 的正反串建 AC 自动机, 把 $S$ 正反两次丢到 AC 自动机上匹配; 建 fail 树, 记录 $p_i$ 和 $S$ 对答案的影响, 也就是修改和查询操作, 并挂在 fail 树对应节点上; 树上差分统计子树信息即可. 因为要去重, 使用两个 BIT 统计.</p><p>注意特判 $p$ 长度小于等于 $k$ 的情况, 如果不特判只有 20 pts = =</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>我也想知道为什么我的常数那么大, __stdcall 跑得那么快.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2278</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">4e5</span>+<span class="number">5</span>, SIGMA = <span class="number">95</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> type, idx, nd;</span><br><span class="line">    Ask(<span class="keyword">int</span> <span class="keyword">_t</span>, <span class="keyword">int</span> _i, <span class="keyword">int</span> _n): type(<span class="keyword">_t</span>), idx(_i), nd(_n) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K;</span><br><span class="line"><span class="keyword">char</span> S[MAXN], P[MAXN];</span><br><span class="line"><span class="keyword">int</span> pos[<span class="number">2</span>][MAXN], dfn[MAXN], size[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Ans[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;Ask&gt; Q[MAXN], M[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx, dfs_clock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        size[u] = <span class="number">1</span>, dfn[u] = ++dfs_clock;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">            dfs(v = edges[i].to), size[u] += size[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> AC &#123;</span><br><span class="line">    <span class="keyword">int</span> ch[SIGMA][MAXN], fail[MAXN], nidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; nidx = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch[v][u]? ch[v][u]: (ch[v][u] = ++nidx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        fail[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; SIGMA; ++c) &#123;</span><br><span class="line">            <span class="keyword">int</span>&amp; v = ch[c][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (v) Q.push(v), fail[v] = <span class="number">1</span>; <span class="keyword">else</span> v = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; SIGMA; ++c) &#123;</span><br><span class="line">                <span class="keyword">int</span>&amp; v = ch[c][u];</span><br><span class="line">                <span class="keyword">if</span> (v) Q.push(v), fail[v] = ch[c][fail[u]];</span><br><span class="line">                <span class="keyword">else</span> v = ch[c][fail[u]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= AC::nidx; ++i) Graph::AddEdge(fail[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> C[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; d, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = d; i &lt;= Graph::dfs_clock; i += lowbit(i)) C[i] += val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = d; i; i -= lowbit(i)) ret += C[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R)</span> </span>&#123; <span class="keyword">return</span> Qry(R) - Qry(L<span class="number">-1</span>); &#125;</span><br><span class="line">&#125; T[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; Q[u].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> Ask&amp; q = Q[u][i];</span><br><span class="line">        Ans[q.idx] -= q.type * T[q.type &lt; <span class="number">0</span>].Qry(dfn[q.nd], dfn[q.nd] + size[q.nd] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; M[u].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> Ask&amp; m = M[u][i];</span><br><span class="line">        T[m.type &lt; <span class="number">0</span>].Mdy(dfn[m.nd], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) solve(edges[i].to);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; Q[u].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> Ask&amp; q = Q[u][i];</span><br><span class="line">        Ans[q.idx] += q.type * T[q.type &lt; <span class="number">0</span>].Qry(dfn[q.nd], dfn[q.nd] + size[q.nd] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">val</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>&amp; c)</span> </span>&#123; <span class="keyword">return</span> c - <span class="number">33</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    AC::init(), Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%s%d"</span>, &amp;K, S + <span class="number">1</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> Slgt = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(S + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, P + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> Plgt = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(P + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 80pts = =</span></span><br><span class="line">        <span class="keyword">if</span> (Plgt &lt;= K) &#123; Ans[j] = Slgt - Plgt + <span class="number">1</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="comment">// AC-automaton</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>, i = <span class="number">1</span>; i &lt;= Plgt; ++i) pos[<span class="number">0</span>][i] = u = AC::insert(u, val(P[i]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>, i = Plgt; i &gt;= <span class="number">1</span>; --i) pos[<span class="number">1</span>][i] = u = AC::insert(u, val(P[i]));</span><br><span class="line">        <span class="comment">// maintain</span></span><br><span class="line">        pos[<span class="number">0</span>][<span class="number">0</span>] = pos[<span class="number">1</span>][Plgt + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Plgt - K; ++i)</span><br><span class="line">            Q[pos[<span class="number">0</span>][i]].push_back(Ask(<span class="number">1</span>, j, pos[<span class="number">1</span>][i + K + <span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Plgt - K; ++i)</span><br><span class="line">            Q[pos[<span class="number">0</span>][i]].push_back(Ask(<span class="number">-1</span>, j, pos[<span class="number">1</span>][i + K]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    AC::getFail(), Graph::dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// match</span></span><br><span class="line">    pos[<span class="number">0</span>][<span class="number">0</span>] = pos[<span class="number">1</span>][Slgt + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Slgt; ++i) pos[<span class="number">0</span>][i] = AC::ch[val(S[i])][pos[<span class="number">0</span>][i - <span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Slgt; i &gt;= <span class="number">1</span>; --i) pos[<span class="number">1</span>][i] = AC::ch[val(S[i])][pos[<span class="number">1</span>][i + <span class="number">1</span>]];</span><br><span class="line">    <span class="comment">// maintain</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Slgt - K; ++i)</span><br><span class="line">        M[pos[<span class="number">0</span>][i]].push_back(Ask(<span class="number">1</span>, <span class="number">0</span>, pos[<span class="number">1</span>][i + K + <span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Slgt - K; ++i)</span><br><span class="line">        M[pos[<span class="number">0</span>][i]].push_back(Ask(<span class="number">-1</span>, <span class="number">0</span>, pos[<span class="number">1</span>][i + K]));</span><br><span class="line">    solve(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「HAOI2017」八纵八横"><a href="#「HAOI2017」八纵八横" class="headerlink" title="「HAOI2017」八纵八横"></a>「HAOI2017」八纵八横</h3><p>在学线段树分治的时候, 看到这道题是 HAOI 就没有写, 于是去写了 <a href="http://codeforces.com/problemset/problem/938/G" target="_blank" rel="noopener">CF938G Shortest Path Queries</a>.</p><p>看到题目后, ???. 不过那场 EDU 是 18 年的… 估计是撞 idea 了 = =</p><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2312" target="_blank" rel="noopener">https://loj.ac/problem/2312</a></li></ul><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>那么这道题的思路就很显然了, 采用线段树分治, 对时间建线段树, 把边的编号挂在对应的节点上.</p><p>然后考虑如何计算答案. 由于这张图是连通的, 考虑图上的环, 容易发现可以构造出一条从 $1$ 开始又回到 $1$ 的路径, 使得仅有环上的路径经过奇数次.</p><p>那么可以记录环上的路径异或值, 并查询其中可以异或到的最大值. 可以使用并查集以及线性基完成.</p><p>不过这屑题中权值二进制位数是 $10^3$ 级别的, 使用 <code>bitset</code> 即可. 考虑到上面都是一些套路性的东西, 于是这道题的难点就是用 <code>bitset</code> 模拟了. = =</p><p>时间复杂度大概是 $O(q \frac{len}{w} \log q \log n)$ ?</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p>似乎不用写带撤销线性基? 偷懒每次直接大力复制当前线性基到线段树下一节点…</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2312</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">505</span>, MAXM = <span class="number">2005</span>, MAXL = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stk</span> &#123;</span> <span class="keyword">int</span> fu, fv, size; &#125; stk[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Modify</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, L, R; <span class="built_in">bitset</span>&lt;MAXL&gt; w;</span><br><span class="line">&#125; M[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, top;</span><br><span class="line"><span class="keyword">char</span> str[MAXL];</span><br><span class="line"></span><br><span class="line"><span class="built_in">bitset</span>&lt;MAXL&gt; fix(<span class="keyword">char</span>* S) &#123;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;MAXL&gt; ret;</span><br><span class="line">    <span class="keyword">int</span> lgt = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(S);</span><br><span class="line">    reverse(S, S + lgt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lgt; ++i) ret[i] = S[i] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinerBasis</span> &#123;</span></span><br><span class="line">    <span class="built_in">bitset</span>&lt;MAXL&gt; A[MAXL];</span><br><span class="line"></span><br><span class="line">    LinerBasis() &#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXL; ++i) A[i].reset(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">bitset</span>&lt;MAXL&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = MAXL<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) <span class="keyword">if</span> (x[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!A[i].any()) &#123; A[i] = x; <span class="keyword">break</span>; &#125;</span><br><span class="line">            x ^= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Qry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// max xor</span></span><br><span class="line">        <span class="built_in">bitset</span>&lt;MAXL&gt; ret; ret.reset();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = MAXL<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) <span class="keyword">if</span> (!ret[i]) ret ^= A[i];</span><br><span class="line">        <span class="comment">// output</span></span><br><span class="line">        <span class="keyword">int</span> i = MAXL<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; !ret[i]) --i;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) <span class="built_in">putchar</span>(ret[i--] + <span class="string">'0'</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DSU &#123;</span><br><span class="line">    <span class="keyword">int</span> fa[MAXN], size[MAXN];</span><br><span class="line">    <span class="built_in">bitset</span>&lt;MAXL&gt; dist[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i, size[i] = <span class="number">1</span>, dist[i].reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">findfa</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (u != fa[u]) u = fa[u];</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="built_in">bitset</span>&lt;MAXL&gt; findist(<span class="keyword">int</span> u) &#123;</span><br><span class="line">        <span class="built_in">bitset</span>&lt;MAXL&gt; ret; ret.reset();</span><br><span class="line">        <span class="keyword">while</span> (u != fa[u]) ret ^= dist[u], u = fa[u];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (nd&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (nd&lt;&lt;1|1)</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> DSU;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dat[MAXM &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR, <span class="keyword">const</span> <span class="keyword">int</span>&amp; idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> <span class="keyword">void</span>( dat[nd].push_back(idx) );</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= Mid) Mdy(lc, L, Mid, opL, opR, idx);</span><br><span class="line">        <span class="keyword">if</span> (opR &gt; Mid) Mdy(rc, Mid+<span class="number">1</span>, R, opL, opR, idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Divide</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, LinerBasis S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> k = top;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; dat[nd].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span>&amp; idx = dat[nd][i];</span><br><span class="line">            <span class="keyword">int</span> fu = findfa(M[idx].u), fv = findfa(M[idx].v);</span><br><span class="line">            <span class="built_in">bitset</span>&lt;MAXL&gt; w = M[idx].w ^ findist(M[idx].u) ^ findist(M[idx].v);</span><br><span class="line">            <span class="keyword">if</span> (fu == fv) S.insert(w);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (size[fu] &lt; size[fv]) swap(fu, fv);</span><br><span class="line">                fa[fv] = fu, size[fu] += size[fv], dist[fv] = w;</span><br><span class="line">                stk[++top] = (Stk)&#123; fu, fv, size[fv] &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (L == R) S.Qry();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">            Divide(lc, L, Mid, S), Divide(rc, Mid+<span class="number">1</span>, R, S);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; k) &#123;</span><br><span class="line">            Stk u = stk[top--];</span><br><span class="line">            dist[u.fv].reset(), fa[u.fv] = u.fv, size[u.fu] -= u.size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    LinerBasis S;</span><br><span class="line">    DSU::init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;u, &amp;v, str);</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> DSU;</span><br><span class="line">        <span class="keyword">int</span> fu = findfa(u), fv = findfa(v);</span><br><span class="line">        <span class="built_in">bitset</span>&lt;MAXL&gt; w = fix(str) ^ findist(u) ^ findist(v);</span><br><span class="line">        <span class="keyword">if</span> (fu == fv) S.insert(w);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (size[fu] &lt; size[fv]) swap(fu, fv);</span><br><span class="line">            fa[fv] = fu, size[fu] += size[fv], dist[fv] = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    S.Qry();</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="comment">// 指定编号就很难受 = =</span></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>, ex = <span class="number">550</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x, y, k; <span class="keyword">static</span> <span class="keyword">char</span> opt[<span class="number">16</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, opt);</span><br><span class="line">        <span class="keyword">switch</span> (opt[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;x, &amp;y, str);</span><br><span class="line">                M[++idx] = (Modify)&#123; x, y, i, <span class="number">-1</span>, fix(str) &#125;;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'a'</span>: <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k), M[k].R = i - <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;k, str);</span><br><span class="line">                M[++ex] = M[k];</span><br><span class="line">                M[ex].R = i - <span class="number">1</span>, M[k].L = i, M[k].w = fix(str);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERR\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= idx; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (M[i].R == <span class="number">-1</span>) M[i].R = q;</span><br><span class="line">        <span class="keyword">if</span> (M[i].L &lt;= M[i].R) SGT::Mdy(<span class="number">1</span>, <span class="number">1</span>, q, M[i].L, M[i].R, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">551</span>; i &lt;= ex; ++i)</span><br><span class="line">        <span class="keyword">if</span> (M[i].L &lt;= M[i].R) SGT::Mdy(<span class="number">1</span>, <span class="number">1</span>, q, M[i].L, M[i].R, i);</span><br><span class="line">    <span class="comment">// DSU::init();</span></span><br><span class="line">    SGT::Divide(<span class="number">1</span>, <span class="number">1</span>, q, S);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="「HAOI2017」供给侧改革"><a href="#「HAOI2017」供给侧改革" class="headerlink" title="「HAOI2017」供给侧改革"></a>「HAOI2017」供给侧改革</h3><p>出题人终于承认数据是他用脚随的了.</p><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul><li><a href="https://loj.ac/problem/2313" target="_blank" rel="noopener">https://loj.ac/problem/2313</a></li></ul><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p><del>根据题目中 “串 S 中的每一位都是在 0 和 1 之间随机产生的” 可以猜测, 这道题适合瞎搞.</del></p><p>既然数据随机, 那么很多不对劲的算法就可以拿过来用了.</p><p><del>似乎可以直接猜最长 LCP 长度然后大力枚举?</del></p><p>还是考虑一种看起来对劲的做法, 先建出原串的后缀树. 这里采用对反串建 SAM, 后缀链接就是原串的后缀树了.</p><p>将所有询问离线, 按 $R$ 从小到大排序, 扫描 $S$ 的每一位, 每次在后缀树上更新一条链, 在后缀树上维护最长 LCP 大小 <code>MaxLCP</code>, 以及节点和前缀长度对应到 $S$ 上的最靠后位置, 分别记作 <code>idx[u]</code> 和 <code>Lidx[l]</code>.</p><p>如果当前扫描位置包含了某个询问的区间, 就把这个询问拿出来计算答案. 从大到小枚举最长 LCP 长度, 如果当前长度 $i$ 对应的 <code>Lidx[i]</code> 比记录的上一次更新位置 <code>lst</code> 要大就更新答案.</p><p>由于答案的单调性, 也就是 $[L,\ R]$ 的答案一定大于等于 $[L+1,\ R],\ \ldots,\ [R-1,\ R]$, 所以分块计算的正确性可以得到保证.</p><p>时间复杂度 $O(\texttt{玄学})$.</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #2313</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> idx, L, R;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Ask&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> R &lt; rhs.R || (R == rhs.R &amp;&amp; L &lt; rhs.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Q[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">char</span> S[MAXN];</span><br><span class="line"><span class="keyword">int</span> pos[MAXN], Ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SAM &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = ::MAXN &lt;&lt; <span class="number">1</span>, SIGMA = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ch[SIGMA][MAXN], lnk[MAXN], len[MAXN], nidx, last;</span><br><span class="line">    <span class="keyword">int</span> idx[MAXN], Lidx[MAXN], MaxLCP;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; nidx = last = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nd = ++nidx, p = last;</span><br><span class="line">        len[nd] = len[last] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !ch[val][p]) ch[val][p] = nd, p = lnk[p];</span><br><span class="line">        <span class="keyword">if</span> (!p) lnk[nd] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> q = ch[val][p];</span><br><span class="line">            <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) lnk[nd] = q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> nxt = ++nidx;</span><br><span class="line">                len[nxt] = len[p] + <span class="number">1</span>, lnk[nxt] = lnk[q];</span><br><span class="line">                ch[<span class="number">0</span>][nxt] = ch[<span class="number">0</span>][q], ch[<span class="number">1</span>][nxt] = ch[<span class="number">1</span>][q];</span><br><span class="line">                <span class="keyword">while</span> (p &amp;&amp; ch[val][p] == q) ch[val][p] = nxt, p = lnk[p];</span><br><span class="line">                lnk[q] = lnk[nd] = nxt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last = nd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Upd</span><span class="params">(<span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = pos[R]; u &gt; <span class="number">1</span>; u = lnk[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx[u]) &#123;</span><br><span class="line">                MaxLCP = max(MaxLCP, len[u]);</span><br><span class="line">                Lidx[len[u]] = max(Lidx[len[u]], idx[u]);</span><br><span class="line">            &#125;</span><br><span class="line">            idx[u] = max(idx[u], R);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> lst = L - <span class="number">1</span>, i = MaxLCP; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">            <span class="keyword">if</span> (lst &lt; Lidx[i]) ret += i * (Lidx[i] - lst), lst = Lidx[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    SAM::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;n, &amp;q, S+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> L, R, i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R), Q[i] = (Ask)&#123; i, L, R &#125;;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) pos[i] = SAM::insert(S[i] - <span class="string">'0'</span>);</span><br><span class="line">    sort(Q+<span class="number">1</span>, Q+<span class="number">1</span>+q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">1</span>, i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        SAM::Upd(i);</span><br><span class="line">        <span class="keyword">while</span> (idx &lt;= q &amp;&amp; Q[idx].R &lt;= i)</span><br><span class="line">            Ans[Q[idx].idx] = SAM::Qry(Q[idx].L), ++idx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;HAOI 2017 的神秘弱省省选难度.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>「Luogu P2664」树上游戏</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/luogu-P2664/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/luogu-P2664/</id>
    <published>2020-02-28T13:40:09.000Z</published>
    <updated>2020-02-28T16:20:10.434Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P2664" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P2664</a></li></ul><p>这是一道点分治好题, 至少我现在这么认为. = =</p><a id="more"></a><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><ol><li>点分治</li></ol><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>考虑点分治. <del>虽然隔壁 O(n) 做法又大又圆但是不管</del></p><blockquote><p>点分治在处理树上路径信息的时候, 把路径分为两类: 一类不经过根节点, 一类经过. 后者为一端点是根节点的路径, 或者可以看作两条端点为根节点的路径拼接而来.</p><p>所以可以依次遍历子树, 每次单独考虑子树中的信息和其他子树信息之间的影响, 从而更新答案.</p></blockquote><p>在处理这道题的时候我们沿用这个思路. 也就是说, 上面是两段废话, 和这题毫无关系.</p><p>为了表述方便, 记 <code>C[u]</code> 为节点 $u$ 的颜色, <code>size[u]</code> 为节点 $u$ 的子树大小.</p><p>可以观察到一个事实, 单独考虑根节点 $root$ 一个子树中的某一个节点 $u$, ($u$ 满足在 $root$ 到 $u$ 的路径中 <code>C[u]</code> 第一次出现), 那么这个节点 $u$ 可以对其他子树中的节点 $v$, ($v$ 满足 $v$ 到 $root$ 路径上不包含 <code>C[u]</code>, 有 <code>size[u]</code> 的贡献.</p><p>正确性显然. 单独考虑每个颜色的贡献, 因为 $u$ 的颜色只在 $u,\ v$ 路径上出现过一次, 所以 $u$ 的子树都可以同 $v$ 构成一个点对, $u$ 的颜色对 $v$ 做一次贡献, 共 <code>size[u]</code>.</p><p>考虑如何在点分治的过程中维护这个东西.</p><p>先维护满足以上条件 $u$ 的子树大小和, (也就是 $u$ 满足 $root$ 到 $u$ 的路径中 (不包括 $root$), $u$ 的颜色第一次出现), 以颜色为下标, 记作 $\operatorname{W}(c) = \sum\limits_{\operatorname{C}(u) = c} \operatorname{size}(u)$.</p><p>并记 <code>tot</code> 为所有 <code>W[c]</code> 的和.</p><ul><li><p>对于根节点, 自身的颜色可以给自己 <code>size[root]</code> 的贡献, 其他节点可以给根节点 <code>tot - W[C[root]]</code> 的贡献.</p><p>其实很好理解, 因为自己的颜色已经计算过了, 自然减掉就好了.</p></li><li><p>对于以 $u$ 为根子树中的点 $v$, 考虑其他子树对该子树的影响.</p><p> 记 <code>num</code> 为 $v$ 到 $root$ 路径 (不包括 $root$) 上的颜色数量.</p><p> 沿路更新 <code>num</code>, <code>tot</code> 的值: 遇到新颜色, 将 <code>tot</code> 减去 <code>W[C[v]]</code>, 并将 <code>num</code> 增加 1.</p><p> 那么对 $v$ 的贡献为 <code>tot + (size[root] - size[u]) * num</code>.</p><p> 也就是满足开始所说的条件的其他子树中的点, 对 $v$ 的答案做贡献; 以及其他子树中的点经过 <code>num</code> 个点来到 $v$, 对 $v$ 的答案做贡献.</p><p> 注意回溯的时候把改变的 <code>tot</code> 以及 <code>num</code> 改回来. = =</p></li></ul><p>那么, 为什么不会算重呢?</p><p><del>实际上计算贡献的方式, 每一步都对应树上不同形式的路径, 细节留给读者思考.</del></p><p>对于根节点的统计, 考虑的是当前分治范围内的子树对其的贡献; 对于子树中节点的统计, 考虑的是其他子树对其的影响, 而不考虑子树内部的贡献, 两者互不影响.</p><p>综上, 可以得到如下的算法流程:</p><ol><li><p>以当前重心为根, DFS 整棵树, 维护 <code>size[u]</code>, <code>W[c]</code>.</p></li><li><p>维护根节点的答案, <code>Ans[root] += tot - W[C[root]] + size[root]</code>.</p></li><li><p>遍历根节点子树, 将当前节点的贡献减去, 计算当前子树答案, <code>Ans[v] += tot + (size[root] - size[v]) * num</code>, 再加回当前节点贡献.</p></li><li><p>清空记录的信息.</p></li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P2664</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> C[MAXN];</span><br><span class="line">LL Ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> TreeDivide &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXN];</span><br><span class="line">    <span class="keyword">int</span> cnt[MAXN], num;</span><br><span class="line">    LL W[MAXN], tot, Y;</span><br><span class="line">    <span class="keyword">int</span> Balance[MAXN], size[MAXN], subsize, ct;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span> </span>&#123; subsize = x, Balance[ct = <span class="number">0</span>] = MAXN; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findCt</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        Balance[u] = <span class="number">0</span>, size[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) == fa || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            findCt(v, u), size[u] += size[v];</span><br><span class="line">            Balance[u] = max(Balance[u], size[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        Balance[u] = max(Balance[u], subsize - size[u]);</span><br><span class="line">        <span class="keyword">if</span> (Balance[u] &lt; Balance[ct]) ct = u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        ++cnt[C[u]], size[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) == fa || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(v, u), size[u] += size[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt[C[u]] == <span class="number">1</span>) tot += size[u], W[C[u]] += size[u];</span><br><span class="line">        --cnt[C[u]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subDfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        ++cnt[C[u]];</span><br><span class="line">        <span class="keyword">if</span> (cnt[C[u]] == <span class="number">1</span>) tot -= W[C[u]], ++num;</span><br><span class="line">        Ans[u] += tot + Y * num;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) != fa &amp;&amp; !vis[v]) subDfs(v, u);</span><br><span class="line">        <span class="keyword">if</span> (cnt[C[u]] == <span class="number">1</span>) tot += W[C[u]], --num;</span><br><span class="line">        --cnt[C[u]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2 --&gt; 3</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">const</span> <span class="keyword">int</span>&amp; type)</span> </span>&#123;</span><br><span class="line">        ++cnt[C[u]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) != fa &amp;&amp; !vis[v]) Mdy(v, u, type);</span><br><span class="line">        <span class="keyword">if</span> (cnt[C[u]] == <span class="number">1</span>) tot += <span class="number">1L</span>L * type * size[u], W[C[u]] += <span class="number">1L</span>L * type * size[u];</span><br><span class="line">        --cnt[C[u]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 4</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        W[C[u]] = cnt[C[u]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) != fa &amp;&amp; !vis[v]) clear(v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Divide</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// now</span></span><br><span class="line">        <span class="comment">// Step 1</span></span><br><span class="line">        dfs(u, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// Step 2</span></span><br><span class="line">        Ans[u] += tot - W[C[u]] + size[u];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[v = edges[i].to]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// Step 2 --&gt; 3</span></span><br><span class="line">            ++cnt[C[u]], tot -= size[v], W[C[u]] -= size[v];</span><br><span class="line">            Mdy(v, u, <span class="number">-1</span>);</span><br><span class="line">            <span class="comment">// Step 3</span></span><br><span class="line">            --cnt[C[u]], Y = size[u] - size[v];</span><br><span class="line">            subDfs(v, u);</span><br><span class="line">            ++cnt[C[u]], tot += size[v], W[C[u]] += size[v];</span><br><span class="line">            Mdy(v, u, <span class="number">1</span>);</span><br><span class="line">            --cnt[C[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Step 4</span></span><br><span class="line">        num = tot = <span class="number">0</span>, clear(u, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// nxt</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[v = edges[i].to]) <span class="keyword">continue</span>;</span><br><span class="line">            init(size[v]), findCt(v, <span class="number">-1</span>), Divide(ct);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123; init(n), findCt(<span class="number">1</span>, <span class="number">-1</span>), Divide(ct); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(C[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        read(u), read(v), Graph::AddEdge(u, v), Graph::AddEdge(v, u);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    TreeDivide::solve();</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>Treeloveswater, 洛谷题解, <a href="https://www.luogu.com.cn/blog/user24559/solution-p2664" target="_blank" rel="noopener">https://www.luogu.com.cn/blog/user24559/solution-p2664</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://www.luogu.com.cn/problem/P2664&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.com.cn/problem/P2664&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是一道点分治好题, 至少我现在这么认为. = =&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>「NOI2018」屠龙勇士 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/luogu-P4774/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/luogu-P4774/</id>
    <published>2020-02-27T13:11:04.000Z</published>
    <updated>2020-02-28T05:42:17.294Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>NOI 又不怎么考数论题.</p><p>from 某神仙</p></blockquote><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P4774" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P4774</a></li></ul><p><del>最近好颓啊 = =, 写题又不想自己写, 学东西又不能静下来好好学</del></p><p>这是一道拓展中国剩余定理的模板题, 由此发现之前学的 Ex CRT 很假, 所以来整理一下.</p><a id="more"></a><p>这还是一道阅读理解题 = =.</p><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><ol><li>基础数论</li><li>拓展中国剩余定理</li></ol><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>记对第 $i$ 个巨龙使用剑的攻击力为 $A_i$.</p><p>容易发现, $A_i$ 的值其实很好确定, 直接在 <code>multiset</code> 上二分即可. 那么, 现在的问题为</p><p>给定 $a_i,\ A_i,\ p_i$, 有</p><p>$$<br>\begin{equation}<br>\left \{<br>    \begin{array}{ccc} a_1 - A_1 x &amp;\equiv &amp; 0 \pmod {p_1} \\ a_2 - A_2 x &amp;\equiv &amp; 0 \pmod {p_2} \\ &amp;\vdots&amp; \\ a_n - A_n x &amp;\equiv &amp; 0 \pmod {p_n} \end{array}<br>\right.<br>\end{equation}<br>$$</p><p>求满足条件的最小 $x$, 其中 $p_i$ 不一定为互质.</p><p>其实这只是一个 Ex CRT, 把式子稍微转换一下, 得</p><p>$$x \equiv a_i \cdot A_i^{-1} \pmod {p_i}$$</p><p>这就和模板题完全一样了, 注意到 $p_i$ 并不是质数, 求乘法逆元的时候跑 exgcd 就好了. 另外会出现无解的情况, 在下文会细谈.</p><p>现在问题已经解决了大半, 但是有一些特判不能忽略.</p><p>首先考虑无解. 一番分析之后可以发现, 无解有两种情况:</p><ul><li><p>化简同余式时无解</p><p>考虑化简的过程, 我们把 $A_i x \equiv a_i \pmod {p_i}$ 化成不定方程的形式, 即</p><p>$$A_i x + y p_i = a_i$$</p><p>根据裴蜀定理, 该方程有解需要满足 $\gcd(A_i,\ p_i) \mid a_i$, 否则无解.</p><p>虽然无解的情况已经解决了, 不妨顺水推舟, 把化简的过程写完.</p><p>记 $g = \gcd(A_i,\ p_i)$, 于是两边同除 $g$, 有</p><p>$$\frac{A_i}{g} x + \frac{p_i}{g} y = \frac{a_i}{g}$$</p><p>记 $A_i^{-1}$ 为模 $p_i$ 意义下的逆元, 整理, 得</p><p>$$x \equiv \frac{a_i}{g}\cdot A_i^{-1}\pmod{ \frac{p_i}{g} }$$</p></li><li><p>合并同余式时无解</p><p>考虑两同余式转换为不定方程后相减, 和上一情况同理.</p></li></ul><p>其次考虑题目的特殊性质.</p><p>特性 2 没什么好说的, 和文末提示 “你所用到的中间结果可能很大，注意保存中间结果的变量类型” 一样, 要注意每个同余方程模数的数量级都在 $10^{12}$, 建议使用 <code>long long</code> 以及龟速乘.</p><p>考虑特性 1 的反例, 也就是 $a_i &gt; p_i$, 会对以上的过程产生什么影响.</p><p>如果存在一个 $x$, 满足 $A_i x = a_i - p_i$, 依然满足 $A_i x \equiv a_i \pmod {p_i}$, 但显然不满足题意 = =</p><p>幸运的是, 不满足特性 1 的数据点另外满足 $p_i = 1$, 此时答案就是</p><p>$$\max _{i = 1} ^n \{\ \lceil \dfrac{a_i}{A_i} \rceil\ \}$$</p><p><del>放到题目背景里就是一直砍, 一直砍</del></p><p>那么这道题就做完了 = =.</p><p>比较良心的是, 大样例 (from loj) 存在部分数据满足这几个特殊性质.</p><p>作为 Day2 T1 (应该? ) 算是送温暖吧, 但对于我这种背板选手一发 15 pts 还是算了 = =.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P4774</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multiset</span>&lt;LL&gt;::iterator IT;</span><br><span class="line"><span class="comment">// 准备迎接 CCF 的省选了 = =</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">smul</span><span class="params">(LL base, LL b, LL m)</span> </span>&#123;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = (ret + base) % m;</span><br><span class="line">        base = (base + base) % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(LL a, LL b, LL&amp; d, LL&amp; x, LL&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) d = a, x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> exgcd(b, a % b, d, y, x), y -= a / b * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">multiset</span>&lt;LL&gt; S;</span><br><span class="line">LL A[MAXN], a[MAXN], p[MAXN], w[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pre done</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">static</span> LL x, d, y;</span><br><span class="line">        exgcd(A[i], p[i], d, x, y);</span><br><span class="line">        <span class="keyword">if</span> (a[i] % d != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        p[i] /= d;</span><br><span class="line">        A[i] = smul(a[i] / d, (x % p[i] + p[i]) % p[i], p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// extra CRT</span></span><br><span class="line">    LL ret = A[<span class="number">1</span>], M = p[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">static</span> LL x, y, c, d, mod;</span><br><span class="line">        c = ((A[i] - ret) % p[i] + p[i]) % p[i];</span><br><span class="line">        exgcd(M, p[i], d, x, y);</span><br><span class="line">        <span class="keyword">if</span> (c % d != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        mod = p[i] / d, x = smul(x, c / d, mod);</span><br><span class="line">        ret += x * M, M *= mod, ret = (ret % M + M) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">p1solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ret = max(ret, (a[i] + A[i] - <span class="number">1</span>) / A[i]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> Ti; read(Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        S.clear();</span><br><span class="line">        <span class="keyword">bool</span> p1 = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        read(n), read(m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(p[i]), p1 &amp;= p[i] == <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(w[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x, i = <span class="number">1</span>; i &lt;= m; ++i) read(x), S.insert(x);</span><br><span class="line">        <span class="comment">// pre done</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            IT ite = (a[i] &lt; *S.begin())? S.begin(): (--S.upper_bound(a[i]));</span><br><span class="line">            A[i] = *ite;</span><br><span class="line">            S.erase(ite), S.insert(w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// output</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, p1? p1solve(): solve());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;NOI 又不怎么考数论题.&lt;/p&gt;
&lt;p&gt;from 某神仙&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://www.luogu.com.cn/problem/P4774&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.com.cn/problem/P4774&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;del&gt;最近好颓啊 = =, 写题又不想自己写, 学东西又不能静下来好好学&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;这是一道拓展中国剩余定理的模板题, 由此发现之前学的 Ex CRT 很假, 所以来整理一下.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Number Theory" scheme="https://depletedprism.github.io/tags/Number-Theory/"/>
    
  </entry>
  
  <entry>
    <title>「UVa-10572」Black &amp; White 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/UVA-10572/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/UVA-10572/</id>
    <published>2020-02-24T12:27:59.000Z</published>
    <updated>2020-03-13T05:41:27.411Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>最后一步判断最为关键, 也最容易想错… 请读者思考如何区分这两种情况.</p></blockquote><ul><li>题目链接: <a href="https://vjudge.net/problem/UVA-10572" target="_blank" rel="noopener">https://vjudge.net/problem/UVA-10572</a></li></ul><p><em>由于某些原因, 链接指向的其实是 vjudge</em></p><p><del>毒瘤啊!</del></p><p>其实是常规的插头 DP 维护棋盘格连通性的问题, 第一次见感觉很新鲜, 然后… 就自闭了. = =</p><a id="more"></a><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给定一个部分黑白染色的 $n \times m$ 棋盘, 现在给出两种限制</p><ol><li>任意 $2 \times 2$ 的网格不会全黑或者全白.</li><li><strong>所有黑格四连通, 所有白格四连通</strong>.</li></ol><p>现在要把所有的棋盘染色, 求满足以上限制的方案数.</p><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>容易发现这是一道插头 DP / 轮廓线 DP, 我们依次考虑两种限制.</p><p>对于题目给定的颜色, 容易发现这个限制很好处理, 只不过是在已染色位置按照给定颜色转移.</p><p>对于第一种限制, 容易发现只用记录 “当前转移位置” 的左上棋盘的颜色即可. 这样转移的时候, 抛弃掉引起冲突的颜色就好了.</p><p>对于第二种限制, 则需要考虑每个点的连通情况. 考虑在轮廓线步步推进的过程中, 刚开始不连通的区域可能在某处得到连通, 所以在转移当前状态时, 显然不能在要求当前轮廓线一直保持两种颜色四连通的状态.</p><p><del>一开始没看到第二种限制, 整个人傻掉了</del></p><p>那怎么办呢? 考虑加一些状态, 记录当前轮廓线上每个位置所属的连通分量编号. 暂且不考虑如何记录这个编号, 先来考虑记录之后如何转移, 以及正确性.</p><p>沿用普通的插头 DP 思路, 对于当前状态, 枚举当前位置要放置的颜色, 排除掉已有颜色, 以及 $2 \times 2$ 方格的限制. 新加入棋盘格的连通分量编号呢? 有两种情况:</p><ol><li><p>当前棋盘格颜色和左侧 / 上方棋盘格颜色相同</p><p>此种情况可以通过对连通分量编号进行简单合并解决.</p></li><li><p>当前棋盘格颜色和<strong>上方</strong>棋盘格颜色<strong>不同</strong></p><p>重点考虑这个情况. 为什么要重点分析? 因为当前棋盘格位置上方的棋盘格即将离开轮廓线, 以后就考虑不到了, 但是题目要求颜色各自是四连通的. 如果直接把她抛弃, 那么就… 人没了. = =</p><p>经过思考可以得出, 在轮廓线上还存在上方棋盘格所对应的连通分量就不需要额外考虑这一点了, 即, 可以直接把这个状态扔掉.</p><p>此时我们在状态中记录黑白两色连通分量个数, 并引入 “钦定选择颜色”. 这样, 转移如下:</p><ul><li><p>如果上方棋盘格颜色所属的连通分量个数 $&gt; 1$, 说明以后没有机会再把这些连通分量连接起来了, 放弃吧</p></li><li><p>如果上方棋盘格颜色所属的连通分量满足题目限制, 那么把剩下的所有格子涂满, 涂成当前棋盘格颜色就好了.</p><p>注意到这样做的条件为, 剩下未填满的行数小于 $2$, 否则直接填满无法满足限制 1.</p></li></ul></li></ol><p>现在再来考虑如何记录连通分量的编号. 常用的方法有: 最小表示法, 以及广义括号法. 这里只考虑最小表示法, 虽然另一种方法更快一点…</p><p>所谓 “最小表示法”, 就是用字典序最小的方法把所有连通分量重标号, 然后没了. 注意每次都要把状态这样整理一下.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>参考了刘汝佳先生的实现…</p><p>毕竟很少有那样清晰的代码和完整的注释了. = =</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UVA-10572</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ch[] = &#123; <span class="string">'o'</span>, <span class="string">'#'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, exist;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">unsigned</span>, <span class="keyword">int</span>&gt; f[MAXN][MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> G[MAXN][MAXN+<span class="number">1</span>], Ans[MAXN][MAXN], Now[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> c[MAXN], g[MAXN], cnt[<span class="number">2</span>], UL, tot;</span><br><span class="line"></span><br><span class="line">    State() &#123; <span class="built_in">memset</span>(<span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">sizeof</span> *<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最小表示法</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Normalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> rep[MAXN + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(rep, <span class="number">-1</span>, <span class="keyword">sizeof</span> rep);</span><br><span class="line">        tot = cnt[<span class="number">0</span>] = cnt[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rep[g[i]] &lt; <span class="number">0</span>) rep[g[i]] = tot++, ++cnt[c[i]];</span><br><span class="line">            g[i] = rep[g[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并: 把 from 对应的连通分量编号改为 to</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> to, <span class="keyword">int</span> from)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (from == to) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) <span class="keyword">if</span> (g[i] == from) g[i] = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码: 最大值 + 1 = 16 ^ m = 2 ^ (4 * 8) = 2 ^ 32, 正好 unsigned int</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="title">encode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) ret = ret * <span class="number">16</span> + c[i] * <span class="number">8</span> + g[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, State&amp; S, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (col == m) ++row, col = <span class="number">0</span>;</span><br><span class="line">    S.Normalize();</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.cnt[<span class="number">0</span>] &gt; <span class="number">1</span> || S.cnt[<span class="number">1</span>] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录方案</span></span><br><span class="line">        <span class="keyword">if</span> (!exist) &#123;</span><br><span class="line">            exist = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) Ans[i][j] = Now[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一个剪枝: 如果左边颜色和上方颜色不同, 那么左上角的颜色就不重要了</span></span><br><span class="line">    <span class="keyword">if</span> (row &gt; <span class="number">0</span> &amp;&amp; col &gt; <span class="number">0</span> &amp;&amp; S.c[col] != S.c[col<span class="number">-1</span>]) S.UL = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> key;</span><br><span class="line">    <span class="comment">// 只在不钦定颜色的情况下记忆化</span></span><br><span class="line">    <span class="keyword">if</span> (limit &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        key = S.encode();</span><br><span class="line">        <span class="keyword">if</span> (f[row][col][S.UL].count(key) &gt; <span class="number">0</span>) <span class="keyword">return</span> f[row][col][S.UL][key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">2</span>; ++t) &#123;</span><br><span class="line">        <span class="comment">// 钦定颜色 / 限制 0</span></span><br><span class="line">        <span class="keyword">if</span> (limit == (t ^ <span class="number">1</span>) || G[row][col] == ch[t ^ <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 限制 1</span></span><br><span class="line">        <span class="keyword">if</span> (row &gt; <span class="number">0</span> &amp;&amp; col &gt; <span class="number">0</span> &amp;&amp; S.UL == t &amp;&amp; S.c[col] == t &amp;&amp; S.c[col<span class="number">-1</span>] == t) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 新的状态 !</span></span><br><span class="line">        State T = S;</span><br><span class="line">        T.c[col] = t, T.UL = S.c[col];</span><br><span class="line">        <span class="comment">// 通过考虑左侧和上方状态, 来合并一些连通分量</span></span><br><span class="line">        T.g[col] = (row &gt; <span class="number">0</span> &amp;&amp; S.c[col] == t)? S.g[col]: S.tot;</span><br><span class="line">        <span class="keyword">if</span> (col &gt; <span class="number">0</span> &amp;&amp; T.c[col<span class="number">-1</span>] == t) T.merge(T.g[col<span class="number">-1</span>], T.g[col]);</span><br><span class="line">        Now[row][col] = ch[t];</span><br><span class="line">        <span class="keyword">if</span> (row &gt; <span class="number">0</span> &amp;&amp; S.c[col] == (t ^ <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">bool</span> none = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; none; ++i)</span><br><span class="line">                <span class="keyword">if</span> (T.g[i] == S.g[col]) none = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (none) &#123;</span><br><span class="line">                <span class="comment">// 注意跳转逻辑: 这些条件满足 / 不满足, 直接向下一颜色进行</span></span><br><span class="line">                <span class="keyword">if</span> (S.cnt[t ^ <span class="number">1</span>] &gt; <span class="number">1</span> || n - row &gt; <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                ret += dfs(row, col + <span class="number">1</span>, T, t);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ret += dfs(row, col + <span class="number">1</span>, T, limit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (limit &lt; <span class="number">0</span>) f[row][col][S.UL][key] = ret;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> Ti;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        exist = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; ++k) f[i][j][k].clear();</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, G[i]);</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        State none; none.Normalize();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dfs(<span class="number">0</span>, <span class="number">0</span>, none, <span class="number">-1</span>));</span><br><span class="line">        <span class="comment">// output</span></span><br><span class="line">        <span class="keyword">if</span> (exist) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i, <span class="built_in">putchar</span>(<span class="string">'\n'</span>))</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) <span class="built_in">putchar</span>(Ans[i][j]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>在 陈丹琦 &lt;基于连通性状态压缩的动态规划问题&gt; 对这一类问题有相当详尽的讲解, 头疼看不懂, 以后再说了 <del>咕咕咕</del></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;最后一步判断最为关键, 也最容易想错… 请读者思考如何区分这两种情况.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://vjudge.net/problem/UVA-10572&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://vjudge.net/problem/UVA-10572&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;由于某些原因, 链接指向的其实是 vjudge&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;毒瘤啊!&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;其实是常规的插头 DP 维护棋盘格连通性的问题, 第一次见感觉很新鲜, 然后… 就自闭了. = =&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Dynamic Programing" scheme="https://depletedprism.github.io/tags/Dynamic-Programing/"/>
    
  </entry>
  
  <entry>
    <title>「JSOI2018」战争 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/luogu-P4557/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/luogu-P4557/</id>
    <published>2020-02-20T04:51:21.000Z</published>
    <updated>2020-02-20T06:00:09.784Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P4557" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P4557</a></li></ul><p>这是一道 <del>九条可怜</del> 计算几何题, 在思路上不算困难但是有一些细节值得留念.</p><a id="more"></a><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><ol><li>二维凸包</li><li>闵可夫斯基和</li></ol><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给定两个大小分别为 $n,\ m$ 的点集, $q$ 次询问, 每次给出一个偏移向量 $\vec{v}$, 问将第二个点集的所有点按这个向量偏移后, 是否存在一个点, 在另一点集的凸包内.</p><p>其中 $3 \le n, m \le 10^5,\ q \le 10^5$</p><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>考虑最简单的思路, 每次直接将第二个点集暴力平移, 求凸包, 判断是否存在一个点在另一个凸包内.</p><p>时间复杂度 $O(n \log n + q (m \log m + n m)\,)$, 期望得分 40 pts.</p><p>如果再加一些技巧, 大概是 $O(n \log n + m\log m + q(n\log m + m\log n))\,)$, 期望得分 40 pts, 并没有本质区别…</p><p>换一种思路, 考虑造成冲突的向量范围, 容易得到这样的式子</p><p>$$\exists \ \vec{v},\ \text{s.t.}\ b + \vec{v} = a\ (a \in A, b \in B)$$</p><p>那么就可以得到 $\vec{v}$ 的范围</p><p>$$\vec{v} = a - b\ (a \in A, b \in B)$$</p><p>把 $B$ 中点的横纵坐标取反, 就得到了闵可夫斯基和的形式.</p><p>考虑到两个凸包的闵可夫斯基和中的边都由两个凸包中的边构成, 而凸包上的边具有单调性, 直接以类似于合并两个有序表的方式进行合并就好了, 这样合并出来的闵可夫斯基和也是个凸包.</p><p>如何统计答案呢? 直接判断偏移向量是否在闵可夫斯基和中的时间复杂度是 $O(n)$ 的, 可以拿到 70 pts 的好成绩.<br>考虑把一个凸包转化为一点到其他点的向量的形式, 这样判断一个向量是否在凸包内可以根据凸包的单调性, 通过二分查找解决.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>如果细节明确了, 其实代码不难写…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P4557</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Geo &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line">        LL x, y;</span><br><span class="line">        Vector(LL _x = <span class="number">0</span>, LL _y = <span class="number">0</span>): x(_x), y(_y) &#123; &#125;</span><br><span class="line"></span><br><span class="line">        Vector <span class="keyword">operator</span> + (<span class="keyword">const</span> Vector&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Vector(x + rhs.x, y + rhs.y); &#125;</span><br><span class="line">        Vector <span class="keyword">operator</span> - (<span class="keyword">const</span> Vector&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Vector(x - rhs.x, y - rhs.y); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">typedef</span> Vector Point;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point&amp; A, <span class="keyword">const</span> Point&amp; B) &#123;</span><br><span class="line">        <span class="keyword">return</span> A.x &lt; B.x || (A.x == B.x &amp;&amp; A.y &lt; B.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>== (<span class="keyword">const</span> Point&amp; A, <span class="keyword">const</span> Point&amp; B) &#123; <span class="keyword">return</span> !(A &lt; B) &amp;&amp; !(B &lt; A); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">Dot</span><span class="params">(<span class="keyword">const</span> Vector&amp; A, <span class="keyword">const</span> Vector&amp; B)</span> </span>&#123; <span class="keyword">return</span> A.x * B.x + A.y * B.y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">Cross</span><span class="params">(<span class="keyword">const</span> Vector&amp; A, <span class="keyword">const</span> Vector&amp; B)</span> </span>&#123; <span class="keyword">return</span> A.x * B.y - A.y * B.x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ConvexHull</span><span class="params">(Point* P, <span class="keyword">int</span> n, Point* ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        sort(P, P+n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (m &gt; <span class="number">1</span> &amp;&amp; Cross(ch[m<span class="number">-1</span>] - ch[m<span class="number">-2</span>], P[i] - ch[m<span class="number">-2</span>]) &lt;= <span class="number">0</span>) --m;</span><br><span class="line">            ch[m++] = P[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (m &gt; k &amp;&amp; Cross(ch[m<span class="number">-1</span>] - ch[m<span class="number">-2</span>], P[i] - ch[m<span class="number">-2</span>]) &lt;= <span class="number">0</span>) --m;</span><br><span class="line">            ch[m++] = P[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m - (n &gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Geo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, pidx, K;</span><br><span class="line">Point poly[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">Vector v1[MAXN], v2[MAXN];</span><br><span class="line">Point P1[MAXN], P2[MAXN], ch1[MAXN], ch2[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通俗地说, 凸包上的边, 在右侧的边总是在左侧的边的 "左侧"</span></span><br><span class="line"><span class="comment">// 还要考虑向量的模长, 可能太长就冲出去了...</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Point&amp; A, <span class="keyword">const</span> Point&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Cross(A, B) &gt; <span class="number">0</span> || (Cross(A, B) == <span class="number">0</span> &amp;&amp; Dot(A, A) &lt; Dot(B, B));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">inPoly</span><span class="params">(<span class="keyword">const</span> Vector&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Cross(v, poly[<span class="number">0</span>]) &gt; <span class="number">0</span> || Cross(v, poly[pidx<span class="number">-1</span>]) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = lower_bound(poly, poly+pidx, v, cmp) - poly - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Cross(v - poly[pos], poly[(pos+<span class="number">1</span>)%pidx] - poly[pos]) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="comment">// freopen("input.in", "r", stdin);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m), read(K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x, y, i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        read(x), read(y), P1[i] = Point(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x, y, i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        read(x), read(y), P2[i] = Point(-x, -y);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    n = ConvexHull(P1, n, ch1);</span><br><span class="line">    m = ConvexHull(P2, m, ch2);</span><br><span class="line">    <span class="comment">// 将凸包的点集转化为边集, 以向量的形式体现</span></span><br><span class="line">    ch1[n] = ch1[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) v1[i] = ch1[i+<span class="number">1</span>] - ch1[i];</span><br><span class="line">    ch2[m] = ch2[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) v2[i] = ch2[i+<span class="number">1</span>] - ch2[i];</span><br><span class="line">    <span class="comment">// Minkowski Sum</span></span><br><span class="line">    <span class="comment">// 合并两个凸包, 由于凸包单调性, 类似于合并两个有序表</span></span><br><span class="line">    poly[pidx++] = ch1[<span class="number">0</span>] + ch2[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; n &amp;&amp; q &lt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Cross(v1[p], v2[q]) &gt;= <span class="number">0</span>)</span><br><span class="line">            poly[pidx] = poly[pidx<span class="number">-1</span>] + v1[p++], ++pidx;</span><br><span class="line">        <span class="keyword">else</span> poly[pidx] = poly[pidx<span class="number">-1</span>] + v2[q++], ++pidx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; n) poly[pidx] = poly[pidx<span class="number">-1</span>] + v1[p++], ++pidx;</span><br><span class="line">    <span class="keyword">while</span> (q &lt; m) poly[pidx] = poly[pidx<span class="number">-1</span>] + v2[q++], ++pidx;</span><br><span class="line">    <span class="keyword">while</span> (pidx &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">        Cross(poly[pidx<span class="number">-1</span>] - poly[pidx<span class="number">-2</span>], poly[<span class="number">0</span>] - poly[pidx<span class="number">-2</span>]) &lt;= <span class="number">0</span>) --pidx;</span><br><span class="line">    <span class="comment">// 将闵可夫斯基和的点集转化为由一点指向其他点的向量</span></span><br><span class="line">    Point o = poly[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pidx; ++i) poly[i] = poly[i] - o;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (K--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x, y;</span><br><span class="line">        read(x), read(y), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, inPoly(Vector(x, y) - o));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://www.luogu.com.cn/problem/P4557&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.com.cn/problem/P4557&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是一道 &lt;del&gt;九条可怜&lt;/del&gt; 计算几何题, 在思路上不算困难但是有一些细节值得留念.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Geometry" scheme="https://depletedprism.github.io/tags/Geometry/"/>
    
  </entry>
  
  <entry>
    <title>一些简单的偏序维护问题</title>
    <link href="https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/simple-partial-order/"/>
    <id>https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/simple-partial-order/</id>
    <published>2020-02-14T15:15:28.000Z</published>
    <updated>2020-02-27T14:58:56.925Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>拜读了毒瘤的数据结构课件, 深受启发, <del>甚是谔谔, 当即感觉自己之前一直在玩泥巴</del>.</p><p>初学数据结构, 恳请指正.</p><a id="more"></a><h3 id="什么是偏序"><a href="#什么是偏序" class="headerlink" title="什么是偏序"></a>什么是偏序</h3><p><em>其实这一点也不重要</em></p><p>对于一个非空集上的二元关系, 如果其满足<strong>自反性</strong>, <strong>反对称性</strong>, <strong>传递性</strong>, 那么称这个二元关系就是这个集合上的偏序.</p><p>一个简单的例子: 实数集上的小于等于关系是一个偏序关系.</p><h3 id="偏序维护"><a href="#偏序维护" class="headerlink" title="偏序维护"></a>偏序维护</h3><p>现在我们有一个具有很多属性的元素, 比如有 $a_i, b_i, c_i, \ldots$</p><p>接下来对每个属性给出一些限制, 对满足这些限制的元素进行一些操作, 像 $L_1 \leq a_i \leq R_1, L_2 \leq b_i \leq R_2, L_3 \leq c_i \leq R_3, \ldots$</p><p>这就是在维护偏序了, 有时候也把 “属性” 称作 “维度”.</p><h2 id="一些维护方法-amp-例题"><a href="#一些维护方法-amp-例题" class="headerlink" title="一些维护方法 &amp; 例题"></a>一些维护方法 &amp; 例题</h2><blockquote><p>反正我之前是先推出一个 poly log 的数据结构做法</p><p>然后想办法去 log，到一个可以接受的复杂度</p><p>from lxl 某次洛谷网课</p></blockquote><p>先是两个离线方法.</p><h3 id="CDQ-分治"><a href="#CDQ-分治" class="headerlink" title="CDQ 分治"></a>CDQ 分治</h3><p>强烈推荐 <a href="https://www.cnblogs.com/mlystdcall/p/6219421.html" target="_blank" rel="noopener">__stdcall 的 CDQ 分治教程</a>.</p><p>简单来说, CDQ 分治做了这样一件事情: 把操作离线下来, 分成两部分, 递归解决; 考虑把这两部分合并, 就要考虑左半部分操作对右半部分的影响, 然后合并.</p><h4 id="Luogu-P3810【模板】三维偏序"><a href="#Luogu-P3810【模板】三维偏序" class="headerlink" title="Luogu P3810【模板】三维偏序"></a>Luogu P3810【模板】三维偏序</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P3810" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3810</a></li></ul><p>是一道经典题, 考虑 CDQ 分治, 先将第一维排序, CDQ 分治过程中按第二维排序, 使用树状数组统计第三维答案.</p><p>有一个细节: 可能存在相同元素, 按题意来讲这些完全相同的元素互相有贡献, 但是在 CDQ 分治的过程中只能统计左半部分对右半部分的贡献, 所以需要去重, 对重复不同次数的元素给定一个不同的权值.</p><p>时间复杂度: $O (n\log n \log k)$</p><p><strong>代码实现</strong></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3810</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">5</span>, MAXM = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> idx, a, b, c, w;</span><br><span class="line">    Item(<span class="keyword">int</span> _i = <span class="number">0</span>, <span class="keyword">int</span> _a = <span class="number">0</span>, <span class="keyword">int</span> _b = <span class="number">0</span>, <span class="keyword">int</span> _c = <span class="number">0</span>, <span class="keyword">int</span> _w = <span class="number">0</span>):</span><br><span class="line">        idx(_i), a(_a), b(_b), c(_c), w(_w) &#123; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (a == rhs.a)? ((b == rhs.b)? c &lt; rhs.c: b &lt; rhs.b): a &lt; rhs.a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>== (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; rhs) &amp;&amp; !(rhs &lt; *<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; A[MAXN], tmp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, nA, K;</span><br><span class="line"><span class="keyword">int</span> Ans[MAXN], f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">    <span class="keyword">int</span> C[MAXM];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; pos, <span class="keyword">const</span> <span class="keyword">int</span>&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= K; i += lowbit(i)) C[i] += d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i; i -= lowbit(i)) ret += C[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, p = L, q = Mid+<span class="number">1</span>;</span><br><span class="line">    CDQ(L, Mid), CDQ(Mid+<span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">        <span class="comment">// 在右半部分排满时移动左半部分</span></span><br><span class="line">        <span class="keyword">if</span> ((p &lt;= Mid &amp;&amp; A[p].b &lt;= A[q].b) || q &gt; R)</span><br><span class="line">            BIT::Mdy(A[p].c, A[p].w), tmp[i] = A[p++];</span><br><span class="line">        <span class="keyword">else</span> Ans[A[q].idx] += BIT::Qry(A[q].c), tmp[i] = A[q++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空树状数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= Mid; ++i) BIT::Mdy(A[i].c, -A[i].w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) A[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a, b, c, i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        read(a), read(b), read(c), A[i] = Item(i, a, b, c, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    sort(A+<span class="number">1</span>, A+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; A[i] == A[j+<span class="number">1</span>]) ++j;</span><br><span class="line">        A[++nA] = A[i], A[nA].w = j - i + <span class="number">1</span>;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    CDQ(<span class="number">1</span>, nA);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nA; ++i) f[Ans[A[i].idx] + A[i].w] += A[i].w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h4 id="Luogu-P3374【模板】树状数组-1"><a href="#Luogu-P3374【模板】树状数组-1" class="headerlink" title="Luogu P3374【模板】树状数组 1"></a>Luogu P3374【模板】树状数组 1</h4><blockquote><p>CDQ 分治可以顶替复杂的高级数据结构.</p></blockquote><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P3374" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3374</a></li></ul><p>我们可以把初始值看作在 $0$ 的基础上单点修改, 把查询看作两次询问前缀和, 这样每个操作有时间, 对应操作位置, 权值三个属性.</p><p>时间这一维按给定顺序有序, CDQ 分治过程中按操作位置维护权值和即可, 注意在操作位置相同时, 按照先修改后查询的顺序统计.</p><p><strong>代码实现</strong></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3374</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc(); </span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> opt, pos; LL val;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Ask&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pos &lt; rhs.pos || (pos == rhs.pos &amp;&amp; opt &lt; rhs.opt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Q[MAXN * <span class="number">3</span>], tmp[MAXN * <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, qidx, aidx;</span><br><span class="line">LL A[MAXN], Ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    CDQ(L, Mid), CDQ(Mid+<span class="number">1</span>, R);</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p = L, q = Mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((p &lt;= Mid &amp;&amp; Q[p] &lt; Q[q]) || q &gt; R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Q[p].opt == <span class="number">1</span>) sum += Q[p].val;</span><br><span class="line">        tmp[i] = Q[p++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Q[q].opt == <span class="number">2</span>) Ans[Q[q].val] -= sum;</span><br><span class="line">        <span class="keyword">if</span> (Q[q].opt == <span class="number">3</span>) Ans[Q[q].val] += sum;</span><br><span class="line">        tmp[i] = Q[q++];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) Q[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        read(A[i]);</span><br><span class="line">        Q[++qidx] = (Ask)&#123; <span class="number">1</span>, i, A[i] &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt, L, R; LL val;</span><br><span class="line">        read(opt); read(L);</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                read(val);</span><br><span class="line">                Q[++qidx] = (Ask)&#123; opt, L, val &#125;;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                read(R);</span><br><span class="line">                Q[++qidx] = (Ask)&#123; opt, L<span class="number">-1</span>, ++aidx &#125;;</span><br><span class="line">                Q[++qidx] = (Ask)&#123; opt+<span class="number">1</span>, R, aidx &#125;;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="built_in">puts</span>(<span class="string">"ERROR"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CDQ(<span class="number">1</span>, qidx);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= aidx; ++i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h4 id="HDU-5126-stars"><a href="#HDU-5126-stars" class="headerlink" title="HDU 5126 stars"></a>HDU 5126 stars</h4><ul><li>题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5126" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=5126</a></li></ul><p>对于四维的情况, CDQ 分治可以嵌套使用. <del>但是 CDQ 套 CDQ 套 CDQ… 就和树套树套树… 一样没用, 不如直接写 bitset</del></p><p>这是一个三维数点问题, 因为要考虑操作时间的影响就是四维偏序了, 在此我使用 CDQ 套 CDQ 解决.</p><p>还是参考 <a href="https://www.cnblogs.com/mlystdcall/p/6232324.html" target="_blank" rel="noopener">__stdcall 的 CDQ 套 CDQ 教程</a>, 把第二维按左右两部分重标号, 依此为根据统计答案.</p><p>空间内数点可仿照平面内数点的思路, 统计前缀和按坐标点容斥计算就好了.</p><p>时间复杂度大概是 $O(n \log ^3 n)$</p><p><strong>代码实现</strong></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HDU 5126</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> opt, idx, x, y, z, part;</span><br><span class="line">&#125; Q[MAXN], tmp2d[MAXN], tmp3d[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, qidx, aidx;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN &lt;&lt; <span class="number">1</span>], nB;</span><br><span class="line"><span class="keyword">int</span> Ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">    <span class="keyword">int</span> C[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; pos, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= nB; i += lowbit(i)) C[i] += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i; i -= lowbit(i)) ret += C[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ3d</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, p = L, q = Mid+<span class="number">1</span>;</span><br><span class="line">    CDQ3d(L, Mid), CDQ3d(Mid+<span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p &lt;= Mid &amp;&amp; tmp2d[p].y &lt;= tmp2d[q].y) || q &gt; R) &#123;</span><br><span class="line">            <span class="comment">// 只考虑两次归并都排布在左半部分的元素的贡献</span></span><br><span class="line">            <span class="keyword">if</span> (tmp2d[p].opt == <span class="number">0</span> &amp;&amp; tmp2d[p].part == <span class="number">0</span>)</span><br><span class="line">                BIT::Mdy(tmp2d[p].z, <span class="number">1</span>);</span><br><span class="line">            tmp3d[i] = tmp2d[p++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 只统计两次归并都排布在右半部分的元素的答案</span></span><br><span class="line">            <span class="keyword">if</span> (tmp2d[q].opt != <span class="number">0</span> &amp;&amp; tmp2d[q].part == <span class="number">1</span>)</span><br><span class="line">                Ans[tmp2d[q].idx] += tmp2d[q].opt * BIT::Qry(tmp2d[q].z);</span><br><span class="line">            tmp3d[i] = tmp2d[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= Mid; ++i)</span><br><span class="line">        <span class="keyword">if</span> (tmp2d[i].opt == <span class="number">0</span> &amp;&amp; tmp2d[i].part == <span class="number">0</span>)</span><br><span class="line">            BIT::Mdy(tmp2d[i].z, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) tmp2d[i] = tmp3d[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ2d</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, p = L, q = Mid+<span class="number">1</span>;</span><br><span class="line">    CDQ2d(L, Mid), CDQ2d(Mid+<span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">        <span class="comment">// 重标号: 左半部分标为 0, 右半部分标为 1</span></span><br><span class="line">        <span class="keyword">if</span> ((p &lt;= Mid &amp;&amp; Q[p].x &lt;= Q[q].x) || q &gt; R) &#123;</span><br><span class="line">            Q[p].part = <span class="number">0</span>;</span><br><span class="line">            tmp2d[i] = Q[p++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Q[q].part = <span class="number">1</span>;</span><br><span class="line">            tmp2d[i] = Q[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) Q[i] = tmp2d[i];</span><br><span class="line">    CDQ3d(L, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> Ti; read(Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        qidx = nB = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        read(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> opt, x1, y1, z1, x2, y2, z2;</span><br><span class="line">            read(opt), read(x1), read(y1), read(z1);</span><br><span class="line">            <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    Q[++qidx] = (Ask)&#123; <span class="number">0</span>, i, x1, y1, z1, <span class="number">0</span> &#125;;</span><br><span class="line">                    Ans[i] = <span class="number">-1</span>, B[++nB] = z1;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    read(x2), read(y2), read(z2);</span><br><span class="line">                    --x1, --y1, --z1;</span><br><span class="line">                    <span class="comment">// 容斥</span></span><br><span class="line">                    Q[++qidx] = (Ask)&#123; <span class="number">1</span>, i, x2, y2, z2, <span class="number">0</span> &#125;;</span><br><span class="line">                    Q[++qidx] = (Ask)&#123;<span class="number">-1</span>, i, x1, y1, z1, <span class="number">0</span> &#125;;</span><br><span class="line">                    Q[++qidx] = (Ask)&#123;<span class="number">-1</span>, i, x1, y2, z2, <span class="number">0</span> &#125;;</span><br><span class="line">                    Q[++qidx] = (Ask)&#123;<span class="number">-1</span>, i, x2, y1, z2, <span class="number">0</span> &#125;;</span><br><span class="line">                    Q[++qidx] = (Ask)&#123;<span class="number">-1</span>, i, x2, y2, z1, <span class="number">0</span> &#125;;</span><br><span class="line">                    Q[++qidx] = (Ask)&#123; <span class="number">1</span>, i, x2, y1, z1, <span class="number">0</span> &#125;;</span><br><span class="line">                    Q[++qidx] = (Ask)&#123; <span class="number">1</span>, i, x1, y2, z1, <span class="number">0</span> &#125;;</span><br><span class="line">                    Q[++qidx] = (Ask)&#123; <span class="number">1</span>, i, x1, y1, z2, <span class="number">0</span> &#125;;</span><br><span class="line">                    Ans[i] = <span class="number">0</span>, B[++nB] = z1, B[++nB] = z2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERR\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// solve</span></span><br><span class="line">        sort(B+<span class="number">1</span>, B+<span class="number">1</span>+nB);</span><br><span class="line">        nB = unique(B+<span class="number">1</span>, B+<span class="number">1</span>+nB) - B - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 这一维要丢到 BIT 里, 于是离散化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qidx; ++i)</span><br><span class="line">            Q[i].z = lower_bound(B+<span class="number">1</span>, B+<span class="number">1</span>+nB, Q[i].z) - B;</span><br><span class="line">        CDQ2d(<span class="number">1</span>, qidx);</span><br><span class="line">        <span class="comment">// output</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (~Ans[i]) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="整体二分"><a href="#整体二分" class="headerlink" title="整体二分"></a>整体二分</h3><p>对于一个询问, 例如区间第 K 小, 有一个朴素的想法: 每次二分答案的值域, 看当前二分值是否恰好在区间的排名为 K.</p><p>这样看起来很慢, 于是可以将所有操作视为一个整体进行二分, 每次给定一个答案区间和一个操作区间, 这就是整体二分了.</p><h4 id="Luogu-P3834【模板】可持久化线段树-1（主席树）"><a href="#Luogu-P3834【模板】可持久化线段树-1（主席树）" class="headerlink" title="Luogu P3834【模板】可持久化线段树 1（主席树）"></a>Luogu P3834【模板】可持久化线段树 1（主席树）</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P3834" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3834</a></li></ul><p>可持久化线段树 $\times$ 静态区间第 k 小 $\checkmark$</p><p>算是整体二分的经典问题了. 直接使用之前说过的思路, 整体二分即可.</p><p>具体地说, 对于原序列上的数, 按当前二分的值域进行划分; 而对于操作, 则统计当前操作对应区间内数的个数, 以当前操作第 k 小为依据进行划分.</p><p><strong>代码实现</strong></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3834</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> opt, idx, L, R, k;</span><br><span class="line">&#125; Q[MAXN &lt;&lt; <span class="number">1</span>], tmpL[MAXN &lt;&lt; <span class="number">1</span>], tmpR[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, qidx;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN], nB;</span><br><span class="line"><span class="keyword">int</span> Ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">    <span class="keyword">int</span> C[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; pos, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= n; i += lowbit(i)) C[i] += val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i; i -= lowbit(i)) ret += C[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R)</span> </span>&#123; <span class="keyword">return</span> Qry(R) - Qry(L<span class="number">-1</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opL &gt; opR) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = opL; i &lt;= opR; ++i)</span><br><span class="line">            <span class="keyword">if</span> (Q[i].opt == <span class="number">1</span>) Ans[Q[i].idx] = L;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, p = <span class="number">0</span>, q = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = opL; i &lt;= opR; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Q[i].opt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Q[i].R &lt;= Mid)</span><br><span class="line">                BIT::Mdy(Q[i].L, Q[i].k), tmpL[++p] = Q[i];</span><br><span class="line">            <span class="keyword">else</span> tmpR[++q] = Q[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> w = BIT::Qry(Q[i].L, Q[i].R);</span><br><span class="line">            <span class="keyword">if</span> (Q[i].k &lt;= w) tmpL[++p] = Q[i];</span><br><span class="line">            <span class="keyword">else</span> Q[i].k -= w, tmpR[++q] = Q[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; ++i)</span><br><span class="line">        <span class="keyword">if</span> (tmpL[i].opt == <span class="number">0</span>) BIT::Mdy(tmpL[i].L, -tmpL[i].k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) Q[opL+i<span class="number">-1</span>] = tmpL[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) Q[opL+p+i<span class="number">-1</span>] = tmpR[i];</span><br><span class="line">    divide(L, Mid, opL, opL + p - <span class="number">1</span>), divide(Mid+<span class="number">1</span>, R, opL + p, opR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]), B[++nB] = A[i];</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    sort(B+<span class="number">1</span>, B+<span class="number">1</span>+nB);</span><br><span class="line">    nB = unique(B+<span class="number">1</span>, B+<span class="number">1</span>+nB) - B - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        A[i] = lower_bound(B+<span class="number">1</span>, B+<span class="number">1</span>+nB, A[i]) - B;</span><br><span class="line">        Q[++qidx] = (Ask)&#123; <span class="number">0</span>, <span class="number">-1</span>, i, A[i], <span class="number">1</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> L, R, k;</span><br><span class="line">        read(L), read(R), read(k);</span><br><span class="line">        Q[++qidx] = (Ask)&#123; <span class="number">1</span>, i, L, R, k &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    divide(<span class="number">1</span>, nB, <span class="number">1</span>, qidx);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, B[Ans[i]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h4 id="Luogu-P3242-HNOI2015-接水果"><a href="#Luogu-P3242-HNOI2015-接水果" class="headerlink" title="Luogu P3242 [HNOI2015] 接水果"></a>Luogu P3242 [HNOI2015] 接水果</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P3242" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3242</a></li></ul><p>通过对路径两端点的 dfs 序的讨论, 路径之间的相互包含可以看作是在二维矩阵中数点, 放在这道题中就是二维矩阵中查询第 k 小了.</p><p>类似的转化还有子树内距离小于等于的点, 将 DFS 序看作一维, 深度看作另一维…</p><p><del>这东西可以写可持久化树套树, 我…</del></p><p>我当然是把矩阵拆成扫描线, 然后整体二分进行统计.</p><p><strong>代码实现</strong></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3242</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">4e4</span>+<span class="number">5</span>, MAXM = <span class="number">5</span> * MAXN;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> opt, idx, u, L, R, k, val;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Ask&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> u &lt; rhs.u || (u == rhs.u &amp;&amp; opt &lt; rhs.opt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Q[MAXM], tmpL[MAXM], tmpR[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, qc, qidx;</span><br><span class="line"><span class="keyword">int</span> st[MAXN], ed[MAXN];</span><br><span class="line"><span class="keyword">int</span> Ans[MAXN], B[MAXN], nB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HLD &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Graph;</span><br><span class="line">    <span class="keyword">int</span> size[MAXN], depth[MAXN], pre[MAXN], son[MAXN];</span><br><span class="line">    <span class="keyword">int</span> topfa[MAXN], dfs_clock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">        pre[u] = fa, size[u] = <span class="number">1</span>, son[u] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) == fa) <span class="keyword">continue</span>;</span><br><span class="line">            dfs1(v, u), size[u] += size[v];</span><br><span class="line">            <span class="keyword">if</span> (son[u] == <span class="number">-1</span> || size[v] &gt; size[son[u]]) son[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">        topfa[u] = top, st[u] = ++dfs_clock;</span><br><span class="line">        <span class="keyword">if</span> (~son[u]) dfs2(son[u], top);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt)</span><br><span class="line">            <span class="keyword">if</span> ((v = edges[i].to) != pre[u] &amp;&amp; v != son[u]) dfs2(v, v);</span><br><span class="line">        ed[u] = dfs_clock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (topfa[u] != topfa[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth[topfa[u]] &lt; depth[topfa[v]]) swap(u, v);</span><br><span class="line">            u = pre[topfa[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth[u] &gt; depth[v]? v: u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findson</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (topfa[u] != topfa[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[topfa[u]] == v) <span class="keyword">return</span> topfa[u];</span><br><span class="line">            u = pre[topfa[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> son[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>)</span> </span>&#123; dfs1(root, <span class="number">0</span>), dfs2(root, root); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">    <span class="keyword">int</span> C[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; pos, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= n; i += lowbit(i)) C[i] += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        Mdy(L, val), Mdy(R+<span class="number">1</span>, -val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i; i -= lowbit(i)) ret += C[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opL &gt; opR) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = opL; i &lt;= opR; ++i)</span><br><span class="line">            <span class="keyword">if</span> (Q[i].opt == <span class="number">1</span>) Ans[Q[i].idx] = B[L];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, p = <span class="number">0</span>, q = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = opL; i &lt;= opR; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Q[i].opt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Q[i].k &lt;= Mid)</span><br><span class="line">                BIT::Mdy(Q[i].L, Q[i].R, Q[i].val), tmpL[++p] = Q[i];</span><br><span class="line">            <span class="keyword">else</span> tmpR[++q] = Q[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> w = BIT::Qry(Q[i].L);</span><br><span class="line">            <span class="keyword">if</span> (Q[i].k &lt;= w) tmpL[++p] = Q[i];</span><br><span class="line">            <span class="keyword">else</span> Q[i].k -= w, tmpR[++q] = Q[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; ++i)</span><br><span class="line">        <span class="keyword">if</span> (tmpL[i].opt == <span class="number">0</span>) BIT::Mdy(tmpL[i].L, tmpL[i].R, -tmpL[i].val);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) Q[opL + i - <span class="number">1</span>] = tmpL[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) Q[opL + p + i - <span class="number">1</span>] = tmpR[i];</span><br><span class="line">    divide(L, Mid, opL, opL + p - <span class="number">1</span>), divide(Mid+<span class="number">1</span>, R, opL + p, opR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    Graph::init();</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m), read(qc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        read(u), read(v), Graph::AddEdge(u, v), Graph::AddEdge(v, u);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    HLD::solve();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, w, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        read(u), read(v), read(w);</span><br><span class="line">        <span class="keyword">if</span> (st[u] &gt; st[v]) swap(u, v);</span><br><span class="line">        B[++nB] = w;</span><br><span class="line">        <span class="keyword">if</span> (HLD::LCA(u, v) == u) &#123;</span><br><span class="line">            <span class="keyword">int</span> z = HLD::findson(v, u);</span><br><span class="line">            <span class="keyword">if</span> (st[z] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                Q[++qidx] = (Ask)&#123; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, st[v], ed[v], w, <span class="number">1</span> &#125;;</span><br><span class="line">                Q[++qidx] = (Ask)&#123; <span class="number">0</span>, <span class="number">-1</span>, st[z], st[v], ed[v], w, <span class="number">-1</span> &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ed[z] &lt; n) &#123;</span><br><span class="line">                Q[++qidx] = (Ask)&#123; <span class="number">0</span>, <span class="number">-1</span>, st[v], ed[z]+<span class="number">1</span>, n, w, <span class="number">1</span> &#125;;</span><br><span class="line">                Q[++qidx] = (Ask)&#123; <span class="number">0</span>, <span class="number">-1</span>, ed[v]+<span class="number">1</span>, ed[z]+<span class="number">1</span>, n, w, <span class="number">-1</span> &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Q[++qidx] = (Ask)&#123; <span class="number">0</span>, <span class="number">-1</span>, st[u], st[v], ed[v], w, <span class="number">1</span> &#125;;</span><br><span class="line">            Q[++qidx] = (Ask)&#123; <span class="number">0</span>, <span class="number">-1</span>, ed[u]+<span class="number">1</span>, st[v], ed[v], w, <span class="number">-1</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(B+<span class="number">1</span>, B+<span class="number">1</span>+nB);</span><br><span class="line">    nB = unique(B+<span class="number">1</span>, B+<span class="number">1</span>+nB) - B - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qidx; ++i)</span><br><span class="line">        Q[i].k = lower_bound(B+<span class="number">1</span>, B+<span class="number">1</span>+nB, Q[i].k) - B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, k, i = <span class="number">1</span>; i &lt;= qc; ++i) &#123;</span><br><span class="line">        read(u), read(v), read(k);</span><br><span class="line">        <span class="keyword">if</span> (st[u] &gt; st[v]) swap(u, v);</span><br><span class="line">        Q[++qidx] = (Ask)&#123; <span class="number">1</span>, i, st[u], st[v], <span class="number">-1</span>, k, <span class="number">0</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(Q+<span class="number">1</span>, Q+<span class="number">1</span>+qidx);</span><br><span class="line">    divide(<span class="number">1</span>, nB, <span class="number">1</span>, qidx);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qc; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>遇到毒瘤出题人强制在线就挂了 = =, 所以还需要一些在线解决问题的科技.</p><h3 id="可持久化"><a href="#可持久化" class="headerlink" title="可持久化"></a>可持久化</h3><p>刚开始学可持久化的时候感觉这个好高级啊, 后来感觉…</p><p>这不就是个数据结构的前缀和吗 = =</p><h4 id="Luogu-P3834【模板】可持久化线段树-1（主席树）-1"><a href="#Luogu-P3834【模板】可持久化线段树-1（主席树）-1" class="headerlink" title="Luogu P3834【模板】可持久化线段树 1（主席树）"></a>Luogu P3834【模板】可持久化线段树 1（主席树）</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P3834" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3834</a></li></ul><p>建权值线段树, 动态开点.</p><p>按照初始序列建可持久化线段树, 每个位置对应的线段树, 就是包含这个位置前缀信息的线段树了.</p><p>具体地说, 先建出一个空树, 然后对于每个位置, 在上一个位置的基础上拓展, 尽量利用之前以及储存过的信息, 再建出一颗新树. 这样每次新增的节点数为 $O(\log n)$, 总共建出 $n$ 颗线段树, 总空间复杂度为 $O(n \log n + n \log n)$.</p><p>这样对于每个询问 $[L,\ R]$, 按照前缀和的基本思想, 在 $L-1,\ R$ 两颗树上进行二分就好了, 即记录当前二分到的两颗树的左子树 size 之差 (因为是求第 $k$ 小), 然后分类讨论移动到左子树还是右子树.</p><p>时间复杂度: $O(n \log n)$</p><p><strong>代码实现</strong></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3834</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, nB;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN], rt[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> <span class="keyword">int</span> lc, rc, sum; &#125; dat[MAXN &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> nidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span>&amp; nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        nd = ++nidx;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        build(dat[nd].lc, L, Mid), build(dat[nd].rc, Mid+<span class="number">1</span>, R);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nxt = ++nidx;</span><br><span class="line">        dat[nxt] = dat[nd], ++dat[nxt].sum;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> nxt;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (val &lt;= Mid) dat[nxt].lc = Mdy(dat[nxt].lc, L, Mid, val);</span><br><span class="line">        <span class="keyword">else</span> dat[nxt].rc = Mdy(dat[nxt].rc, Mid+<span class="number">1</span>, R, val);</span><br><span class="line">        <span class="keyword">return</span> nxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> L;</span><br><span class="line">        <span class="keyword">int</span> d = dat[dat[y].lc].sum - dat[dat[x].lc].sum, Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= d) <span class="keyword">return</span> Qry(dat[x].lc, dat[y].lc, L, Mid, k);</span><br><span class="line">        <span class="keyword">return</span> Qry(dat[x].rc, dat[y].rc, Mid+<span class="number">1</span>, R, k - d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]), B[i] = A[i];</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    sort(B+<span class="number">1</span>, B+<span class="number">1</span>+n);</span><br><span class="line">    nB = unique(B+<span class="number">1</span>, B+<span class="number">1</span>+n) - B - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) A[i] = lower_bound(B+<span class="number">1</span>, B+<span class="number">1</span>+nB, A[i]) - B;</span><br><span class="line">    SGT::build(rt[<span class="number">0</span>], <span class="number">1</span>, nB);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rt[i] = SGT::Mdy(rt[i<span class="number">-1</span>], <span class="number">1</span>, nB, A[i]);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> L, R, K;</span><br><span class="line">        read(L), read(R), read(K);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, B[SGT::Qry(rt[L<span class="number">-1</span>], rt[R], <span class="number">1</span>, nB, K)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h4 id="Luogu-P3168-CQOI2015-任务查询系统"><a href="#Luogu-P3168-CQOI2015-任务查询系统" class="headerlink" title="Luogu P3168 [CQOI2015] 任务查询系统"></a>Luogu P3168 [CQOI2015] 任务查询系统</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P3168" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3168</a></li></ul><p>刚才是单点修改, 区间求和, 而现在是区间修改, 单点求和, 那么差分即可解决.</p><p><del>尝试了不先建出空树的写法, 感觉还行 ?</del></p><p>对时间建权值线段树, 把每次区间操作差分, 挂在对应的时间点上, 记录最后操作对应的节点为当前时间点的节点, 对于询问直接在对应时间点的树上二分即可.</p><p><strong>代码实现</strong></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3168</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span>+<span class="number">5</span>, MAXV = <span class="number">1e7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> rt[MAXN], pos[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PSGT &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mid ((L + R) / 2)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> <span class="keyword">int</span> lc, rc, size; LL sum; &#125; dat[MAXN &lt;&lt; <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">int</span> nidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Abs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123; <span class="keyword">return</span> v &gt; <span class="number">0</span>? v: -v; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nxt = ++nidx;</span><br><span class="line">        dat[nxt] = dat[nd], dat[nxt].size += (val &lt; <span class="number">0</span>? <span class="number">-1</span>: <span class="number">1</span>), dat[nxt].sum += val;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> nxt;</span><br><span class="line">        <span class="keyword">if</span> (Abs(val) &lt;= Mid) dat[nxt].lc = Mdy(dat[nxt].lc, L, Mid, val);</span><br><span class="line">        <span class="keyword">else</span> dat[nxt].rc = Mdy(dat[nxt].rc, Mid+<span class="number">1</span>, R, val);</span><br><span class="line">        <span class="keyword">return</span> nxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> k * L;</span><br><span class="line">        <span class="keyword">int</span> d = dat[dat[nd].lc].size;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= d) <span class="keyword">return</span> Qry(dat[nd].lc, L, Mid, k);</span><br><span class="line">        <span class="keyword">return</span> Qry(dat[nd].rc, Mid+<span class="number">1</span>, R, k - d) + dat[dat[nd].lc].sum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> Mid</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(m), read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> L, R, val;</span><br><span class="line">        read(L), read(R), read(val);</span><br><span class="line">        A[L].push_back(val), A[R+<span class="number">1</span>].push_back(-val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">int</span> nidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> k = <span class="number">0</span>; k &lt; A[i].size(); ++k)</span><br><span class="line">            ++nidx, rt[nidx] = PSGT::Mdy(rt[nidx<span class="number">-1</span>], <span class="number">1</span>, MAXV, A[i][k]);</span><br><span class="line">        pos[i] = nidx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x, a, b, c, k, nd; <span class="keyword">static</span> LL pre = <span class="number">1</span>;</span><br><span class="line">        read(x), read(a), read(b), read(c);</span><br><span class="line">        k = <span class="number">1</span> + (a * pre + b) % c, nd = pos[x];</span><br><span class="line">        <span class="keyword">if</span> (PSGT::dat[rt[nd]].size &gt; k) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, pre = PSGT::Qry(rt[nd], <span class="number">1</span>, MAXV, k));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, pre = PSGT::dat[rt[nd]].sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="K-D-Tree"><a href="#K-D-Tree" class="headerlink" title="K-D Tree"></a>K-D Tree</h3><p>解决 K 维问题 !</p><p>K-D Tree 类似于二叉搜索树, 建树选择一个维度对当前元素进行分割, 采用合适选择方法和优秀实现, 建树的时间复杂度为 $O(n \log n)$. 详情请 <a href="https://oi-wiki.org/ds/kdt/" target="_blank" rel="noopener">OI Wiki</a>.</p><p>考虑到 K-D Tree 的结构, 插入采用类似替罪羊树的平衡方法, 如果有一个节点某一子树的大小超过限制, 就直接重构这个以这一节点为根的子树.</p><p>查询直接仿照二叉搜索树了, 注意到 K-D Tree 某些情况下可以剪枝, 可以多维护一些信息来排除掉一些子树.</p><p>可以证明, 在 $k$ 维情况下, 单次查询时间复杂度为 $O(n ^ {1 - \frac{1}{k}} + \log n )$.</p><p>不过值得注意的是, 这里的查询是类似于矩阵查询的偏序维护, 来个平面最近点对单次操作还是最劣 $O(n)$.</p><h4 id="Luogu-P4148-简单题"><a href="#Luogu-P4148-简单题" class="headerlink" title="Luogu P4148 简单题"></a>Luogu P4148 简单题</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P4148" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P4148</a></li></ul><p>感觉 K-D Tree 的模板题, 没什么好说的, 把 K-D Tree 的操作汇总就好了.</p><p><del>然而我重构写挂了调了好久…</del></p><p><strong>代码实现</strong></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P4148</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> alpha = <span class="number">0.725</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, nidx, root;</span><br><span class="line"><span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span> <span class="keyword">int</span> x, y, val; &#125; A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> KDT &#123;</span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>][MAXN], d[MAXN], g[MAXN], t;</span><br><span class="line">    <span class="keyword">int</span> size[MAXN], datSum[MAXN], mnL[MAXN], mxR[MAXN], mnD[MAXN], mxU[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123; <span class="keyword">return</span> A[a].x &lt; A[b].x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123; <span class="keyword">return</span> A[a].y &lt; A[b].y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> &amp;lc = ch[<span class="number">0</span>][nd], &amp;rc = ch[<span class="number">1</span>][nd];</span><br><span class="line">        size[nd] = <span class="number">1</span>, datSum[nd] = A[nd].val;</span><br><span class="line">        mnL[nd] = mxR[nd] = A[nd].x, mnD[nd] = mxU[nd] = A[nd].y;</span><br><span class="line">        <span class="keyword">if</span> (lc) &#123;</span><br><span class="line">            size[nd] += size[lc], datSum[nd] += datSum[lc];</span><br><span class="line">            mnL[nd] = min(mnL[nd], mnL[lc]), mxR[nd] = max(mxR[nd], mxR[lc]);</span><br><span class="line">            mnD[nd] = min(mnD[nd], mnD[lc]), mxU[nd] = max(mxU[nd], mxU[lc]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            size[nd] += size[rc], datSum[nd] += datSum[rc];</span><br><span class="line">            mnL[nd] = min(mnL[nd], mnL[rc]), mxR[nd] = max(mxR[nd], mxR[rc]);</span><br><span class="line">            mnD[nd] = min(mnD[nd], mnD[rc]), mxU[nd] = max(mxU[nd], mxU[rc]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> avx = <span class="number">0</span>, avy = <span class="number">0</span>, x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) avx += A[g[i]].x, avy += A[g[i]].y;</span><br><span class="line">        avx /= (R - L + <span class="number">1.0</span>), avy /= (R - L + <span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">            x += (A[g[i]].x - avx) * (A[g[i]].x - avx);</span><br><span class="line">            y += (A[g[i]].y - avy) * (A[g[i]].y - avy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">            nth_element(g+L, g+Mid, g+R+<span class="number">1</span>, cmp1), d[g[Mid]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nth_element(g+L, g+Mid, g+R+<span class="number">1</span>, cmp2), d[g[Mid]] = <span class="number">2</span>;</span><br><span class="line">        ch[<span class="number">0</span>][g[Mid]] = build(L, Mid<span class="number">-1</span>), ch[<span class="number">1</span>][g[Mid]] = build(Mid+<span class="number">1</span>, R);</span><br><span class="line">        <span class="keyword">return</span> maintain(g[Mid]), g[Mid];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nd) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>][nd]) dfs(ch[<span class="number">0</span>][nd]);</span><br><span class="line">        g[++t] = nd;</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">1</span>][nd]) dfs(ch[<span class="number">1</span>][nd]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span>&amp; nd)</span> </span>&#123;</span><br><span class="line">        t = <span class="number">0</span>, dfs(nd), nd = build(<span class="number">1</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">canrb</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> alpha * size[nd] &lt;= max(size[ch[<span class="number">0</span>][nd]], size[ch[<span class="number">1</span>][nd]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span>&amp; nd, <span class="keyword">const</span> <span class="keyword">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nd) &#123; nd = pos, maintain(nd); <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (d[nd] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[pos].x &lt;= A[nd].x) Ins(ch[<span class="number">0</span>][nd], pos);</span><br><span class="line">            <span class="keyword">else</span> Ins(ch[<span class="number">1</span>][nd], pos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[pos].y &lt;= A[nd].y) Ins(ch[<span class="number">0</span>][nd], pos);</span><br><span class="line">            <span class="keyword">else</span> Ins(ch[<span class="number">1</span>][nd], pos);</span><br><span class="line">        &#125;</span><br><span class="line">        maintain(nd);</span><br><span class="line">        <span class="keyword">if</span> (canrb(nd)) rebuild(nd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nd || x1 &gt; mxR[nd] || x2 &lt; mnL[nd] || y1 &gt; mxU[nd] || y2 &lt; mnD[nd])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x1 &lt;= mnL[nd] &amp;&amp; mxR[nd] &lt;= x2 &amp;&amp; y1 &lt;= mnD[nd] &amp;&amp; mxU[nd] &lt;= y2)</span><br><span class="line">            <span class="keyword">return</span> datSum[nd];</span><br><span class="line">        <span class="keyword">if</span> (x1 &lt;= A[nd].x &amp;&amp; A[nd].x &lt;= x2 &amp;&amp; y1 &lt;= A[nd].y &amp;&amp; A[nd].y &lt;= y2)</span><br><span class="line">            <span class="keyword">return</span> Qry(ch[<span class="number">0</span>][nd]) + Qry(ch[<span class="number">1</span>][nd]) + A[nd].val;</span><br><span class="line">        <span class="keyword">return</span> Qry(ch[<span class="number">0</span>][nd]) + Qry(ch[<span class="number">1</span>][nd]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"11.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">int</span> opt, val, lastans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (read(opt), opt != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            read(x1), read(y1), read(val);</span><br><span class="line">            x1 ^= lastans, y1 ^= lastans, val ^= lastans;</span><br><span class="line">            A[++nidx] = (Point)&#123; x1, y1, val &#125;;</span><br><span class="line">            KDT::Ins(root, nidx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">            read(x1), read(y1), read(x2), read(y2);</span><br><span class="line">            x1 ^= lastans, y1 ^= lastans, x2 ^= lastans, y2 ^= lastans;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lastans = KDT::Qry(root));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h4 id="Luogu-P5471-NOI2019-弹跳"><a href="#Luogu-P5471-NOI2019-弹跳" class="headerlink" title="Luogu P5471 [NOI2019] 弹跳"></a>Luogu P5471 [NOI2019] 弹跳</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P5471" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P5471</a></li></ul><p><em>如果直接用 K-D Tree 建图, <del>如果用四分树甚至可以 AC</del>, 可以收获 88 pts 的好成绩</em></p><p><em>卡卡常可以卡过? 为什么不尝试更快的做法呢…</em></p><p>那么怎么做呢? 考虑模拟 Dijkstra 的过程, 把这个 K-D Tree 当成堆使用, 记录子树内最小路径长度 (用于更新答案), 以及最大路径长度 (用于剪枝).</p><p>具体地说, 因为每个点的最短距离只会被更新一次, 所以 K-D Tree 要维护</p><ol><li>当前子树覆盖矩阵范围</li><li>当前节点到起点的最短路, 视作当前点的权值</li><li>子树内最小权值, 用于查找节点及更新答案</li><li>当前节点是否被更新过, 换言之, 在 Dijkstra 维护的点集中是否被删去</li></ol><p>另外有一个剪枝: 维护一个子树内最大权值, 这样在修改值 (也就是一个矩阵内更新最小值) 的时候遇到 “最大值比修改值还要小” 的情况就可以剪枝.</p><p>还有一些细节, 在修改整块矩阵的时候打一个类似于线段树的标记, 以及对于已删除节点值的情况要注意分类讨论.</p><p><strong>代码实现</strong></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P5471</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">7e4</span>+<span class="number">5</span>, MAXM = <span class="number">15e4</span>, MAXD = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x[MAXD], idx;</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">int</span>&amp; i) &#123; <span class="keyword">return</span> x[i]; &#125;</span><br><span class="line">&#125; A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, W, H;</span><br><span class="line"><span class="keyword">int</span> pos[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> KDT &#123;</span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>][MAXN], mn[MAXD][MAXN], mx[MAXD][MAXN];</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXN];</span><br><span class="line">    <span class="keyword">int</span> tag[MAXN], datMin[MAXN], datMax[MAXN], datVal[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; nd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> &amp;lc = ch[<span class="number">0</span>][nd], &amp;rc = ch[<span class="number">1</span>][nd];</span><br><span class="line">        <span class="keyword">if</span> (vis[nd]) &#123;</span><br><span class="line">            datMin[nd] = INF, datMax[nd] = -INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; MAXD; ++d) mn[d][nd] = INF, mx[d][nd] = -INF;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            datMin[nd] = datMax[nd] = datVal[nd];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; MAXD; ++d) mn[d][nd] = mx[d][nd] = A[nd][d];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lc) &#123;</span><br><span class="line">            datMin[nd] = min(datMin[nd], datMin[lc]);</span><br><span class="line">            datMax[nd] = max(datMax[nd], datMax[lc]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; MAXD; ++d) &#123;</span><br><span class="line">                mn[d][nd] = min(mn[d][nd], mn[d][lc]);</span><br><span class="line">                mx[d][nd] = max(mx[d][nd], mx[d][lc]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            datMin[nd] = min(datMin[nd], datMin[rc]);</span><br><span class="line">            datMax[nd] = max(datMax[nd], datMax[rc]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; MAXD; ++d) &#123;</span><br><span class="line">                mn[d][nd] = min(mn[d][nd], mn[d][rc]);</span><br><span class="line">                mx[d][nd] = max(mx[d][nd], mx[d][rc]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushTag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; nd, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (val &gt;= datMax[nd] || val &gt;= tag[nd]) <span class="keyword">return</span>;</span><br><span class="line">        datMax[nd] = tag[nd] = val;</span><br><span class="line">        datMin[nd] = min(datMin[nd], val);</span><br><span class="line">        <span class="keyword">if</span> (!vis[nd]) datVal[nd] = min(datVal[nd], val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nd || tag[nd] == INF) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> &amp;lc = ch[<span class="number">0</span>][nd], &amp;rc = ch[<span class="number">1</span>][nd];</span><br><span class="line">        <span class="keyword">if</span> (lc) pushTag(lc, tag[nd]);</span><br><span class="line">        <span class="keyword">if</span> (rc) pushTag(rc, tag[nd]);</span><br><span class="line">        tag[nd] = INF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp0</span><span class="params">(<span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b)</span> </span>&#123; <span class="keyword">return</span> a.x[<span class="number">0</span>] &lt; b.x[<span class="number">0</span>]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b)</span> </span>&#123; <span class="keyword">return</span> a.x[<span class="number">1</span>] &lt; b.x[<span class="number">1</span>]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> avx = <span class="number">0</span>, avy = <span class="number">0</span>, x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) avx += A[i][<span class="number">0</span>], avy += A[i][<span class="number">1</span>];</span><br><span class="line">        avx /= (R - L + <span class="number">1.0</span>), avy /= (R - L + <span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">            x += (avx - A[i][<span class="number">0</span>]) * (avx - A[i][<span class="number">0</span>]);</span><br><span class="line">            y += (avy - A[i][<span class="number">1</span>]) * (avy - A[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) nth_element(A + L, A + Mid, A + R + <span class="number">1</span>, cmp0);</span><br><span class="line">        <span class="keyword">else</span> nth_element(A + L, A + Mid, A + R + <span class="number">1</span>, cmp1);</span><br><span class="line">        pos[Mid] = A[Mid].idx;</span><br><span class="line">        tag[Mid] = INF, datVal[Mid] = (pos[Mid] == <span class="number">1</span>)? <span class="number">0</span>: INF;</span><br><span class="line">        ch[<span class="number">0</span>][Mid] = build(L, Mid<span class="number">-1</span>), ch[<span class="number">1</span>][Mid] = build(Mid+<span class="number">1</span>, R);</span><br><span class="line">        <span class="keyword">return</span> maintain(Mid), Mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="keyword">int</span>&amp; L, <span class="keyword">const</span> <span class="keyword">int</span>&amp; R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; D, <span class="keyword">const</span> <span class="keyword">int</span>&amp; U)</span> </span>&#123;</span><br><span class="line">        pushdown(nd);</span><br><span class="line">        <span class="keyword">if</span> (datMax[nd] &lt;= val) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (L &gt; mx[<span class="number">0</span>][nd] || R &lt; mn[<span class="number">0</span>][nd] || D &gt; mx[<span class="number">1</span>][nd] || U &lt; mn[<span class="number">1</span>][nd]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= mn[<span class="number">0</span>][nd] &amp;&amp; mx[<span class="number">0</span>][nd] &lt;= R &amp;&amp; D &lt;= mn[<span class="number">1</span>][nd] &amp;&amp; mx[<span class="number">1</span>][nd] &lt;= U)</span><br><span class="line">            <span class="keyword">return</span> pushTag(nd, val);</span><br><span class="line">        <span class="keyword">if</span> (!vis[nd] &amp;&amp; L &lt;= A[nd][<span class="number">0</span>] &amp;&amp; A[nd][<span class="number">0</span>] &lt;= R &amp;&amp; D &lt;= A[nd][<span class="number">1</span>] &amp;&amp; A[nd][<span class="number">1</span>] &lt;= U)</span><br><span class="line">            datVal[nd] = min(datVal[nd], val);</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>][nd]) Mdy(ch[<span class="number">0</span>][nd], val, L, R, D, U);</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">1</span>][nd]) Mdy(ch[<span class="number">1</span>][nd], val, L, R, D, U);</span><br><span class="line">        maintain(nd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        pushdown(nd);</span><br><span class="line">        <span class="keyword">if</span> (!vis[nd] &amp;&amp; datVal[nd] == val) &#123;</span><br><span class="line">            vis[nd] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> maintain(nd), nd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>][nd] &amp;&amp; datMin[ch[<span class="number">0</span>][nd]] == val) &#123;</span><br><span class="line">            <span class="keyword">int</span> ret = Qry(ch[<span class="number">0</span>][nd], val);</span><br><span class="line">            <span class="keyword">return</span> maintain(nd), ret;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ret = Qry(ch[<span class="number">1</span>][nd], val);</span><br><span class="line">            <span class="keyword">return</span> maintain(nd), ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> L, R, D, U, w; &#125;; </span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; G[MAXN];</span><br><span class="line">    <span class="keyword">int</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> D, <span class="keyword">int</span> U, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        G[from].push_back((Edge)&#123; L, R, D, U, w &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = KDT::build(<span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> nd = KDT::Qry(root, KDT::datMin[root]);</span><br><span class="line">            <span class="keyword">int</span> u = pos[nd];</span><br><span class="line">            dist[u] = KDT::datVal[nd];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> k = <span class="number">0</span>; k &lt; G[u].size(); ++k) &#123;</span><br><span class="line">                <span class="keyword">const</span> Edge&amp; e = G[u][k];</span><br><span class="line">                KDT::Mdy(root, dist[u] + e.w, e.L, e.R, e.D, e.U);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dist[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m), read(W), read(H);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        A[i].idx = i, read(A[i][<span class="number">0</span>]), read(A[i][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> p, w, L, R, D, U;</span><br><span class="line">        read(p), read(w), read(L), read(R), read(D), read(U);</span><br><span class="line">        Graph::AddEdge(p, L, R, D, U, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    Graph::Dijkstra();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="树套树"><a href="#树套树" class="headerlink" title="树套树"></a>树套树</h3><p>字面意思, 嵌套数据结构.</p><p>带有巨大常数, 占用大量空间.</p><h4 id="Luogu-P3380【模板】二逼平衡树（树套树）"><a href="#Luogu-P3380【模板】二逼平衡树（树套树）" class="headerlink" title="Luogu P3380【模板】二逼平衡树（树套树）"></a>Luogu P3380【模板】二逼平衡树（树套树）</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P3380" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3380</a></li></ul><p>采用线段树套平衡树的方法, 为了好些一些, 内层平衡树我选择了 无旋 Treap.</p><ol><li><p>$k$ 在区间内的排名</p><p>把区间丢到线段树上处理, 把区间拆分后得到的排名相加即可. 单次操作时间复杂度 $O(\log^2 n)$</p><p>注意一些细节: 数值 $k$ 可能在区间内的贡献可能被计算多次, 所以每次查询内层平衡树时把得到的排名 $-1$, 最后得出答案时再把自己加上.</p></li><li><p>查询区间内排名为 $k$ 的值</p><p>这个问题在普通的平衡树上可以通过二分解决, 但是在多棵平衡树的情况下进行二分好像很困难…</p><p>所以直接采用二分值域的方式, 判断当前二分的值是否在区间内排名为 $k$, 单次操作时间复杂度 $O(\log ^3 n)$.</p><p>(好像在多个 Trie 上二分很可做, 或者用树状数组套 Trie 来维护, 可以做到 $O(\log ^2 n)$, 还没写过, 值得尝试)</p></li><li><p>修改某一位值上的数值</p><p>在线段树上跑一遍单点修改的操作, 沿途把原来的值删除, 再把修改的值加入就好了. 时间复杂度 $O(\log^2 n)$.</p></li><li><p>查询 $k$ 在区间内的前驱</p></li><li><p>查询 $k$ 在区间内的后继</p><p>也是把区间丢到线段树上, 注意把前驱取 $\max$, 后缀取 $\min$. 时间复杂度 $O(\log^2 n)$</p></li></ol><p><strong>代码实现</strong></p><p>只有靠 O2 才勉强续命的样子.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3380</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e4</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Treap &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = ::MAXN &lt;&lt; <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>][MAXN], size[MAXN], rnd[MAXN], val[MAXN], nidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">        size[nd] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>][nd]) size[nd] += size[ch[<span class="number">0</span>][nd]];</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">1</span>][nd]) size[nd] += size[ch[<span class="number">1</span>][nd]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val[++nidx] = v, size[nidx] = <span class="number">1</span>, rnd[nidx] = rand(), nidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nd) <span class="keyword">return</span> <span class="keyword">void</span>( x = y = <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">if</span> (val[nd] &lt;= k) x = nd, split(ch[<span class="number">1</span>][nd], k, ch[<span class="number">1</span>][nd], y);</span><br><span class="line">        <span class="keyword">else</span> y = nd, split(ch[<span class="number">0</span>][nd], k, x, ch[<span class="number">0</span>][nd]);</span><br><span class="line">        maintain(nd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line">        <span class="keyword">if</span> (rnd[x] &lt; rnd[y]) <span class="keyword">return</span> ch[<span class="number">1</span>][x] = merge(ch[<span class="number">1</span>][x], y), maintain(x), x;</span><br><span class="line">        <span class="keyword">return</span> ch[<span class="number">0</span>][y] = merge(x, ch[<span class="number">0</span>][y]), maintain(y), y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>&amp; root, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x, y; x = y = <span class="number">0</span>;</span><br><span class="line">        split(root, v, x, y), root = merge(merge(x, newnode(v)), y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span>&amp; root, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x, y, z; x = y = z = <span class="number">0</span>;</span><br><span class="line">        split(root, v, x, z), split(x, v<span class="number">-1</span>, x, y);</span><br><span class="line">        y = merge(ch[<span class="number">0</span>][y], ch[<span class="number">1</span>][y]), root = merge(merge(x, y), z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Rnk</span><span class="params">(<span class="keyword">int</span>&amp; root, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x, y, ret; x = y = ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> split(root, v<span class="number">-1</span>, x, y), ret = size[x] + <span class="number">1</span>, root = merge(x, y), ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Kth</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (nd) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = ch[<span class="number">0</span>][nd]? size[ch[<span class="number">0</span>][nd]] + <span class="number">1</span>: <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (k == t) <span class="keyword">return</span> nd;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; t) k -= t, nd = ch[<span class="number">1</span>][nd];</span><br><span class="line">            <span class="keyword">else</span> nd = ch[<span class="number">0</span>][nd];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pre</span><span class="params">(<span class="keyword">int</span>&amp; root, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x, y, ret; x = y = ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> split(root, v<span class="number">-1</span>, x, y), ret = x? val[Kth(x, size[x])]: -INT_MAX, root = merge(x, y), ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Suf</span><span class="params">(<span class="keyword">int</span>&amp; root, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x, y, ret; x = y = ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> split(root, v, x, y), ret = y? val[Kth(y, <span class="number">1</span>)]: INT_MAX, root = merge(x, y), ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>][u]) dfs(ch[<span class="number">0</span>][u]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, val[u]);</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">1</span>][u]) dfs(ch[<span class="number">1</span>][u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (nd&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (nd&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mid ((L + R) / 2)</span></span><br><span class="line">    <span class="keyword">int</span> rt[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i) Treap::insert(rt[nd], A[i]);</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">        build(lc, L, Mid), build(rc, Mid+<span class="number">1</span>, R);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; pos, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        Treap::remove(rt[nd], A[pos]), Treap::insert(rt[nd], val);</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= Mid) Mdy(lc, L, Mid, pos, val);</span><br><span class="line">        <span class="keyword">else</span> Mdy(rc, Mid+<span class="number">1</span>, R, pos, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Rnk</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> Treap::Rnk(rt[nd], val) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> Rnk(lc, L, Mid, opL, opR, val);</span><br><span class="line">        <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> Rnk(rc, Mid+<span class="number">1</span>, R, opL, opR, val);</span><br><span class="line">        <span class="keyword">return</span> Rnk(lc, L, Mid, opL, opR, val) + Rnk(rc, Mid+<span class="number">1</span>, R, opL, opR, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Kth</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = <span class="number">1e8</span>, ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Rnk(<span class="number">1</span>, <span class="number">1</span>, n, opL, opR, Mid) + <span class="number">1</span> &lt;= k) ret = Mid, L = Mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> R = Mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Pre</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> Treap::Pre(rt[nd], val);</span><br><span class="line">        <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> Pre(lc, L, Mid, opL, opR, val);</span><br><span class="line">        <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> Pre(rc, Mid+<span class="number">1</span>, R, opL, opR, val);</span><br><span class="line">        <span class="keyword">return</span> max(Pre(lc, L, Mid, opL, opR, val), Pre(rc, Mid+<span class="number">1</span>, R, opL, opR, val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Suf</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> Treap::Suf(rt[nd], val);</span><br><span class="line">        <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> Suf(lc, L, Mid, opL, opR, val);</span><br><span class="line">        <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> Suf(rc, Mid+<span class="number">1</span>, R, opL, opR, val);</span><br><span class="line">        <span class="keyword">return</span> min(Suf(lc, L, Mid, opL, opR, val), Suf(rc, Mid+<span class="number">1</span>, R, opL, opR, val));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> Mid</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    srand( time(<span class="literal">nullptr</span>) );</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    SGT::build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> opt, L, R, K;</span><br><span class="line">        read(opt), read(L), read(R); <span class="keyword">if</span> (opt != <span class="number">3</span>) read(K);</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, SGT::Rnk(<span class="number">1</span>, <span class="number">1</span>, n, L, R, K) + <span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, SGT::Kth(L, R, K)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: SGT::Mdy(<span class="number">1</span>, <span class="number">1</span>, n, L, R), A[L] = R; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, SGT::Pre(<span class="number">1</span>, <span class="number">1</span>, n, L, R, K)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, SGT::Suf(<span class="number">1</span>, <span class="number">1</span>, n, L, R, K)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERR\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h4 id="Luogu-P3332-ZJOI2013-K-大数查询"><a href="#Luogu-P3332-ZJOI2013-K-大数查询" class="headerlink" title="Luogu P3332 [ZJOI2013] K 大数查询"></a>Luogu P3332 [ZJOI2013] K 大数查询</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P3332" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3332</a></li></ul><p>大概是权值线段树套普通线段树 ?</p><p><del>话说这种直接给出操作的数据结构应该是几年前的画风吧 ?</del></p><p>首先对题意进行转化, 将加入的元素看作一个带有两种属性的元素, 那么操作 1 就是加入 $(l, c),\ (l+1, c),\ \ldots, (r, c)$ 这些点, 操作 2 就是查询第一个属性 $a$ 满足 $l \le a \le r$ 的点集中第 $k$ 大.</p><p>于是就可以很自然地联想到树套树了. 但是区间加入一个数的操作不好实现, 所以就有了一个朴素的想法: 在外层线段树上维护权值, 在内层维护位置.</p><p>现在的问题就很明朗了:</p><ul><li><p>对于操作 1: 在外层线段树单点插入一个值, 并在这个位置对应的线段树区间加 1, 表明这个位置加入值了.</p><p>注意到代码中使用了 “标记永久化” 的技巧, 这样会比每次下传标记要快, <del>但是我要卡常为什么不直接写整体二分呢?</del></p><p>单次操作时间复杂度 $O(log^2 n)$.</p></li><li><p>对于操作 2: 在外层线段树上二分, 和普通权值线段树的操作没什么大的差别, 只是查询子树大小的 $O(\log n)$ 而已…</p><p>单次操作时间复杂度 $O(log^2 n)$.</p></li></ul><p><strong>代码实现</strong></p><p>活在 O2, 以及被整体二分吊打的空气之下 = =.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3332</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e4</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> opt, L, R; LL c;</span><br><span class="line">&#125; Q[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">LL B[MAXN], nB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DSGT &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = ::MAXN * <span class="number">17</span> * <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">int</span> lc[MAXN], rc[MAXN], nidx;</span><br><span class="line">    LL datSum[MAXN], tagAdd[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (max(l1, l2) &gt; min(r1, r2)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> min(r1, r2) - max(l1, l2) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 标记永久化</span></span><br><span class="line">        datSum[nd] += calc(L, R, opL, opR);</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> <span class="keyword">void</span>( ++tagAdd[nd] );</span><br><span class="line">        <span class="comment">// 内层线段树需要动态开点, 空间复杂度 O(n log^2 n)</span></span><br><span class="line">        <span class="keyword">if</span> (!lc[nd]) lc[nd] = ++nidx;</span><br><span class="line">        <span class="keyword">if</span> (!rc[nd]) rc[nd] = ++nidx;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= Mid) Mdy(lc[nd], L, Mid, opL, opR);</span><br><span class="line">        <span class="keyword">if</span> (opR &gt; Mid) Mdy(rc[nd], Mid+<span class="number">1</span>, R, opL, opR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR, <span class="keyword">const</span> <span class="keyword">int</span>&amp; tag = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 标记永久化</span></span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> datSum[nd] + tag * (R-L+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= Mid) ret += Qry(lc[nd], L, Mid, opL, opR, tag + tagAdd[nd]);</span><br><span class="line">        <span class="keyword">if</span> (opR &gt; Mid) ret += Qry(rc[nd], Mid+<span class="number">1</span>, R, opL, opR, tag + tagAdd[nd]);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (nd&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (nd&lt;&lt;1|1)</span></span><br><span class="line">    <span class="keyword">int</span> rt[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR, <span class="keyword">const</span> <span class="keyword">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!rt[nd]) rt[nd] = ++DSGT::nidx;</span><br><span class="line">        DSGT::Mdy(rt[nd], <span class="number">1</span>, n, opL, opR);</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= Mid) Mdy(lc, L, Mid, opL, opR, pos);</span><br><span class="line">        <span class="keyword">else</span> Mdy(rc, Mid+<span class="number">1</span>, R, opL, opR, pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Kth</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR, <span class="keyword">const</span> LL&amp; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> L;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        LL d = DSGT::Qry(rt[rc], <span class="number">1</span>, n, opL, opR);</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= d) <span class="keyword">return</span> Kth(rc, Mid+<span class="number">1</span>, R, opL, opR, k);</span><br><span class="line">        <span class="keyword">return</span> Kth(lc, L, Mid, opL, opR, k - d);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> opt, L, R; <span class="keyword">static</span> LL c;</span><br><span class="line">        read(opt), read(L), read(R), read(c);</span><br><span class="line">        Q[i] = (Ask)&#123; opt, L, R, c &#125;;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) B[++nB] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    sort(B+<span class="number">1</span>, B+<span class="number">1</span>+nB);</span><br><span class="line">    nB = unique(B+<span class="number">1</span>, B+<span class="number">1</span>+nB) - B - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 需要丢到权值线段树里, 随手离散化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">if</span> (Q[i].opt == <span class="number">1</span>) Q[i].c = lower_bound(B+<span class="number">1</span>, B+<span class="number">1</span>+nB, Q[i].c) - B;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> Ask&amp; q = Q[i];</span><br><span class="line">        <span class="keyword">switch</span> (q.opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: SGT::Mdy(<span class="number">1</span>, <span class="number">1</span>, nB, q.L, q.R, q.c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, B[SGT::Kth(<span class="number">1</span>, <span class="number">1</span>, nB, q.L, q.R, q.c)]); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERR\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h4 id="Luogu-P3759-TJOI2017-不勤劳的图书管理员"><a href="#Luogu-P3759-TJOI2017-不勤劳的图书管理员" class="headerlink" title="Luogu P3759 [TJOI2017] 不勤劳的图书管理员"></a>Luogu P3759 [TJOI2017] 不勤劳的图书管理员</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P3759" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3759</a></li></ul><p>带权动态逆序对.</p><p><del>题外话: 这题有点题意杀, 不过模拟一遍样例就好了</del></p><p>仍然使用上一题的转化思路, 题目所求即为 $n$ 个带有两种属性的元素 $(a_i,\ b_i)$ 中满足 $a_i &lt; a_j$ 且 $b_i &gt; b_j$ 的元素对权值和.</p><p>交换位置的操作可以看作删除两个元素后加入两个新元素, 所以问题的关键在于加入 / 删除元素对答案的影响.</p><p>每次查询一个元素 $(a,\ b)$ 的影响, 对这个元素有贡献的, 一定满足:</p><ul><li><p>第一维 $&lt; a$, 第二维 $&gt; b$</p></li><li><p>第一维 $&gt; a$, 第二维 $&lt; b$</p></li></ul><p>由于记录信息具有可减性, 采用树状数组套权值线段树实现.</p><p><strong>代码实现</strong></p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3759</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e4</span>+<span class="number">5</span>, P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], v[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = ::MAXN * <span class="number">16</span> * <span class="number">16</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> size, sum;</span><br><span class="line">        Node() &#123; size = sum = <span class="number">0</span>; &#125;</span><br><span class="line">        Node(<span class="keyword">int</span> _s, <span class="keyword">int</span> _v): size(_s), sum(_v) &#123; &#125;</span><br><span class="line">        Node <span class="keyword">operator</span> + (<span class="keyword">const</span> Node&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Node((size + rhs.size) % P, (sum + rhs.sum) % P);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; dat[MAXN];</span><br><span class="line">    <span class="keyword">int</span> lc[MAXN], rc[MAXN], nidx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; pos, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val, <span class="keyword">const</span> <span class="keyword">int</span>&amp; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nd) nd = ++nidx;</span><br><span class="line">        dat[nd].size = (dat[nd].size + <span class="number">1L</span>L * type) % P;</span><br><span class="line">        dat[nd].sum = (dat[nd].sum + <span class="number">1L</span>L * type * val) % P;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> nd;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= Mid) lc[nd] = Mdy(lc[nd], L, Mid, pos, val, type);</span><br><span class="line">        <span class="keyword">else</span> rc[nd] = Mdy(rc[nd], Mid+<span class="number">1</span>, R, pos, val, type);</span><br><span class="line">        <span class="keyword">return</span> nd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> dat[nd];</span><br><span class="line">        <span class="keyword">if</span> (!nd) <span class="keyword">return</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> Qry(lc[nd], L, Mid, opL, opR);</span><br><span class="line">        <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> Qry(rc[nd], Mid+<span class="number">1</span>, R, opL, opR);</span><br><span class="line">        <span class="keyword">return</span> Qry(lc[nd], L, Mid, opL, opR) + Qry(rc[nd], Mid+<span class="number">1</span>, R, opL, opR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line">    <span class="keyword">using</span> SGT::Node;</span><br><span class="line">    <span class="keyword">int</span> rt[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; d1, <span class="keyword">const</span> <span class="keyword">int</span>&amp; d2, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val, <span class="keyword">const</span> <span class="keyword">int</span>&amp; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = d1; i &lt;= n; i += lowbit(i))</span><br><span class="line">            rt[i] = SGT::Mdy(rt[i], <span class="number">1</span>, n, d2, val, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; d1, <span class="keyword">const</span> <span class="keyword">int</span>&amp; d2, <span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = d1; i; i -= lowbit(i)) &#123;</span><br><span class="line">            Node tmp = SGT::Qry(rt[i], <span class="number">1</span>, n, d2, n);</span><br><span class="line">            ret = (ret + tmp.sum + <span class="number">1L</span>L * val * tmp.size) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i -= lowbit(i)) &#123;</span><br><span class="line">            Node tmp = SGT::Qry(rt[i], <span class="number">1</span>, n, <span class="number">1</span>, d2);</span><br><span class="line">            ret = (ret + tmp.sum + <span class="number">1L</span>L * val * tmp.size) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = d1; i; i -= lowbit(i)) &#123;</span><br><span class="line">            Node tmp = SGT::Qry(rt[i], <span class="number">1</span>, n, <span class="number">1</span>, d2);</span><br><span class="line">            ret = (ret - (tmp.sum + <span class="number">1L</span>L * val * tmp.size) % P + P) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        read(A[i]), read(v[i]);</span><br><span class="line">        ans = (ans + BIT::Qry(i, A[i], v[i])) % P;</span><br><span class="line">        BIT::Mdy(i, A[i], v[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> L, R;</span><br><span class="line">        read(L), read(R);</span><br><span class="line">        <span class="comment">// remove</span></span><br><span class="line">        ans = (ans - BIT::Qry(L, A[L], v[L]) + P) % P;</span><br><span class="line">        BIT::Mdy(L, A[L], v[L], <span class="number">-1</span>);</span><br><span class="line">        ans = (ans - BIT::Qry(R, A[R], v[R]) + P) % P;</span><br><span class="line">        BIT::Mdy(R, A[R], v[R], <span class="number">-1</span>);</span><br><span class="line">        swap(A[L], A[R]), swap(v[L], v[R]);</span><br><span class="line">        <span class="comment">// add</span></span><br><span class="line">        BIT::Mdy(L, A[L], v[L], <span class="number">1</span>);</span><br><span class="line">        ans = (ans + BIT::Qry(L, A[L], v[L])) % P;</span><br><span class="line">        BIT::Mdy(R, A[R], v[R], <span class="number">1</span>);</span><br><span class="line">        ans = (ans + BIT::Qry(R, A[R], v[R])) % P;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>数据结构还是学不明白啊, 真是活该退役.png</p><p><strong>UPD on 2020.2.27</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>nzhtl1477, 简单数据结构</li><li>__stdcall, <a href="https://www.cnblogs.com/mlystdcall/p/6219421.html" target="_blank" rel="noopener">简易 CDQ 分治教程 &amp; 学习笔记</a></li><li>Owen_codeisking, <a href="https://www.luogu.com.cn/blog/Owencodeisking/post-xue-xi-bi-ji-cdq-fen-zhi-hu-zheng-ti-er-fen" target="_blank" rel="noopener">[学习笔记] CDQ 分治和整体二分</a></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;拜读了毒瘤的数据结构课件, 深受启发, &lt;del&gt;甚是谔谔, 当即感觉自己之前一直在玩泥巴&lt;/del&gt;.&lt;/p&gt;
&lt;p&gt;初学数据结构, 恳请指正.&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://depletedprism.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Data Structure" scheme="https://depletedprism.github.io/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>「十二省联考 2019」字符串问题 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/luogu-P5284/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/luogu-P5284/</id>
    <published>2020-02-04T14:24:45.000Z</published>
    <updated>2020-02-20T06:00:29.853Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>谨以此题纪念自己颓废的, 什么都不会的高一 (bushi</p></blockquote><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P5284" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P5284</a></li></ul><p>SAM 优化建图 + 拓扑排序求最长路.</p><p>写这道题啊, 只是感到自己的高一很可笑吧, 连题意都不大能读清, 正解的算法听都没有听过, 输出样例就弃疗离场.</p><a id="more"></a><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>考虑目标串 $T$ 的构造过程, 可以发现 $A,\ B$ 串可以视为节点, 支配关系和前缀可以看作边, $T$ 就对应图中一条路径, 那么把图建出来跑最长路就好了.</p><p>另外可以发现, 如果图上存在环就说明可以构造出无限长的串 $T$, 输出 <code>-1</code>, 否则这就是个 DAG, 最长路跑拓扑排序就好了.</p><p>进一步考虑建边</p><ol><li><p>$A_{id_i} \rightarrow B$</p><p>支配关系是题目给出的, 直接把 $A,\ B$ 串对应节点连起来就好了.</p></li><li><p>$B_j \rightarrow A_i$, 其中 $B_j$ 为 $A_i$ 的前缀</p><p>这里就有些意思了, <del>如果直接暴力建边就可以拿到 10 pts 的好成绩</del></p><p>考虑前缀, 就是反串的后缀, 我们可以想到对 $S$ 的反串建出 SAM, 把串 $A,\ B$ 放到 SAM 上匹配, 这一步可以套路地用倍增解决. 假设匹配到 SAM 上的节点 $u$, 那么就新建一个节点 $v$ 表示当前匹配串, 点权为匹配串长度, 并把 $v$ 挂在 $u$ 上.</p><p>对于 SAM 上的一个节点 $u$, <del>上面挂这一堆节点表示 A, B 串</del>, 我们将这些节点以点权为第一关键字, 是否为 $B$ 串为第二关键字从小到大排序, 并根据这个顺序依次连边.</p><p>另外还需考虑 SAM 上节点 $u$ 和后缀链接 $\text{lnk}(u)$ 的关系, 对于反串中的前缀, 存在一个前缀是另一前缀的前缀, 那么就是从 $\text{lnk}(u)$ 向 $u$ 连边了. 当然, 由于上一步的连边此处 $\text{lnk}(u)$ 的实际节点稍有不同.</p><p><del>具体实现代码里很清晰, 正确性很显然</del></p></li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>细节不多的题还是好码一点的.<br><del>这就是你抄题解还 WA 了一发的原因了 ?</del> (</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P5284</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span>+<span class="number">5</span>, LOG = <span class="number">20</span>, MAXV = MAXN &lt;&lt; <span class="number">2</span>, MAXE = MAXN * <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, na, nb, uidx;</span><br><span class="line"><span class="keyword">char</span> S[MAXN];</span><br><span class="line"><span class="keyword">bool</span> isA[MAXV];</span><br><span class="line"><span class="keyword">int</span> Aidx[MAXN], Bidx[MAXN], lst[MAXN &lt;&lt; <span class="number">1</span>], pos[MAXN], pre[LOG][MAXN &lt;&lt; <span class="number">1</span>], len[MAXV];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SAM &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = ::MAXN &lt;&lt; <span class="number">1</span>, SIGMA = <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][SIGMA], lnk[MAXN], nidx, last;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        last = nidx = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ch[<span class="number">1</span>], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        len[++nidx] = l, lnk[nidx] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ch[nidx], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[nidx]);</span><br><span class="line">        <span class="keyword">return</span> nidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nd = newnode(len[last] + <span class="number">1</span>), p = last;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !ch[p][val]) ch[p][val] = nd, p = lnk[p];</span><br><span class="line">        <span class="keyword">if</span> (!p) lnk[nd] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> q = ch[p][val];</span><br><span class="line">            <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) lnk[nd] = q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> nxt = newnode(len[p] + <span class="number">1</span>);</span><br><span class="line">                lnk[nxt] = lnk[q];</span><br><span class="line">                <span class="built_in">memcpy</span>(ch[nxt], ch[q], <span class="keyword">sizeof</span> ch[nxt]);</span><br><span class="line">                <span class="keyword">while</span> (p &amp;&amp; ch[p][val] == q) ch[p][val] = nxt, p = lnk[p];</span><br><span class="line">                lnk[q] = lnk[nd] = nxt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last = nd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXE];</span><br><span class="line">    <span class="keyword">int</span> head[MAXV], eidx, in[MAXV];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span> in);</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        ++in[to];</span><br><span class="line">        edges[++eidx] = (Edge)&#123; head[from], to &#125;;</span><br><span class="line">        head[from] = eidx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">Toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> LL f[MAXV];</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= uidx; ++i) &#123;</span><br><span class="line">            f[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!in[i]) Q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        LL ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            ans = max(ans, f[u] + len[u]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = edges[i].to;</span><br><span class="line">                f[v] = max(f[v], f[u] + len[u]);</span><br><span class="line">                <span class="keyword">if</span> (!(--in[v])) Q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= uidx; ++i)</span><br><span class="line">            <span class="keyword">if</span> (in[i]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> Ti;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        SAM::init(), Graph::init();</span><br><span class="line">        <span class="built_in">memset</span>(isA, <span class="literal">false</span>, <span class="keyword">sizeof</span> isA);</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// build SAM</span></span><br><span class="line">        n = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(S+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i)</span><br><span class="line">            SAM::insert(S[i] - <span class="string">'a'</span>), pos[i] = SAM::last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= SAM::nidx; ++i)</span><br><span class="line">            pre[<span class="number">0</span>][i] = SAM::lnk[i], G[i].clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; LOG; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= SAM::nidx; ++i) pre[j][i] = pre[j<span class="number">-1</span>][pre[j<span class="number">-1</span>][i]];</span><br><span class="line">        <span class="comment">// find A in SAM</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;na);</span><br><span class="line">        uidx = SAM::nidx;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L, R, i = <span class="number">1</span>; i &lt;= na; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">            <span class="keyword">int</span> lgt = R - L + <span class="number">1</span>, u = pos[L];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = LOG<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">                <span class="keyword">if</span> (pre[j][u] &amp;&amp; len[pre[j][u]] &gt;= lgt) u = pre[j][u];</span><br><span class="line">            len[++uidx] = lgt, Aidx[i] = uidx, isA[uidx] = <span class="literal">true</span>;</span><br><span class="line">            G[u].push_back(uidx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// find B in SAM</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;nb);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L, R, i = <span class="number">1</span>; i &lt;= nb; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">            <span class="keyword">int</span> lgt = R - L + <span class="number">1</span>, u = pos[L];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = LOG<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">                <span class="keyword">if</span> (pre[j][u] &amp;&amp; len[pre[j][u]] &gt;= lgt) u = pre[j][u];</span><br><span class="line">            len[++uidx] = lgt, Bidx[i] = uidx;</span><br><span class="line">            G[u].push_back(uidx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// link edges in SAM</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v, u = <span class="number">1</span>; u &lt;= SAM::nidx; ++u) &#123;</span><br><span class="line">            <span class="keyword">int</span> last = u;</span><br><span class="line">            sort(G[u].begin(), G[u].end(),</span><br><span class="line">                    [](<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)&#123; <span class="keyword">return</span> len[a] &lt; len[b] || (len[a] == len[b] &amp;&amp; isA[a] &lt; isA[b]); &#125;);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; G[u].size(); ++i) &#123;</span><br><span class="line">                Graph::AddEdge(last, v = G[u][i]);</span><br><span class="line">                <span class="keyword">if</span> (!isA[v]) last = v;</span><br><span class="line">            &#125;</span><br><span class="line">            lst[u] = last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= SAM::nidx; ++i)</span><br><span class="line">            Graph::AddEdge(lst[SAM::lnk[i]], i);</span><br><span class="line">        <span class="comment">// clean unexisted value</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= uidx; ++u)</span><br><span class="line">            <span class="keyword">if</span> (!isA[u]) len[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// link A, B</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), Graph::AddEdge(Aidx[u], Bidx[v]);</span><br><span class="line">        <span class="comment">// solve &amp; output</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Graph::Toposort());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;谨以此题纪念自己颓废的, 什么都不会的高一 (bushi&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://www.luogu.com.cn/problem/P5284&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.com.cn/problem/P5284&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SAM 优化建图 + 拓扑排序求最长路.&lt;/p&gt;
&lt;p&gt;写这道题啊, 只是感到自己的高一很可笑吧, 连题意都不大能读清, 正解的算法听都没有听过, 输出样例就弃疗离场.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="String" scheme="https://depletedprism.github.io/tags/String/"/>
    
      <category term="Graph" scheme="https://depletedprism.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>第一 / 二类 Stirling 数的一些平庸求法</title>
    <link href="https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/stirling-polynomial/"/>
    <id>https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/stirling-polynomial/</id>
    <published>2020-01-28T12:19:12.000Z</published>
    <updated>2020-02-27T16:50:20.289Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>看到洛谷上有求 Stirling 数的神奇板子, 于是就想写 = =</p><p><del>虽然不知道会有什么用处, 其实是不想写题又不敢颓废吧</del></p><p>大概是一些式子推推推然后拉板子算算算…</p><a id="more"></a><h3 id="第一类-Stirling-数"><a href="#第一类-Stirling-数" class="headerlink" title="第一类 Stirling 数"></a>第一类 Stirling 数</h3><p>本文采用 $\begin{bmatrix} n \\ m \end{bmatrix}$ 表示第一类 Stirling 数.</p><h4 id="Part-1-行"><a href="#Part-1-行" class="headerlink" title="Part 1 行"></a>Part 1 行</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P5408" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P5408</a></li></ul><p>我们知道, $x$ 的 $n$ 次上升幂就是第 $n$ 行第一类 Stirling 数的生成函数, 即<br>$$x^{\overline n} = \prod_{i=0}^{n-1} (x + i) = \sum_{i=0}^n \begin{bmatrix} n \\ i \end{bmatrix} x^i$$</p><p>论据如下, 归纳法易证 $$ \begin{bmatrix} n \\ m \end{bmatrix} = \begin{bmatrix} n-1 \\ m-1 \end{bmatrix} + (n-1) \cdot \begin{bmatrix} n-1 \\ m \end{bmatrix}$$</p><p>此时通过分治 FFT 可以在 $O(n \log^2 n)$ 的时间复杂度内计算.</p><p>但是用倍增可以做到 $O(n \log n)$.</p><p>考虑倍增, 有<br>$$x^{\overline {2n}} = x^{\overline{n}} (x+n)^{\overline{n}}$$</p><p>写成这个形式鬼知道怎么推, 于是<br>$$x^{\overline{2n}} = \prod_{i=0}^{n-1} (x+i) \prod_{i=0}^{n-1} (x+i+n)$$</p><p>设 $f(x) = \prod_{i=0}^{n-1} (x+i) = \sum_{i=0}^n a_i x^i$, 如果能根据 $f(x)$ 算 $f(x+n)$ 就可以了.<br>$$f(x+n) = \sum_{i=0}^n a_i (x+n)^i = \sum_{i=0}^n a_i \sum_{j=0}^{i} \binom{i}{j} x^i n^{i-j} $$</p><p>交换 $i$, $j$ 枚举顺序, 得<br>$$f(x+n) = \sum_{i=0}^n x^i \sum_{j=i}^n \binom{j}{i} n^{j-i} a_i$$</p><p>展开, 有<br>$$f(x+n) = \sum_{i=0}^n \frac{x^i}{i!} \sum_{j=i}^n \frac{n^{j-i}}{(j-i)!} j!\ a_j$$</p><p>最后一个和式的卷积形式并不显然, 还要将其中一项翻转…</p><p>写起来有很多细节, 中途出了无数锅, 以及我现在都不知道为什么我写的迭代和开区间会死…</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P5408</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">524295</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">167772161</span>, G = <span class="number">3</span>, iG = <span class="number">55924054</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fac[MAXN], ifac[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> m = P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * base * ret % m;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> Lim, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> unit = fpow(type &gt; <span class="number">0</span>? G: iG, (P<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j, w = <span class="number">1L</span>L * w * unit % P) &#123;</span><br><span class="line">                    <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1L</span>L * w * f[i+j+Mid] % P;</span><br><span class="line">                    f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> inv = fpow(Lim, P<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * inv % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> Mid, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">        <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*Mid) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> powk = <span class="number">1</span>, i = <span class="number">0</span>; i &lt; Mid; ++i, powk = <span class="number">1L</span>L * powk * k % P) &#123;</span><br><span class="line">            A[Mid-i<span class="number">-1</span>] = <span class="number">1L</span>L * f[i] * fac[i] % P;</span><br><span class="line">            B[i] = <span class="number">1L</span>L * powk * ifac[i] % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">        init(Lim, L), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = <span class="number">1L</span>L * A[i] * B[i] % P;</span><br><span class="line">        NTT(A, Lim, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) g[i] = <span class="number">1L</span>L * A[Mid-i<span class="number">-1</span>] * ifac[i] % P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="keyword">void</span>( f[<span class="number">0</span>] = <span class="number">1</span> );</span><br><span class="line">        <span class="keyword">int</span> Mid = n / <span class="number">2</span>, Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">        solve(f, Mid);</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt;= n) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">        <span class="comment">// 得到 f(x + Mid)</span></span><br><span class="line">        calc(f, A, Mid+<span class="number">1</span>, Mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Mid; ++i) B[i] = f[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid+<span class="number">1</span>; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">        init(Lim, L), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = <span class="number">1L</span>L * A[i] * B[i] % P;</span><br><span class="line">        NTT(A, Lim, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// n 为奇数时, 有乘 (x + (n-1)) 的情况, 此时直接乘就好了.</span></span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">            f[i] = ((i? A[i<span class="number">-1</span>]: <span class="number">0</span>) + <span class="number">1L</span>L * A[i] * (n<span class="number">-1</span>) % P) % P;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) f[i] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    ifac[<span class="number">0</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = <span class="number">1L</span>L * fac[i<span class="number">-1</span>] * i % P;</span><br><span class="line">    ifac[n] = fpow(fac[n], P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) ifac[i<span class="number">-1</span>] = <span class="number">1L</span>L * ifac[i] * i % P;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    Poly::solve(f, n);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, f[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h4 id="Part-2-列"><a href="#Part-2-列" class="headerlink" title="Part 2 列"></a>Part 2 列</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P5409" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P5409</a></li></ul><p>首先有第一类 Stirling 数的一个性质, 即<br>$$x^{\underline n} = \prod_{i=0}^{n-1} (x-i) = \sum_{i=0}^n (-1)^{n-i} \begin{bmatrix} n \\ i \end{bmatrix} x^i$$</p><p>同样也是归纳法易证.</p><p>对于 $(1+x)^t$, 由牛顿二项式定理, 可知<br>$$(1+x)^t = \sum_{i=0}^\infty \binom{t}{i} x^i$$</p><p>其中 $\binom{t}{i} = \frac{t (t-1) \cdots (t-i+1)}{i!}$, 不妨写作<br>$$(1+x)^t = \sum_{i=0}^\infty \frac{t^{\underline i}}{i!} x^i$$</p><p>愉快套公式, 得<br>$$(1+x)^t = \sum_{i=0}^\infty \frac{1}{i!} x^i \sum_{j=0}^i (-1)^{i-j} \begin{bmatrix} i \\ j \end{bmatrix} t^j$$</p><p>交换枚举顺序, 得<br>$$(1+x)^t = \sum_{i=0}^\infty t^i \sum_{j=i}^\infty \frac{1}{j!} x^j (-1)^{j-i} \begin{bmatrix}j \\ i \end{bmatrix} $$</p><p>同时, 有<br>$$(1+x)^t = \exp (t \cdot \ln (1+x)) = \sum_{i=0}^\infty \frac{1}{i!} \ln^i (1+x)\ t^i$$</p><p>对应项系数相等, 得<br>$$\frac{1}{i!} \ln^i (1+x) = \sum_{j=i}^\infty \frac{1}{j!} (-1)^{j-i} \begin{bmatrix}j \\ i \end{bmatrix} x^j$$</p><p>可以看到, 其中 $i$ 为给定的值, 利用多项式幂函数算就好了.</p><p>值得注意的是, $[x^0] \ln (1+x)$ 有不等于 $1$ 的可能, 所以要用鲁棒性更强的板子 = =</p><p>时间复杂度是带常数的 $O(n \log n)$, 大概是跑不过 $O(n \log^2 n)$ 的带常数吧</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P5409</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">131075</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">167772161</span>, G = <span class="number">3</span>, iG = <span class="number">55924054</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fac[MAXN], ifac[MAXN], inv[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> m = P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % m;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> Lim, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> unit = fpow(type &gt; <span class="number">0</span>? G: iG, (P<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j, w = <span class="number">1L</span>L * w * unit % P) &#123;</span><br><span class="line">                    <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1L</span>L * w * f[i+j+Mid] % P;</span><br><span class="line">                    f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> inv = fpow(Lim, P<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * inv * f[i] % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">        g[<span class="number">0</span>] = fpow(f[<span class="number">0</span>], P<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">0</span>, Lim = <span class="number">1</span>, Mid = <span class="number">2</span>; Mid &lt; <span class="number">2</span>*n; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*Mid) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) A[i] = f[i], B[i] = g[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">            init(Lim, L), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i)</span><br><span class="line">                g[i] = ((B[i] + B[i]) % P - <span class="number">1L</span>L * A[i] * B[i] % P * B[i] % P + P) % P;</span><br><span class="line">            NTT(g, Lim, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = min(Mid, n); i &lt; Lim; ++i) g[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Der</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) g[i<span class="number">-1</span>] = <span class="number">1L</span>L * i * f[i] % P;</span><br><span class="line">        g[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Int</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        g[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i; --i) g[i] = <span class="number">1L</span>L * inv[i] * f[i<span class="number">-1</span>] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ln</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">        Der(f, A, n), Inv(f, B, n);</span><br><span class="line">        <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*n) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">        init(Lim, L), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = <span class="number">1L</span>L * A[i] * B[i] % P;</span><br><span class="line">        NTT(A, Lim, <span class="number">-1</span>), Int(A, g, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Exp</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN], lng[MAXN];</span><br><span class="line">        g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">0</span>, Lim = <span class="number">1</span>, Mid = <span class="number">2</span>; Mid &lt; <span class="number">2</span>*n; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            Ln(g, lng, Mid);</span><br><span class="line">            <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*Mid) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) A[i] = (f[i] - lng[i] + P) % P, B[i] = g[i];</span><br><span class="line">            A[<span class="number">0</span>] = (A[<span class="number">0</span>] + <span class="number">1</span>) % P;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">            init(Lim, L), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) g[i] = <span class="number">1L</span>L * A[i] * B[i] % P;</span><br><span class="line">            NTT(g, Lim, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = min(Mid, n); i &lt; Lim; ++i) g[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> lng[MAXN];</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!f[pos]) ++pos;</span><br><span class="line">        <span class="keyword">int</span> Mid = n - pos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) g[i] = f[i+pos];</span><br><span class="line">        <span class="keyword">int</span> base = g[<span class="number">0</span>], inv = fpow(base, P<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) g[i] = <span class="number">1L</span>L * g[i] * inv % P;</span><br><span class="line">        Ln(g, lng, Mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) lng[i] = <span class="number">1L</span>L * lng[i] * K % P;</span><br><span class="line">        Exp(lng, g, Mid);</span><br><span class="line">        base = fpow(base, K);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) g[i] = <span class="number">1L</span>L * g[i] * base % P;</span><br><span class="line">        pos = min(pos * K, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= pos; --i) g[i] = g[i-pos];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos; ++i) g[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K;</span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;K);</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="keyword">int</span> N = n;</span><br><span class="line">    ifac[<span class="number">0</span>] = fac[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) inv[i] = <span class="number">1L</span>L * (P - P / i) * inv[P % i] % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) fac[i] = <span class="number">1L</span>L * i * fac[i<span class="number">-1</span>] % P;</span><br><span class="line">    ifac[N] = fpow(fac[N], P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i; --i) ifac[i<span class="number">-1</span>] = <span class="number">1L</span>L * i * ifac[i] % P;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    Poly::Ln(f, f, n+<span class="number">1</span>); Poly::Pow(f, f, n+<span class="number">1</span>, K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) f[i] = <span class="number">1L</span>L * f[i] * ifac[K] % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        f[i] = <span class="number">1L</span>L * f[i] * fac[i] % P * (((i-K) &amp; <span class="number">1</span>)? P<span class="number">-1</span>: <span class="number">1</span>) % P;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, f[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h3 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h3><p>本文采用 $\begin{Bmatrix} n \\ m \end{Bmatrix}$ 表示第二类 Stirling 数.</p><h4 id="Part-1-行-1"><a href="#Part-1-行-1" class="headerlink" title="Part 1 行"></a>Part 1 行</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P5395" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P5395</a></li></ul><p><del>感觉这个是最简单的了</del></p><p>考虑第二类 Stirling 数的组合意义, 也就是把 $n$ 个有区别的小球放入 $m$ 个无区别的盒子里的方案数.</p><p>其实这个东西是可以用容斥算的, 可以得到<br>$$\begin{Bmatrix} n \\ m \end{Bmatrix} = \frac{1}{m!} \sum_{k=0}^n (-1)^{k} \binom{m}{k} (m-k)^n$$</p><p>右边和式的意义为, 在 $m$ 个<strong>有区别</strong>的盒子里挑 $k$ 个空盒子, 然后把 $n$ 个小球丢到盒子里. 因为容斥时假设盒子有区别, 最后还要除以 $m!$.</p><p>把这个式子展开就可以看到卷积的形式了.<br>$$\begin{Bmatrix} n \\ m \end{Bmatrix} = \sum_{k=0}^n \frac{(-1)^k}{k!} \frac{(m-k)^n}{(m-k)!}$$</p><p>通过 NTT 就可以在 $O(n \log n)$ 的时间复杂度内计算.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P5395</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">167772161</span>, G = <span class="number">3</span>, iG = <span class="number">55924054</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> m = P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % m;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> Lim, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> unit = fpow(type &gt; <span class="number">0</span>? G: iG, (P<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j, w = <span class="number">1L</span>L * w * unit % P) &#123;</span><br><span class="line">                    <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1L</span>L * w * f[i+j+Mid] % P;</span><br><span class="line">                    f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> inv = fpow(Lim, P<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * inv % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[MAXN], g[MAXN];</span><br><span class="line"><span class="keyword">int</span> fac[MAXN], ifac[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = <span class="number">1L</span>L * fac[i<span class="number">-1</span>] * i % P;</span><br><span class="line">    ifac[n] = fpow(fac[n], P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) ifac[i<span class="number">-1</span>] = <span class="number">1L</span>L * ifac[i] * i % P;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i] = (i &amp; <span class="number">1</span>)? P - ifac[i]: ifac[i];</span><br><span class="line">        g[i] = <span class="number">1L</span>L * fpow(i, n) * ifac[i] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*n) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">    Poly::init(Lim, L), Poly::NTT(f, Lim, <span class="number">1</span>), Poly::NTT(g, Lim, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * g[i] % P;</span><br><span class="line">    Poly::NTT(f, Lim, <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, f[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h4 id="Part-2-列-1"><a href="#Part-2-列-1" class="headerlink" title="Part 2 列"></a>Part 2 列</h4><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P5396" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P5396</a></li></ul><p>设第二类 Stirling 数一列的生成函数为 $S_m$, 即<br>$$S_m (x) = \sum_{i=0}^\infty \begin{Bmatrix} i \\ m \end{Bmatrix} x^i$$</p><p>根据第二类 Stirling 数递推式, 可以得到<br>$$S_m (x) = \sum_{i=1}^\infty \begin{Bmatrix} i-1 \\ m-1 \end{Bmatrix} x^i  + m \sum_{i=1}^\infty \begin{Bmatrix} i-1 \\ m \end{Bmatrix} x^i$$</p><p>$$S_m (x) = x \cdot S_{m-1} (x) + m x \cdot S_m (x)$$</p><p>移项并整理, 得<br>$$S_m (x) = \frac{x}{1-mx} S_{m-1} (x) = \frac{x^m}{\prod_{i=1}^m (1-ix)}$$</p><p>分式的分母可以使用分治 FFT 得到, 然后求逆并乘一个单项式 (也就是把系数右移) 即可.</p><p>所以我们就得到了 $O(n \log^2 n)$ 的做法, 然而存在 $O(n\log n)$ 且小常数的倍增优秀做法, 只是我学不动了…</p><p>佐以 O2 食用更佳.</p><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P5396</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">131075</span> &lt;&lt; <span class="number">1</span>, LOG = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">167772161</span>, G = <span class="number">3</span>, iG = <span class="number">55924054</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> m = P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * base * ret % m;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    <span class="keyword">int</span> tmp[LOG][MAXN], ptr = <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> Lim, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> unit = fpow(type &gt; <span class="number">0</span>? G: iG, (P<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j, w = <span class="number">1L</span>L * w * unit % P) &#123;</span><br><span class="line">                    <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1L</span>L * w * f[i+j+Mid] % P;</span><br><span class="line">                    f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> inv = fpow(Lim, P<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * inv % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span>* g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line">        g[<span class="number">0</span>] = fpow(f[<span class="number">0</span>], P<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">0</span>, Lim = <span class="number">1</span>, Mid = <span class="number">2</span>; Mid &lt; <span class="number">2</span>*n; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (Lim &lt; <span class="number">2</span>*Mid) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mid; ++i) A[i] = f[i], B[i] = g[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid; i &lt; Lim; ++i) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">            init(Lim, L), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i)</span><br><span class="line">                g[i] = ((B[i] + B[i]) % P - <span class="number">1L</span>L * A[i] * B[i] % P * B[i] % P + P) % P;</span><br><span class="line">            NTT(g, Lim, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = min(Mid, n); i &lt; Lim; ++i) g[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> f[<span class="number">0</span>] = <span class="number">1</span>, <span class="keyword">void</span>( f[<span class="number">1</span>] = P - L );</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, *f0 = tmp[++ptr], *f1 = tmp[++ptr];</span><br><span class="line">        solve(f0, L, Mid), solve(f1, Mid+<span class="number">1</span>, R);</span><br><span class="line">        <span class="keyword">int</span> Lim = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt;= R-L+<span class="number">1</span>) Lim &lt;&lt;= <span class="number">1</span>, ++l;</span><br><span class="line">        init(Lim, l), NTT(f0, Lim, <span class="number">1</span>), NTT(f1, Lim, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f0[i] * f1[i] % P, f0[i] = f1[i] = <span class="number">0</span>;</span><br><span class="line">        NTT(f, Lim, <span class="number">-1</span>), ptr -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K;</span><br><span class="line"><span class="keyword">int</span> f[MAXN], g[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;K);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    Poly::solve(f, <span class="number">1</span>, K);</span><br><span class="line">    Poly::Inv(f, g, n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i+K &lt;= n; ++i) f[i+K] = g[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; ++i) f[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, f[i], <span class="string">" \n"</span>[i==n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>Richard A. Brualdi. 组合数学. 机械工业出版社, 2012.4.</li><li><a href="https://www.cnblogs.com/y2823774827y/p/10700231.html" target="_blank" rel="noopener">斯特林数及斯特林反演 by y2823774827y</a></li><li><a href="https://www.luogu.com.cn/blog/NaCly-Fish-blog/solution-p5408" target="_blank" rel="noopener">题解 P5408 【模板】第一类斯特林数·行 by NaCly_Fish</a></li><li><a href="https://www.luogu.com.cn/blog/user7035/solution-p5409" target="_blank" rel="noopener">题解 P5409 【模板】第一类斯特林数·列 by Great_Influence</a></li><li><a href="https://www.luogu.com.cn/blog/user7035/solution-p5396" target="_blank" rel="noopener">题解 P5396 【模板】第二类斯特林数·列 by Great_Influence</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;看到洛谷上有求 Stirling 数的神奇板子, 于是就想写 = =&lt;/p&gt;
&lt;p&gt;&lt;del&gt;虽然不知道会有什么用处, 其实是不想写题又不敢颓废吧&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;大概是一些式子推推推然后拉板子算算算…&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://depletedprism.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Polynomial" scheme="https://depletedprism.github.io/tags/Polynomial/"/>
    
  </entry>
  
  <entry>
    <title>牛顿二项式定理 学习笔记</title>
    <link href="https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/binomial-theorem/"/>
    <id>https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/binomial-theorem/</id>
    <published>2020-01-21T03:52:42.000Z</published>
    <updated>2020-03-05T12:33:35.109Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>数学就是用的时候不够用的东西. = =</p></blockquote><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>牛顿二项式定理是对二项式定理的推广, <del>那直接叫广义二项式定理不好吗</del>, 刚开始看 &lt;组合数学&gt; 的时候见到这个东西, 以为没什么用 = =, 后来…</p><p>当然本文作者没有仔细严谨地学习相关的数学知识, 内容充满谬误, 恳请指正.</p><a id="more"></a><h2 id="陈述"><a href="#陈述" class="headerlink" title="陈述"></a>陈述</h2><h3 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h3><p>对于正整数 $n$ 和任意 $x,\ y$, 有<br>$$(x + y) ^ n = \sum_{k=0}^n\; \binom{n}{k} x^k y ^{n-k}$$</p><p>这就是最常见的二项式定理, 其中 $n$ 可以推广到任意实数, 即</p><h3 id="牛顿二项式定理"><a href="#牛顿二项式定理" class="headerlink" title="牛顿二项式定理"></a>牛顿二项式定理</h3><p>设 $\alpha$ 是实数, 对于所有满足 $0 \leq |x| &lt; |y|$ 的 $x$,  $y$, 有<br>$$(x+y)^\alpha = \sum_{k=0}^\infty\; \binom{\alpha}{k} x^k y^{n-k}$$</p><p>其中<br>$$\binom{\alpha}{k} = \frac{\alpha (\alpha - 1) \cdots (\alpha - k + 1)}{k!} $$</p><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>在此不证.</p><h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><p>看到这个和式上的无穷的时候, <del>顷刻留下了感动的泪水</del>…</p><h3 id="一些拓展"><a href="#一些拓展" class="headerlink" title="一些拓展"></a>一些拓展</h3><p>设 $z = \frac{x}{y}$, 那么上述定理可以转述为</p><p>对于所有满足 $|z| &lt; 1$ 的任意 $z$, 有<br>$$(1+z) ^ \alpha = \sum_{k=0}^\infty\; \binom{\alpha}{k} z^k$$</p><p>设 $n$ 为正整数, 取 $\alpha$ 为负整数 $-n$, 则<br>$$\binom{\alpha}{k} = \binom{-n}{k} = \frac{-n (-n-1) \cdots (-n-k+1)}{k!} = (-1)^k \binom{n+k-1}{k}$$</p><p>所以<br>$$(1+z)^{-n} = \frac{1}{(1+z)^n} = \sum_{k=0}^\infty\; (-1)^k \binom{n+k-1}{k} z^k$$</p><p>为了干掉那个 $-1$, 令 $-z$ 代替 $z$, 得<br>$$(1-z)^{-n} = \frac{1}{(1-z)^n} = \sum_{k=0}^\infty\; \binom{n+k-1}{k} z^k$$</p><p>取 $n=1$, 有 $\binom{n+k-1}{k} = \binom{k}{k} = 1$, 所以<br>$$\frac{1}{1-z} = \sum_{k=0}^\infty\; z^k = 1 + z + z^2 + z^3 + \cdots$$</p><p>类似地, 有<br>$$\frac{1}{1+z} = \sum_{k=0}^\infty\; (-1)^k z^k = 1 - z + z^2 - z^3 \cdots$$</p><p>稍微总结一下</p><p>如果 $n$ 是正整数, $r$ 是非 $0$ 实数, 那么<br>$$(1-rx)^{-n} = \sum_{k=0}^\infty\; \binom{-n}{k} (-rx)^k$$</p><p>或等价地, 有<br>$$\frac{1}{(1-rx)^n} = \sum_{k=0}^\infty\; \binom{n+k-1}{k} r^k x^k$$</p><p>其中 $|x| &lt; \frac{1}{|r|}$.</p><h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><p>可能在生成函数有关的题目会用到这些东西吧…</p><p>$$1 + x + x^2 + \cdots = \frac{1}{1-x} \\<br>1 + x^2 + x^4 + \cdots = 1 + (x)^2 + (x^2)^2 + \cdots = \frac{1}{1 - x^2} \\<br>x + x^2 + x^3 + \cdots = x\; (1 + x + x^2 + \cdots) = \frac{x}{1 - x} \\<br>1 + x + x^2 + x^3 + x^4 = \frac{1 - x^5}{1-x}$$</p><p>最后一个式子似乎是乱入的… 不过还好是显然的, 直接通分验证即可</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="BZOJ-3028-食物"><a href="#BZOJ-3028-食物" class="headerlink" title="BZOJ 3028 食物"></a>BZOJ 3028 食物</h4><ul><li>题目链接: <a href="https://lydsy.com/JudgeOnline/problem.php?id=3028" target="_blank" rel="noopener">https://lydsy.com/JudgeOnline/problem.php?id=3028</a></li></ul><p><del>乐色 OJ 什么都是权限题</del> = =</p><p>首先您要学会生成函数, 然后这就是一道裸题.</p><p>设生成函数为 $g(x)$, 化简后得<br>$$g(x) = \frac{x}{(1-x)^4} = x \sum_{k=0}^\infty\; \binom{k+3}{k} x^k = \sum_{k=0}^\infty\; \binom{k+2}{k-1} x^k$$</p><p>所以第 $n$ 项系数, 即答案, 为 $\binom{n+2}{n-1} = \binom{n+2}{3} = \frac{1}{6} n(n+1)(n+2)$</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>Richard A. Brualdi. 组合数学. 机械工业出版社, 2012.4.</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;数学就是用的时候不够用的东西. = =&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;牛顿二项式定理是对二项式定理的推广, &lt;del&gt;那直接叫广义二项式定理不好吗&lt;/del&gt;, 刚开始看 &amp;lt;组合数学&amp;gt; 的时候见到这个东西, 以为没什么用 = =, 后来…&lt;/p&gt;
&lt;p&gt;当然本文作者没有仔细严谨地学习相关的数学知识, 内容充满谬误, 恳请指正.&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://depletedprism.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Combinatorics" scheme="https://depletedprism.github.io/tags/Combinatorics/"/>
    
  </entry>
  
  <entry>
    <title>「51nod 1348」乘积之和 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/51nod-1348/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/51nod-1348/</id>
    <published>2020-01-18T16:41:47.000Z</published>
    <updated>2020-02-06T03:35:32.288Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接: <a href="https://www.51nod.com/Challenge/Problem.html#problemId=1348" target="_blank" rel="noopener">https://www.51nod.com/Challenge/Problem.html#problemId=1348</a></li></ul><p>分治 FFT 如果使用三模数 NTT, 那么每次合并只需要记录实际模数下的答案…</p><a id="more"></a><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>首先容易发现, 多次询问是个假的限制, 实际上我们可以预先计算出所以答案, 然后每次 $O(1)$ 回答…</p><p>对于每个数, 有选和不选两种选择, 容易构造出生成函数 $g(x)$ 如下, 选择 $k$ 个数的乘积即为 $x^k$ 对应项的系数.<br>$$g(x) = \prod_{i=1}^n (a_i x + 1)$$</p><p>现在的问题就是如何计算这个式子, 有一种无脑且直接的方法就是分治 FFT…</p><p>不过值得注意的是, 这屑题的模数为 $100003 = 2\times 3\times 7\times 2381 + 1$, 并不是友好的 NTT 模数, 于是使用三模数 NTT, (实际上这个模数很小, 用双模数 NTT 就足够了), 统计答案的时候中国剩余定理合并即可.</p><p>然后我就写出了这样的乐色代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span>* a, Num* f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> f[<span class="number">0</span>] = Num(<span class="number">1</span>), <span class="keyword">void</span>( f[<span class="number">1</span>] = Num(a[L]) );</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, Lim = <span class="number">1</span>, K = <span class="number">0</span>;</span><br><span class="line">    Num *f0 = tmp[++idx], *f1 = tmp[++idx];</span><br><span class="line">    divide(L, Mid, a, f0), divide(Mid+<span class="number">1</span>, R, a, f1);</span><br><span class="line">    <span class="keyword">while</span> (Lim &lt;= R-L+<span class="number">1</span>) Lim &lt;&lt;= <span class="number">1</span>, ++K;</span><br><span class="line">    init(Lim, K), NTT(f0, Lim, <span class="number">1</span>), NTT(f1, Lim, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = f0[i] * f1[i], f0[i] = f1[i] = Num(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 注意到这里 f 为在三模数意义下的三个值, 而不是模 100003 意义下的答案 (</span></span><br><span class="line">    NTT(f, Lim, <span class="number">-1</span>), idx -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后接下来就调了好长时间 = =, 终于发现了这个锅,  <del>其实想一想也挺有道理的</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span>* a, <span class="keyword">int</span>* f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> f[<span class="number">0</span>] = <span class="number">1</span>, <span class="keyword">void</span>( f[<span class="number">1</span>] = a[L] );</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, *f0 = tmp[++idx], *f1 = tmp[++idx];</span><br><span class="line">    divide(L, Mid, a, f0), divide(Mid+<span class="number">1</span>, R, a, f1);</span><br><span class="line">    <span class="keyword">int</span> Lim = <span class="number">1</span>, K = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Lim &lt;= R-L+<span class="number">1</span>) Lim &lt;&lt;= <span class="number">1</span>, ++K;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Mid-L+<span class="number">1</span>; ++i) A[i] = Num(f0[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid-L+<span class="number">2</span>; i &lt; Lim; ++i) A[i] = Num(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= R-Mid; ++i) B[i] = Num(f1[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = R-Mid+<span class="number">1</span>; i &lt; Lim; ++i) B[i] = Num(<span class="number">0</span>);</span><br><span class="line">    init(Lim, K), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = A[i] * B[i], f0[i] = f1[i] = <span class="number">0</span>;</span><br><span class="line">    NTT(A, Lim, <span class="number">-1</span>), idx -= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= R-L+<span class="number">1</span>; ++i) f[i] = A[i].Merge();</span><br><span class="line">    <span class="comment">// 只记录模 100003 下的答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 51nod 1348</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e5</span>+<span class="number">5</span>, invP1 = <span class="number">669690699</span>, invP12 = <span class="number">354521948</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P1 = <span class="number">998244353</span>, P2 = <span class="number">1004535809</span>, P3 = <span class="number">469762049</span>, G = <span class="number">3</span>, mod = <span class="number">100003</span>;</span><br><span class="line"><span class="keyword">const</span> LL P12 = <span class="number">1L</span>L * P1 * P2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Num</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    Num() &#123; a = b = c = <span class="number">0</span>; &#125;</span><br><span class="line">    Num(<span class="keyword">int</span> _x): a(_x), b(_x), c(_x) &#123; &#125;</span><br><span class="line">    Num(<span class="keyword">int</span> _a, <span class="keyword">int</span> _b, <span class="keyword">int</span> _c): a(_a), b(_b), c(_c) &#123; &#125;</span><br><span class="line">    <span class="function">Num <span class="title">Mod</span><span class="params">(<span class="keyword">const</span> Num&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Num(x.a + (x.a &gt;&gt; <span class="number">31</span> &amp; P1), x.b + (x.b &gt;&gt; <span class="number">31</span> &amp; P2), x.c + (x.c &gt;&gt; <span class="number">31</span> &amp; P3));</span><br><span class="line">    &#125;</span><br><span class="line">    Num <span class="keyword">operator</span> + (<span class="keyword">const</span> Num&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Mod(Num(a + rhs.a - P1, b + rhs.b - P2, c + rhs.c - P3)); &#125;</span><br><span class="line">    Num <span class="keyword">operator</span> - (<span class="keyword">const</span> Num&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Mod(Num(a - rhs.a, b - rhs.b, c - rhs.c)); &#125;</span><br><span class="line">    Num <span class="keyword">operator</span> * (<span class="keyword">const</span> Num&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Num(<span class="number">1L</span>L * a * rhs.a % P1, <span class="number">1L</span>L * b * rhs.b % P2, <span class="number">1L</span>L * c * rhs.c % P3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Merge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LL x = <span class="number">1L</span>L * (b - a + P2) % P2 * invP1 % P2 * P1 + a;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1L</span>L * (c - x % P3 + P3) % P3 * invP12 % P3 * (P12 % mod) % mod + x) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * base * ret % P;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % P, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    Num A[MAXN], B[MAXN];</span><br><span class="line">    <span class="keyword">int</span> r[MAXN], tmp[<span class="number">31</span>][MAXN], idx = <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(Num* f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="function">Num <span class="title">unit</span><span class="params">( fpow(type &gt; <span class="number">0</span>? G: fpow(G, P1<span class="number">-2</span>, P1), (P1<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>), P1), </span></span></span><br><span class="line"><span class="function"><span class="params">                      fpow(type &gt; <span class="number">0</span>? G: fpow(G, P2<span class="number">-2</span>, P2), (P2<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>), P2),</span></span></span><br><span class="line"><span class="function"><span class="params">                      fpow(type &gt; <span class="number">0</span>? G: fpow(G, P3<span class="number">-2</span>, P3), (P3<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>), P3) )</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="function">Num <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j, w = w * unit) &#123;</span><br><span class="line">                    Num f0 = f[i+j], f1 = w * f[i+j+Mid];</span><br><span class="line">                    f[i+j] = f0 + f1, f[i+j+Mid] = f0 - f1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function">Num <span class="title">inv</span><span class="params">( fpow(Lim, P1<span class="number">-2</span>, P1), fpow(Lim, P2<span class="number">-2</span>, P2), fpow(Lim, P3<span class="number">-2</span>, P3) )</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = f[i] * inv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span>* a, <span class="keyword">int</span>* f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> f[<span class="number">0</span>] = <span class="number">1</span>, <span class="keyword">void</span>( f[<span class="number">1</span>] = a[L] );</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>, *f0 = tmp[++idx], *f1 = tmp[++idx];</span><br><span class="line">        divide(L, Mid, a, f0), divide(Mid+<span class="number">1</span>, R, a, f1);</span><br><span class="line">        <span class="keyword">int</span> Lim = <span class="number">1</span>, K = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Lim &lt;= R-L+<span class="number">1</span>) Lim &lt;&lt;= <span class="number">1</span>, ++K;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Mid-L+<span class="number">1</span>; ++i) A[i] = Num(f0[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid-L+<span class="number">2</span>; i &lt; Lim; ++i) A[i] = Num(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= R-Mid; ++i) B[i] = Num(f1[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = R-Mid+<span class="number">1</span>; i &lt; Lim; ++i) B[i] = Num(<span class="number">0</span>);</span><br><span class="line">        init(Lim, K), NTT(A, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) A[i] = A[i] * B[i], f0[i] = f1[i] = <span class="number">0</span>;</span><br><span class="line">        NTT(A, Lim, <span class="number">-1</span>), idx -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= R-L+<span class="number">1</span>; ++i) f[i] = A[i].Merge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(n), read(q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(A[i]);</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    Poly::divide(<span class="number">1</span>, n, A, f);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> K;</span><br><span class="line">        read(K), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[K]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://www.51nod.com/Challenge/Problem.html#problemId=1348&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.51nod.com/Challenge/Problem.html#problemId=1348&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分治 FFT 如果使用三模数 NTT, 那么每次合并只需要记录实际模数下的答案…&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Polynomial" scheme="https://depletedprism.github.io/tags/Polynomial/"/>
    
  </entry>
  
  <entry>
    <title>「BZOJ 5093」图的价值 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/BZOJ-5093/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/BZOJ-5093/</id>
    <published>2020-01-17T14:27:41.000Z</published>
    <updated>2020-02-27T16:50:20.289Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p> 组合数学学不明白祭.</p></blockquote><ul><li>题目链接: <a href="https://lydsy.com/JudgeOnline/problem.php?id=5093" target="_blank" rel="noopener">https://lydsy.com/JudgeOnline/problem.php?id=5093</a></li></ul><p>根据题意列出式子, 并通过第二类 Stirling 数对式子进行化简, 在合适的时间内计算出结果.</p><a id="more"></a><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><ul><li>NTT</li><li><p>第二类 Stirling 数的一些性质</p><ul><li><p>$m^n=\sum_{i=0}^{m} \begin{Bmatrix}n \\ i\end{Bmatrix}\  i! \cdot  \binom{m}{i}$<br>提供了一个计算自然数幂的新思路.</p></li><li><p>$\begin{Bmatrix} n\\ m\end{Bmatrix} =  \sum_{i=0}^{m} \frac{(-1)^i}{i!} \frac{(m-i)^n}{(m-i)!}$<br>显然是一个卷积的形式, 可以在 $O(n \log n)$ 的时间复杂度计算.</p><p>详尽的解释可以在这里找到: <a href="https://www.cnblogs.com/y2823774827y/p/10700231.html" target="_blank" rel="noopener">https://www.cnblogs.com/y2823774827y/p/10700231.html</a></p></li></ul></li></ul><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>考虑单独枚举一个点的度数 $i$, 那么答案可以表示为 $$n \cdot \sum_{i=0}^{n-1} \binom{n-1}{i} i^k \cdot 2^{\frac{1}{2} (n-1)(n-2)}$$</p><p>如何理解呢? 首先, 每个点在枚举时是等价的, 所以最终结果乘 $n$</p><p>其次, 当前点的贡献为 $i^k$, 考虑度数为 $k$, 即在剩余的 $n-1$ 个点中选择 $i$ 个点. 要求无向图无重边, 剩余的边随意, 方案数为 $2^{\frac{1}{2} (n-1)(n-2)}$.</p><p>整理, 得 $$n \cdot 2^{\frac{1}{2} (n-1)(n-2)} \sum_{i=0}^{n-1} \ \binom{n-1}{i} i^k$$</p><p>现在的问题主要在后半部分, 由第二类 Stirling 数的性质, 得 $$\sum_{i=0}^{n-1} \ \binom{n-1}{i} \sum_{j=0}^{i} \  \begin{Bmatrix}k \\ j \end{Bmatrix}\ j!\ \binom{i}{j}$$</p><p>改变 $i, j$ 的枚举顺序, 有 $$\sum_{j=0}^{n-1}\ \begin{Bmatrix} k\\ j \end{Bmatrix} \cdot j! \ \sum_{i = j}^{n - 1}\ \binom{n-1}{i} \binom{i}{j}$$<br>不过要注意到 $\forall \ m &gt; n,\ \begin{Bmatrix} n \\ m \end{Bmatrix} = 0$</p><p>接下来的 trick 来源于 <a href="https://www.cnblogs.com/Tiw-Air-OAO/p/10286501.html" target="_blank" rel="noopener">Tiw’s Blog</a>, 考虑右边和式的组合意义, 即在 $n-1$ 个物品中选取 $i$ 个物品, 并在 $i$ 个物品中选择 $j$ 个的方案数. 可以发现, 这样等同于在 $n-1$ 个物品中选择 $j$ 个, 剩下部分可选可不选, 这样就同 $i$ 无关了. 可得 $$\sum_{j=0}^{n-1}\ \begin{Bmatrix} k\\ j \end{Bmatrix} \cdot j! \ \binom{n-1}{j}\ 2^{ n-1-j } \\ \sum_{j=0}^{n-1}\ \begin{Bmatrix} k\\ j \end{Bmatrix} \ \frac{(n-1)!}{(n-1-j)!}\ 2^{ n-1-j }$$</p><p>接下来就可以写了…</p><p>先计算 $k$ 对应的第二类 Stirling 数, 之后 $O(n)$ 扫一遍统计答案. 式子中间的一项在 $j$ 增加的过程中每次只多出一个乘积, 顺手维护就好了.</p><p>最后答案 $$n \cdot 2^{\frac{1}{2} (n-1)(n-2)} \sum_{j=0}^{n-1}\ \begin{Bmatrix} k\\ j \end{Bmatrix} \ \frac{(n-1)!}{(n-1-j)!}\ 2^{ n-1-j }$$</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">    Problem: 5093</span></span><br><span class="line"><span class="comment">    User: DepletedPrism</span></span><br><span class="line"><span class="comment">    Language: C++</span></span><br><span class="line"><span class="comment">    Result: Accepted</span></span><br><span class="line"><span class="comment">    Time:10104 ms</span></span><br><span class="line"><span class="comment">    Memory:20352 kb</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// BZOJ 5093</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>, G = <span class="number">3</span>, iG = <span class="number">332748118</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> b, <span class="keyword">int</span> m = P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1L</span>L * ret * base % m;</span><br><span class="line">        base = <span class="number">1L</span>L * base * base % m, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line">    <span class="keyword">int</span> r[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Lim, <span class="keyword">const</span> <span class="keyword">int</span>&amp; L)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) r[i] = (r[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* f, <span class="keyword">int</span> Lim, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Lim; ++i) <span class="keyword">if</span> (i &lt; r[i]) swap(f[i], f[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> Mid = <span class="number">1</span>; Mid &lt; Lim; Mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> unit = fpow(type &gt; <span class="number">0</span>? G: iG, (P<span class="number">-1</span>) / (Mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i += Mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Mid; ++j, w = <span class="number">1L</span>L * w * unit % P) &#123;</span><br><span class="line">                    <span class="keyword">int</span> f0 = f[i+j], f1 = <span class="number">1L</span>L * w * f[i+j+Mid] % P;</span><br><span class="line">                    f[i+j] = (f0 + f1) % P, f[i+j+Mid] = (f0 - f1 + P) % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> inv = fpow(Lim, P<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * inv % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n, K;</span><br><span class="line"><span class="keyword">int</span> f[MAXN], g[MAXN];</span><br><span class="line"><span class="keyword">int</span> inv[MAXN], fac[MAXN];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;K);</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    inv[<span class="number">0</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i) fac[i] = <span class="number">1L</span>L * fac[i<span class="number">-1</span>] * i % P;</span><br><span class="line">    inv[K] = fpow(fac[K], P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = K; i; --i) inv[i<span class="number">-1</span>] = <span class="number">1L</span>L * i * inv[i] % P;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= K; ++i) &#123;</span><br><span class="line">        f[i] = (i &amp; <span class="number">1</span>)? P-inv[i]: inv[i];</span><br><span class="line">        g[i] = <span class="number">1L</span>L * fpow(i, K) * inv[i] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Lim &lt;= <span class="number">2</span>*K) Lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">    Poly::init(Lim, L), Poly::NTT(f, Lim, <span class="number">1</span>), Poly::NTT(g, Lim, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; ++i) f[i] = <span class="number">1L</span>L * f[i] * g[i] % P;</span><br><span class="line">    Poly::NTT(f, Lim, <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, b = <span class="number">1L</span>L * (n<span class="number">-1</span>) * (n<span class="number">-2</span>) / <span class="number">2</span> % (P<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> inv2 = fpow(<span class="number">2</span>, P<span class="number">-2</span>), mul = <span class="number">1</span>, pow2 = fpow(<span class="number">2</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; i &lt;= K; ++i) &#123;</span><br><span class="line">        ans = (ans + <span class="number">1L</span>L * f[i] * mul % P * pow2 % P) % P;</span><br><span class="line">        mul = <span class="number">1L</span>L * mul * (n-i<span class="number">-1</span>) % P, pow2 = <span class="number">1L</span>L * pow2 * inv2 % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, <span class="number">1L</span>L * ans * fpow(<span class="number">2</span>, b) % P * n % P);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt; 组合数学学不明白祭.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://lydsy.com/JudgeOnline/problem.php?id=5093&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://lydsy.com/JudgeOnline/problem.php?id=5093&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据题意列出式子, 并通过第二类 Stirling 数对式子进行化简, 在合适的时间内计算出结果.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Polynomial" scheme="https://depletedprism.github.io/tags/Polynomial/"/>
    
      <category term="Combinatorics" scheme="https://depletedprism.github.io/tags/Combinatorics/"/>
    
  </entry>
  
  <entry>
    <title>小学数学之前 n 个正整数的 a 次方之和</title>
    <link href="https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/sum-of-n/"/>
    <id>https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/sum-of-n/</id>
    <published>2020-01-09T05:09:38.000Z</published>
    <updated>2020-02-27T16:50:20.289Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>我不如小学生.png</p></blockquote><p>作为高中生, 被小学奥 (chang) 数 (shi) 针对了.</p><p>于是, 这里集中了形如 $\sum_{i=1}^n i^a,\ (a = 1,\ 2,\ 3,\ \ldots )$, 即前 $n$ 个正整数的 $a$ 次方和的计算公式.</p><a id="more"></a><h2 id="简单结论"><a href="#简单结论" class="headerlink" title="简单结论"></a>简单结论</h2><p>首先, 有以下结论</p><p>$$\sum_{i=1}^n i = \frac{n(n+1)}{2}$$</p><p>$$\sum_{i=1}^n i^2 = \frac{n(n+1)(2n+1)}{6}$$</p><p>$$\sum_{i=1}^n i^{3} = \frac{n^2(n+1)^2}{4}$$</p><p>至此, 本文结束, <del>你不应该在这个乐色结论上浪费太多时间 (</del>.</p><h2 id="结论证明"><a href="#结论证明" class="headerlink" title="结论证明"></a>结论证明</h2><ul><li><p>$a = 1$</p><p>设 $S_n = \sum_{i=1}^n i$, 并容易发现这就是个公差为 $1$ 的等差数列, 直接上求和公式即可.</p><p>但是, 这是小学生的数学, 我们换一种方式</p><p>$$S_n = 1 + 2 + 3 + \cdots + (n-2) + (n-1) + n \\ S_n = n + (n-1) + (n-2) + \cdots + 3 + 2 + 1$$</p><p>显然有</p><p>$$2S_n = (n+1) + (n+1) + (n+1) + \cdots + (n+1) + (n+1) \\ S_n = \frac{n(n+1)}{2}$$</p><p>这是个数列里普通的技巧 “倒序相加”, <del>也就能拿来骗小学生玩了</del></p><p>但是这个方法不能推广到 $a=2$ 的情况, 于是继续换一种方式</p><p>我们有 $(k-1)^2 = k^2 - 2k + 1$, 移项得 $k^2 - (k-1)^2 = 2k - 1$</p><p>所以 $$\sum_{k=1}^n k^2 - \sum_{k=1}^n (k-1)^2 = 2\sum_{k=1}^n k - n$$</p><p>$$\sum_{k=1}^n k^2 - \sum_{k=1}^{n-1} k^2 = 2\sum_{k=1}^n k - n$$</p><p>所以 $$n^2 = 2S_n - n \\ S_n = \frac{n(n+1)}{2}$$</p></li><li><p>$a = 2$</p><p>同样, 设 $S_n = \sum_{i=1}^n i^2$, 有 $(k-1)^3 = k^3 - 3k^2 + 3k - 1$</p><p>移项, 得 $$k^3 - (k-1)^3 = 3k^2 - 3k + 1$$</p><p>所以 $$\sum_{i=1}^n k^3 - \sum_{i=1}^n (k-1)^3 = 3 \sum_{k=1}^n k^2 - 3 \sum_{i=1}^n k + n$$</p><p>$$\sum_{i=1}^n k^3 - \sum_{i=1}^{n-1} k^3 = n^3 = 3 \sum_{k=1}^n k^2 - 3 \sum_{i=1}^n k + n$$</p><p>经过一番代换, 有 $$\sum_{k=1}^n k^2 = \frac{1}{3} n^3 + \frac{1}{2} n^2 + \frac{1}{6} n = \frac{n(n+1)(2n+1)}{6}$$</p></li><li><p>$a = 3$</p><p>同理可得, 留给读者当作练习 (</p><p>$$\sum_{i=1}^n i^3 = \frac{n^2(n+1)^2}{4}$$</p><p>当然, 这个公式有另一种理解方式  $$\sum_{i=1}^n i^3 = (\sum_{i=1}^n i)^2 = \frac{n(n+1)}{2} \cdot \frac{n(n+1)}{2}$$</p><p>这是为什么呢, 可以参考 <a href="https://proofwiki.org/wiki/Sum_of_Sequence_of_Cubes/Proof_by_Nicomachus" target="_blank" rel="noopener">Nicomachus’s Proof</a></p></li><li><p>$a \geq 4$</p><p>可以用很多方法做, 然而我只会拉格朗日插值.</p><ul><li><p>拉格朗日插值</p><p>详见 <a href="https://codeforces.com/problemset/problem/622/F" target="_blank" rel="noopener">CF622F The Sum of the k-th Powers</a>, 好的实现可以在 $O(a)$ 的时间内计算.</p></li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://brilliant.org/wiki/sum-of-n-n2-or-n3/" target="_blank" rel="noopener">https://brilliant.org/wiki/sum-of-n-n2-or-n3/</a></li><li><a href="https://proofwiki.org/wiki/Sum_of_Sequence_of_Cubes" target="_blank" rel="noopener">https://proofwiki.org/wiki/Sum_of_Sequence_of_Cubes</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;我不如小学生.png&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为高中生, 被小学奥 (chang) 数 (shi) 针对了.&lt;/p&gt;
&lt;p&gt;于是, 这里集中了形如 $\sum_{i=1}^n i^a,\ (a = 1,\ 2,\ 3,\ \ldots )$, 即前 $n$ 个正整数的 $a$ 次方和的计算公式.&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://depletedprism.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Polynomial" scheme="https://depletedprism.github.io/tags/Polynomial/"/>
    
  </entry>
  
  <entry>
    <title>「CERC2014」Virus synthesis 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/luogu-P4762/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/luogu-P4762/</id>
    <published>2020-01-07T11:01:44.000Z</published>
    <updated>2020-03-09T14:47:03.974Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P4762" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P4762</a></li></ul><p>一道回文自动机 + DP 的题, 感觉能启发思路以及学习到一些技巧, 故记之.</p><a id="more"></a><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>假设字符串 $S$ 的长度为 $n$, 容易想到 $O(n^3)$ 的区间 DP 做法, 但是不大可取 = =, 状态数就已经到达了 $O(n^2)$.</p><p>于是换一种思路, 设 $f(i)$ 表示构造 PAM 上第 $i$ 个节点所代表的回文串, 且 $len(i)$ 为偶数, 所需要的最少操作次数, 那么</p><ul><li><p>对于 $i$ 的子节点 $j$, 有 $f(j) = f(i) + 1$</p><p>因为 PAM 的节点表示一个回文串, 那么 $j$ 代表的回文串可以视为 $i$ 代表的回文串两端多出一个字符. 因为 $i$ 是回文串, 考虑在构造字符串 $i$ 时, 一定会有一次 2 操作, 否则就不是最优解. 那么, 我们就可以在这次 2 操作之前, 在 $i$ 的某端添加一个字符, 这样从 $i$ 到 $j$ 只需要一次操作.</p></li><li><p>假设 $j$ 是 $i$ 的一个回文后缀, 且满足 $2 \cdot len(j) \leq len(i)$, 有  $$f(i) = \min\{f(j) + 1 + len(i) / 2 - len(j)\}$$</p><p>这里将 $i$ 视为 $j$ 通过 1 操作填到一半, 再通过一次 2 操作构造而来.</p></li></ul><p>然后答案很好统计了, 可以把最终的字符串视为一个回文串和多次 1 操作堆叠而成, 那么 $$ans = \min\{f(i) + n - len(i)\}$$</p><p>现在的问题就是如何实现转移. </p><p>对于第一个转移, 没什么好说的, 在 PAM 偶节点从上到下 BFS 一遍就好了, (似乎有在线的做法, 在新加入节点时更新 $f(i)$ 的值).</p><p>对于第二个转移, 需要处理出满足 $i$ 满足 $2 \cdot len(j) \leq len(i)$ 的最长回文后缀, 记为 $trans(i)$ 可以通过求 fail 类似的方法维护, 只是在跳 fail 的时候多了一个限制条件, 相同的技巧也在 <a href="https://www.luogu.com.cn/problem/P4287" target="_blank" rel="noopener">[SHOI2011]双倍回文</a> 使用过.</p><h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P4762</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">5</span>, SIGMA = <span class="number">4</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> M[<span class="number">128</span>], f[MAXN];</span><br><span class="line"><span class="keyword">char</span> S[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PAM &#123;</span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][SIGMA], len[MAXN], trans[MAXN], fail[MAXN], last, nidx, ptr;</span><br><span class="line">    <span class="keyword">char</span> S[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="keyword">sizeof</span> ch);</span><br><span class="line">        last = <span class="number">0</span>, nidx = <span class="number">1</span>;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>, fail[<span class="number">0</span>] = <span class="number">1</span>, len[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        S[ptr = <span class="number">0</span>] = <span class="string">'$'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getfail</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (S[ptr-len[u]<span class="number">-1</span>] != S[ptr]) u = fail[u];</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        S[++ptr] = c;</span><br><span class="line">        <span class="keyword">int</span> val = M[(<span class="keyword">int</span>) c], nd = getfail(last);</span><br><span class="line">        <span class="keyword">if</span> (!ch[nd][val]) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = ++nidx;</span><br><span class="line">            len[p] = len[nd] + <span class="number">2</span>;</span><br><span class="line">            fail[p] = ch[getfail(fail[nd])][val];</span><br><span class="line">            <span class="keyword">if</span> (len[p] &lt;= <span class="number">2</span>) trans[p] = fail[p];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> u = trans[nd];</span><br><span class="line">                <span class="comment">// int u = fail[nd];</span></span><br><span class="line">                <span class="comment">// 如果写成以上写法, 复杂度就是假的 = =</span></span><br><span class="line">                <span class="keyword">while</span> (S[ptr-len[u]<span class="number">-1</span>] != S[ptr] || <span class="number">2</span>*(len[u]+<span class="number">2</span>) &gt; len[p]) u = fail[u];</span><br><span class="line">                trans[p] = ch[u][val];</span><br><span class="line">            &#125;</span><br><span class="line">            ch[nd][val] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        last = ch[nd][val];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> Q[MAXN], head, tail, ret;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        ret = n, f[<span class="number">0</span>] = <span class="number">1</span>, Q[head = tail = <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意答案的最大值为 n, 如果不存在长度为偶数的回文串, 那么 min&#123;f&#125; = INF...</span></span><br><span class="line">        <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q[head++];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; SIGMA; ++c) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = ch[u][c];</span><br><span class="line">                <span class="keyword">if</span> (!i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> j = trans[i];</span><br><span class="line">                f[i] = min(f[i], min(f[u] + <span class="number">1</span>, f[j] + <span class="number">1</span> + len[i] / <span class="number">2</span> - len[j]));</span><br><span class="line">                ret = min(ret, f[i] + n - len[i]);</span><br><span class="line">                Q[++tail] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"1.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    M[<span class="string">'A'</span>] = <span class="number">0</span>, M[<span class="string">'C'</span>] = <span class="number">1</span>, M[<span class="string">'G'</span>] = <span class="number">2</span>, M[<span class="string">'T'</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> Ti;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        PAM::init();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S+<span class="number">1</span>);</span><br><span class="line">        n = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(S+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) PAM::insert(S[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, PAM::solve());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h4><p>上述代码成功拿到了 67 pts 的好成绩, 在第一个点跑了很久…</p><p>通过学习其他人的卡常技巧, 算是卡了过去</p><ol><li>用到再初始化 <code>ch</code> 的值</li><li>BFS 遍历 PAM 时, 每个节点只更新一次</li><li>给 $f(i)$ 赋初值为节点的长度 $len(i)$, 并只在 $len(i)$ 为偶数的时候更新 $f(i)$</li><li>使用 <code>ckmin</code> 更新最小值</li></ol><p>话说用 <code>static</code> 把数组开到函数里会快一点? 不明所以.png</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P4762</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">5</span>, SIGMA = <span class="number">4</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> M[<span class="number">128</span>], f[MAXN];</span><br><span class="line"><span class="keyword">char</span> S[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PAM &#123;</span><br><span class="line">    <span class="keyword">int</span> ch[MAXN][SIGMA], len[MAXN], trans[MAXN], fail[MAXN], last, nidx, ptr;</span><br><span class="line">    <span class="keyword">char</span> S[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.</span></span><br><span class="line">        <span class="built_in">memset</span>(ch[<span class="number">0</span>], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">memset</span>(ch[<span class="number">1</span>], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[<span class="number">1</span>]);</span><br><span class="line">        last = <span class="number">0</span>, nidx = <span class="number">1</span>;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>, fail[<span class="number">0</span>] = <span class="number">1</span>, len[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        S[ptr = <span class="number">0</span>] = <span class="string">'$'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getfail</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (S[ptr-len[u]<span class="number">-1</span>] != S[ptr]) u = fail[u];</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        S[++ptr] = c;</span><br><span class="line">        <span class="keyword">int</span> val = M[(<span class="keyword">int</span>) c], nd = getfail(last);</span><br><span class="line">        <span class="keyword">if</span> (!ch[nd][val]) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = ++nidx;</span><br><span class="line">            <span class="comment">// 1.</span></span><br><span class="line">            <span class="built_in">memset</span>(ch[p], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[p]);</span><br><span class="line">            len[p] = len[nd] + <span class="number">2</span>;</span><br><span class="line">            fail[p] = ch[getfail(fail[nd])][val];</span><br><span class="line">            <span class="keyword">if</span> (len[p] &lt;= <span class="number">2</span>) trans[p] = fail[p];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> u = trans[nd];</span><br><span class="line">                <span class="keyword">while</span> (S[ptr-len[u]<span class="number">-1</span>] != S[ptr] || <span class="number">2</span>*(len[u]+<span class="number">2</span>) &gt; len[p]) u = fail[u];</span><br><span class="line">                trans[p] = ch[u][val];</span><br><span class="line">            &#125;</span><br><span class="line">            ch[nd][val] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        last = ch[nd][val];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ckmin</span><span class="params">(T&amp; x, <span class="keyword">const</span> T&amp; y)</span> </span>&#123; <span class="keyword">if</span> (x &gt; y) x = y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> vis[MAXN], Time, Q[MAXN], head, tail, ret;</span><br><span class="line">        ++Time;</span><br><span class="line">        <span class="comment">// 3.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nidx; ++i) f[i] = len[i];</span><br><span class="line">        ret = n, f[<span class="number">0</span>] = <span class="number">1</span>, Q[head = tail = <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q[head++];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; SIGMA; ++c) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = ch[u][c];</span><br><span class="line">                <span class="keyword">if</span> (!i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> j = trans[i];</span><br><span class="line">                f[i] = f[u] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 3.</span></span><br><span class="line">                <span class="keyword">if</span> (len[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                    ckmin(f[i], f[j] + <span class="number">1</span> + len[i] / <span class="number">2</span> - len[j]);</span><br><span class="line">                ckmin(ret, f[i] + n - len[i]);</span><br><span class="line">                <span class="comment">// 2.</span></span><br><span class="line">                <span class="keyword">if</span> (vis[i] != Time) Q[++tail] = i, vis[i] = Time;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"1.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    M[<span class="string">'A'</span>] = <span class="number">0</span>, M[<span class="string">'C'</span>] = <span class="number">1</span>, M[<span class="string">'G'</span>] = <span class="number">2</span>, M[<span class="string">'T'</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> Ti;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Ti);</span><br><span class="line">    <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">        PAM::init();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S+<span class="number">1</span>);</span><br><span class="line">        n = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(S+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) PAM::insert(S[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, PAM::solve());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://www.luogu.com.cn/problem/P4762&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.com.cn/problem/P4762&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一道回文自动机 + DP 的题, 感觉能启发思路以及学习到一些技巧, 故记之.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="String" scheme="https://depletedprism.github.io/tags/String/"/>
    
      <category term="Dynamic Programing" scheme="https://depletedprism.github.io/tags/Dynamic-Programing/"/>
    
  </entry>
  
  <entry>
    <title>「SCOI2012」喵星球上的点名 题解</title>
    <link href="https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/luogu-P2336/"/>
    <id>https://depletedprism.github.io/%E9%A2%98%E8%A7%A3/sol/oj/luogu-P2336/</id>
    <published>2020-01-02T12:47:48.000Z</published>
    <updated>2020-02-24T08:53:16.725Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>题目链接: <a href="https://www.luogu.com.cn/problem/P2336" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P2336</a></li></ul><p>一道后缀数组的题, 毒瘤了我大半个晚上, 故写题解以纪念.</p><a id="more"></a><h4 id="一些约定"><a href="#一些约定" class="headerlink" title="一些约定"></a>一些约定</h4><ol><li>字符串下标从 $1$ 开始</li><li>记 $sa[i]$ 表示字符串所有后缀排序后第 $i$ 大的后缀的编号, $rnk[i]$ 表示后缀 $i$ 在 $sa$ 中的下标, 即后缀 $i$ 在所有后缀中的排名</li></ol><h4 id="运用到-SA-的性质"><a href="#运用到-SA-的性质" class="headerlink" title="运用到 SA 的性质"></a>运用到 SA 的性质</h4><ol><li><p>SA 中前缀相同的串排在一起, 也就是说, SA 按照字典序对所有后缀排序</p></li><li><p>两子串最长公共前缀 $$\text{LCP}(sa[i], sa[j]) = \min_{k = i+1}^j { \text{height[k]} }$$</p></li></ol><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>首先, 我们的任务是确定一个字符串是不是一个字符串的子串, 可以联想到的算法有 AC 自动机, 哈希之类的东西… 不过这道题的字符集大小达到了 $10^4$, 感觉 SA 似乎更可做一点.</p><p>那么, 怎么用 SA 确定一个字符串是否是另一个字符串的子串呢? 可以通过 LCP 来做.</p><p>现在有一个显然的事情, 如果一个字符串 $S$ 是 $T$ 的子串, 那么 $T$ 存在一个后缀 $T’$, 使得 $\text{LCP}(S, T’) = |S|$.</p><p>对于一个 $S$ 和一个 $T$, 可以将 $S,\ T$ 拼接成一个新串, 中间用一个从未出现过的字符连接, 通过对新串求后缀数组, 然后再二分判定.</p><p>回到这道题上来, 对于多个 $S$, $T$, 也可以用相同的方式. 对于一个 “点名串” $S$, 包含 $S$ 的字符串一定在 $sa$ 是一段连续的区间. 那么, 现在的问题就是序列上的问题了.</p><ol><li>区间 $[L, R]$ 中不同猫的个数;</li><li>询问完之后猫的点名次数.</li></ol><p><del>存在使用树状数组 / 线段树的做法, 可惜实在学不会, 于是使用了莫队</del></p><p>考虑莫队, 第一个问题比较经典, 开一个桶记录猫在现在维护区间内出现次数, 在出现次数改变为 0 / 1 时更新答案就可以了. 对于第二个问题, 参考了 <a href="https://www.luogu.com.cn/blog/hl666/solution-p2336" target="_blank" rel="noopener">hl666 的题解</a> = =, 每次有新的猫进入区间, 或者一只猫已经完全离开现在的区间时, 更新当前情况下被点到次数的最大值.</p><p>但是这样为什么是对的呢? 考虑一只猫进出区间的两个过程, 虽然我们在进入区间的时候给他算上了最大的可能点名次数, 但是在离开又减去了可能的最大值. 感性理解一下, 差值就像是正确答案…</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>写起来 rnk, sa, idx 翻来覆去 = =</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P2336</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXSIZE, <span class="built_in">stdin</span>), p1 == p2)? EOF: *p1++; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">'-'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = Gc();</span><br><span class="line">        <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"><span class="comment">// 普通的读入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span>+<span class="number">5</span>, MAXM = <span class="number">1e4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> block;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> idx, L, R;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Ask&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> R / block == rhs.R / block? (L == rhs.L? <span class="number">0</span>: ((R / block) &amp; <span class="number">1</span>) &amp; (L &lt; rhs.L)): R &lt; rhs.R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Q[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, N, q;</span><br><span class="line"><span class="keyword">int</span> A[MAXN];</span><br><span class="line"><span class="keyword">int</span> S[MAXN]; <span class="comment">// 拼接后的数组</span></span><br><span class="line"><span class="keyword">int</span> idx[MAXN]; <span class="comment">// 拼接后第 i 个位置对应原字符串的编号</span></span><br><span class="line"><span class="keyword">int</span> firstpos[MAXN]; <span class="comment">// 点名串对应在 S 中的位置, 二分区间左右端点使用</span></span><br><span class="line"><span class="keyword">int</span> qlen[MAXN]; <span class="comment">// 点名串长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> id)</span> </span>&#123; S[++n] = val, idx[n] = id; &#125; <span class="comment">// 更新 S</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SA &#123;</span><br><span class="line">    <span class="keyword">int</span> sa[MAXN], rnk[MAXN], id[MAXN], px[MAXN], ht[MAXN], cnt[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[x] == id[y] &amp;&amp; id[x+k] == id[y+k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, k, p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) ++cnt[rnk[i] = S[i]];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i) cnt[i] += cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i = n; i; --i) sa[cnt[rnk[i]]--] = i;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n &amp;&amp; p &lt; n; k &lt;&lt;= <span class="number">1</span>, m = p) &#123;</span><br><span class="line">            <span class="keyword">for</span> (p = <span class="number">0</span>, i = n; i &gt; n-k; --i) id[++p] = i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (sa[i] &gt; k) id[++p] = sa[i]-k;</span><br><span class="line">            <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> (<span class="keyword">int</span>) * (m+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) ++cnt[px[i] = rnk[id[i]]];</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i) cnt[i] += cnt[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span> (i = n; i; --i) sa[cnt[px[i]]--] = id[i]; <span class="comment">// 这里打挂过</span></span><br><span class="line">            swap(rnk, id), rnk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++i) rnk[sa[i]] = cmp(sa[i], sa[i<span class="number">-1</span>], k)? p: ++p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) rnk[sa[i]] = i; <span class="comment">// 这里打挂过</span></span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>, i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k) --k;</span><br><span class="line">            <span class="keyword">while</span> (S[i + k] == S[sa[rnk[i]<span class="number">-1</span>] + k]) ++k;</span><br><span class="line">            ht[rnk[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> SA::rnk; <span class="keyword">using</span> SA::sa;</span><br><span class="line"><span class="comment">// SA 倍增实现模板</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ST &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> LOG = <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">int</span> minHt[LOG][MAXN], lg2[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) minHt[<span class="number">0</span>][i] = SA::ht[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; LOG; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span> &lt;= n; ++i)</span><br><span class="line">                minHt[j][i] = min(minHt[j<span class="number">-1</span>][i], minHt[j<span class="number">-1</span>][i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))]);</span><br><span class="line">        lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) lg2[i] = lg2[i/<span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">RMQ</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = lg2[R-L+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> min(minHt[k][L], minHt[k][R-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现 RMQ</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MoAlg &#123;</span><br><span class="line">    <span class="keyword">int</span> L, R, ans1;</span><br><span class="line">    <span class="keyword">int</span> Ans1[MAXN], Ans2[MAXN], cnt[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        pos = idx[pos];</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= N &amp;&amp; ++cnt[pos] == <span class="number">1</span>) ++ans1, Ans2[pos] += q-cur+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 只统计编号在猫范围之内的种类数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        pos = idx[pos];</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= N &amp;&amp; --cnt[pos] == <span class="number">0</span>) --ans1, Ans2[pos] -= q-cur+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 只统计编号在猫范围之内的种类数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        block = <span class="keyword">int</span>( n / <span class="built_in">sqrt</span>(q) );</span><br><span class="line">        sort(Q+<span class="number">1</span>, Q+<span class="number">1</span>+q);</span><br><span class="line">        L = <span class="number">1</span>, R = ans1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> Ask&amp; qr = Q[i];</span><br><span class="line">            <span class="keyword">while</span> (L &gt; qr.L) add(sa[--L], i);</span><br><span class="line">            <span class="keyword">while</span> (R &gt; qr.R) del(sa[R--], i);</span><br><span class="line">            <span class="keyword">while</span> (L &lt; qr.L) del(sa[L++], i);</span><br><span class="line">            <span class="keyword">while</span> (R &lt; qr.R) add(sa[++R], i);</span><br><span class="line">            Ans1[qr.idx] = ans1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> MoAlg::Ans1; <span class="keyword">using</span> MoAlg::Ans2;</span><br><span class="line"><span class="comment">// 莫队</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"input.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    read(N), read(q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k, i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        read(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) read(A[j]), add(A[j]+<span class="number">1</span>, i);</span><br><span class="line">        add(MAXM + <span class="number">2</span>*i<span class="number">-1</span>, N+<span class="number">1</span>);</span><br><span class="line">        read(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) read(A[j]), add(A[j]+<span class="number">1</span>, i);</span><br><span class="line">        add(MAXM + <span class="number">2</span>*i, N+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k, i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        read(k), qlen[i] = k, firstpos[i] = n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) read(A[j]), add(A[j]+<span class="number">1</span>, N + i);</span><br><span class="line">        add(MAXM + <span class="number">2</span>*N + i, N+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// solve</span></span><br><span class="line">    SA::build(MAXM + <span class="number">2</span>*N + q), ST::init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> L, R, qL, qR;</span><br><span class="line">        L = <span class="number">1</span>, R = rnk[firstpos[i]]<span class="number">-1</span>, qL = rnk[firstpos[i]];</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// LCP, 注意到 +1</span></span><br><span class="line">            <span class="keyword">if</span> (ST::RMQ(Mid + <span class="number">1</span>, rnk[firstpos[i]]) &gt;= qlen[i]) qL = Mid, R = Mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> L = Mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        L = rnk[firstpos[i]]+<span class="number">1</span>, R = n, qR = rnk[firstpos[i]];</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// LCP, 注意到 +1</span></span><br><span class="line">            <span class="keyword">if</span> (ST::RMQ(rnk[firstpos[i]] + <span class="number">1</span>, Mid) &gt;= qlen[i]) qR = Mid, L = Mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> R = Mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Q[i] = (Ask)&#123; i, qL, qR &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    MoAlg::solve();</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans1[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, Ans2[i], <span class="string">" \n"</span>[i==N]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="得出的一些调试的经验"><a href="#得出的一些调试的经验" class="headerlink" title="得出的一些调试的经验?"></a>得出的一些调试的经验?</h4><ol><li>如果不保证模板的正确性, 先检查以下板子… = =</li><li><del>抄题解的时候注意一些细节, 以免调试半天发现是细节问题</del></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;题目链接: &lt;a href=&quot;https://www.luogu.com.cn/problem/P2336&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.com.cn/problem/P2336&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一道后缀数组的题, 毒瘤了我大半个晚上, 故写题解以纪念.&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://depletedprism.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Data Structure" scheme="https://depletedprism.github.io/tags/Data-Structure/"/>
    
      <category term="String" scheme="https://depletedprism.github.io/tags/String/"/>
    
  </entry>
  
</feed>
