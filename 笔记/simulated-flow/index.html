<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    一些简单的模拟费用流问题
  
</title>

<meta name="description" content="祝贺我又学了一个学不明白的东西 ( 综述模拟费用流, 大概是利用流的一些性质, 从而用数据结构高效模拟费用流. 基础理论和模型可以看看文末的参考资料, 这里只是记录我做过的一些题目.">
<meta property="og:type" content="article">
<meta property="og:title" content="一些简单的模拟费用流问题">
<meta property="og:url" content="https://depletedprism.github.io/%E7%AC%94%E8%AE%B0/simulated-flow/index.html">
<meta property="og:site_name" content="DepletedPrism&#39;s Blog">
<meta property="og:description" content="祝贺我又学了一个学不明白的东西 ( 综述模拟费用流, 大概是利用流的一些性质, 从而用数据结构高效模拟费用流. 基础理论和模型可以看看文末的参考资料, 这里只是记录我做过的一些题目.">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-06-06T05:28:55.000Z">
<meta property="article:modified_time" content="2022-03-27T10:05:16.475Z">
<meta property="article:author" content="DepletedPrism">
<meta property="article:tag" content="Graph">
<meta property="article:tag" content="Greedy">
<meta name="twitter:card" content="summary">


  <link rel="alternative" href="/atom.xml" title="DepletedPrism&#39;s Blog" type="application/atom+xml">



  <link rel="icon" href="/images/favicon.jpg">



<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">


<link rel="stylesheet" href="/styles/main.css">







<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>
<body
  
    class="monochrome"
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">DepletedPrism&#39;s Blog</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">DepletedPrism&#39;s Blog</a></h1>
    
      <p class="subtitle">
        厌离秽土, 欣求净土.
      </p>
    
    <div class="info">
      <div class="content">
        
        
          <div class="author">DepletedPrism</div>
        
      </div>
      
        <div class="avatar">
          
            <a href="/about"><img src="/images/favicon.jpg"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">分类</a>
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a><span class="category-list-count">46</span></li></ul>
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">标签</a>
                <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Combinatorics/" rel="tag">Combinatorics</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dynamic-Programming/" rel="tag">Dynamic Programming</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Geometry/" rel="tag">Geometry</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Graph/" rel="tag">Graph</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Greedy/" rel="tag">Greedy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Number-Theory/" rel="tag">Number Theory</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Polynomial/" rel="tag">Polynomial</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Probability-Mean/" rel="tag">Probability & Mean</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/String/" rel="tag">String</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vim/" rel="tag">Vim</a><span class="tag-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">归档</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/9102/">9102</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">43</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">16</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/index.html" title="Homepage" external="false">Homepage</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://github.com/DepletedPrism" title="Github" target="_blank" rel="noopener">Github</a>
              </li>
            
          
            
              <li>
                <a href="https://codeforces.com/profile/DepletedPrism" title="Codeforces" target="_blank" rel="noopener">Codeforces</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          <article id="post-simulated-flow" class="article article-type-post">
  
    <h1 class="article-header">
      一些简单的模拟费用流问题
    </h1>
  
  

  <div class="article-info">
    <span class="article-date">
  2020-06-06
</span>

    
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></li></ul>
	</span>


    
	<span class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Graph/" rel="tag">Graph</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Greedy/" rel="tag">Greedy</a></li></ul>
	</span>


	
  </div>
  <div class="article-entry">
    <hr>
<p>祝贺我又学了一个学不明白的东西 (</p>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>模拟费用流, 大概是利用流的一些性质, 从而用数据结构高效模拟费用流.</p>
<p>基础理论和模型可以看看文末的参考资料, 这里只是记录我做过的一些题目.</p>
<span id="more"></span>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>题目顺序随心情.</p>
<hr>
<p>首先是一些 “模拟” 费用流的例子.</p>
<h3 id="CF280D-k-Maximum-Subsequence-Sum"><a href="#CF280D-k-Maximum-Subsequence-Sum" class="headerlink" title="CF280D k-Maximum Subsequence Sum"></a>CF280D k-Maximum Subsequence Sum</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://codeforces.com/problemset/problem/280/D">https://codeforces.com/problemset/problem/280/D</a></li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先有一个费用流做法. 设源汇点 $S$, $T$, 同时将每个位置拆为入点 $i$ 和出点 $i’$.</p>
<ol>
<li>连边 $(S, S’)$, 容量为 $k$, 费用为 $0$.</li>
<li>连边 $(S’, i)$, 容量为 $1$, 费用为 $0$.</li>
<li>连边 $(i, i’)$, 容量为 $1$, 费用为 $a_i$.</li>
<li>连边 $(i’, i + 1)$, 容量为 $1$, 费用为 $0$.</li>
<li>连边 $(i’, T)$, 容量为 $1$, 费用为 $0$.</li>
</ol>
<p>此时将费用取反, 求最小费用流即可. 可惜时间复杂度不够优秀.</p>
<p>注意到每次增广的过程, 本质上是选择序列一段区间中的最大连续子段和, 直接用线段树维护即可.</p>
<p>同时需要维护反向边, 也就是将该区间翻转并将权值取反. 那么记录子段和时需记录该子段对应区间端点, 以及最小子段和, 用于权值取反后快速计算现有区间最大子段和. 这样区间取反可打标记维护.</p>
<p>根据这个思路, 单点修改就没什么意思了. 注意每组询问直接独立, 在区间取反后需要撤销影响.</p>
<p>时间复杂度 $O(n \log n)$.</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CF280D</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>, MAXM = MAXN &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, top;</span><br><span class="line"><span class="keyword">int</span> A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> L, R, v;</span><br><span class="line">  <span class="built_in">Item</span>() &#123; L = MAXN, R = -MAXN, v = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="built_in">Item</span>(<span class="keyword">int</span> _L, <span class="keyword">int</span> _R, <span class="keyword">int</span> _v): <span class="built_in">L</span>(_L), <span class="built_in">R</span>(_R), <span class="built_in">v</span>(_v) &#123; &#125;</span><br><span class="line">  Item <span class="keyword">operator</span> + (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Item</span>(<span class="built_in">min</span>(L, rhs.L), <span class="built_in">max</span>(R, rhs.R), v + rhs.v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v &lt; rhs.v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; stk[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (nd &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (nd &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="keyword">namespace</span> SGT &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Item s, MxL, MxR, MxM, MnL, MnR, MnM;</span><br><span class="line">    <span class="built_in">Node</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">Node</span>(Item v) &#123; s = MxL = MxR = MxM = MnL = MnR = MnM = v; &#125;</span><br><span class="line">    Node <span class="keyword">operator</span> + (<span class="keyword">const</span> Node&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">      Node ret;</span><br><span class="line">      ret.s = s + rhs.s;</span><br><span class="line"></span><br><span class="line">      ret.MxL = <span class="built_in">max</span>(MxL, s + rhs.MxL);</span><br><span class="line">      ret.MxR = <span class="built_in">max</span>(rhs.MxR, rhs.s + MxR);</span><br><span class="line">      ret.MxM = <span class="built_in">max</span>(MxR + rhs.MxL, <span class="built_in">max</span>(MxM, rhs.MxM));</span><br><span class="line"></span><br><span class="line">      ret.MnL = <span class="built_in">min</span>(MnL, s + rhs.MnL);</span><br><span class="line">      ret.MnR = <span class="built_in">min</span>(rhs.MnR, rhs.s + MnR);</span><br><span class="line">      ret.MnM = <span class="built_in">min</span>(MnR + rhs.MnL, <span class="built_in">min</span>(MnM, rhs.MnM));</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; dat[MAXM];</span><br><span class="line">  <span class="keyword">bool</span> res[MAXM];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123; dat[nd] = dat[lc] + dat[rc]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(dat[nd].MxM, dat[nd].MnM);</span><br><span class="line">    <span class="built_in">swap</span>(dat[nd].MxL, dat[nd].MnL), <span class="built_in">swap</span>(dat[nd].MxR, dat[nd].MnR);</span><br><span class="line">    dat[nd].s.v *= <span class="number">-1</span>;</span><br><span class="line">    dat[nd].MxL.v *= <span class="number">-1</span>, dat[nd].MxR.v *= <span class="number">-1</span>, dat[nd].MxM.v *= <span class="number">-1</span>;</span><br><span class="line">    dat[nd].MnL.v *= <span class="number">-1</span>, dat[nd].MnR.v *= <span class="number">-1</span>, dat[nd].MnM.v *= <span class="number">-1</span>;</span><br><span class="line">    res[nd] ^= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> nd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (res[nd]) <span class="built_in">push</span>(lc), <span class="built_in">push</span>(rc), res[nd] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>( dat[nd] = <span class="built_in">Item</span>(L, R, A[L]) );</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc, L, Mid), <span class="built_in">build</span>(rc, Mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">maintain</span>(nd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Rev</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> <span class="built_in">push</span>(nd);</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(nd);</span><br><span class="line">    <span class="keyword">if</span> (opL &lt;= Mid) <span class="built_in">Rev</span>(lc, L, Mid, opL, opR);</span><br><span class="line">    <span class="keyword">if</span> (opR &gt; Mid) <span class="built_in">Rev</span>(rc, Mid + <span class="number">1</span>, R, opL, opR);</span><br><span class="line">    <span class="built_in">maintain</span>(nd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; p, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>( dat[nd] = <span class="built_in">Item</span>(L, R, v) );</span><br><span class="line">    <span class="built_in">pushdown</span>(nd);</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= Mid) <span class="built_in">Mdy</span>(lc, L, Mid, p, v); <span class="keyword">else</span> <span class="built_in">Mdy</span>(rc, Mid + <span class="number">1</span>, R, p, v);</span><br><span class="line">    <span class="built_in">maintain</span>(nd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Node <span class="title">Qry</span><span class="params">(<span class="keyword">int</span> nd, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opL, <span class="keyword">const</span> <span class="keyword">int</span>&amp; opR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opL &lt;= L &amp;&amp; R &lt;= opR) <span class="keyword">return</span> dat[nd];</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(nd);</span><br><span class="line">    <span class="keyword">if</span> (opR &lt;= Mid) <span class="keyword">return</span> <span class="built_in">Qry</span>(lc, L, Mid, opL, opR);</span><br><span class="line">    <span class="keyword">if</span> (opL &gt; Mid) <span class="keyword">return</span> <span class="built_in">Qry</span>(rc, Mid + <span class="number">1</span>, R, opL, opR);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Qry</span>(lc, L, Mid, opL, opR) + <span class="built_in">Qry</span>(rc, Mid + <span class="number">1</span>, R, opL, opR);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">read</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(A[i]);</span><br><span class="line"></span><br><span class="line">  SGT::<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">read</span>(q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> opt, L, R, k, ans; q; --q) &#123;</span><br><span class="line">    <span class="built_in">read</span>(opt), <span class="built_in">read</span>(L);</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (opt) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">read</span>(k), SGT::<span class="built_in">Mdy</span>(<span class="number">1</span>, <span class="number">1</span>, n, L, k);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">read</span>(R), <span class="built_in">read</span>(k), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">          Item v = SGT::<span class="built_in">Qry</span>(<span class="number">1</span>, <span class="number">1</span>, n, L, R).MxM;</span><br><span class="line">          <span class="keyword">if</span> (v.v &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">          ans += v.v, SGT::<span class="built_in">Rev</span>(<span class="number">1</span>, <span class="number">1</span>, n, v.L, v.R), stk[++top] = v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          Item v = stk[top--];</span><br><span class="line">          SGT::<span class="built_in">Rev</span>(<span class="number">1</span>, <span class="number">1</span>, n, v.L, v.R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>: <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ERR\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="Luogu-P6122「NEERC2016」Mole-Tunnels"><a href="#Luogu-P6122「NEERC2016」Mole-Tunnels" class="headerlink" title="Luogu P6122「NEERC2016」Mole Tunnels"></a>Luogu P6122「NEERC2016」Mole Tunnels</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://www.luogu.com.cn/problem/P6122">https://www.luogu.com.cn/problem/P6122</a></li>
</ul>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先有一个费用流思路. 设源汇点分别为 $S$, $T$, 将每只鼹鼠视作流量.</p>
<ol>
<li>对于树上每条边, 连边 $(u, \lfloor \frac{u}{2} \rfloor)$, $(\lfloor \frac{u}{2} \rfloor, u)$, 容量为 $\infty$, 费用为 $1$.</li>
<li>对于树上每个点 $u$, 连边 $(u, T)$, 容量为 $c_u$, 费用为 $0$.</li>
<li>对于每只鼹鼠, 依次向其树上所在位置 $u$ 连边 $(S, u)$, 容量为 $1$, 费用为 $0$.</li>
</ol>
<p>观察每次增广的过程, 都是选择树上一条路径, 为保证费用尽量小, 显然是在要求路径尽量短.</p>
<p>考虑到题中给定树为二叉树, 其深度为 $O(\log n)$. 枚举新增鼹鼠位置 $s$ 和最终匹配位置的 LCA $t$. 同时对每个节点 $u$ 记录位置 $p(u)$, 表示 $u$ 子树内同 $u$ 匹配的最优位置.</p>
<p>此时增广的路径即 $s \rightarrow t \rightarrow {p}(t)$, 更新流量计算费用即可.</p>
<p>${p}(u)$ 可从下向上递推计算. 另外需记录树边中的流量. 为了便于计算路径费用, 将连向祖先的流量视作正数, 相反则视作负数.</p>
<p>时间复杂度 $O(n \log n)$.</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P6122</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a &gt; b)? a = b, <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> C[MAXN], flow[MAXN], d[MAXN], p[MAXN];</span><br><span class="line"><span class="comment">// flow: u --&gt; pre(u) 流量, d: u --&gt; 匹配位置 距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">augment</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> lc = u &lt;&lt; <span class="number">1</span>, rc = u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">  d[u] = INF, p[u] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (C[u] &gt; <span class="number">0</span>) d[u] = <span class="number">0</span>, p[u] = u;</span><br><span class="line">  <span class="keyword">if</span> (lc &lt;= n &amp;&amp; <span class="built_in">ckmin</span>(d[u], d[lc] + ((flow[lc] &gt; <span class="number">0</span>)? <span class="number">-1</span>: <span class="number">1</span>)))</span><br><span class="line">    p[u] = p[lc];</span><br><span class="line">  <span class="keyword">if</span> (rc &lt;= n &amp;&amp; <span class="built_in">ckmin</span>(d[u], d[rc] + ((flow[rc] &gt; <span class="number">0</span>)? <span class="number">-1</span>: <span class="number">1</span>)))</span><br><span class="line">    p[u] = p[rc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, C + i);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> u = n; u; --u) <span class="built_in">augment</span>(u);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k) &#123;</span><br><span class="line">    <span class="keyword">int</span> s, t = <span class="number">0</span>, cost = INF, ds = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = s; u &gt; <span class="number">0</span>; u /= <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ckmin</span>(cost, ds + d[u])) t = u;</span><br><span class="line">      ds += ((flow[u] &lt; <span class="number">0</span>)? <span class="number">-1</span>: <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ans += cost;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = s; u != t; u /= <span class="number">2</span>) ++flow[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = p[t]; u != t; u /= <span class="number">2</span>) --flow[u];</span><br><span class="line">    --C[p[t]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = p[t]; u != t; u /= <span class="number">2</span>) <span class="built_in">augment</span>(u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = s; u &gt; <span class="number">0</span>; u /= <span class="number">2</span>) <span class="built_in">augment</span>(u);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, ans, <span class="string">&quot; \n&quot;</span>[k == m]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="HDU-6634「2019-Multi-University-Training-Contest」Salty-fish"><a href="#HDU-6634「2019-Multi-University-Training-Contest」Salty-fish" class="headerlink" title="HDU 6634「2019 Multi-University Training Contest」Salty fish"></a>HDU 6634「2019 Multi-University Training Contest」Salty fish</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6634">http://acm.hdu.edu.cn/showproblem.php?pid=6634</a></li>
</ul>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>考虑最大权闭合子图的建图方式. 设源汇点分别为 $S$, $T$.</p>
<ol>
<li>对于树上每个节点 $i$, 连边 $(S, i)$, 容量为 $a_i$.</li>
<li>对于每个摄像头 $j$, 连边 $(j, T)$, 容量为 $c_j$.</li>
<li>对于摄像头 $j$, 若节点 $i$ 在 $j$ 的监控范围内, 连边 $(i, j)$, 容量为 $\infty$.</li>
</ol>
<p>此时答案为 $\sum {a_i} - \text{mincut}$.</p>
<p>根据最大流-最小割定理, 我们只需要计算出网络的最大流即可. 对于节点 $i$, 其流量一定流向能够监控到 $i$ 的, 且深度尽量小的摄像头. 因为深度大的摄像头更可能监控到深度大的节点. 换言之, 每个摄像头一定选择其范围内深度尽量大的节点.</p>
<p>那么我们可以对每个节点 $u$, 记录 $f(u, i)$ 表示 $u$ 子树内, 同根节点距离为 $i$ 节点的 $a$ 之和. 由深度从大到小的顺序选择每个摄像头, 从满足要求的最大深度开始向前推进, 更新流量和答案即可.</p>
<p>注意到 $f(u, i)$ 和深度有关, 可利用长链剖分维护. 此时需要在一个数组中快速修改 / 删除 / 加入一个数, 用 <code>map</code> 维护 $f(u, i)$ 就好了. <del>当然也可以写线段树合并.</del></p>
<p>时间复杂度 $O\big((n + m) \log n\big)$.</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HDU 6634</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> map&lt;<span class="keyword">int</span>, LL&gt;::iterator IT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> pre[MAXN], A[MAXN], K[MAXN], C[MAXN];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; P[MAXN];</span><br><span class="line"></span><br><span class="line">LL ans;</span><br><span class="line"><span class="keyword">int</span> Idx[MAXN], idx;</span><br><span class="line">map&lt;<span class="keyword">int</span>, LL&gt; M[MAXN]; <span class="comment">// depth, flow</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to; &#125; edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    edges[++eidx] = (Edge)&#123; head[from], to &#125;, head[from] = eidx;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> depth[MAXN], d[MAXN], son[MAXN];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    d[u] = <span class="number">1</span>, son[u] = <span class="number">-1</span>;</span><br><span class="line">    depth[u] = depth[pre[u]] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">      <span class="built_in">dfs</span>(v = edges[i].to);</span><br><span class="line">      <span class="keyword">if</span> (son[u] == <span class="number">-1</span> || d[son[u]] &lt; d[v])</span><br><span class="line">        son[u] = v, d[u] = d[v] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Idx[u] = (~son[u])? Idx[son[u]]: ++idx;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, LL&gt;&amp; f = M[Idx[u]];</span><br><span class="line">    f[depth[u]] += A[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((v = edges[i].to) == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span> (IT ite = M[Idx[v]].<span class="built_in">begin</span>(); ite != M[Idx[v]].<span class="built_in">end</span>(); ++ite)</span><br><span class="line">        f[ite-&gt;first] += ite-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> k = <span class="number">0</span>; k &lt; P[u].<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span>&amp; i = P[u][k];</span><br><span class="line">      IT ite = f.<span class="built_in">upper_bound</span>(depth[u] + K[i]);</span><br><span class="line">      <span class="keyword">if</span> (ite == f.<span class="built_in">begin</span>()) <span class="keyword">continue</span>;</span><br><span class="line">      --ite;</span><br><span class="line">      <span class="keyword">while</span> (C[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        LL w = <span class="built_in">min</span>((LL) C[i], ite-&gt;second);</span><br><span class="line">        ite-&gt;second -= w, C[i] -= w, ans -= w;</span><br><span class="line">        <span class="keyword">if</span> (ite-&gt;second &gt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (ite == f.<span class="built_in">begin</span>()) &#123; f.<span class="built_in">erase</span>(ite); <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> dep = ite-&gt;first;</span><br><span class="line">        --ite, f.<span class="built_in">erase</span>(dep);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> Ti;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Ti);</span><br><span class="line">  <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) P[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= idx; ++i) M[i].<span class="built_in">clear</span>();</span><br><span class="line">    ans = idx = <span class="number">0</span>, Graph::<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, pre + i), Graph::<span class="built_in">AddEdge</span>(pre[i], i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, A + i), ans += A[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, K + i, C + i), P[u].<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">    Graph::<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="UOJ-318「NOI2017」蔬菜"><a href="#UOJ-318「NOI2017」蔬菜" class="headerlink" title="UOJ #318「NOI2017」蔬菜"></a>UOJ #318「NOI2017」蔬菜</h3><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://uoj.ac/problem/318">https://uoj.ac/problem/318</a></li>
</ul>
<h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先有一个朴素的网络流思路. 设源汇点分别为 $S$, $T$, 同时将每天视作一个节点, 记 $p$ 为最大天数.</p>
<ol>
<li>对于每个蔬菜 $i$, 记其最大售卖天数 $k$ 为 $\min\{ p, \lceil \frac{c_i}{x_i} \rceil \}$.<ul>
<li>向第 $1 \sim k - 1$ 天依次连边, 容量为 $x_i$, 费用为 $a_i$.</li>
<li>向第 $k$ 天连边, 容量为 $c_i - k x_i - 1$, 费用为 $a_i$.</li>
<li>向第 $k$ 天连边, 容量为 $1$, 费用为 $a_i + s_i$</li>
</ul>
</li>
<li>对于第 $i$ 天<ul>
<li>连边 $(i, i - 1)$, 容量为 $\infty$, 费用为 $0$.</li>
<li>连边 $(i, T)$, 容量为 $m$, 费用为 $0$.</li>
</ul>
</li>
</ol>
<p>观察每次增广时的情况. 在天数不断增加时, 原有流量改变一定不优, 否则在前一天可改变流量使得前一天答案更优. 也就是说, 第 $i$ 天售出的蔬菜一定是第 $i + 1$ 天售出蔬菜的一部分, 且网络中不存在退流.</p>
<p>同时, 注意到天数对应点之间的连边, 对于每个蔬菜, 尽量选择靠后天数是更优秀的. 从建图解释, 选择靠后天数可通过容量为 $\infty$ 的边增广. 从实际意义解释, 将蔬菜尽量放在快过期的时候卖出更优. 同时要选择权值尽量大的蔬菜卖出.</p>
<p>那么用堆维护当前可选的蔬菜, 每天的销售情况视作增广 $m$ 的流量, 选择权值最大的蔬菜即可. 同时需要知道当前天对应节点在向 $T$ 的边满流之后, 向前增广的位置. 可以利用并查集维护.</p>
<p>时间复杂度 $O(n \log n + pm\log n)$.</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UOJ #318</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], X[MAXN], S[MAXN], C[MAXN], Q[MAXN];</span><br><span class="line"></span><br><span class="line">LL Ans[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> idx, v;</span><br><span class="line">  <span class="built_in">Item</span>(<span class="keyword">int</span> _i, <span class="keyword">int</span> _v): <span class="built_in">idx</span>(_i), <span class="built_in">v</span>(_v) &#123; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Item&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v &lt; rhs.v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Item&gt; PQ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DSU &#123;</span><br><span class="line">  <span class="keyword">int</span> fa[MAXN];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= _n; ++i) fa[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findfa</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fa[u] == u)? u: fa[u] = <span class="built_in">findfa</span>(fa[u]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;data/ex_vegetables3.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">read</span>(n), <span class="built_in">read</span>(m), <span class="built_in">read</span>(q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">read</span>(A[i]), <span class="built_in">read</span>(S[i]), <span class="built_in">read</span>(C[i]), <span class="built_in">read</span>(X[i]);</span><br><span class="line">  <span class="keyword">int</span> Mx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">    <span class="built_in">read</span>(Q[i]), Mx = <span class="built_in">max</span>(Mx, Q[i]);</span><br><span class="line"></span><br><span class="line">  DSU::<span class="built_in">init</span>(Mx);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    PQ.<span class="built_in">push</span>(<span class="built_in">Item</span>(i, A[i] + S[i]));</span><br><span class="line"></span><br><span class="line">  LL ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>; p &lt;= Mx; ++p) &#123;</span><br><span class="line">    <span class="keyword">int</span> flow = m;</span><br><span class="line">    <span class="keyword">while</span> (flow &gt; <span class="number">0</span> &amp;&amp; !PQ.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">int</span> i = PQ.<span class="built_in">top</span>().idx, v = PQ.<span class="built_in">top</span>().v; PQ.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">int</span> k = (X[i] == <span class="number">0</span>)? Mx: <span class="built_in">min</span>(Mx, (C[i] + X[i] - <span class="number">1</span>) / X[i]);</span><br><span class="line">      k = DSU::<span class="built_in">findfa</span>(k);</span><br><span class="line">      <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      ++cnt[k];</span><br><span class="line">      <span class="keyword">if</span> (cnt[k] == m) DSU::fa[k] = DSU::<span class="built_in">findfa</span>(k - <span class="number">1</span>);</span><br><span class="line">      --flow, --C[i], ans += v;</span><br><span class="line">      <span class="keyword">if</span> (C[i] &gt; <span class="number">0</span>) PQ.<span class="built_in">push</span>(<span class="built_in">Item</span>(i, A[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    Ans[p] = ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, Ans[Q[i]]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="UOJ-480「NOI2019」序列"><a href="#UOJ-480「NOI2019」序列" class="headerlink" title="UOJ #480「NOI2019」序列"></a>UOJ #480「NOI2019」序列</h3><h4 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://uoj.ac/problem/480">https://uoj.ac/problem/480</a></li>
</ul>
<h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先有一个朴素的费用流思路. 设源汇点分别为 $S$, $T$, 对两序列的每个位置分别建点 $i$, $i’$.</p>
<ol>
<li>新建节点 $S’$, 连边 $(S, S’)$, 容量为 $K$, 费用为 $0$.</li>
<li>对于序列的每个位置 $i$, 连边<ul>
<li>$(S, i)$, 容量为 $1$, 费用为 $a_i$.</li>
<li>$(S, i’)$, 容量为 $1$, 费用为 $b_i$.</li>
<li>$(i, i’)$, 容量为 $1$, 费用为 $0$.</li>
</ul>
</li>
<li>新建节点 $C$, $D$. 用于描述 “至少有 $L$ 个下标在两个序列中都被指定” 的限制.<ul>
<li>连边 $(C, D)$, 容量为 $K - L$, 费用为 $0$.</li>
<li>对于每个位置 $i$, 连边 $(i, C)$, $(D, i’)$, 容量为 $1$, 费用为 $0$.</li>
</ul>
</li>
</ol>
<p>现在考虑如何模拟该费用流.</p>
<p>存在至多 $K - L$ 个位置不受在两个序列中都被指定的限制. 此时一定先选择 $a_i$, $b_i$ 中权值大的位置, 体现在网络中即边 $(C, D)$ 满流.</p>
<p>现在还剩下 $L$ 个位置需要选择, 即剩下 $L$ 的流量需要增广. 记录每个位置 $i$ 被选择的情况 $f_i$, 其二进制第 $0$ 位表示 $a_i$ 是否被选择, 或是边 $(S, i)$ 的流量. 第 $1$ 位则表示 $b_i$ 的情况.</p>
<p>为使总权值最大, 每次需要选择权值尽量大的位置. 那么利用数个大根堆 (<code>r0</code>, <code>r1</code>, <code>r</code>), 分别维护恰在序列 $a_i$ (<code>r0</code>) 或 $b_i$ (<code>r1</code>) 中没有选择的位置, 以及都没有选择的位置 (<code>r</code>). 对于前两种情况, 在选择位置时需要另一序列某一元素配对, 再利用两个堆 (<code>p0</code>, <code>p1</code>) 记录可配对的位置.</p>
<p>首先单独考虑 $f_i = 3$ 的情况, 此时简直是理想状态, 满足权值尽量大的同时也满足了限制.</p>
<p>为使总权值尽量大, 则需要将边 $(C, D)$ 的某个流量改流在形同 $(i, i’)$ 的边上. 那么记录此种情况的流量总数 <code>flow</code>, 在允许此种增广时选择一组流经 $(C, D)$ 的流量即可. 也就是在 <code>r0</code>, <code>r1</code> 中选择两个元素.</p>
<p>剩下的情况无外乎 $f_i$ 为 $0, 1, 2$. 根据其特性选择增广路, 也就是不同的位置匹配, 记录其权值并取权值最大的情况即可.</p>
<p>细节可能有些多, 还是建议想清楚之后再动键盘. 注意要根据 $f_i$ 的取值删除堆中的不合法元素, 以及及时更新 $f_i$ 和 <code>flow</code>.</p>
<p>时间复杂度 $O(T \cdot n \log n)$.</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UOJ #480</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K, L;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ItemA</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> idx;</span><br><span class="line">  <span class="built_in">ItemA</span>(<span class="keyword">int</span> _i): <span class="built_in">idx</span>(_i) &#123; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> ItemA&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> A[idx] &lt; A[rhs.idx];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ItemB</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> idx;</span><br><span class="line">  <span class="built_in">ItemB</span>(<span class="keyword">int</span> _i): <span class="built_in">idx</span>(_i) &#123; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> ItemB&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> B[idx] &lt; B[rhs.idx];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ItemAB</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> idx;</span><br><span class="line">  <span class="built_in">ItemAB</span>(<span class="keyword">int</span> _i): <span class="built_in">idx</span>(_i) &#123; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> ItemAB&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> A[idx] + B[idx] &lt; A[rhs.idx] + B[rhs.idx];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> idx[MAXN], f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;data/ex_sequence3.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> Ti; <span class="built_in">read</span>(Ti);</span><br><span class="line">  <span class="keyword">while</span> (Ti--) &#123;</span><br><span class="line">    <span class="built_in">read</span>(n), <span class="built_in">read</span>(K), <span class="built_in">read</span>(L);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(B[i]);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;ItemA&gt; r0, p0;</span><br><span class="line">    priority_queue&lt;ItemB&gt; r1, p1;</span><br><span class="line">    priority_queue&lt;ItemAB&gt; r;</span><br><span class="line"></span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = <span class="number">0</span>, idx[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(idx + <span class="number">1</span>, idx + <span class="number">1</span> + n, [](<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y) &#123;</span><br><span class="line">        <span class="keyword">return</span> A[x] &gt; A[y];</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K - L; ++i)</span><br><span class="line">      ans += A[idx[i]], f[idx[i]] |= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(idx + <span class="number">1</span>, idx + <span class="number">1</span> + n, [](<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y) &#123;</span><br><span class="line">        <span class="keyword">return</span> B[x] &gt; B[y];</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K - L; ++i)</span><br><span class="line">      ans += B[idx[i]], f[idx[i]] |= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="built_in"><span class="keyword">switch</span></span> (f[i]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: r0.<span class="built_in">push</span>(i), r1.<span class="built_in">push</span>(i), r.<span class="built_in">push</span>(i); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: r1.<span class="built_in">push</span>(i), p1.<span class="built_in">push</span>(i); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: r0.<span class="built_in">push</span>(i), p0.<span class="built_in">push</span>(i); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: ++flow; <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (L--) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!r.<span class="built_in">empty</span>() &amp;&amp; f[r.<span class="built_in">top</span>().idx] &gt; <span class="number">0</span>) r.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">while</span> (!r0.<span class="built_in">empty</span>() &amp;&amp; (f[r0.<span class="built_in">top</span>().idx] &amp; <span class="number">1</span>)) r0.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">while</span> (!p0.<span class="built_in">empty</span>() &amp;&amp; (f[p0.<span class="built_in">top</span>().idx] ^ <span class="number">2</span>)) p0.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">while</span> (!r1.<span class="built_in">empty</span>() &amp;&amp; (f[r1.<span class="built_in">top</span>().idx] &amp; <span class="number">2</span>)) r1.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">while</span> (!p1.<span class="built_in">empty</span>() &amp;&amp; (f[p1.<span class="built_in">top</span>().idx] ^ <span class="number">1</span>)) p1.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (flow &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = r0.<span class="built_in">top</span>().idx, j = r1.<span class="built_in">top</span>().idx;</span><br><span class="line">        ans += A[i] + B[j], --flow, f[i] |= <span class="number">1</span>, f[j] |= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (f[i] != <span class="number">3</span>) p1.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (f[j] != <span class="number">3</span>) p0.<span class="built_in">push</span>(j);</span><br><span class="line">        flow += (i == j)? <span class="number">1</span>: ((f[i] == <span class="number">3</span>) + (f[j] == <span class="number">3</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> i1, j1, i2, j2, p3;</span><br><span class="line">        LL Mx, v1 = <span class="number">0</span>, v2 = <span class="number">0</span>, v3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!r0.<span class="built_in">empty</span>() &amp;&amp; !p1.<span class="built_in">empty</span>())</span><br><span class="line">          i1 = r0.<span class="built_in">top</span>().idx, j1 = p1.<span class="built_in">top</span>().idx, v1 = A[i1] + B[j1];</span><br><span class="line">        <span class="keyword">if</span> (!p0.<span class="built_in">empty</span>() &amp;&amp; !r1.<span class="built_in">empty</span>())</span><br><span class="line">          i2 = p0.<span class="built_in">top</span>().idx, j2 = r1.<span class="built_in">top</span>().idx, v2 = A[i2] + B[j2];</span><br><span class="line">        <span class="keyword">if</span> (!r.<span class="built_in">empty</span>())</span><br><span class="line">          p3 = r.<span class="built_in">top</span>().idx, v3 = A[p3] + B[p3];</span><br><span class="line">        Mx = <span class="built_in">max</span>(v1, <span class="built_in">max</span>(v2, v3)), ans += Mx;</span><br><span class="line">        <span class="keyword">if</span> (v1 == Mx) &#123;</span><br><span class="line">          f[i1] |= <span class="number">1</span>, f[j1] |= <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span> (f[i1] != <span class="number">3</span>) p1.<span class="built_in">push</span>(i1); <span class="keyword">else</span> ++flow;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v2 == Mx) &#123;</span><br><span class="line">          f[i2] |= <span class="number">1</span>, f[j2] |= <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span> (f[j2] != <span class="number">3</span>) p0.<span class="built_in">push</span>(j2); <span class="keyword">else</span> ++flow;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v3 == Mx)</span><br><span class="line">          r.<span class="built_in">pop</span>(), f[p3] |= <span class="number">3</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<hr>
<p>以下就是 laofu 课件中 “老鼠进洞” 的模型了. 或者说是, 二分图带权匹配的模型.</p>
<p>考虑到二分图带权匹配已经是经典问题, 下文就不再赘述朴素的网络流做法.</p>
<p>laofu 课件中利用较多篇幅, 从 DP 凸性的角度入手解决了这些问题… 作为没有梦想的咸鱼选手, 我暂且还是选择感性理解的方式.</p>
<h3 id="BZOJ-4977「Lydsy1708-月赛」跳伞求生"><a href="#BZOJ-4977「Lydsy1708-月赛」跳伞求生" class="headerlink" title="BZOJ 4977「Lydsy1708 月赛」跳伞求生"></a>BZOJ 4977「Lydsy1708 月赛」跳伞求生</h3><h4 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><del><a href="http://lydsy.com/JudgeOnline/problem.php?id=4977">http://lydsy.com/JudgeOnline/problem.php?id=4977</a></del></li>
<li><a href="https://darkbzoj.tk/problem/4977">https://darkbzoj.tk/problem/4977</a></li>
</ul>
<h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>laofu 课件中的 Problem 3.</p>
<p>首先思考简化版的问题.</p>
<blockquote>
<p>数轴上有 $n$ 只老鼠和 $m$ 个老鼠洞. 第 $i$ 只老鼠的坐标为 $x_i$, 第 $j$ 个老鼠洞的坐标为 $y_i$.<br>现在要让老鼠进洞, 也就是寻找老鼠和洞的匹配.</p>
<p>假定每只老鼠只能往左走, 每个洞容量为 $1$. 求所有老鼠都进洞的最小总代价（即行走的最小总距离）.</p>
</blockquote>
<p>也就是 laofu 课件中的 Problem 1.</p>
<p>首先将洞的权值视作 $-y_i$, 老鼠的权值视作 $x_i$, 所求即最小权匹配. 将数轴上的所有点排序, 那么用栈记录所有的未匹配洞的位置, 在遇到老鼠时选择栈顶的洞匹配上即可.</p>
<p>再来考虑这个问题. 此时每个洞带权, 且不要求所有老鼠都进洞, 所求为最大权匹配.</p>
<p>对于一组匹配, 其对答案的贡献为 $x_i - y_j + w_j$. 考虑到 $w_j$ 的影响, 对所有点按坐标排序后洞的权值并不单调. 那么将栈换作堆维护最值即可.</p>
<p>但直接选择的匹配并不一定为最优解. 联系费用流中的退流操作, 在选择一组匹配后向堆中增加权值为 $-x_i$ 的元素, 从而体现匹配更改的情况.</p>
<p>时间复杂度 $O(n \log n)$.</p>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BZOJ #4977</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x, w;</span><br><span class="line">  <span class="built_in">Point</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">Point</span>(<span class="keyword">int</span> _x, <span class="keyword">int</span> _w): <span class="built_in">x</span>(_x), <span class="built_in">w</span>(_w) &#123; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; rhs.x || (x == rhs.x &amp;&amp; w &lt; rhs.w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; P[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> a, i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a), P[++p] = <span class="built_in">Point</span>(a, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> b, c, i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;b, &amp;c), P[++p] = <span class="built_in">Point</span>(b, c);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(P + <span class="number">1</span>, P + <span class="number">1</span> + p);</span><br><span class="line">  LL ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (P[i].w == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (d.<span class="built_in">empty</span>() || d.<span class="built_in">top</span>() + P[i].x &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      ans += d.<span class="built_in">top</span>() + P[i].x;</span><br><span class="line">      d.<span class="built_in">pop</span>(), d.<span class="built_in">push</span>(-P[i].x);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      d.<span class="built_in">push</span>(-P[i].x + P[i].w);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="UOJ-455【UER-8】雪灾与外卖"><a href="#UOJ-455【UER-8】雪灾与外卖" class="headerlink" title="UOJ #455【UER #8】雪灾与外卖"></a>UOJ #455【UER #8】雪灾与外卖</h3><h4 id="题目链接-6"><a href="#题目链接-6" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://uoj.ac/problem/455">https://uoj.ac/problem/455</a></li>
</ul>
<h4 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h4><p>laofu 课件中的 Problem 6.</p>
<p>不妨先去除每个洞容量的限制, 考虑容量为 $1$ 的情况.</p>
<p>首先匹配交叉一定不优. 同样将数轴上的点从小到大排序, 对于每只老鼠或是每个洞, 讨论其匹配和反悔的权值即可.</p>
<p>具体的讨论可参考 <a href="https://whzzt.blog.uoj.ac/blog/4749">UOJ 官方题解</a>, 或者是文末的参考资料 (</p>
<p>每个洞容量的限制体现在网络流中即边的容量, 直接往之前的堆中丢一个 <code>pair</code> 记录增广的权值和容量即可. 可以证明, 此时对堆操作次数仍为线性.</p>
<p>在老鼠存在 “分身” 的情况下, 也是可以这样做的.</p>
<p>时间复杂度 $O(n \log n)$.</p>
<h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UOJ #455</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; Pll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL INFLL = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x, w, c;</span><br><span class="line">  <span class="built_in">Point</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">Point</span>(<span class="keyword">int</span> _x, <span class="keyword">int</span> _w, <span class="keyword">int</span> _c): <span class="built_in">x</span>(_x), <span class="built_in">w</span>(_w), <span class="built_in">c</span>(_c) &#123; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; rhs.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; P[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p;</span><br><span class="line">priority_queue&lt;Pll, vector&lt;Pll&gt;, greater&lt;Pll&gt; &gt; d0, d1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;data/ex_hole7.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x, i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">read</span>(x), P[++p] = <span class="built_in">Point</span>(x, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">  LL sc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x, w, c, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">read</span>(x), <span class="built_in">read</span>(w), <span class="built_in">read</span>(c);</span><br><span class="line">    P[++p] = <span class="built_in">Point</span>(x, w, c), sc += c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sc &lt; n)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(P + <span class="number">1</span>, P + <span class="number">1</span> + p);</span><br><span class="line">  LL ans = <span class="number">0</span>;</span><br><span class="line">  d1.<span class="built_in">push</span>(<span class="built_in">Pll</span>(INFLL, n));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = P[i].x, w = P[i].w;</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="number">-1</span>) &#123;</span><br><span class="line">      Pll t = d1.<span class="built_in">top</span>(); d1.<span class="built_in">pop</span>();</span><br><span class="line">      ans += t.first + x, --t.second;</span><br><span class="line">      <span class="keyword">if</span> (t.second &gt; <span class="number">0</span>) d1.<span class="built_in">push</span>(t);</span><br><span class="line">      d0.<span class="built_in">push</span>(<span class="built_in">Pll</span>(<span class="number">-2LL</span> * x - t.first, <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LL tot = <span class="number">0</span>, c = P[i].c;</span><br><span class="line">      <span class="keyword">while</span> (c &gt; <span class="number">0</span> &amp;&amp; !d0.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Pll t = d0.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span> (t.first + x + w &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        d0.<span class="built_in">pop</span>();</span><br><span class="line">        LL s = <span class="built_in">min</span>((LL) c, t.second);</span><br><span class="line">        ans += s * (t.first + w + x), t.second -= s, c -= s;</span><br><span class="line">        <span class="keyword">if</span> (t.second &gt; <span class="number">0</span>) d0.<span class="built_in">push</span>(t);</span><br><span class="line">        tot += s, d1.<span class="built_in">push</span>(<span class="built_in">Pll</span>(<span class="number">-2LL</span> * x - t.first, s));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (tot &gt; <span class="number">0</span>)</span><br><span class="line">        d0.<span class="built_in">push</span>(<span class="built_in">Pll</span>(-x - w, tot));</span><br><span class="line">      <span class="keyword">if</span> (c &gt; <span class="number">0</span>)</span><br><span class="line">        d1.<span class="built_in">push</span>(<span class="built_in">Pll</span>(-x + w, c));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="LOJ-6405「ICPC-World-Finals-2018」征服世界"><a href="#LOJ-6405「ICPC-World-Finals-2018」征服世界" class="headerlink" title="LOJ #6405「ICPC World Finals 2018」征服世界"></a>LOJ #6405「ICPC World Finals 2018」征服世界</h3><h4 id="题目链接-7"><a href="#题目链接-7" class="headerlink" title="题目链接"></a>题目链接</h4><ul>
<li><a href="https://loj.ac/problem/6405">https://loj.ac/problem/6405</a></li>
</ul>
<h4 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h4><p>laofu 课件中的 Problem 7.</p>
<p>上一题的模型上树.</p>
<p>首先每个点都存在军队和需求的限制是假的, 每个位置的军队解决自己的问题显然更优.  把军队视为洞, 军队需求视作老鼠, 可以得到老鼠进洞的模型. 换句话说, 对于 $x_i &gt; y_i$ 的节点, 视作容量为 $x_i - y_i$ 的洞; 对于满足 $x_i &lt; y_i$ 的节点, 视作 $y_i - x_i$ 只老鼠.</p>
<p>现在需要让所有老鼠进洞并使花费最小. 记 $\mathrm{dist}(u)$ 表示树上节点 $u$ 到根的距离, 那么花费形同 $\mathrm{dist}(u) + \mathrm{dist}(v) - 2\cdot \mathrm{dist}(\mathrm{LCA}(u, v))$.</p>
<p>对于每个点 $u$, 将 $\mathrm{dist}(u)$ 视作 $u$ 的权值. 同时, 每只老鼠一定要进洞, 直接将权值减去 $\infty$, 在计算答案时加上就好了.</p>
<p>剩下的情况和上一题没有太大区别, 另外需要可并堆快速从下向上合并节点的信息.</p>
<p>时间复杂度 $O(n \log n)$.</p>
<h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title">点击显示 / 隐藏 </div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOJ #6405</span></span><br><span class="line"><span class="comment">// DeP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">18</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp;</span><br><span class="line">      (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin), p1 == p2)? EOF: *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">Gc</span>();</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, <span class="keyword">int</span>&gt; Pli;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2.5e5</span> + <span class="number">5</span>, MAXM = MAXN &lt;&lt; <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL INFLL = MAXN * <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> X[MAXN], Y[MAXN];</span><br><span class="line"></span><br><span class="line">LL d[MAXN], ans;</span><br><span class="line"><span class="keyword">int</span> rt0[MAXN], rt1[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Heap &#123;</span><br><span class="line">  Pli val[MAXM];</span><br><span class="line">  <span class="keyword">int</span> ch[<span class="number">2</span>][MAXM], dist[MAXM], nidx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">const</span> Pli&amp; v)</span> </span>&#123; <span class="keyword">return</span> val[++nidx] = v, nidx; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Mrg</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line">    <span class="keyword">if</span> (val[x] &gt; val[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    ch[<span class="number">1</span>][x] = <span class="built_in">Mrg</span>(ch[<span class="number">1</span>][x], y);</span><br><span class="line">    <span class="keyword">if</span> (dist[ch[<span class="number">0</span>][x]] &lt; dist[ch[<span class="number">1</span>][x]]) <span class="built_in">swap</span>(ch[<span class="number">0</span>][x], ch[<span class="number">1</span>][x]);</span><br><span class="line">    dist[x] = dist[ch[<span class="number">1</span>][x]] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pop</span><span class="params">(<span class="keyword">int</span>&amp; u)</span> </span>&#123; u = <span class="built_in">Mrg</span>(ch[<span class="number">0</span>][u], ch[<span class="number">1</span>][u]); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Psh</span><span class="params">(<span class="keyword">int</span>&amp; u, <span class="keyword">const</span> Pli&amp; v)</span> </span>&#123; u = <span class="built_in">Mrg</span>(u, <span class="built_in">newnode</span>(v)); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nxt, to, w; &#125; edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> head[MAXN], eidx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head), eidx = <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edges[++eidx] = (Edge)&#123; head[from], to, w &#125;, head[from] = eidx;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">const</span> LL&amp; d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (rt0[x] &gt; <span class="number">0</span> &amp;&amp; rt1[y] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      Pli &amp;t0 = Heap::val[rt0[x]], &amp;t1 = Heap::val[rt1[y]];</span><br><span class="line">      <span class="keyword">if</span> (t0.first + t1.first - <span class="number">2</span> * d &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">int</span> s = <span class="built_in">min</span>(t0.second, t1.second);</span><br><span class="line">      ans += s * (t0.first + t1.first - <span class="number">2</span> * d);</span><br><span class="line">      t0.second -= s, t1.second -= s;</span><br><span class="line">      <span class="keyword">if</span> (t0.second == <span class="number">0</span>) Heap::<span class="built_in">Pop</span>(rt0[x]);</span><br><span class="line">      <span class="keyword">if</span> (t1.second == <span class="number">0</span>) Heap::<span class="built_in">Pop</span>(rt1[y]);</span><br><span class="line">      Heap::<span class="built_in">Psh</span>(rt0[x], <span class="built_in">Pli</span>(-t1.first + <span class="number">2</span> * d, s));</span><br><span class="line">      Heap::<span class="built_in">Psh</span>(rt1[y], <span class="built_in">Pli</span>(-t0.first + <span class="number">2</span> * d, s));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (X[u] &gt; <span class="number">0</span>)</span><br><span class="line">      Heap::<span class="built_in">Psh</span>(rt0[u], <span class="built_in">Pli</span>(d[u], X[u]));</span><br><span class="line">    <span class="keyword">if</span> (Y[u] &gt; <span class="number">0</span>)</span><br><span class="line">      Heap::<span class="built_in">Psh</span>(rt1[u], <span class="built_in">Pli</span>(d[u] - INFLL, Y[u])), ans += INFLL * Y[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v, i = head[u]; ~i; i = edges[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((v = edges[i].to) == fa) <span class="keyword">continue</span>;</span><br><span class="line">      d[v] = d[u] + edges[i].w, <span class="built_in">dfs</span>(v, u);</span><br><span class="line">      <span class="built_in">Merge</span>(u, v, d[u]), <span class="built_in">Merge</span>(v, u, d[u]);</span><br><span class="line">      rt0[u] = Heap::<span class="built_in">Mrg</span>(rt0[u], rt0[v]);</span><br><span class="line">      rt1[u] = Heap::<span class="built_in">Mrg</span>(rt1[u], rt1[v]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  Graph::<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">read</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> u, v, w, i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">read</span>(u), <span class="built_in">read</span>(v), <span class="built_in">read</span>(w);</span><br><span class="line">    Graph::<span class="built_in">AddEdge</span>(u, v, w), Graph::<span class="built_in">AddEdge</span>(v, u, w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v, i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">read</span>(X[i]), <span class="built_in">read</span>(Y[i]);</span><br><span class="line">    v = <span class="built_in">min</span>(X[i], Y[i]), X[i] -= v, Y[i] -= v;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Graph::<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>陈江伦, &lt;模拟费用流问题&gt;, 2019.1.27.</li>
<li>boshi, <a href="https://www.mina.moe/archives/11762">模拟费用流的基本模型</a>.</li>
<li>mangoyang, <a href="https://www.cnblogs.com/mangoyang/p/11563486.html">模拟流的问题小结</a>.</li>
<li>litble, <a href="https://blog.csdn.net/litble/article/details/88410435">模拟费用流模型总结</a>.</li>
<li>200815147, <a href="https://blog.csdn.net/baidu_36797646/java/article/details/87071691">LOJ #2306「NOI2017」蔬菜 模拟费用流</a></li>
</ul>
<hr>

  </div>
  <footer class="article-footer">
    
  <div class="cc">
    <a href="http://creativecommons.org/licenses/by-nc/4.0/deed.z" target="_blank" title="署名-非商业性使用">
      <img src="/images/cc/cc.png">
      
          <img src="/images/cc/by.png">
        
          <img src="/images/cc/nc.png">
        
      <span>
        本作品采用知识共享 署名-非商业性使用 4.0 国际许可协议进行许可。
      </span>
    </a>
  </div>


  </footer>
  
</article>





          <div class="main-footer">
  
    © 2019-2022 DepletedPrism&#39;s Blog
    
	- Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  
<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>


  
<link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">

  
<link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">


  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  
<script src="/PhotoSwipe/photoswipe.js"></script>

  
<script src="/PhotoSwipe/photoswipe-ui-default.js"></script>




<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>


<script src="/scripts/main.js"></script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!--script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

</body>
</html>
